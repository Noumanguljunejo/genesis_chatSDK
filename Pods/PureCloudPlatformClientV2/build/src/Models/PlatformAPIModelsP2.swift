//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation


/** Identity of a CX infrastructure as code accelerator to be run and its inputs */

public class AcceleratorInput: Codable {







    /** Set this true to test the job without making any changes. Defaults to false. */
    public var dryRun: Bool?
    /** Accelerator ID */
    public var acceleratorId: String?
    /** Parameters required for this accelerator */
    public var parameters: [AcceleratorParameter]?

    public init(dryRun: Bool?, acceleratorId: String?, parameters: [AcceleratorParameter]?) {
        self.dryRun = dryRun
        self.acceleratorId = acceleratorId
        self.parameters = parameters
    }


}




public class ActionAggregateDataContainer: Codable {





    /** A mapping from dimension to value */
    public var group: [String:String]?
    public var data: [StatisticalResponse]?

    public init(group: [String:String]?, data: [StatisticalResponse]?) {
        self.group = group
        self.data = data
    }


}




public class ActionAggregateQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [ActionAggregateQueryPredicate]?

    public init(type: ModelType?, predicates: [ActionAggregateQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class ActionAggregationQuery: Codable {







    public enum GroupBy: String, Codable { 
        case actioncategory = "actionCategory"
        case actionid = "actionId"
        case actionname = "actionName"
        case correlationid = "correlationId"
        case errortype = "errorType"
        case integrationid = "integrationId"
        case integrationname = "integrationName"
        case responsestatus = "responseStatus"
    }



    public enum Metrics: String, Codable { 
        case ttotalexecution = "tTotalExecution"
    }





    public enum AlternateTimeDimension: String, Codable { 
        case eventtime = "eventTime"
    }

    /** Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H */
    public var granularity: String?
    /** Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var timeZone: String?
    /** Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group. */
    public var groupBy: [GroupBy]?
    /** Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters */
    public var filter: ActionAggregateQueryFilter?
    /** Behaves like a SQL SELECT clause. Only named metrics will be retrieved. */
    public var metrics: [Metrics]?
    /** Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c') */
    public var flattenMultivaluedDimensions: Bool?
    /** Custom derived metric views */
    public var views: [ActionAggregationView]?
    /** Dimension to use as the alternative timestamp for data in the aggregate.  Choosing \"eventTime\" uses the actual time of the data event. */
    public var alternateTimeDimension: AlternateTimeDimension?

    public init(interval: String?, granularity: String?, timeZone: String?, groupBy: [GroupBy]?, filter: ActionAggregateQueryFilter?, metrics: [Metrics]?, flattenMultivaluedDimensions: Bool?, views: [ActionAggregationView]?, alternateTimeDimension: AlternateTimeDimension?) {
        self.interval = interval
        self.granularity = granularity
        self.timeZone = timeZone
        self.groupBy = groupBy
        self.filter = filter
        self.metrics = metrics
        self.flattenMultivaluedDimensions = flattenMultivaluedDimensions
        self.views = views
        self.alternateTimeDimension = alternateTimeDimension
    }


}




public class ActionEntityListing: Codable {





















    public var entities: [Action]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Action]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ActionMapAction: Codable {



    public enum MediaType: String, Codable { 
        case webchat = "webchat"
        case webmessagingoffer = "webMessagingOffer"
        case contentoffer = "contentOffer"
        case integrationaction = "integrationAction"
        case architectflow = "architectFlow"
        case openaction = "openAction"
    }













    /** Action template associated with the action map. */
    public var actionTemplate: ActionMapActionTemplate?
    /** Media type of action. */
    public var mediaType: MediaType?
    /** Action target ID. */
    public var actionTargetId: String?
    /** Whether this action should be throttled. */
    public var isPacingEnabled: Bool?
    /** Additional properties. */
    public var props: ActionProperties?
    /** Architect Flow Id and input contract. */
    public var architectFlowFields: ArchitectFlowFields?
    /** Admin-configurable fields of a web messaging offer action. */
    public var webMessagingOfferFields: WebMessagingOfferFields?
    /** Admin-configurable fields of an open action. */
    public var openActionFields: OpenActionFields?

    public init(actionTemplate: ActionMapActionTemplate?, mediaType: MediaType?, actionTargetId: String?, isPacingEnabled: Bool?, props: ActionProperties?, architectFlowFields: ArchitectFlowFields?, webMessagingOfferFields: WebMessagingOfferFields?, openActionFields: OpenActionFields?) {
        self.actionTemplate = actionTemplate
        self.mediaType = mediaType
        self.actionTargetId = actionTargetId
        self.isPacingEnabled = isPacingEnabled
        self.props = props
        self.architectFlowFields = architectFlowFields
        self.webMessagingOfferFields = webMessagingOfferFields
        self.openActionFields = openActionFields
    }


}



/** Output definition of Action. */

public class ActionOutput: Codable {













    /** JSON schema that defines the transformed, successful result that will be sent back to the caller. If the 'flatten' query parameter is omitted or false, this field will be returned. Either successSchema or successSchemaFlattened will be returned, not both. */
    public var successSchema: JsonSchemaDocument?
    /** URI to retrieve success schema */
    public var successSchemaUri: String?
    /** JSON schema that defines the body of response when request is not successful. If the 'flatten' query parameter is omitted or false, this field will be returned. Either errorSchema or errorSchemaFlattened will be returned, not both. */
    public var errorSchema: JsonSchemaDocument?
    /** URI to retrieve error schema */
    public var errorSchemaUri: String?
    /** JSON schema that defines the transformed, successful result that will be sent back to the caller. The schema is transformed based on Architect's flattened format. If the 'flatten' query parameter is supplied as true, this field will be returned. Either successSchema or successSchemaFlattened will be returned, not both. */
    public var successSchemaFlattened: JsonSchemaDocument?
    /** JSON schema that defines the body of response when request is not successful. The schema is transformed based on Architect's flattened format. If the 'flatten' query parameter is supplied as true, this field will be returned. Either errorSchema or errorSchemaFlattened will be returned, not both. */
    public var errorSchemaFlattened: JSON?

    public init(successSchema: JsonSchemaDocument?, successSchemaUri: String?, errorSchema: JsonSchemaDocument?, errorSchemaUri: String?, successSchemaFlattened: JsonSchemaDocument?, errorSchemaFlattened: JSON?) {
        self.successSchema = successSchema
        self.successSchemaUri = successSchemaUri
        self.errorSchema = errorSchema
        self.errorSchemaUri = errorSchemaUri
        self.successSchemaFlattened = successSchemaFlattened
        self.errorSchemaFlattened = errorSchemaFlattened
    }


}




public class AdherenceExplanationJob: Codable {



    public enum ModelType: String, Codable { 
        case addExplanation = "AddExplanation"
        case updateExplanation = "UpdateExplanation"
        case queryAgentExplanations = "QueryAgentExplanations"
        case queryBuExplanations = "QueryBuExplanations"
    }

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case error = "Error"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The type of the adherence explanation job */
    public var type: ModelType?
    /** The status of the adherence explanation job */
    public var status: Status?
    /** The adherence explanation added or modified by the job once complete; may be null if status == 'Error'. Used if type is in [ 'AddExplanation', 'UpdateExplanation' ] */
    public var adherenceExplanation: AdherenceExplanationResponse?
    /** A URL to fetch results of the job. Only set if status == 'Complete' and type is in [ 'QueryAgentExplanations', 'QueryBuExplanations' ] */
    public var downloadUrl: String?
    /** Error details if status == 'Error' */
    public var error: ErrorBody?
    /** Schema template for deserializing data returned from the downloadUrl. Use if type == 'QueryAgentExplanations' */
    public var agentQueryResponseTemplate: AdherenceExplanationListingAgentQueryResponse?
    /** Schema template for deserializing data returned from the downloadUrl. Use if type == 'QueryBuExplanations' */
    public var buQueryResponseTemplate: AdherenceExplanationListingBuQueryResponse?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, type: ModelType?, status: Status?, adherenceExplanation: AdherenceExplanationResponse?, downloadUrl: String?, error: ErrorBody?, agentQueryResponseTemplate: AdherenceExplanationListingAgentQueryResponse?, buQueryResponseTemplate: AdherenceExplanationListingBuQueryResponse?, selfUri: String?) {
        self._id = _id
        self.type = type
        self.status = status
        self.adherenceExplanation = adherenceExplanation
        self.downloadUrl = downloadUrl
        self.error = error
        self.agentQueryResponseTemplate = agentQueryResponseTemplate
        self.buQueryResponseTemplate = buQueryResponseTemplate
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
        case status
        case adherenceExplanation
        case downloadUrl
        case error
        case agentQueryResponseTemplate
        case buQueryResponseTemplate
        case selfUri
    }


}




public class AdhocRecordingTopicConversationData: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class AdhocRecordingTopicUserData: Codable {





    public var _id: String?
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class AfterCallWorkUpdate: Codable {



    /** Indicates whether or not after-call work must be completed for the communication. Can only be updated for connected communications. */
    public var afterCallWorkRequired: Bool?

    public init(afterCallWorkRequired: Bool?) {
        self.afterCallWorkRequired = afterCallWorkRequired
    }


}




public class AgentActivityChangedTopicAgentActivity: Codable {













    public var _id: String?
    public var routingStatus: AgentActivityChangedTopicRoutingStatus?
    public var presence: AgentActivityChangedTopicPresence?
    public var outOfOffice: AgentActivityChangedTopicOutOfOffice?
    public var activeQueueIds: [String]?
    public var dateActiveQueuesChanged: Date?

    public init(_id: String?, routingStatus: AgentActivityChangedTopicRoutingStatus?, presence: AgentActivityChangedTopicPresence?, outOfOffice: AgentActivityChangedTopicOutOfOffice?, activeQueueIds: [String]?, dateActiveQueuesChanged: Date?) {
        self._id = _id
        self.routingStatus = routingStatus
        self.presence = presence
        self.outOfOffice = outOfOffice
        self.activeQueueIds = activeQueueIds
        self.dateActiveQueuesChanged = dateActiveQueuesChanged
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case routingStatus
        case presence
        case outOfOffice
        case activeQueueIds
        case dateActiveQueuesChanged
    }


}




public class AgentActivityChangedTopicOrganizationPresence: Codable {





    public var _id: String?
    public var systemPresence: String?

    public init(_id: String?, systemPresence: String?) {
        self._id = _id
        self.systemPresence = systemPresence
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case systemPresence
    }


}




public class AgentIntegrationsResponse: Codable {









    /** The user associated with the integrations */
    public var agent: UserReference?
    /** The integration selected for the agent. If not set, no integration will be used for the agent */
    public var selectedIntegration: WfmIntegrationReference?
    /** Whether the integration association has been manually selected */
    public var userSelected: Bool?
    /** The list of integrations associated with the agent */
    public var associatedIntegrations: [AgentIntegrationAssociationResponse]?

    public init(agent: UserReference?, selectedIntegration: WfmIntegrationReference?, userSelected: Bool?, associatedIntegrations: [AgentIntegrationAssociationResponse]?) {
        self.agent = agent
        self.selectedIntegration = selectedIntegration
        self.userSelected = userSelected
        self.associatedIntegrations = associatedIntegrations
    }


}




public class AgentManagementUnitReference: Codable {







    /** The user (agent) for whom the management unit was requested */
    public var user: UserReference?
    /** The management to which the user (agent) belongs */
    public var managementUnit: ManagementUnitReference?
    /** The business unit to which the user (agent) belongs. Populate with expand=businessUnit */
    public var businessUnit: BusinessUnitReference?

    public init(user: UserReference?, managementUnit: ManagementUnitReference?, businessUnit: BusinessUnitReference?) {
        self.user = user
        self.managementUnit = managementUnit
        self.businessUnit = businessUnit
    }


}




public class AgentOwnedMappingPreview: Codable {













    /** The raw value of the agent-owned column */
    public var agentOwnedColumn: String?
    /** The email address of the user, if it exists */
    public var email: String?
    /** The id of the user, if it exists */
    public var userId: String?
    /** Whether the user exists */
    public var exists: Bool?
    /** Whether the user is a member of the campaign's queue */
    public var isQueueMember: Bool?
    /** The number of contact records whose agent-owned column matches the raw value */
    public var recordCount: Int?

    public init(agentOwnedColumn: String?, email: String?, userId: String?, exists: Bool?, isQueueMember: Bool?, recordCount: Int?) {
        self.agentOwnedColumn = agentOwnedColumn
        self.email = email
        self.userId = userId
        self.exists = exists
        self.isQueueMember = isQueueMember
        self.recordCount = recordCount
    }


}




public class AgentOwnedMappingPreviewListing: Codable {



    public var entities: [AgentOwnedMappingPreview]?

    public init(entities: [AgentOwnedMappingPreview]?) {
        self.entities = entities
    }


}




public class AgentOwnedRouting: Codable {







    /** Indicates if Agent Owned Callbacks are enabled for the queue */
    public var enableAgentOwnedCallbacks: Bool?
    /** The max amount of time a callback can be owned (in hours); Allowable range 1 - 168 hour(s) (inclusive) */
    public var maxOwnedCallbackHours: Int?
    /** The max amount of time a callback can be scheduled out into the future (in hours); Allowable range 1 - 720 hour(s) (inclusive) */
    public var maxOwnedCallbackDelayHours: Int?

    public init(enableAgentOwnedCallbacks: Bool?, maxOwnedCallbackHours: Int?, maxOwnedCallbackDelayHours: Int?) {
        self.enableAgentOwnedCallbacks = enableAgentOwnedCallbacks
        self.maxOwnedCallbackHours = maxOwnedCallbackHours
        self.maxOwnedCallbackDelayHours = maxOwnedCallbackDelayHours
    }


}




public class AgentTimeOffRequestPatch: Codable {



    public enum Status: String, Codable { 
        case canceled = "CANCELED"
    }



    /** Whether this request has been read by the agent */
    public var markedAsRead: Bool?
    /** The status of this time off request. Can only be canceled if the requested date has not already passed */
    public var status: Status?
    /** Notes about the time off request. Can only be edited while the request is still pending */
    public var notes: String?

    public init(markedAsRead: Bool?, status: Status?, notes: String?) {
        self.markedAsRead = markedAsRead
        self.status = status
        self.notes = notes
    }


}




public class AgentlessEmailSendResponseDto: Codable {





    public enum SenderType: String, Codable { 
        case outbound = "Outbound"
        case inbound = "Inbound"
        case integration = "Integration"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The identifier of the conversation. */
    public var conversationId: String?
    /** The identifier of the external participant of the given conversation. */
    public var senderType: SenderType?
    /** The sender of the message. */
    public var fromAddress: EmailAddress?
    /** The recipient of the message. We currently support one recipient only. */
    public var toAddresses: [EmailAddress]?
    /** The address to use for reply. */
    public var replyToAddress: EmailAddress?
    /** The subject of the message. */
    public var subject: String?
    /** The message creation timestamp. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, conversationId: String?, senderType: SenderType?, fromAddress: EmailAddress?, toAddresses: [EmailAddress]?, replyToAddress: EmailAddress?, subject: String?, dateCreated: Date?, selfUri: String?) {
        self._id = _id
        self.conversationId = conversationId
        self.senderType = senderType
        self.fromAddress = fromAddress
        self.toAddresses = toAddresses
        self.replyToAddress = replyToAddress
        self.subject = subject
        self.dateCreated = dateCreated
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case conversationId
        case senderType
        case fromAddress
        case toAddresses
        case replyToAddress
        case subject
        case dateCreated
        case selfUri
    }


}




public class AggregateMetricData: Codable {







    public var metric: String?
    public var qualifier: String?
    public var stats: StatisticalSummary?

    public init(metric: String?, qualifier: String?, stats: StatisticalSummary?) {
        self.metric = metric
        self.qualifier = qualifier
        self.stats = stats
    }


}




public class AlertingUnreadStatus: Codable {



    /** True is alert is unread, false if it has not been. */
    public var unread: Bool?

    public init(unread: Bool?) {
        self.unread = unread
    }


}




public class AnalyticsConversationWithoutAttributesMultiGetResponse: Codable {



    public var conversations: [AnalyticsConversationWithoutAttributes]?

    public init(conversations: [AnalyticsConversationWithoutAttributes]?) {
        self.conversations = conversations
    }


}




public class AnalyticsDataRetentionResponse: Codable {







    /** Analytics data retention period in days for the organization. */
    public var retentionDays: Int?
    /** Date and time when the analytics data retention was set. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date and time when the analytics data retention was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?

    public init(retentionDays: Int?, dateCreated: Date?, dateModified: Date?) {
        self.retentionDays = retentionDays
        self.dateCreated = dateCreated
        self.dateModified = dateModified
    }


}




public class AnalyticsQueryAggregation: Codable {

    public enum ModelType: String, Codable { 
        case termfrequency = "termFrequency"
        case numericrange = "numericRange"
    }









    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** For use with termFrequency aggregations */
    public var dimension: String?
    /** For use with numericRange aggregations */
    public var metric: String?
    /** For use with termFrequency aggregations */
    public var size: Int?
    /** For use with numericRange aggregations */
    public var ranges: [AggregationRange]?

    public init(type: ModelType?, dimension: String?, metric: String?, size: Int?, ranges: [AggregationRange]?) {
        self.type = type
        self.dimension = dimension
        self.metric = metric
        self.size = size
        self.ranges = ranges
    }


}




public class AnalyticsSessionMetric: Codable {







    /** Metric emission date. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var emitDate: Date?
    /** Unique name of this metric */
    public var name: String?
    /** The metric value */
    public var value: Int64?

    public init(emitDate: Date?, name: String?, value: Int64?) {
        self.emitDate = emitDate
        self.name = name
        self.value = value
    }


}




public class AppEventRequest: Codable {

























    /** Represents the action the customer performed. Event types are created for each unique event name and can be faceted on in segment and outcome conditions. A valid event name must only contain alphanumeric characters and underscores. A good event name is typically an object followed by the action performed in past tense, e.g. screen_viewed, search_performed, user_registered. */
    public var eventName: String?
    /** The name of the screen, view, or fragment in the app where the event took place. */
    public var screenName: String?
    /** Application that the customer is interacting with. */
    public var app: JourneyApp?
    /** Customer's device. */
    public var device: RequestDevice?
    /** SDK library used to generate the event. */
    public var sdkLibrary: SdkLibrary?
    /** Information relating to the device's network connectivity. */
    public var networkConnectivity: NetworkConnectivity?
    /** The referrer URL of the first event in the app session. */
    public var referrerUrl: String?
    /** Represents the keywords in a customer search query. */
    public var searchQuery: String?
    /** User-defined attributes associated with a particular event. These attributes provide additional context about the event. For example, items_in_cart or subscription_level. */
    public var attributes: [String:CustomEventAttribute]?
    /** Traits are attributes intrinsic to the customer that may be sent in selected events, (e.g. email, lastName, cellPhone). Traits are used to collect information for identity resolution. For example, the same person might be using an application on different devices which might create two sessions with different customerIds. Additional information can be provided as traits to help link those two sessions and customers to a single external contact through common identifiers that were submitted via a form fill, message, or other input in both sessions. */
    public var traits: [String:CustomEventAttribute]?
    /** Cookie ID of the customer associated with the app event. This is expected to be set per application install or device and can be used to identify a single customer across multiple sessions. This identifier, along with others passed as traits, is used for identity resolution. */
    public var customerCookieId: String?
    /** UTC timestamp indicating when the event actually took place, events older than an hour will be rejected. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?

    public init(eventName: String?, screenName: String?, app: JourneyApp?, device: RequestDevice?, sdkLibrary: SdkLibrary?, networkConnectivity: NetworkConnectivity?, referrerUrl: String?, searchQuery: String?, attributes: [String:CustomEventAttribute]?, traits: [String:CustomEventAttribute]?, customerCookieId: String?, createdDate: Date?) {
        self.eventName = eventName
        self.screenName = screenName
        self.app = app
        self.device = device
        self.sdkLibrary = sdkLibrary
        self.networkConnectivity = networkConnectivity
        self.referrerUrl = referrerUrl
        self.searchQuery = searchQuery
        self.attributes = attributes
        self.traits = traits
        self.customerCookieId = customerCookieId
        self.createdDate = createdDate
    }


}



/** Describes an operation being performed on an Architect object */

public class ArchitectFlowOutcomeNotificationArchitectOperation: Codable {









    public enum ActionName: String, Codable { 
        case create = "CREATE"
        case checkin = "CHECKIN"
        case checkout = "CHECKOUT"
        case debug = "DEBUG"
        case delete = "DELETE"
        case history = "HISTORY"
        case publish = "PUBLISH"
        case revert = "REVERT"
        case save = "SAVE"
        case stateChange = "STATE_CHANGE"
        case update = "UPDATE"
        case validate = "VALIDATE"
    }

    public enum ActionStatus: String, Codable { 
        case locked = "LOCKED"
        case unlocked = "UNLOCKED"
        case started = "STARTED"
        case pendingGeneration = "PENDING_GENERATION"
        case pendingBackendNotification = "PENDING_BACKEND_NOTIFICATION"
        case success = "SUCCESS"
        case failure = "FAILURE"
    }









    /** A unique identifier for this operation, as generated by the initiating client */
    public var _id: String?
    /** Indicates if the operation is complete */
    public var complete: Bool?
    public var user: ArchitectFlowOutcomeNotificationUser?
    public var client: ArchitectFlowOutcomeNotificationClient?
    /** The action being performed */
    public var actionName: ActionName?
    /** The action status */
    public var actionStatus: ActionStatus?
    /** The error message, if the action failed */
    public var errorMessage: String?
    /** The error code, if the action failed */
    public var errorCode: String?
    public var errorMessageParams: ArchitectFlowOutcomeNotificationErrorMessageParams?
    /** The error details, if the action failed */
    public var errorDetails: [ArchitectFlowOutcomeNotificationErrorDetail]?

    public init(_id: String?, complete: Bool?, user: ArchitectFlowOutcomeNotificationUser?, client: ArchitectFlowOutcomeNotificationClient?, actionName: ActionName?, actionStatus: ActionStatus?, errorMessage: String?, errorCode: String?, errorMessageParams: ArchitectFlowOutcomeNotificationErrorMessageParams?, errorDetails: [ArchitectFlowOutcomeNotificationErrorDetail]?) {
        self._id = _id
        self.complete = complete
        self.user = user
        self.client = client
        self.actionName = actionName
        self.actionStatus = actionStatus
        self.errorMessage = errorMessage
        self.errorCode = errorCode
        self.errorMessageParams = errorMessageParams
        self.errorDetails = errorDetails
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case complete
        case user
        case client
        case actionName
        case actionStatus
        case errorMessage
        case errorCode
        case errorMessageParams
        case errorDetails
    }


}



/** The client who initiated the change. */

public class ArchitectPromptNotificationClient: Codable {





    /** The ID of the client. */
    public var _id: String?
    /** The name of the client, if available. */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class ArchitectPromptNotificationErrorDetail: Codable {









    public var errorCode: String?
    public var entityId: String?
    public var entityName: String?
    public var fieldName: String?

    public init(errorCode: String?, entityId: String?, entityName: String?, fieldName: String?) {
        self.errorCode = errorCode
        self.entityId = entityId
        self.entityName = entityName
        self.fieldName = fieldName
    }


}




public class ArchitectPromptNotificationHomeOrganization: Codable {







    public var _id: String?
    public var name: String?
    public var thirdPartyOrgName: String?

    public init(_id: String?, name: String?, thirdPartyOrgName: String?) {
        self._id = _id
        self.name = name
        self.thirdPartyOrgName = thirdPartyOrgName
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case thirdPartyOrgName
    }


}




public class ArchitectPromptNotificationPromptNotification: Codable {









    /** The prompt ID */
    public var _id: String?
    /** The prompt name */
    public var name: String?
    /** The prompt description */
    public var _description: String?
    public var currentOperation: ArchitectPromptNotificationArchitectOperation?

    public init(_id: String?, name: String?, _description: String?, currentOperation: ArchitectPromptNotificationArchitectOperation?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.currentOperation = currentOperation
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case currentOperation
    }


}




public class ArchitectPromptResourceNotificationPromptResourceNotification: Codable {













    /** Id of the prompt that this notification is for. */
    public var promptId: String?
    /** Id of the prompt resource that this notification is for. */
    public var _id: String?
    /** Language resource that this notification is for. */
    public var language: String?
    /** Uri to the file for this prompt resource. */
    public var mediaUri: String?
    /** Current upload status of the prompt resource (created, uploaded, transcoded, transcodeFailed). */
    public var uploadStatus: String?
    /** Duration (in seconds) for the transcoded audio file. */
    public var durationSeconds: Double?

    public init(promptId: String?, _id: String?, language: String?, mediaUri: String?, uploadStatus: String?, durationSeconds: Double?) {
        self.promptId = promptId
        self._id = _id
        self.language = language
        self.mediaUri = mediaUri
        self.uploadStatus = uploadStatus
        self.durationSeconds = durationSeconds
    }

    public enum CodingKeys: String, CodingKey { 
        case promptId
        case _id = "id"
        case language
        case mediaUri
        case uploadStatus
        case durationSeconds
    }


}




public class ArchitectSystemPromptResourceNotificationSystemPromptResourceNotification: Codable {













    /** Id of the prompt that this notification is for. */
    public var promptId: String?
    /** Id of the prompt resource that this notification is for. */
    public var _id: String?
    /** Language resource that this notification is for. */
    public var language: String?
    /** Uri to the file for this system prompt resource. */
    public var mediaUri: String?
    /** Current upload status of the prompt resource (created, uploaded, transcoded, transcodeFailed). */
    public var uploadStatus: String?
    /** Duration (in seconds) for the transcoded audio file. */
    public var durationSeconds: Double?

    public init(promptId: String?, _id: String?, language: String?, mediaUri: String?, uploadStatus: String?, durationSeconds: Double?) {
        self.promptId = promptId
        self._id = _id
        self.language = language
        self.mediaUri = mediaUri
        self.uploadStatus = uploadStatus
        self.durationSeconds = durationSeconds
    }

    public enum CodingKeys: String, CodingKey { 
        case promptId
        case _id = "id"
        case language
        case mediaUri
        case uploadStatus
        case durationSeconds
    }


}




public class ArchiveRetention: Codable {



    public enum StorageMedium: String, Codable { 
        case cloudarchive = "CLOUDARCHIVE"
    }

    public var days: Int?
    public var storageMedium: StorageMedium?

    public init(days: Int?, storageMedium: StorageMedium?) {
        self.days = days
        self.storageMedium = storageMedium
    }


}




public class AssignUsers: Codable {





    /** List of user ids to assign to a performance profile */
    public var membersToAssign: [String]?
    /** List of user ids to remove from a performance profile */
    public var membersToRemove: [String]?

    public init(membersToAssign: [String]?, membersToRemove: [String]?) {
        self.membersToAssign = membersToAssign
        self.membersToRemove = membersToRemove
    }


}




public class AssistanceCondition: Codable {

    public enum Operator: String, Codable { 
        case exists = "EXISTS"
        case notexists = "NOTEXISTS"
    }



    /** The operator for the assistance condition. The operator defines whether the listed topicIds should EXIST or NOTEXIST for the condition to be evaluated as true. */
    public var _operator: Operator?
    /** List of topicIds within the assistance condition which would be combined together using logical OR operator. Eg ( topicId_1 || topicId_2 ) . */
    public var topicIds: [String]?

    public init(_operator: Operator?, topicIds: [String]?) {
        self._operator = _operator
        self.topicIds = topicIds
    }

    public enum CodingKeys: String, CodingKey { 
        case _operator = "operator"
        case topicIds
    }


}




public class AsyncJob: Codable {





    public enum State: String, Codable { 
        case running = "Running"
        case completed = "Completed"
        case failed = "Failed"
        case cancelled = "Cancelled"
    }

    public var _id: String?
    public var selfUri: String?
    public var state: State?

    public init(_id: String?, selfUri: String?, state: State?) {
        self._id = _id
        self.selfUri = selfUri
        self.state = state
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case state
    }


}




public class AsyncQueryStatus: Codable {

    public enum State: String, Codable { 
        case queued = "QUEUED"
        case pending = "PENDING"
        case failed = "FAILED"
        case cancelled = "CANCELLED"
        case fulfilled = "FULFILLED"
        case expired = "EXPIRED"
    }









    /** The current state of the asynchronous query */
    public var state: State?
    /** The error associated with the current query, if the state is FAILED */
    public var errorMessage: String?
    /** The time at which results for this query will expire. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var expirationDate: Date?
    /** The time at which the query was submitted. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var submissionDate: Date?
    /** The time at which the query completed. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var completionDate: Date?

    public init(state: State?, errorMessage: String?, expirationDate: Date?, submissionDate: Date?, completionDate: Date?) {
        self.state = state
        self.errorMessage = errorMessage
        self.expirationDate = expirationDate
        self.submissionDate = submissionDate
        self.completionDate = completionDate
    }


}




public class Attachment: Codable {













    /** The unique identifier for the attachment. */
    public var attachmentId: String?
    /** The name of the attachment. */
    public var name: String?
    /** The content uri of the attachment. If set, this is commonly a public api download location. */
    public var contentUri: String?
    /** The type of file the attachment is. */
    public var contentType: String?
    /** The length of the attachment file. */
    public var contentLength: Int?
    /** Whether or not the attachment was attached inline., */
    public var inlineImage: Bool?

    public init(attachmentId: String?, name: String?, contentUri: String?, contentType: String?, contentLength: Int?, inlineImage: Bool?) {
        self.attachmentId = attachmentId
        self.name = name
        self.contentUri = contentUri
        self.contentType = contentType
        self.contentLength = contentLength
        self.inlineImage = inlineImage
    }


}




public class AttemptLimitsEntityListing: Codable {





















    public var entities: [AttemptLimits]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [AttemptLimits]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class Attribute: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The attribute name. */
    public var name: String?
    public var version: Int?
    public var _description: String?
    public var createdBy: DomainEntityRef?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    public var modifiedBy: DomainEntityRef?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, version: Int?, _description: String?, createdBy: DomainEntityRef?, dateCreated: Date?, modifiedBy: DomainEntityRef?, dateModified: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.version = version
        self._description = _description
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case version
        case _description = "description"
        case createdBy
        case dateCreated
        case modifiedBy
        case dateModified
        case selfUri
    }


}




public class AudioUpdatedEvent: Codable {











    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication */
    public var communicationId: String?
    /** The updated audioState for the target communication. */
    public var audioState: AudioState?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, audioState: AudioState?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.audioState = audioState
    }


}




public class AuditQueryService: Codable {





    /** Name of the Service */
    public var name: String?
    /** List of Entities */
    public var entities: [AuditQueryEntity]?

    public init(name: String?, entities: [AuditQueryEntity]?) {
        self.name = name
        self.entities = entities
    }


}




public class AuditUser: Codable {







    /** The ID (UUID) of the user who initiated the action of this AuditMessage. */
    public var _id: String?
    /** The full username of the user who initiated the action of this AuditMessage. */
    public var name: String?
    /** The display name of the user who initiated the action of this AuditMessage. */
    public var display: String?

    public init(_id: String?, name: String?, display: String?) {
        self._id = _id
        self.name = name
        self.display = display
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case display
    }


}




public class AuthzDivisionEntityListing: Codable {





















    public var entities: [AuthzDivision]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [AuthzDivision]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class AvailableLanguageList: Codable {



    public var languages: [String]?

    public init(languages: [String]?) {
        self.languages = languages
    }


}




public class AvailableTopic: Codable {















    public enum Visibility: String, Codable { 
        case _public = "Public"
        case preview = "Preview"
    }







    public enum Transports: String, Codable { 
        case all = "All"
        case websocket = "Websocket"
        case eventBridge = "EventBridge"
        case processAutomation = "ProcessAutomation"
    }





    public var _description: String?
    public var _id: String?
    /** Full detailed permissions required to subscribe to the topic */
    public var permissionDetails: [PermissionDetails]?
    /** Permissions required to subscribe to the topic */
    public var requiresPermissions: [String]?
    /** True if the subscribing user must belong to the same division as the topic object ID */
    public var requiresDivisionPermissions: Bool?
    /** If multiple permissions are required for this topic, such as both requiresCurrentUser and requiresDivisionPermissions, then true here indicates that meeting any one condition will satisfy the requirements; false indicates all conditions must be met. */
    public var requiresAnyValidator: Bool?
    /** Whether or not the permissions on this topic are enforced */
    public var enforced: Bool?
    /** Visibility of this topic (Public or Preview) */
    public var visibility: Visibility?
    public var schema: [String:JSON]?
    /** True if the topic user ID is required to match the subscribing user ID */
    public var requiresCurrentUser: Bool?
    /** True if permissions are only required when the topic user ID does not match the subscribing user ID */
    public var requiresCurrentUserOrPermission: Bool?
    /** Transports that support events for the topic */
    public var transports: [Transports]?
    public var publicApiTemplateUriPaths: [String]?
    /** Parameters in the topic name that can be substituted, in the order they appear in the topic name */
    public var topicParameters: [String]?

    public init(_description: String?, _id: String?, permissionDetails: [PermissionDetails]?, requiresPermissions: [String]?, requiresDivisionPermissions: Bool?, requiresAnyValidator: Bool?, enforced: Bool?, visibility: Visibility?, schema: [String:JSON]?, requiresCurrentUser: Bool?, requiresCurrentUserOrPermission: Bool?, transports: [Transports]?, publicApiTemplateUriPaths: [String]?, topicParameters: [String]?) {
        self._description = _description
        self._id = _id
        self.permissionDetails = permissionDetails
        self.requiresPermissions = requiresPermissions
        self.requiresDivisionPermissions = requiresDivisionPermissions
        self.requiresAnyValidator = requiresAnyValidator
        self.enforced = enforced
        self.visibility = visibility
        self.schema = schema
        self.requiresCurrentUser = requiresCurrentUser
        self.requiresCurrentUserOrPermission = requiresCurrentUserOrPermission
        self.transports = transports
        self.publicApiTemplateUriPaths = publicApiTemplateUriPaths
        self.topicParameters = topicParameters
    }

    public enum CodingKeys: String, CodingKey { 
        case _description = "description"
        case _id = "id"
        case permissionDetails
        case requiresPermissions
        case requiresDivisionPermissions
        case requiresAnyValidator
        case enforced
        case visibility
        case schema
        case requiresCurrentUser
        case requiresCurrentUserOrPermission
        case transports
        case publicApiTemplateUriPaths
        case topicParameters
    }


}




public class BaseMediaSettings: Codable {



    /** Indicates if auto-answer is enabled for the given media type or subtype (default is false).  Subtype settings take precedence over media type settings. */
    public var enableAutoAnswer: Bool?

    public init(enableAutoAnswer: Bool?) {
        self.enableAutoAnswer = enableAutoAnswer
    }


}




public class BatchDownloadJobResult: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Conversation id of the result */
    public var conversationId: String?
    /** Recording id of the result */
    public var recordingId: String?
    /** URL of results... HTTP GET from this location to download results for this item */
    public var resultUrl: String?
    /** Content type of this result */
    public var contentType: String?
    /** An error message, in case of failed processing will indicate the cause of the failure */
    public var errorMsg: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, conversationId: String?, recordingId: String?, resultUrl: String?, contentType: String?, errorMsg: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.conversationId = conversationId
        self.recordingId = recordingId
        self.resultUrl = resultUrl
        self.contentType = contentType
        self.errorMsg = errorMsg
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case conversationId
        case recordingId
        case resultUrl
        case contentType
        case errorMsg
        case selfUri
    }


}




public class BatchEventResponse: Codable {



    /** A list of validation or server errors that occurred for posted events. */
    public var errors: [EventError]?

    public init(errors: [EventError]?) {
        self.errors = errors
    }


}




public class BenefitAssessment: Codable {







    public enum State: String, Codable { 
        case created = "Created"
        case finished = "Finished"
        case failed = "Failed"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The list of queues that are assessed for Predictive Routing benefit. */
    public var queues: [AddressableEntityRef]?
    /** A set of key performance indicators applied on the queue to determine suitability of Predictive Routing. */
    public var kpiAssessments: [KeyPerformanceIndicatorAssessment]?
    /** State of the benefit assessment. */
    public var state: State?
    /** The unique identifier of job that created this benefit assessment. */
    public var jobId: String?
    /** Creation Date of the benefit assessment. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Modified Date of the benefit assessment. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, queues: [AddressableEntityRef]?, kpiAssessments: [KeyPerformanceIndicatorAssessment]?, state: State?, jobId: String?, dateCreated: Date?, dateModified: Date?, selfUri: String?) {
        self._id = _id
        self.queues = queues
        self.kpiAssessments = kpiAssessments
        self.state = state
        self.jobId = jobId
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case queues
        case kpiAssessments
        case state
        case jobId
        case dateCreated
        case dateModified
        case selfUri
    }


}




public class Biography: Codable {











    /** Personal detailed description */
    public var biography: String?
    public var interests: [String]?
    public var hobbies: [String]?
    public var spouse: String?
    /** User education details */
    public var education: [Education]?

    public init(biography: String?, interests: [String]?, hobbies: [String]?, spouse: String?, education: [Education]?) {
        self.biography = biography
        self.interests = interests
        self.hobbies = hobbies
        self.spouse = spouse
        self.education = education
    }


}




public class BotAggregateQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case askactionid = "askActionId"
        case askactionresult = "askActionResult"
        case askactiontype = "askActionType"
        case botfinalintent = "botFinalIntent"
        case botid = "botId"
        case botintent = "botIntent"
        case botproduct = "botProduct"
        case botprovider = "botProvider"
        case botrecognitionfailurereason = "botRecognitionFailureReason"
        case botresult = "botResult"
        case botsessionid = "botSessionId"
        case botslot = "botSlot"
        case botversion = "botVersion"
        case conversationid = "conversationId"
        case externalcontactid = "externalContactId"
        case intermediateintentname = "intermediateIntentName"
        case knowledgebaseid = "knowledgeBaseId"
        case languagecode = "languageCode"
        case lastactionid = "lastActionId"
        case lastinputactionid = "lastInputActionId"
        case mediatype = "mediaType"
        case messagetype = "messageType"
        case selfserved = "selfServed"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension predicates */
    public var value: String?
    /** Right hand side for dimension predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case _operator = "operator"
        case value
        case range
    }


}




public class BotSearchResponse: Codable {





    public enum BotType: String, Codable { 
        case genesysBotConnector = "GenesysBotConnector"
        case genesysDialogEngine = "GenesysDialogEngine"
        case amazonLex = "AmazonLex"
        case googleDialogFlowES = "GoogleDialogFlowES"
        case googleDialogFlowCX = "GoogleDialogFlowCX"
        case nuanceDlg = "NuanceDlg"
        case genesysBotFlow = "GenesysBotFlow"
    }





    /** The id of the bot */
    public var _id: String?
    /** The name of the bot */
    public var name: String?
    /** The provider of the bot */
    public var botType: BotType?
    /** The description of the bot */
    public var _description: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, botType: BotType?, _description: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.botType = botType
        self._description = _description
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case botType
        case _description = "description"
        case selfUri
    }


}



/** A summary description for a botConnector bot */

public class BotSummary: Codable {









    /** The name of the bot. */
    public var name: String?
    /** The id of the bot. */
    public var _id: String?
    /** An optional description of the bot. */
    public var _description: String?
    /** A system-generated string that contains metadata about this bot. */
    public var botCompositeTag: String?

    public init(name: String?, _id: String?, _description: String?, botCompositeTag: String?) {
        self.name = name
        self._id = _id
        self._description = _description
        self.botCompositeTag = botCompositeTag
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _id = "id"
        case _description = "description"
        case botCompositeTag
    }


}




public class BuAgentScheduleHistoryChangeMetadata: Codable {





    /** The timestamp of the schedule change. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The user that made the schedule change */
    public var modifiedBy: UserReference?

    public init(dateModified: Date?, modifiedBy: UserReference?) {
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
    }


}




public class BuAgentSchedulePublishedScheduleReference: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The start week date for this schedule. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekDate: Date?
    /** The number of weeks encompassed by the schedule */
    public var weekCount: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, weekDate: Date?, weekCount: Int?, selfUri: String?) {
        self._id = _id
        self.weekDate = weekDate
        self.weekCount = weekCount
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case weekCount
        case selfUri
    }


}




public class BuAsyncScheduleResponse: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }





    /** The status of the operation */
    public var status: Status?
    /** The ID for the operation */
    public var operationId: String?
    /** The result of the operation.  Null unless status == Complete */
    public var result: BuScheduleMetadata?

    public init(status: Status?, operationId: String?, result: BuScheduleMetadata?) {
        self.status = status
        self.operationId = operationId
        self.result = result
    }


}




public class BuForecastTimeSeriesResult: Codable {

    public enum Metric: String, Codable { 
        case offered = "Offered"
        case averageHandleTimeSeconds = "AverageHandleTimeSeconds"
    }

    public enum ForecastingMethod: String, Codable { 
        case autoRegressiveIntegratedMovingAverage = "AutoRegressiveIntegratedMovingAverage"
        case movingAverage = "MovingAverage"
        case singleExponentialSmoothing = "SingleExponentialSmoothing"
        case randomWalk = "RandomWalk"
        case decompositionUsingAdditiveSeasonality = "DecompositionUsingAdditiveSeasonality"
        case decompositionUsingMultiplicativeSeasonality = "DecompositionUsingMultiplicativeSeasonality"
        case holtWintersAdditiveSeasonality = "HoltWintersAdditiveSeasonality"
        case holtWintersAdditiveSeasonalityWithDampedTrend = "HoltWintersAdditiveSeasonalityWithDampedTrend"
        case holtWintersMultiplicativeSeasonality = "HoltWintersMultiplicativeSeasonality"
        case holtWintersMultiplicativeSeasonalityWithDampedTrend = "HoltWintersMultiplicativeSeasonalityWithDampedTrend"
        case dampedLinearExponentialSmoothing = "DampedLinearExponentialSmoothing"
        case doubleExponentialSmoothing = "DoubleExponentialSmoothing"
        case doubleMovingAverage = "DoubleMovingAverage"
        case linearExponentialSmoothing = "LinearExponentialSmoothing"
        case linearWeightedMovingAverage = "LinearWeightedMovingAverage"
        case pointEstimateUsingDampedLinearExponentialSmoothing = "PointEstimateUsingDampedLinearExponentialSmoothing"
        case pointEstimateUsingDoubleExponentialSmoothing = "PointEstimateUsingDoubleExponentialSmoothing"
        case pointEstimateUsingLatestWeek = "PointEstimateUsingLatestWeek"
        case pointEstimateUsingLinearExponentialSmoothing = "PointEstimateUsingLinearExponentialSmoothing"
        case pointEstimateUsingWeightedAverage = "PointEstimateUsingWeightedAverage"
        case curveFit = "CurveFit"
        case multiLinearRegression = "MultiLinearRegression"
        case dynamicHarmonicRegression = "DynamicHarmonicRegression"
        case theta = "Theta"
        case ensemble = "Ensemble"
        case other = "Other"
    }

    public enum ForecastType: String, Codable { 
        case longTerm = "LongTerm"
        case shortTerm = "ShortTerm"
    }

    /** The metric this result applies to */
    public var metric: Metric?
    /** The forecasting method that was used for this metric */
    public var forecastingMethod: ForecastingMethod?
    /** The forecasting type in this forecast result */
    public var forecastType: ForecastType?

    public init(metric: Metric?, forecastingMethod: ForecastingMethod?, forecastType: ForecastType?) {
        self.metric = metric
        self.forecastingMethod = forecastingMethod
        self.forecastType = forecastType
    }


}




public class BuGetCurrentAgentScheduleRequest: Codable {





    /** Start date of the range to search. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** End date of the range to search. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endDate: Date?

    public init(startDate: Date?, endDate: Date?) {
        self.startDate = startDate
        self.endDate = endDate
    }


}




public class BuIntradayResponse: Codable {







    public enum NoDataReason: String, Codable { 
        case noPublishedSchedule = "NoPublishedSchedule"
        case noSourceForecast = "NoSourceForecast"
    }

    public enum Categories: String, Codable { 
        case forecastData = "ForecastData"
        case scheduleData = "ScheduleData"
        case performancePredictionData = "PerformancePredictionData"
    }







    /** The start of the date range for which this data applies.  This is also the start reference point for the intervals represented in the various arrays. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** The end of the date range for which this data applies. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endDate: Date?
    /** The aggregation period in minutes, which determines the interval duration of the returned data */
    public var intervalLengthMinutes: Int?
    /** If not null, the reason there was no data for the request */
    public var noDataReason: NoDataReason?
    /** The categories to which this data corresponds */
    public var categories: [Categories]?
    /** Short term forecast reference */
    public var shortTermForecast: BuShortTermForecastReference?
    /** Schedule reference */
    public var schedule: BuScheduleReference?
    /** Intraday data grouped by a single media type and set of planning group IDs */
    public var intradayDataGroupings: [BuIntradayDataGroup]?

    public init(startDate: Date?, endDate: Date?, intervalLengthMinutes: Int?, noDataReason: NoDataReason?, categories: [Categories]?, shortTermForecast: BuShortTermForecastReference?, schedule: BuScheduleReference?, intradayDataGroupings: [BuIntradayDataGroup]?) {
        self.startDate = startDate
        self.endDate = endDate
        self.intervalLengthMinutes = intervalLengthMinutes
        self.noDataReason = noDataReason
        self.categories = categories
        self.shortTermForecast = shortTermForecast
        self.schedule = schedule
        self.intradayDataGroupings = intradayDataGroupings
    }


}




public class BuManagementUnitScheduleSummary: Codable {











    /** The management unit to which this summary applies */
    public var managementUnit: ManagementUnitReference?
    /** The number of agents from this management unit that are in the schedule */
    public var agentCount: Int?
    /** The start of the schedule change in the management unit. Only populated in schedule update notifications. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** The end of the schedule change in the management unit. Only populated in schedule update notifications. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endDate: Date?
    /** The agents in the management unit who are part of this schedule, or in schedule change notifications, the agents that were changed. Note this will come back as an empty list unless the appropriate expand query parameter is passed */
    public var agents: [UserReference]?

    public init(managementUnit: ManagementUnitReference?, agentCount: Int?, startDate: Date?, endDate: Date?, agents: [UserReference]?) {
        self.managementUnit = managementUnit
        self.agentCount = agentCount
        self.startDate = startDate
        self.endDate = endDate
        self.agents = agents
    }


}




public class BuRescheduleAgentScheduleResult: Codable {







    /** The management unit to which this part of the result applies */
    public var managementUnit: ManagementUnitReference?
    /** The agent schedules.  Result will always come via the downloadUrl; however the schema is included for documentation */
    public var downloadResult: MuRescheduleResultWrapper?
    /** The download URL from which to fetch the result */
    public var downloadUrl: String?

    public init(managementUnit: ManagementUnitReference?, downloadResult: MuRescheduleResultWrapper?, downloadUrl: String?) {
        self.managementUnit = managementUnit
        self.downloadResult = downloadResult
        self.downloadUrl = downloadUrl
    }


}




public class BuScheduleReferenceForMuRoute: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The start week date for this schedule. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekDate: Date?
    /** The start week date for this schedule */
    public var businessUnit: BusinessUnitReference?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, weekDate: Date?, businessUnit: BusinessUnitReference?, selfUri: String?) {
        self._id = _id
        self.weekDate = weekDate
        self.businessUnit = businessUnit
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case businessUnit
        case selfUri
    }


}




public class BuServiceLevel: Codable {







    /** Whether to include service level targets in the associated configuration */
    public var include: Bool?
    /** Service level target percent answered. Required if include == true */
    public var percent: Int?
    /** Service level target answer time. Required if include == true */
    public var seconds: Int?

    public init(include: Bool?, percent: Int?, seconds: Int?) {
        self.include = include
        self.percent = percent
        self.seconds = seconds
    }


}




public class BuShortTermForecastListItem: Codable {







    public enum CreationMethod: String, Codable { 
        case _import = "Import"
        case importedHistoricalWeightedAverage = "ImportedHistoricalWeightedAverage"
        case historicalWeightedAverage = "HistoricalWeightedAverage"
        case advanced = "Advanced"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The start week date of this forecast in yyyy-MM-dd.  Must fall on the start day of week for the associated business unit. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekDate: Date?
    /** The number of weeks this forecast covers */
    public var weekCount: Int?
    /** The method by which this forecast was created */
    public var creationMethod: CreationMethod?
    /** The description of this forecast */
    public var _description: String?
    /** Whether this forecast contains modifications on legacy metrics */
    public var legacy: Bool?
    /** Metadata for this forecast */
    public var metadata: WfmVersionedEntityMetadata?
    /** Whether this forecast can be used for scheduling */
    public var canUseForScheduling: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, weekDate: Date?, weekCount: Int?, creationMethod: CreationMethod?, _description: String?, legacy: Bool?, metadata: WfmVersionedEntityMetadata?, canUseForScheduling: Bool?, selfUri: String?) {
        self._id = _id
        self.weekDate = weekDate
        self.weekCount = weekCount
        self.creationMethod = creationMethod
        self._description = _description
        self.legacy = legacy
        self.metadata = metadata
        self.canUseForScheduling = canUseForScheduling
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case weekCount
        case creationMethod
        case _description = "description"
        case legacy
        case metadata
        case canUseForScheduling
        case selfUri
    }


}




public class BuShortTermForecastReference: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The weekDate of the short term forecast in yyyy-MM-dd format. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekDate: Date?
    /** The description of the short term forecast */
    public var _description: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, weekDate: Date?, _description: String?, selfUri: String?) {
        self._id = _id
        self.weekDate = weekDate
        self._description = _description
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case _description = "description"
        case selfUri
    }


}




public class BuUpdateAgentScheduleUploadSchema: Codable {















    /** The ID of the user to whom this agent schedule applies */
    public var userId: String?
    /** The ID of the work plan for this user.  Mutually exclusive with workPlanIdsPerWeek */
    public var workPlanId: ValueWrapperString?
    /** The IDs of the work plans per week for this user.  Mutually exclusive with workPlanId */
    public var workPlanIdsPerWeek: ListWrapperString?
    /** The shift definitions for this agent schedule */
    public var shifts: [BuUpdateAgentScheduleShift]?
    /** Any full day time off markers that apply to this agent schedule */
    public var fullDayTimeOffMarkers: [BuFullDayTimeOffMarker]?
    /** Version metadata for this agent schedule. Required if updating or deleting an existing agent schedule, otherwise should be omitted */
    public var metadata: WfmVersionedEntityMetadata?
    /** Whether to delete this agent's schedule. Defaults to false if not set */
    public var delete: Bool?

    public init(userId: String?, workPlanId: ValueWrapperString?, workPlanIdsPerWeek: ListWrapperString?, shifts: [BuUpdateAgentScheduleShift]?, fullDayTimeOffMarkers: [BuFullDayTimeOffMarker]?, metadata: WfmVersionedEntityMetadata?, delete: Bool?) {
        self.userId = userId
        self.workPlanId = workPlanId
        self.workPlanIdsPerWeek = workPlanIdsPerWeek
        self.shifts = shifts
        self.fullDayTimeOffMarkers = fullDayTimeOffMarkers
        self.metadata = metadata
        self.delete = delete
    }


}




public class BulkCallbackDisconnectRequest: Codable {



    /** The list of requests to disconnect callbacks in bulk */
    public var callbackDisconnectIdentifiers: [CallbackDisconnectIdentifier]?

    public init(callbackDisconnectIdentifiers: [CallbackDisconnectIdentifier]?) {
        self.callbackDisconnectIdentifiers = callbackDisconnectIdentifiers
    }


}




public class BulkResponseResultVoidEntity: Codable {









    public var _id: String?
    public var success: Bool?
    public var entity: JSON?
    public var error: BulkErrorEntity?

    public init(_id: String?, success: Bool?, entity: JSON?, error: BulkErrorEntity?) {
        self._id = _id
        self.success = success
        self.entity = entity
        self.error = error
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case success
        case entity
        case error
    }


}




public class BulkShiftTradeStateUpdateRequest: Codable {



    /** The shift trades to update */
    public var entities: [BulkUpdateShiftTradeStateRequestItem]?

    public init(entities: [BulkUpdateShiftTradeStateRequestItem]?) {
        self.entities = entities
    }


}



/** Structured template button object. */

public class ButtonComponent: Codable {





    /** Text to show inside the button. */
    public var title: String?
    /** The button actions (Deprecated). */
    public var actions: ContentActions?

    public init(title: String?, actions: ContentActions?) {
        self.title = title
        self.actions = actions
    }


}




public class ButtonResponse: Codable {

    public enum ModelType: String, Codable { 
        case button = "Button"
        case quickReply = "QuickReply"
    }





    public enum MessageType: String, Codable { 
        case quickReply = "QuickReply"
        case card = "Card"
        case carousel = "Carousel"
    }

    /** Button response type that captures Button and QuickReply type responses */
    public var type: ModelType?
    /** Text to show inside the Button reply. This is also used as the response text after clicking on the Button. */
    public var text: String?
    /** Content of the textback payload after clicking a button */
    public var payload: String?
    /** Button response message type that captures QuickReply , Cards and Carousel .This is used  as label for Card selection */
    public var messageType: MessageType?

    public init(type: ModelType?, text: String?, payload: String?, messageType: MessageType?) {
        self.type = type
        self.text = text
        self.payload = payload
        self.messageType = messageType
    }


}




public class CalendarUrlResponse: Codable {





    /** The calendar url for the user to subscribe with supported clients */
    public var calendarUrl: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(calendarUrl: String?, selfUri: String?) {
        self.calendarUrl = calendarUrl
        self.selfUri = selfUri
    }


}




public class Calibration: Codable {

































    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var calibrator: User?
    public var agent: User?
    public var conversation: ConversationReference?
    public var evaluationForm: EvaluationForm?
    public var contextId: String?
    public var averageScore: Int?
    public var highScore: Int?
    public var lowScore: Int?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    public var evaluations: [Evaluation]?
    public var evaluators: [User]?
    public var scoringIndex: Evaluation?
    public var expertEvaluator: User?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, calibrator: User?, agent: User?, conversation: ConversationReference?, evaluationForm: EvaluationForm?, contextId: String?, averageScore: Int?, highScore: Int?, lowScore: Int?, createdDate: Date?, evaluations: [Evaluation]?, evaluators: [User]?, scoringIndex: Evaluation?, expertEvaluator: User?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.calibrator = calibrator
        self.agent = agent
        self.conversation = conversation
        self.evaluationForm = evaluationForm
        self.contextId = contextId
        self.averageScore = averageScore
        self.highScore = highScore
        self.lowScore = lowScore
        self.createdDate = createdDate
        self.evaluations = evaluations
        self.evaluators = evaluators
        self.scoringIndex = scoringIndex
        self.expertEvaluator = expertEvaluator
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case calibrator
        case agent
        case conversation
        case evaluationForm
        case contextId
        case averageScore
        case highScore
        case lowScore
        case createdDate
        case evaluations
        case evaluators
        case scoringIndex
        case expertEvaluator
        case selfUri
    }


}




public class CallCommand: Codable {





    /** The phone number to dial for this call. */
    public var callNumber: String?
    /** For a dialer preview or scheduled callback, the phone column associated with the phone number */
    public var phoneColumn: String?

    public init(callNumber: String?, phoneColumn: String?) {
        self.callNumber = callNumber
        self.phoneColumn = phoneColumn
    }


}




public class CallForwarding: Codable {













    public enum Voicemail: String, Codable { 
        case purecloud = "PURECLOUD"
        case lastcall = "LASTCALL"
        case _none = "NONE"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var user: User?
    /** Whether or not CallForwarding is enabled */
    public var enabled: Bool?
    /** This property is deprecated. Please use the calls property */
    public var phoneNumber: String?
    /** An ordered list of CallRoutes to be executed when CallForwarding is enabled */
    public var calls: [CallRoute]?
    /** The type of voicemail to use with the callForwarding configuration */
    public var voicemail: Voicemail?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, user: User?, enabled: Bool?, phoneNumber: String?, calls: [CallRoute]?, voicemail: Voicemail?, modifiedDate: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.user = user
        self.enabled = enabled
        self.phoneNumber = phoneNumber
        self.calls = calls
        self.voicemail = voicemail
        self.modifiedDate = modifiedDate
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case user
        case enabled
        case phoneNumber
        case calls
        case voicemail
        case modifiedDate
        case selfUri
    }


}




public class CallableTime: Codable {





    /** The time intervals for which it is acceptable to place outbound calls. */
    public var timeSlots: [CampaignTimeSlot]?
    /** The time zone for the time slots; for example, Africa/Abidjan */
    public var timeZoneId: String?

    public init(timeSlots: [CampaignTimeSlot]?, timeZoneId: String?) {
        self.timeSlots = timeSlots
        self.timeZoneId = timeZoneId
    }


}




public class CallableTimeSet: Codable {















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the CallableTimeSet. */
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** The list of CallableTimes for which it is acceptable to place outbound calls. */
    public var callableTimes: [CallableTime]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, callableTimes: [CallableTime]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.callableTimes = callableTimes
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case callableTimes
        case selfUri
    }


}




public class CallbackBasic: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case scheduled = "scheduled"
        case _none = "none"
    }





    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }



    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }













































    /** The connection state of this communication. */
    public var state: State?
    /** The initial connection state of this communication. */
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The time line of the participant's callback, divided into activity segments. */
    public var segments: [Segment]?
    /** The direction of the call */
    public var direction: Direction?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the callback was placed on hold in the cloud clock if the callback is currently on hold. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startHoldTime: Date?
    /** The preview data to be used when this callback is a Preview. */
    public var dialerPreview: DialerPreview?
    /** The voicemail data to be used when this callback is an ACD voicemail. */
    public var voicemail: Voicemail?
    /** The phone number(s) to use to place the callback. */
    public var callbackNumbers: [String]?
    /** The name of the user requesting a callback. */
    public var callbackUserName: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** True if the call for the callback uses external dialing. */
    public var externalCampaign: Bool?
    /** True if the ability to skip a callback should be enabled. */
    public var skipEnabled: Bool?
    /** The number of seconds before the system automatically places a call for a callback.  0 means the automatic placement is disabled. */
    public var timeoutSeconds: Int?
    /** The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAlertingTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var disconnectedTime: Date?
    /** The timestamp when this communication is scheduled in the provider clock. If this value is missing it indicates the callback will be placed immediately. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var callbackScheduledTime: Date?
    /** The id of the config for automatically placing the callback (and handling the disposition). If null, the callback will not be placed automatically but routed to an agent as per normal. */
    public var automatedCallbackConfigId: String?
    /** The source provider for the callback. */
    public var provider: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** Call wrap up or disposition data. */
    public var wrapup: Wrapup?
    /** After-call work for the communication. */
    public var afterCallWork: AfterCallWork?
    /** Indicates if after-call work is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** The phone number displayed to recipients of the phone call. The value should conform to the E164 format. */
    public var callerId: String?
    /** The name displayed to recipients of the phone call. */
    public var callerIdName: String?
    /** Represents the queue settings for this media type. */
    public var queueMediaSettings: ConversationQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _id: String?, segments: [Segment]?, direction: Direction?, held: Bool?, disconnectType: DisconnectType?, startHoldTime: Date?, dialerPreview: DialerPreview?, voicemail: Voicemail?, callbackNumbers: [String]?, callbackUserName: String?, scriptId: String?, externalCampaign: Bool?, skipEnabled: Bool?, timeoutSeconds: Int?, startAlertingTime: Date?, connectedTime: Date?, disconnectedTime: Date?, callbackScheduledTime: Date?, automatedCallbackConfigId: String?, provider: String?, peerId: String?, wrapup: Wrapup?, afterCallWork: AfterCallWork?, afterCallWorkRequired: Bool?, callerId: String?, callerIdName: String?, queueMediaSettings: ConversationQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.segments = segments
        self.direction = direction
        self.held = held
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.dialerPreview = dialerPreview
        self.voicemail = voicemail
        self.callbackNumbers = callbackNumbers
        self.callbackUserName = callbackUserName
        self.scriptId = scriptId
        self.externalCampaign = externalCampaign
        self.skipEnabled = skipEnabled
        self.timeoutSeconds = timeoutSeconds
        self.startAlertingTime = startAlertingTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.callbackScheduledTime = callbackScheduledTime
        self.automatedCallbackConfigId = automatedCallbackConfigId
        self.provider = provider
        self.peerId = peerId
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.callerId = callerId
        self.callerIdName = callerIdName
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case segments
        case direction
        case held
        case disconnectType
        case startHoldTime
        case dialerPreview
        case voicemail
        case callbackNumbers
        case callbackUserName
        case scriptId
        case externalCampaign
        case skipEnabled
        case timeoutSeconds
        case startAlertingTime
        case connectedTime
        case disconnectedTime
        case callbackScheduledTime
        case automatedCallbackConfigId
        case provider
        case peerId
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case callerId
        case callerIdName
        case queueMediaSettings
    }


}




public class CallbackConversationEntityListing: Codable {





















    public var entities: [CallbackConversation]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CallbackConversation]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CallbackIdentifier: Codable {

    public enum ModelType: String, Codable { 
        case acd = "ACD"
        case external = "EXTERNAL"
    }



    /** The type of the associated callback participant */
    public var type: ModelType?
    /** The identifier of the callback */
    public var _id: String?

    public init(type: ModelType?, _id: String?) {
        self.type = type
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case _id = "id"
    }


}




public class CampaignDivisionView: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case selfUri
    }


}




public class CampaignDivisionViewListing: Codable {





















    public var entities: [CampaignDivisionView]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CampaignDivisionView]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CampaignProgress: Codable {















    /** Identifier of the campaign */
    public var campaign: DomainEntityRef?
    /** Identifier of the contact list */
    public var contactList: DomainEntityRef?
    /** Number of contacts called during the campaign */
    public var numberOfContactsCalled: Int64?
    /** Number of contacts messaged during the campaign */
    public var numberOfContactsMessaged: Int64?
    /** Total number of contacts in the campaign */
    public var totalNumberOfContacts: Int64?
    /** Percentage of contacts processed during the campaign */
    public var percentage: Int64?
    /** Number of contacts skipped during the campaign */
    public var numberOfContactsSkipped: [String:Int]?

    public init(campaign: DomainEntityRef?, contactList: DomainEntityRef?, numberOfContactsCalled: Int64?, numberOfContactsMessaged: Int64?, totalNumberOfContacts: Int64?, percentage: Int64?, numberOfContactsSkipped: [String:Int]?) {
        self.campaign = campaign
        self.contactList = contactList
        self.numberOfContactsCalled = numberOfContactsCalled
        self.numberOfContactsMessaged = numberOfContactsMessaged
        self.totalNumberOfContacts = totalNumberOfContacts
        self.percentage = percentage
        self.numberOfContactsSkipped = numberOfContactsSkipped
    }


}




public class CampaignRule: Codable {























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the CampaignRule. */
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** The list of entities that this CampaignRule monitors. */
    public var campaignRuleEntities: CampaignRuleEntities?
    /** The list of conditions that are evaluated on the entities. */
    public var campaignRuleConditions: [CampaignRuleCondition]?
    /** The list of actions that are executed if the conditions are satisfied. */
    public var campaignRuleActions: [CampaignRuleAction]?
    public var matchAnyConditions: Bool?
    /** Whether or not this CampaignRule is currently enabled. Required on updates. */
    public var enabled: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, campaignRuleEntities: CampaignRuleEntities?, campaignRuleConditions: [CampaignRuleCondition]?, campaignRuleActions: [CampaignRuleAction]?, matchAnyConditions: Bool?, enabled: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.campaignRuleEntities = campaignRuleEntities
        self.campaignRuleConditions = campaignRuleConditions
        self.campaignRuleActions = campaignRuleActions
        self.matchAnyConditions = matchAnyConditions
        self.enabled = enabled
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case campaignRuleEntities
        case campaignRuleConditions
        case campaignRuleActions
        case matchAnyConditions
        case enabled
        case selfUri
    }


}




public class CampaignRuleCondition: Codable {





    public enum ConditionType: String, Codable { 
        case campaignprogress = "campaignProgress"
        case campaignagents = "campaignAgents"
    }

    public var _id: String?
    /** The parameters for the CampaignRuleCondition. */
    public var parameters: CampaignRuleParameters?
    /** The type of condition to evaluate. */
    public var conditionType: ConditionType?

    public init(_id: String?, parameters: CampaignRuleParameters?, conditionType: ConditionType?) {
        self._id = _id
        self.parameters = parameters
        self.conditionType = conditionType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case parameters
        case conditionType
    }


}




public class CampaignSchedule: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** A list of intervals during which to run the associated Campaign. */
    public var intervals: [ScheduleInterval]?
    /** The time zone for this CampaignSchedule. For example, Africa/Abidjan. */
    public var timeZone: String?
    /** The Campaign that this CampaignSchedule is for. */
    public var campaign: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, intervals: [ScheduleInterval]?, timeZone: String?, campaign: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.intervals = intervals
        self.timeZone = timeZone
        self.campaign = campaign
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case intervals
        case timeZone
        case campaign
        case selfUri
    }


}




public class CampaignSkillStatistics: Codable {





    /** Number of available skill combinations for the campaign */
    public var skillCombinations: Int?
    /** Number of eligible agents with skills for campaign */
    public var eligibleSkilledAgents: Int?

    public init(skillCombinations: Int?, eligibleSkilledAgents: Int?) {
        self.skillCombinations = skillCombinations
        self.eligibleSkilledAgents = eligibleSkilledAgents
    }


}




public class Card: Codable {











    /** Text to show in the title. */
    public var title: String?
    /** Text to show in the description. */
    public var _description: String?
    /** URL of an image. */
    public var url: String?
    /** The default action to be taken. */
    public var defaultAction: CardAction?
    /** List of possible action objects. */
    public var actions: [CardAction]?

    public init(title: String?, _description: String?, url: String?, defaultAction: CardAction?, actions: [CardAction]?) {
        self.title = title
        self._description = _description
        self.url = url
        self.defaultAction = defaultAction
        self.actions = actions
    }

    public enum CodingKeys: String, CodingKey { 
        case title
        case _description = "description"
        case url
        case defaultAction
        case actions
    }


}



/** Represents a certificate to parse. */

public class Certificate: Codable {



    /** The certificate to parse. */
    public var certificate: String?

    public init(certificate: String?) {
        self.certificate = certificate
    }


}



/** Represents the details of a parsed certificate. */

public class CertificateDetails: Codable {















    /** Information about the issuer of the certificate.  The value of this property is a comma separated key=value format.  Each key is one of the attribute names supported by X.500. */
    public var issuer: String?
    /** Information about the subject of the certificate.  The value of this property is a comma separated key=value format.  Each key is one of the attribute names supported by X.500. */
    public var subject: String?
    /** The expiration date of the certificate. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var expirationDate: Date?
    /** The issue date of the certificate. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var issueDate: Date?
    /** True if the certificate is expired, false otherwise. */
    public var expired: Bool?
    public var valid: Bool?
    public var signatureValid: Bool?

    public init(issuer: String?, subject: String?, expirationDate: Date?, issueDate: Date?, expired: Bool?, valid: Bool?, signatureValid: Bool?) {
        self.issuer = issuer
        self.subject = subject
        self.expirationDate = expirationDate
        self.issueDate = issueDate
        self.expired = expired
        self.valid = valid
        self.signatureValid = signatureValid
    }


}




public class ChangePasswordRequest: Codable {



    /** The new password */
    public var newPassword: String?

    public init(newPassword: String?) {
        self.newPassword = newPassword
    }


}




public class ChannelTopic: Codable {



    public enum State: String, Codable { 
        case permitted = "Permitted"
        case rejected = "Rejected"
    }





    public var _id: String?
    public var state: State?
    public var rejectionReason: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, state: State?, rejectionReason: String?, selfUri: String?) {
        self._id = _id
        self.state = state
        self.rejectionReason = rejectionReason
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case rejectionReason
        case selfUri
    }


}




public class ChatBadgeTopicChatBadge: Codable {







    public var entity: ChatBadgeTopicBadgeEntity?
    public var unreadCount: Int?
    public var lastUnreadNotificationDate: Date?

    public init(entity: ChatBadgeTopicBadgeEntity?, unreadCount: Int?, lastUnreadNotificationDate: Date?) {
        self.entity = entity
        self.unreadCount = unreadCount
        self.lastUnreadNotificationDate = lastUnreadNotificationDate
    }


}




public class ChatMediaPolicy: Codable {





    /** Actions applied when specified conditions are met */
    public var actions: PolicyActions?
    /** Conditions for when actions should be applied */
    public var conditions: ChatMediaPolicyConditions?

    public init(actions: PolicyActions?, conditions: ChatMediaPolicyConditions?) {
        self.actions = actions
        self.conditions = conditions
    }


}




public class ChatMediaPolicyConditions: Codable {

















    public var forUsers: [User]?
    public var dateRanges: [String]?
    public var forQueues: [Queue]?
    public var wrapupCodes: [WrapupCode]?
    public var languages: [Language]?
    public var timeAllowed: TimeAllowed?
    /** Teams to match conversations against */
    public var teams: [Team]?
    public var duration: DurationCondition?

    public init(forUsers: [User]?, dateRanges: [String]?, forQueues: [Queue]?, wrapupCodes: [WrapupCode]?, languages: [Language]?, timeAllowed: TimeAllowed?, teams: [Team]?, duration: DurationCondition?) {
        self.forUsers = forUsers
        self.dateRanges = dateRanges
        self.forQueues = forQueues
        self.wrapupCodes = wrapupCodes
        self.languages = languages
        self.timeAllowed = timeAllowed
        self.teams = teams
        self.duration = duration
    }


}




public class ChatMessage: Codable {

















    public enum BodyType: String, Codable { 
        case standard = "STANDARD"
        case activity = "ACTIVITY"
        case typing = "TYPING"
        case notice = "NOTICE"
        case memberjoin = "MEMBERJOIN"
        case memberleave = "MEMBERLEAVE"
        case mediarequest = "MEDIAREQUEST"
    }







    /** The message body */
    public var body: String?
    public var _id: String?
    /** The message recipient */
    public var to: String?
    /** The message sender */
    public var from: String?
    public var utc: String?
    /** The interaction id (if available) */
    public var chat: String?
    /** The message id */
    public var message: String?
    public var type: String?
    /** Type of the message body (v2 chats only) */
    public var bodyType: BodyType?
    /** Communication of sender (v2 chats only) */
    public var senderCommunicationId: String?
    /** Participant purpose of sender (v2 chats only) */
    public var participantPurpose: String?
    /** The user information for the sender (if available) */
    public var user: ChatMessageUser?

    public init(body: String?, _id: String?, to: String?, from: String?, utc: String?, chat: String?, message: String?, type: String?, bodyType: BodyType?, senderCommunicationId: String?, participantPurpose: String?, user: ChatMessageUser?) {
        self.body = body
        self._id = _id
        self.to = to
        self.from = from
        self.utc = utc
        self.chat = chat
        self.message = message
        self.type = type
        self.bodyType = bodyType
        self.senderCommunicationId = senderCommunicationId
        self.participantPurpose = participantPurpose
        self.user = user
    }

    public enum CodingKeys: String, CodingKey { 
        case body
        case _id = "id"
        case to
        case from
        case utc
        case chat
        case message
        case type
        case bodyType
        case senderCommunicationId
        case participantPurpose
        case user
    }


}




public class ChatMessageUser: Codable {











    public var _id: String?
    public var name: String?
    public var displayName: String?
    public var username: String?
    public var images: [UserImage]?

    public init(_id: String?, name: String?, displayName: String?, username: String?, images: [UserImage]?) {
        self._id = _id
        self.name = name
        self.displayName = displayName
        self.username = username
        self.images = images
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case displayName
        case username
        case images
    }


}




public class ChatSettings: Codable {



    /** Retention time for messages in days */
    public var messageRetentionPeriodDays: Int?

    public init(messageRetentionPeriodDays: Int?) {
        self.messageRetentionPeriodDays = messageRetentionPeriodDays
    }


}




public class Check: Codable {

    public enum Result: String, Codable { 
        case passed = "Passed"
        case failed = "Failed"
        case unknown = "Unknown"
        case skipped = "Skipped"
        case error = "Error"
    }

    public enum ModelType: String, Codable { 
        case handleTimeValue = "HandleTimeValue"
        case transferRateValue = "TransferRateValue"
        case salesConversionRateValue = "SalesConversionRateValue"
        case salesAmountValue = "SalesAmountValue"
        case retentionRateValue = "RetentionRateValue"
        case churnRateValue = "ChurnRateValue"
        case interactionVolume = "InteractionVolume"
        case userVariance = "UserVariance"
        case dataCoverage = "DataCoverage"
        case modelQuality = "ModelQuality"
    }

    /** The result of a check executed. This indicates if the check was successful or not. */
    public var result: Result?
    /** The type of check executed. */
    public var type: ModelType?

    public init(result: Result?, type: ModelType?) {
        self.result = result
        self.type = type
    }


}




public class ClientAppEntityListing: Codable {





















    public var entities: [ClientApp]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ClientApp]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CoachingAnnotationCreateRequest: Codable {



    public enum AccessType: String, Codable { 
        case _public = "Public"
        case _private = "Private"
    }

    /** The text of the annotation. */
    public var text: String?
    /** Determines the permissions required to view this item. */
    public var accessType: AccessType?

    public init(text: String?, accessType: AccessType?) {
        self.text = text
        self.accessType = accessType
    }


}




public class CoachingAppointmentAggregateResponse: Codable {



    /** The results of the query */
    public var results: [QueryResponseGroupedData]?

    public init(results: [QueryResponseGroupedData]?) {
        self.results = results
    }


}




public class CoachingNotificationList: Codable {





















    public var entities: [CoachingNotification]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CoachingNotification]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CobrowseConversationEntityListing: Codable {





















    public var entities: [CobrowseConversation]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CobrowseConversation]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CobrowseWebMessagingSession: Codable {











    public enum CommunicationType: String, Codable { 
        case call = "Call"
        case message = "Message"
        case unknown = "Unknown"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Cobrowse session join code */
    public var joinCode: String?
    /** WebSocket URL for the JS client */
    public var websocketUrl: String?
    /** Date when Cobrowse Offer Expires. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateOfferEnds: Date?
    /** CommunicationType for Cobrowse Session */
    public var communicationType: CommunicationType?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, joinCode: String?, websocketUrl: String?, dateOfferEnds: Date?, communicationType: CommunicationType?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.joinCode = joinCode
        self.websocketUrl = websocketUrl
        self.dateOfferEnds = dateOfferEnds
        self.communicationType = communicationType
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case joinCode
        case websocketUrl
        case dateOfferEnds
        case communicationType
        case selfUri
    }


}




public class Cobrowsesession: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case scheduled = "scheduled"
        case _none = "none"
    }



    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }































    /** The connection state of this communication. */
    public var state: State?
    /** The initial connection state of this communication. */
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** Address and name data for a call endpoint. */
    public var _self: Address?
    /** The co-browse session ID. */
    public var cobrowseSessionId: String?
    /** This value identifies the role of the co-browse client within the co-browse session (a client is a sharer or a viewer). */
    public var cobrowseRole: String?
    /** ID of co-browse participants for which this client has been granted control (list is empty if this client cannot control any shared pages). */
    public var controlling: [String]?
    /** The URL that can be used to open co-browse session in web browser. */
    public var viewerUrl: String?
    /** The time when the provider event which triggered this conversation update happened in the corrected provider clock (milliseconds since 1970-01-01 00:00:00 UTC). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var providerEventTime: Date?
    /** The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAlertingTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var disconnectedTime: Date?
    /** The source provider for the co-browse session. */
    public var provider: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The time line of the participant's call, divided into activity segments. */
    public var segments: [Segment]?
    /** Call wrap up or disposition data. */
    public var wrapup: Wrapup?
    /** After-call work for the communication. */
    public var afterCallWork: AfterCallWork?
    /** Indicates if after-call work is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?

    public init(state: State?, initialState: InitialState?, _id: String?, disconnectType: DisconnectType?, _self: Address?, cobrowseSessionId: String?, cobrowseRole: String?, controlling: [String]?, viewerUrl: String?, providerEventTime: Date?, startAlertingTime: Date?, connectedTime: Date?, disconnectedTime: Date?, provider: String?, peerId: String?, segments: [Segment]?, wrapup: Wrapup?, afterCallWork: AfterCallWork?, afterCallWorkRequired: Bool?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.disconnectType = disconnectType
        self._self = _self
        self.cobrowseSessionId = cobrowseSessionId
        self.cobrowseRole = cobrowseRole
        self.controlling = controlling
        self.viewerUrl = viewerUrl
        self.providerEventTime = providerEventTime
        self.startAlertingTime = startAlertingTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.provider = provider
        self.peerId = peerId
        self.segments = segments
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case disconnectType
        case _self = "self"
        case cobrowseSessionId
        case cobrowseRole
        case controlling
        case viewerUrl
        case providerEventTime
        case startAlertingTime
        case connectedTime
        case disconnectedTime
        case provider
        case peerId
        case segments
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
    }


}




public class ColumnDataTypeSpecification: Codable {



    public enum ColumnDataType: String, Codable { 
        case numeric = "NUMERIC"
        case text = "TEXT"
        case timestamp = "TIMESTAMP"
    }







    /** The column name of a column selected for dynamic queueing */
    public var columnName: String?
    /** The data type of the column selected for dynamic queueing (TEXT, NUMERIC or TIMESTAMP) */
    public var columnDataType: ColumnDataType?
    /** The minimum length of the numeric column selected for dynamic queueing */
    public var min: Int?
    /** The maximum length of the numeric column selected for dynamic queueing */
    public var max: Int?
    /** The maximum length of the text column selected for dynamic queueing */
    public var maxLength: Int?

    public init(columnName: String?, columnDataType: ColumnDataType?, min: Int?, max: Int?, maxLength: Int?) {
        self.columnName = columnName
        self.columnDataType = columnDataType
        self.min = min
        self.max = max
        self.maxLength = maxLength
    }


}




public class CommonRuleBulkDeleteRequest: Codable {



    /** The user supplied rule ids to be deleted */
    public var ruleIds: [String]?

    public init(ruleIds: [String]?) {
        self.ruleIds = ruleIds
    }


}




public class CommonRulePredicate: Codable {

    public enum MetricType: String, Codable { 
        case interval = "Interval"
        case instance = "Instance"
    }

    public enum MetricValueType: String, Codable { 
        case count = "Count"
        case min = "Min"
        case timer = "Timer"
        case max = "Max"
        case percentage = "Percentage"
        case average = "Average"
        case observation = "Observation"
    }

    public enum ComparisonOperator: String, Codable { 
        case gt = "Gt"
        case gte = "Gte"
        case lt = "Lt"
        case lte = "Lte"
        case eq = "Eq"
        case ne = "Ne"
    }







    public enum MediaType: String, Codable { 
        case voice = "Voice"
        case chat = "Chat"
        case email = "Email"
        case callback = "Callback"
        case message = "Message"
    }

    public enum Metric: String, Codable { 
        case nabandon = "nAbandon"
        case nconnected = "nConnected"
        case ninteractions = "nInteractions"
        case noffered = "nOffered"
        case noutbound = "nOutbound"
        case ntransferred = "nTransferred"
        case servicelevel = "serviceLevel"
        case oservicelevel = "oServiceLevel"
        case owaiting = "oWaiting"
        case tabandon = "tAbandon"
        case tacw = "tAcw"
        case talert = "tAlert"
        case tanswered = "tAnswered"
        case thandle = "tHandle"
        case theldcomplete = "tHeldComplete"
        case ttalkcomplete = "tTalkComplete"
        case twait = "tWait"
        case ttalk = "tTalk"
        case theld = "tHeld"
        case torganizationpresence = "tOrganizationPresence"
        case tsystempresence = "tSystemPresence"
        case tagentroutingstatus = "tAgentRoutingStatus"
        case ouserroutingstatuses = "oUserRoutingStatuses"
        case ouserpresences = "oUserPresences"
        case ointeracting = "oInteracting"
        case tflowout = "tFlowOut"
        case tadherencestatus = "tAdherenceStatus"
    }

    /** The type of metric being evaluated. */
    public var metricType: MetricType?
    /** The type of metric value being evaluated. */
    public var metricValueType: MetricValueType?
    /** The comparison operator being performed on the metric. */
    public var comparisonOperator: ComparisonOperator?
    /** The value the metric will be compared to. */
    public var value: Double?
    /** The status of the entity corresponding to the metric. */
    public var status: String?
    /** The entity whose metric is being represented. */
    public var entity: CommonRulePredicateEntity?
    /** The media type of the conversation the metric describes. */
    public var mediaType: MediaType?
    /** The metric being evaluated. */
    public var metric: Metric?

    public init(metricType: MetricType?, metricValueType: MetricValueType?, comparisonOperator: ComparisonOperator?, value: Double?, status: String?, entity: CommonRulePredicateEntity?, mediaType: MediaType?, metric: Metric?) {
        self.metricType = metricType
        self.metricValueType = metricValueType
        self.comparisonOperator = comparisonOperator
        self.value = value
        self.status = status
        self.entity = entity
        self.mediaType = mediaType
        self.metric = metric
    }


}




public class ConfusionDetails: Codable {



    /** Confusion details between this utterance and other intents. */
    public var intents: [ConfusionIntentDetails]?

    public init(intents: [ConfusionIntentDetails]?) {
        self.intents = intents
    }


}




public class ConnectedEdge: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Edge interface name used for the connection */
    public var interfaceName: String?
    /** Edge interface IP address */
    public var interfaceIpAddress: String?
    public var edgeConnectionList: [EdgeConnectionInfo]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, interfaceName: String?, interfaceIpAddress: String?, edgeConnectionList: [EdgeConnectionInfo]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.interfaceName = interfaceName
        self.interfaceIpAddress = interfaceIpAddress
        self.edgeConnectionList = edgeConnectionList
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case interfaceName
        case interfaceIpAddress
        case edgeConnectionList
        case selfUri
    }


}




public class ConstraintConflictMessage: Codable {





    /** Message for how to resolve a set of conflicted work plan constraints */
    public var message: WorkPlanConstraintConflictMessage?
    /** Messages for the set of conflicted work plan constraints. Each element indicates the message of a work plan constraint that is conflicted in the set */
    public var conflictedConstraintMessages: [WorkPlanConstraintMessage]?

    public init(message: WorkPlanConstraintConflictMessage?, conflictedConstraintMessages: [WorkPlanConstraintMessage]?) {
        self.message = message
        self.conflictedConstraintMessages = conflictedConstraintMessages
    }


}




public class ConsultTransferResponse: Codable {



    /** Participant ID to whom the call is being transferred. */
    public var destinationParticipantId: String?

    public init(destinationParticipantId: String?) {
        self.destinationParticipantId = destinationParticipantId
    }


}




public class ConsultTransferToQueue: Codable {

    public enum SpeakTo: String, Codable { 
        case destination = "DESTINATION"
        case object = "OBJECT"
        case both = "BOTH"
        case conference = "CONFERENCE"
    }







    /** Determines to whom the initiating participant is speaking. Defaults to DESTINATION */
    public var speakTo: SpeakTo?
    /** The user ID of the person who wants to talk before completing the transfer. Could be the same of the context user ID */
    public var consultingUserId: String?
    /** The id of the queue. */
    public var queueId: String?
    /** The name of the queue. */
    public var queueName: String?

    public init(speakTo: SpeakTo?, consultingUserId: String?, queueId: String?, queueName: String?) {
        self.speakTo = speakTo
        self.consultingUserId = consultingUserId
        self.queueId = queueId
        self.queueName = queueName
    }


}




public class ContactAddressTypeConditionSettings: Codable {

    public enum Operator: String, Codable { 
        case equals = "Equals"
        case contains = "Contains"
        case beginsWith = "BeginsWith"
        case endsWith = "EndsWith"
    }



    /** The operator to use when comparing the address types. */
    public var _operator: Operator?
    /** The type value to compare against the contact column type. */
    public var value: String?

    public init(_operator: Operator?, value: String?) {
        self._operator = _operator
        self.value = value
    }

    public enum CodingKeys: String, CodingKey { 
        case _operator = "operator"
        case value
    }


}




public class ContactIdentifier: Codable {



    public enum ModelType: String, Codable { 
        case socialLine = "SocialLine"
        case socialFacebook = "SocialFacebook"
        case socialTwitter = "SocialTwitter"
        case socialWhatsapp = "SocialWhatsapp"
        case email = "Email"
        case phone = "Phone"
        case cookie = "Cookie"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The type of this identifier */
    public var type: ModelType?
    /** The string value of the identifier. Will vary in syntax by type. */
    public var value: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, type: ModelType?, value: String?, dateCreated: Date?, selfUri: String?) {
        self._id = _id
        self.type = type
        self.value = value
        self.dateCreated = dateCreated
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
        case value
        case dateCreated
        case selfUri
    }


}




public class ContactList: Codable {







































    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** The division this entity belongs to. */
    public var division: DomainEntityRef?
    /** The names of the contact data columns. */
    public var columnNames: [String]?
    /** Indicates which columns are phone numbers. */
    public var phoneColumns: [ContactPhoneNumberColumn]?
    /** Indicates which columns are email addresses */
    public var emailColumns: [EmailColumn]?
    /** The status of the import process. */
    public var importStatus: ImportStatus?
    /** A column to check if a contact should always be dialed in preview mode. */
    public var previewModeColumnName: String?
    /** The values in the previewModeColumnName column that indicate a contact should always be dialed in preview mode. */
    public var previewModeAcceptedValues: [String]?
    /** The number of contacts in the ContactList. */
    public var size: Int64?
    /** AttemptLimits for this ContactList. */
    public var attemptLimits: DomainEntityRef?
    /** Indicates if automatic time zone mapping is to be used for this ContactList. */
    public var automaticTimeZoneMapping: Bool?
    /** The name of contact list column containing the zip code for use with automatic time zone mapping. Only allowed if 'automaticTimeZoneMapping' is set to true. */
    public var zipCodeColumnName: String?
    /** The settings of the columns selected for dynamic queueing */
    public var columnDataTypeSpecifications: [ColumnDataTypeSpecification]?
    /** Whether to trim white space when importing a contactlist csv file, default value = true */
    public var trimWhitespace: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, division: DomainEntityRef?, columnNames: [String]?, phoneColumns: [ContactPhoneNumberColumn]?, emailColumns: [EmailColumn]?, importStatus: ImportStatus?, previewModeColumnName: String?, previewModeAcceptedValues: [String]?, size: Int64?, attemptLimits: DomainEntityRef?, automaticTimeZoneMapping: Bool?, zipCodeColumnName: String?, columnDataTypeSpecifications: [ColumnDataTypeSpecification]?, trimWhitespace: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.division = division
        self.columnNames = columnNames
        self.phoneColumns = phoneColumns
        self.emailColumns = emailColumns
        self.importStatus = importStatus
        self.previewModeColumnName = previewModeColumnName
        self.previewModeAcceptedValues = previewModeAcceptedValues
        self.size = size
        self.attemptLimits = attemptLimits
        self.automaticTimeZoneMapping = automaticTimeZoneMapping
        self.zipCodeColumnName = zipCodeColumnName
        self.columnDataTypeSpecifications = columnDataTypeSpecifications
        self.trimWhitespace = trimWhitespace
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case division
        case columnNames
        case phoneColumns
        case emailColumns
        case importStatus
        case previewModeColumnName
        case previewModeAcceptedValues
        case size
        case attemptLimits
        case automaticTimeZoneMapping
        case zipCodeColumnName
        case columnDataTypeSpecifications
        case trimWhitespace
        case selfUri
    }


}




public class ContactListTemplateEntityListing: Codable {





















    public var entities: [ContactListTemplate]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ContactListTemplate]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ContactlistImportStatusImportStatus: Codable {

    public enum ImportState: String, Codable { 
        case inProgress = "IN_PROGRESS"
        case failed = "FAILED"
    }















    /** current status of the import */
    public var importState: ImportState?
    /** total number of records to be imported */
    public var totalRecords: Int?
    /** number of records finished importing */
    public var completedRecords: Int?
    /** percentage of records finished importing */
    public var percentageComplete: Int?
    /** if the import has failed, the reason for the failure */
    public var failureReason: String?
    /** The ids for target contact lists */
    public var targetContactListIds: [String]?
    /** The prefix used for target contact list names */
    public var listNamePrefix: String?
    public var additionalProperties: [String:JSON]?

    public init(importState: ImportState?, totalRecords: Int?, completedRecords: Int?, percentageComplete: Int?, failureReason: String?, targetContactListIds: [String]?, listNamePrefix: String?, additionalProperties: [String:JSON]?) {
        self.importState = importState
        self.totalRecords = totalRecords
        self.completedRecords = completedRecords
        self.percentageComplete = percentageComplete
        self.failureReason = failureReason
        self.targetContactListIds = targetContactListIds
        self.listNamePrefix = listNamePrefix
        self.additionalProperties = additionalProperties
    }


}




public class ContactsExportRequest: Codable {







    /** Contact List Filter ID. */
    public var contactListFilterId: String?
    /** Criteria to filter the contacts by. */
    public var searchCriteria: ContactBulkSearchCriteria?
    /** Contact IDs to be exported. */
    public var contactIds: [String]?

    public init(contactListFilterId: String?, searchCriteria: ContactBulkSearchCriteria?, contactIds: [String]?) {
        self.contactListFilterId = contactListFilterId
        self.searchCriteria = searchCriteria
        self.contactIds = contactIds
    }


}



/** List content object. */

public class ContentList: Codable {



    public enum ListType: String, Codable { 
        case selection = "Selection"
        case vertical = "Vertical"
    }











    /** A unique ID assigned to this rich message content. */
    public var _id: String?
    /** The type of list this instance represents. */
    public var listType: ListType?
    /** Text to show in the title. */
    public var title: String?
    /** Text to show in the description. */
    public var _description: String?
    /** Label for Submit button. */
    public var submitLabel: String?
    /** The list actions (Deprecated). */
    public var actions: ContentActions?
    /** An array of component objects. */
    public var components: [ListItemComponent]?

    public init(_id: String?, listType: ListType?, title: String?, _description: String?, submitLabel: String?, actions: ContentActions?, components: [ListItemComponent]?) {
        self._id = _id
        self.listType = listType
        self.title = title
        self._description = _description
        self.submitLabel = submitLabel
        self.actions = actions
        self.components = components
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case listType
        case title
        case _description = "description"
        case submitLabel
        case actions
        case components
    }


}




public class ContentManagementWorkspaceDocumentsTopicLockData: Codable {







    public var lockedBy: ContentManagementWorkspaceDocumentsTopicUserData?
    public var dateCreated: Date?
    public var dateExpires: Date?

    public init(lockedBy: ContentManagementWorkspaceDocumentsTopicUserData?, dateCreated: Date?, dateExpires: Date?) {
        self.lockedBy = lockedBy
        self.dateCreated = dateCreated
        self.dateExpires = dateExpires
    }


}




public class ContentManagementWorkspaceDocumentsTopicWorkspaceData: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class ContentOfferStylingConfiguration: Codable {















    /** Properties for customizing the positioning of the content offer. */
    public var position: ContentPositionProperties?
    /** Properties for customizing the appearance of the content offer. */
    public var offer: ContentOfferStyleProperties?
    /** Properties for customizing the appearance of the close button. */
    public var closeButton: CloseButtonStyleProperties?
    /** Properties for customizing the appearance of the CTA button. */
    public var ctaButton: CtaButtonStyleProperties?
    /** Properties for customizing the appearance of the title text. */
    public var title: TextStyleProperties?
    /** Properties for customizing the appearance of the headline text. */
    public var headline: TextStyleProperties?
    /** Properties for customizing the appearance of the body text. */
    public var body: TextStyleProperties?

    public init(position: ContentPositionProperties?, offer: ContentOfferStyleProperties?, closeButton: CloseButtonStyleProperties?, ctaButton: CtaButtonStyleProperties?, title: TextStyleProperties?, headline: TextStyleProperties?, body: TextStyleProperties?) {
        self.position = position
        self.offer = offer
        self.closeButton = closeButton
        self.ctaButton = ctaButton
        self.title = title
        self.headline = headline
        self.body = body
    }


}




public class ContentPositionProperties: Codable {









    /** Top positioning offset. */
    public var top: String?
    /** Bottom positioning offset. */
    public var bottom: String?
    /** Left positioning offset. */
    public var _left: String?
    /** Right positioning offset. */
    public var _right: String?

    public init(top: String?, bottom: String?, _left: String?, _right: String?) {
        self.top = top
        self.bottom = bottom
        self._left = _left
        self._right = _right
    }

    public enum CodingKeys: String, CodingKey { 
        case top
        case bottom
        case _left = "left"
        case _right = "right"
    }


}




public class ContextEntity: Codable {



    /** The name of the entity. */
    public var name: String?

    public init(name: String?) {
        self.name = name
    }


}



/** Conversation settings that handles chats within the messenger */

public class ConversationAppSettings: Codable {







    public enum AutoStartType: String, Codable { 
        case standard = "Standard"
        case automatic = "Automatic"
    }











    /** The toggle to enable or disable conversations */
    public var enabled: Bool?
    /** The toggle to enable or disable typing indicator for messenger */
    public var showAgentTypingIndicator: Bool?
    /** The toggle to enable or disable typing indicator for messenger */
    public var showUserTypingIndicator: Bool?
    /** Deprecated. The auto start type for the messenger conversation */
    public var autoStartType: AutoStartType?
    /** The auto start for the messenger conversation */
    public var autoStart: AutoStart?
    /** The markdown for the messenger app */
    public var markdown: Markdown?
    /** The conversation disconnect settings for the messenger app */
    public var conversationDisconnect: ConversationDisconnectSettings?
    /** The conversation clear settings for the messenger app */
    public var conversationClear: ConversationClearSettings?
    /** The humanize conversations settings for the messenger app */
    public var humanize: Humanize?

    public init(enabled: Bool?, showAgentTypingIndicator: Bool?, showUserTypingIndicator: Bool?, autoStartType: AutoStartType?, autoStart: AutoStart?, markdown: Markdown?, conversationDisconnect: ConversationDisconnectSettings?, conversationClear: ConversationClearSettings?, humanize: Humanize?) {
        self.enabled = enabled
        self.showAgentTypingIndicator = showAgentTypingIndicator
        self.showUserTypingIndicator = showUserTypingIndicator
        self.autoStartType = autoStartType
        self.autoStart = autoStart
        self.markdown = markdown
        self.conversationDisconnect = conversationDisconnect
        self.conversationClear = conversationClear
        self.humanize = humanize
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationCallEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationCallEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}




public class ConversationCallEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: ConversationCallEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int?

    public init(agent: ConversationCallEventTopicUriReference?, score: Int?) {
        self.agent = agent
        self.score = score
    }


}




public class ConversationCallbackEventTopicCallbackMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case timeout = "timeout"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }







































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }





























    public var _id: String?
    public var name: String?
    public var address: String?
    public var startTime: Date?
    public var connectedTime: Date?
    public var endTime: Date?
    public var startHoldTime: Date?
    public var purpose: String?
    public var state: State?
    public var initialState: InitialState?
    public var direction: Direction?
    public var disconnectType: DisconnectType?
    public var held: Bool?
    public var wrapupRequired: Bool?
    public var wrapupPrompt: String?
    public var user: ConversationCallbackEventTopicUriReference?
    public var queue: ConversationCallbackEventTopicUriReference?
    public var team: ConversationCallbackEventTopicUriReference?
    public var attributes: [String:String]?
    public var errorInfo: ConversationCallbackEventTopicErrorBody?
    public var script: ConversationCallbackEventTopicUriReference?
    public var wrapupTimeoutMs: Int?
    public var wrapupSkipped: Bool?
    public var alertingTimeoutMs: Int?
    public var provider: String?
    public var externalContact: ConversationCallbackEventTopicUriReference?
    public var externalOrganization: ConversationCallbackEventTopicUriReference?
    public var wrapup: ConversationCallbackEventTopicWrapup?
    public var conversationRoutingData: ConversationCallbackEventTopicConversationRoutingData?
    public var peer: String?
    public var screenRecordingState: String?
    public var flaggedReason: FlaggedReason?
    public var journeyContext: ConversationCallbackEventTopicJourneyContext?
    public var startAcwTime: Date?
    public var endAcwTime: Date?
    public var mediaRoles: [String]?
    public var queueMediaSettings: ConversationCallbackEventTopicQueueMediaSettings?
    public var outboundPreview: ConversationCallbackEventTopicDialerPreview?
    public var voicemail: ConversationCallbackEventTopicVoicemail?
    public var callbackNumbers: [String]?
    public var callbackUserName: String?
    public var skipEnabled: Bool?
    public var externalCampaign: Bool?
    public var timeoutSeconds: Int?
    public var callbackScheduledTime: Date?
    public var automatedCallbackConfigId: String?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, initialState: InitialState?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, user: ConversationCallbackEventTopicUriReference?, queue: ConversationCallbackEventTopicUriReference?, team: ConversationCallbackEventTopicUriReference?, attributes: [String:String]?, errorInfo: ConversationCallbackEventTopicErrorBody?, script: ConversationCallbackEventTopicUriReference?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, alertingTimeoutMs: Int?, provider: String?, externalContact: ConversationCallbackEventTopicUriReference?, externalOrganization: ConversationCallbackEventTopicUriReference?, wrapup: ConversationCallbackEventTopicWrapup?, conversationRoutingData: ConversationCallbackEventTopicConversationRoutingData?, peer: String?, screenRecordingState: String?, flaggedReason: FlaggedReason?, journeyContext: ConversationCallbackEventTopicJourneyContext?, startAcwTime: Date?, endAcwTime: Date?, mediaRoles: [String]?, queueMediaSettings: ConversationCallbackEventTopicQueueMediaSettings?, outboundPreview: ConversationCallbackEventTopicDialerPreview?, voicemail: ConversationCallbackEventTopicVoicemail?, callbackNumbers: [String]?, callbackUserName: String?, skipEnabled: Bool?, externalCampaign: Bool?, timeoutSeconds: Int?, callbackScheduledTime: Date?, automatedCallbackConfigId: String?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.conversationRoutingData = conversationRoutingData
        self.peer = peer
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.mediaRoles = mediaRoles
        self.queueMediaSettings = queueMediaSettings
        self.outboundPreview = outboundPreview
        self.voicemail = voicemail
        self.callbackNumbers = callbackNumbers
        self.callbackUserName = callbackUserName
        self.skipEnabled = skipEnabled
        self.externalCampaign = externalCampaign
        self.timeoutSeconds = timeoutSeconds
        self.callbackScheduledTime = callbackScheduledTime
        self.automatedCallbackConfigId = automatedCallbackConfigId
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case initialState
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalOrganization
        case wrapup
        case conversationRoutingData
        case peer
        case screenRecordingState
        case flaggedReason
        case journeyContext
        case startAcwTime
        case endAcwTime
        case mediaRoles
        case queueMediaSettings
        case outboundPreview
        case voicemail
        case callbackNumbers
        case callbackUserName
        case skipEnabled
        case externalCampaign
        case timeoutSeconds
        case callbackScheduledTime
        case automatedCallbackConfigId
    }


}




public class ConversationCallbackEventTopicConversationRoutingData: Codable {











    /** A UriReference for a resource */
    public var queue: ConversationCallbackEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: ConversationCallbackEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int?
    /** The skills to use for routing decisions */
    public var skills: [ConversationCallbackEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [ConversationCallbackEventTopicScoredAgent]?

    public init(queue: ConversationCallbackEventTopicUriReference?, language: ConversationCallbackEventTopicUriReference?, priority: Int?, skills: [ConversationCallbackEventTopicUriReference]?, scoredAgents: [ConversationCallbackEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}




public class ConversationChatEventTopicChatConversation: Codable {









    public var _id: String?
    public var name: String?
    public var participants: [ConversationChatEventTopicChatMediaParticipant]?
    public var otherMediaUris: [String]?

    public init(_id: String?, name: String?, participants: [ConversationChatEventTopicChatMediaParticipant]?, otherMediaUris: [String]?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class ConversationChatEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: ConversationChatEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: ConversationChatEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}




public class ConversationChatEventTopicJourneyContext: Codable {







    public var customer: ConversationChatEventTopicJourneyCustomer?
    public var customerSession: ConversationChatEventTopicJourneyCustomerSession?
    public var triggeringAction: ConversationChatEventTopicJourneyAction?

    public init(customer: ConversationChatEventTopicJourneyCustomer?, customerSession: ConversationChatEventTopicJourneyCustomerSession?, triggeringAction: ConversationChatEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class ConversationChatEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}




public class ConversationCobrowseEventTopicCobrowseMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case timeout = "timeout"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }







































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }





















    public var _id: String?
    public var name: String?
    public var address: String?
    public var startTime: Date?
    public var connectedTime: Date?
    public var endTime: Date?
    public var startHoldTime: Date?
    public var purpose: String?
    public var state: State?
    public var initialState: InitialState?
    public var direction: Direction?
    public var disconnectType: DisconnectType?
    public var held: Bool?
    public var wrapupRequired: Bool?
    public var wrapupPrompt: String?
    public var user: ConversationCobrowseEventTopicUriReference?
    public var queue: ConversationCobrowseEventTopicUriReference?
    public var team: ConversationCobrowseEventTopicUriReference?
    public var attributes: [String:String]?
    public var errorInfo: ConversationCobrowseEventTopicErrorBody?
    public var script: ConversationCobrowseEventTopicUriReference?
    public var wrapupTimeoutMs: Int?
    public var wrapupSkipped: Bool?
    public var alertingTimeoutMs: Int?
    public var provider: String?
    public var externalContact: ConversationCobrowseEventTopicUriReference?
    public var externalOrganization: ConversationCobrowseEventTopicUriReference?
    public var wrapup: ConversationCobrowseEventTopicWrapup?
    public var conversationRoutingData: ConversationCobrowseEventTopicConversationRoutingData?
    public var peer: String?
    public var screenRecordingState: String?
    public var flaggedReason: FlaggedReason?
    public var journeyContext: ConversationCobrowseEventTopicJourneyContext?
    public var startAcwTime: Date?
    public var endAcwTime: Date?
    public var mediaRoles: [String]?
    public var queueMediaSettings: ConversationCobrowseEventTopicQueueMediaSettings?
    public var cobrowseSessionId: String?
    public var cobrowseRole: String?
    public var viewerUrl: String?
    public var providerEventTime: Date?
    public var controlling: [String]?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, initialState: InitialState?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, user: ConversationCobrowseEventTopicUriReference?, queue: ConversationCobrowseEventTopicUriReference?, team: ConversationCobrowseEventTopicUriReference?, attributes: [String:String]?, errorInfo: ConversationCobrowseEventTopicErrorBody?, script: ConversationCobrowseEventTopicUriReference?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, alertingTimeoutMs: Int?, provider: String?, externalContact: ConversationCobrowseEventTopicUriReference?, externalOrganization: ConversationCobrowseEventTopicUriReference?, wrapup: ConversationCobrowseEventTopicWrapup?, conversationRoutingData: ConversationCobrowseEventTopicConversationRoutingData?, peer: String?, screenRecordingState: String?, flaggedReason: FlaggedReason?, journeyContext: ConversationCobrowseEventTopicJourneyContext?, startAcwTime: Date?, endAcwTime: Date?, mediaRoles: [String]?, queueMediaSettings: ConversationCobrowseEventTopicQueueMediaSettings?, cobrowseSessionId: String?, cobrowseRole: String?, viewerUrl: String?, providerEventTime: Date?, controlling: [String]?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.conversationRoutingData = conversationRoutingData
        self.peer = peer
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.mediaRoles = mediaRoles
        self.queueMediaSettings = queueMediaSettings
        self.cobrowseSessionId = cobrowseSessionId
        self.cobrowseRole = cobrowseRole
        self.viewerUrl = viewerUrl
        self.providerEventTime = providerEventTime
        self.controlling = controlling
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case initialState
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalOrganization
        case wrapup
        case conversationRoutingData
        case peer
        case screenRecordingState
        case flaggedReason
        case journeyContext
        case startAcwTime
        case endAcwTime
        case mediaRoles
        case queueMediaSettings
        case cobrowseSessionId
        case cobrowseRole
        case viewerUrl
        case providerEventTime
        case controlling
    }


}




public class ConversationCobrowseEventTopicConversationRoutingData: Codable {











    /** A UriReference for a resource */
    public var queue: ConversationCobrowseEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: ConversationCobrowseEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int?
    /** The skills to use for routing decisions */
    public var skills: [ConversationCobrowseEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [ConversationCobrowseEventTopicScoredAgent]?

    public init(queue: ConversationCobrowseEventTopicUriReference?, language: ConversationCobrowseEventTopicUriReference?, priority: Int?, skills: [ConversationCobrowseEventTopicUriReference]?, scoredAgents: [ConversationCobrowseEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}




public class ConversationDetailQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [ConversationDetailQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [ConversationDetailQueryPredicate]?

    public init(type: ModelType?, clauses: [ConversationDetailQueryClause]?, predicates: [ConversationDetailQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class ConversationDetailsDatalakeAvailabilityTopicDataAvailabilityChangeNotification: Codable {



    /** Date and time before which data is guaranteed to be available in the datalake */
    public var dataAvailabilityDate: Date?

    public init(dataAvailabilityDate: Date?) {
        self.dataAvailabilityDate = dataAvailabilityDate
    }


}




public class ConversationDisconnectSettings: Codable {



    public enum ModelType: String, Codable { 
        case send = "Send"
        case readOnly = "ReadOnly"
    }

    /** whether or not conversation disconnect setting is enabled */
    public var enabled: Bool?
    /** Conversation disconnect type */
    public var type: ModelType?

    public init(enabled: Bool?, type: ModelType?) {
        self.enabled = enabled
        self.type = type
    }


}




public class ConversationDivisionMembership: Codable {





    /** A division the conversation belongs to. */
    public var division: DomainEntityRef?
    /** The entities on the conversation within the division. These are the users, queues, work flows, etc. that can be on conversations and and be assigned to different divisions. */
    public var entities: [DomainEntityRef]?

    public init(division: DomainEntityRef?, entities: [DomainEntityRef]?) {
        self.division = division
        self.entities = entities
    }


}




public class ConversationEmailEventTopicDetail: Codable {









    public var errorCode: String?
    public var fieldName: String?
    public var entityId: String?
    public var entityName: String?

    public init(errorCode: String?, fieldName: String?, entityId: String?, entityName: String?) {
        self.errorCode = errorCode
        self.fieldName = fieldName
        self.entityId = entityId
        self.entityName = entityName
    }


}




public class ConversationEmailEventTopicErrorBody: Codable {





















    public var message: String?
    public var code: String?
    public var status: Int?
    public var entityId: String?
    public var entityName: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var contextId: String?
    public var details: [ConversationEmailEventTopicDetail]?
    public var errors: [ConversationEmailEventTopicErrorBody]?

    public init(message: String?, code: String?, status: Int?, entityId: String?, entityName: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, details: [ConversationEmailEventTopicDetail]?, errors: [ConversationEmailEventTopicErrorBody]?) {
        self.message = message
        self.code = code
        self.status = status
        self.entityId = entityId
        self.entityName = entityName
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.details = details
        self.errors = errors
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class ConversationEmailEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int?

    public init(_id: String?, version: Int?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}




public class ConversationEmailEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}



/** A CoBrowse event. */

public class ConversationEventCoBrowse: Codable {

    public enum ModelType: String, Codable { 
        case offering = "Offering"
        case offeringExpired = "OfferingExpired"
        case offeringAccepted = "OfferingAccepted"
        case offeringRejected = "OfferingRejected"
    }





    /** Describes the type of CoBrowse event. */
    public var type: ModelType?
    /** The CoBrowse session ID. */
    public var sessionId: String?
    /** The CoBrowse session join token. */
    public var sessionJoinToken: String?

    public init(type: ModelType?, sessionId: String?, sessionJoinToken: String?) {
        self.type = type
        self.sessionId = sessionId
        self.sessionJoinToken = sessionJoinToken
    }


}




public class ConversationEventTopicAttachment: Codable {











    /** The unique identifier for the attachment. */
    public var attachmentId: String?
    /** The name of the attachment. */
    public var name: String?
    /** The content uri of the attachment. If set, this is commonly a public api download location. */
    public var contentUri: String?
    /** The type of file the attachment is. */
    public var contentType: String?
    /** The length of the attachment file. */
    public var contentLength: Int?

    public init(attachmentId: String?, name: String?, contentUri: String?, contentType: String?, contentLength: Int?) {
        self.attachmentId = attachmentId
        self.name = name
        self.contentUri = contentUri
        self.contentType = contentType
        self.contentLength = contentLength
    }


}




public class ConversationEventTopicEmail: Codable {



    public enum State: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case disconnected = "disconnected"
        case _none = "none"
        case transmitting = "transmitting"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case disconnected = "disconnected"
        case _none = "none"
        case transmitting = "transmitting"
    }

















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }









    public enum Direction: String, Codable { 
        case outbound = "outbound"
        case inbound = "inbound"
    }













    /** A globally unique identifier for this communication. */
    public var _id: String?
    public var state: State?
    public var initialState: InitialState?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** Indicates that the email was auto-generated like an Out of Office reply. */
    public var autoGenerated: Bool?
    /** The subject for the initial email that started this conversation. */
    public var subject: String?
    /** The source provider of the email. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The number of email messages sent by this participant. */
    public var messagesSent: Int?
    /** Detailed information about an error response. */
    public var errorInfo: ConversationEventTopicErrorDetails?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the email was placed on hold in the cloud clock if the email is currently on hold. */
    public var startHoldTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** A globally unique identifier for the stored content of this communication. */
    public var messageId: String?
    /** Whether an email is inbound or outbound. */
    public var direction: Direction?
    /** A list of uploaded attachments on the email draft. */
    public var draftAttachments: [ConversationEventTopicAttachment]?
    /** Indicates if the inbound email was marked as spam. */
    public var spam: Bool?
    /** Call wrap up or disposition data. */
    public var wrapup: ConversationEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: ConversationEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: ConversationEventTopicQueueMediaSettings?

    public init(_id: String?, state: State?, initialState: InitialState?, held: Bool?, autoGenerated: Bool?, subject: String?, provider: String?, scriptId: String?, peerId: String?, messagesSent: Int?, errorInfo: ConversationEventTopicErrorDetails?, disconnectType: DisconnectType?, startHoldTime: Date?, connectedTime: Date?, disconnectedTime: Date?, messageId: String?, direction: Direction?, draftAttachments: [ConversationEventTopicAttachment]?, spam: Bool?, wrapup: ConversationEventTopicWrapup?, afterCallWork: ConversationEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: ConversationEventTopicQueueMediaSettings?) {
        self._id = _id
        self.state = state
        self.initialState = initialState
        self.held = held
        self.autoGenerated = autoGenerated
        self.subject = subject
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.messagesSent = messagesSent
        self.errorInfo = errorInfo
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.messageId = messageId
        self.direction = direction
        self.draftAttachments = draftAttachments
        self.spam = spam
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case initialState
        case held
        case autoGenerated
        case subject
        case provider
        case scriptId
        case peerId
        case messagesSent
        case errorInfo
        case disconnectType
        case startHoldTime
        case connectedTime
        case disconnectedTime
        case messageId
        case direction
        case draftAttachments
        case spam
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}



/** Fields identifying the entity that updated the command. */

public class ConversationEventTopicModifiedBy: Codable {





    /** The id of the user if the updater is an internal user. */
    public var _id: String?
    /** The URI for the user if the updater is an internal user. */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class ConversationEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: ConversationEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int?

    public init(agent: ConversationEventTopicUriReference?, score: Int?) {
        self.agent = agent
        self.score = score
    }


}




public class ConversationEventTopicVideo: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }





















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }















    public var state: State?
    public var initialState: InitialState?
    /** Address and name data for a call endpoint. */
    public var _self: ConversationEventTopicAddress?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The room id context (xmpp jid) for the conference session. */
    public var context: String?
    /** Indicates whether this participant has muted their outgoing audio. */
    public var audioMuted: Bool?
    /** Indicates whether this participant has muted/paused their outgoing video. */
    public var videoMuted: Bool?
    /** Indicates whether this participant is sharing their screen to the session. */
    public var sharingScreen: Bool?
    /** The number of peer participants from the perspective of the participant in the conference. */
    public var peerCount: JSON?
    /** The media provider controlling the video. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** List of media stream ids */
    public var msids: [String]?
    /** Call wrap up or disposition data. */
    public var wrapup: ConversationEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: ConversationEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: ConversationEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _self: ConversationEventTopicAddress?, _id: String?, context: String?, audioMuted: Bool?, videoMuted: Bool?, sharingScreen: Bool?, peerCount: JSON?, provider: String?, scriptId: String?, peerId: String?, disconnectType: DisconnectType?, connectedTime: Date?, disconnectedTime: Date?, msids: [String]?, wrapup: ConversationEventTopicWrapup?, afterCallWork: ConversationEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: ConversationEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._self = _self
        self._id = _id
        self.context = context
        self.audioMuted = audioMuted
        self.videoMuted = videoMuted
        self.sharingScreen = sharingScreen
        self.peerCount = peerCount
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.disconnectType = disconnectType
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.msids = msids
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _self = "self"
        case _id = "id"
        case context
        case audioMuted
        case videoMuted
        case sharingScreen
        case peerCount
        case provider
        case scriptId
        case peerId
        case disconnectType
        case connectedTime
        case disconnectedTime
        case msids
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}



/** Message event element.  Examples include: system messages, typing indicators, cobrowse offerings. */

public class ConversationMessageEvent: Codable {

    public enum EventType: String, Codable { 
        case coBrowse = "CoBrowse"
        case typing = "Typing"
        case presence = "Presence"
        case unknown = "Unknown"
    }







    /** Type of this event element */
    public var eventType: EventType?
    /** CoBrowse event. */
    public var coBrowse: ConversationEventCoBrowse?
    /** Typing event. */
    public var typing: ConversationEventTyping?
    /** Presence event. */
    public var presence: ConversationEventPresence?

    public init(eventType: EventType?, coBrowse: ConversationEventCoBrowse?, typing: ConversationEventTyping?, presence: ConversationEventPresence?) {
        self.eventType = eventType
        self.coBrowse = coBrowse
        self.typing = typing
        self.presence = presence
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class ConversationMessageEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: ConversationMessageEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: ConversationMessageEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}




public class ConversationMessageEventTopicJourneyContext: Codable {







    public var customer: ConversationMessageEventTopicJourneyCustomer?
    public var customerSession: ConversationMessageEventTopicJourneyCustomerSession?
    public var triggeringAction: ConversationMessageEventTopicJourneyAction?

    public init(customer: ConversationMessageEventTopicJourneyCustomer?, customerSession: ConversationMessageEventTopicJourneyCustomerSession?, triggeringAction: ConversationMessageEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class ConversationMessageEventTopicMessageConversation: Codable {









    public var _id: String?
    public var name: String?
    public var participants: [ConversationMessageEventTopicMessageMediaParticipant]?
    public var otherMediaUris: [String]?

    public init(_id: String?, name: String?, participants: [ConversationMessageEventTopicMessageMediaParticipant]?, otherMediaUris: [String]?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
    }


}




public class ConversationMessageEventTopicMessageDetails: Codable {







    public enum MessageStatus: String, Codable { 
        case queued = "queued"
        case sent = "sent"
        case failed = "failed"
        case received = "received"
        case deliverySuccess = "delivery-success"
        case deliveryFailed = "delivery-failed"
        case read = "read"
        case removed = "removed"
    }









    public var message: ConversationMessageEventTopicUriReference?
    public var messageTime: Date?
    public var messageSegmentCount: Int?
    public var messageStatus: MessageStatus?
    public var media: [ConversationMessageEventTopicMessageMedia]?
    public var stickers: [ConversationMessageEventTopicMessageSticker]?
    public var errorInfo: ConversationMessageEventTopicErrorDetails?
    public var messageMetadata: ConversationMessageEventTopicMessageMetadata?

    public init(message: ConversationMessageEventTopicUriReference?, messageTime: Date?, messageSegmentCount: Int?, messageStatus: MessageStatus?, media: [ConversationMessageEventTopicMessageMedia]?, stickers: [ConversationMessageEventTopicMessageSticker]?, errorInfo: ConversationMessageEventTopicErrorDetails?, messageMetadata: ConversationMessageEventTopicMessageMetadata?) {
        self.message = message
        self.messageTime = messageTime
        self.messageSegmentCount = messageSegmentCount
        self.messageStatus = messageStatus
        self.media = media
        self.stickers = stickers
        self.errorInfo = errorInfo
        self.messageMetadata = messageMetadata
    }


}




public class ConversationMessageEventTopicMessageMedia: Codable {











    /** The location of the media, useful for retrieving it */
    public var url: String?
    /** The optional internet media type of the the media object.  If null then the media type should be dictated by the url */
    public var mediaType: String?
    /** The optional content length of the the media object, in bytes. */
    public var contentLengthBytes: Int?
    /** The optional name of the the media object. */
    public var name: String?
    /** The optional id of the the media object. */
    public var _id: String?

    public init(url: String?, mediaType: String?, contentLengthBytes: Int?, name: String?, _id: String?) {
        self.url = url
        self.mediaType = mediaType
        self.contentLengthBytes = contentLengthBytes
        self.name = name
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case url
        case mediaType
        case contentLengthBytes
        case name
        case _id = "id"
    }


}




public class ConversationMessageEventTopicMessageMetadataEvent: Codable {





    /** Type of this event element. */
    public var eventType: String?
    /** Event subtype, if any */
    public var subType: String?

    public init(eventType: String?, subType: String?) {
        self.eventType = eventType
        self.subType = subType
    }


}




public class ConversationMessageEventTopicMessageSticker: Codable {





    /** The location of the sticker, useful for retrieving it */
    public var url: String?
    /** The unique id of the the sticker object. */
    public var _id: String?

    public init(url: String?, _id: String?) {
        self.url = url
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case url
        case _id = "id"
    }


}




public class ConversationMessageEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}



/** Channel-specific information that describes the message and the message channel/provider. */

public class ConversationMessagingChannel: Codable {



    public enum Platform: String, Codable { 
        case twitter = "Twitter"
        case facebook = "Facebook"
        case instagram = "Instagram"
        case line = "Line"
        case whatsapp = "Whatsapp"
        case webMessaging = "WebMessaging"
        case _open = "Open"
        case sms = "Sms"
    }













    /** The integration ID. */
    public var _id: String?
    /** The provider type. */
    public var platform: Platform?
    /** Unique provider ID of the message such as a Facebook message ID. */
    public var messageId: String?
    /** Information about the recipient the message is sent to. */
    public var to: ConversationMessagingToRecipient?
    /** Information about the recipient the message is received from. */
    public var from: ConversationMessagingFromRecipient?
    /** Original time of the event. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var time: Date?
    /** Time the message was edited. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Time the message was deleted. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateDeleted: Date?

    public init(_id: String?, platform: Platform?, messageId: String?, to: ConversationMessagingToRecipient?, from: ConversationMessagingFromRecipient?, time: Date?, dateModified: Date?, dateDeleted: Date?) {
        self._id = _id
        self.platform = platform
        self.messageId = messageId
        self.to = to
        self.from = from
        self.time = time
        self.dateModified = dateModified
        self.dateDeleted = dateDeleted
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case platform
        case messageId
        case to
        case from
        case time
        case dateModified
        case dateDeleted
    }


}



/** Template header object. */

public class ConversationNotificationTemplateHeader: Codable {

    public enum ModelType: String, Codable { 
        case text = "Text"
        case media = "Media"
    }







    /** Template header type. */
    public var type: ModelType?
    /** Header text. For WhatsApp, ignored. */
    public var text: String?
    /** Media template header image. */
    public var media: ConversationContentAttachment?
    /** Template parameters for placeholders in template. */
    public var parameters: [ConversationNotificationTemplateParameter]?

    public init(type: ModelType?, text: String?, media: ConversationContentAttachment?, parameters: [ConversationNotificationTemplateParameter]?) {
        self.type = type
        self.text = text
        self.media = media
        self.parameters = parameters
    }


}




public class ConversationParticipantSearchCriteria: Codable {









    public enum Operator: String, Codable { 
        case and = "AND"
        case or = "OR"
        case not = "NOT"
    }





    public enum ModelType: String, Codable { 
        case exact = "EXACT"
        case dateRange = "DATE_RANGE"
    }



    /** The end value of the range. This field is used for range search types. */
    public var endValue: String?
    /** A list of values for the search to match against */
    public var values: [String]?
    /** The start value of the range. This field is used for range search types. */
    public var startValue: String?
    /** A value for the search to match against */
    public var value: String?
    /** How to apply this search criteria against other criteria */
    public var _operator: Operator?
    /** Groups multiple conditions */
    public var group: [ConversationParticipantSearchCriteria]?
    /** Set date format for criteria values when using date range search type.  Supports Java date format syntax, example yyyy-MM-dd'T'HH:mm:ss.SSSX. */
    public var dateFormat: String?
    /** Search Type */
    public var type: ModelType?
    /** Field names to search against */
    public var fields: [String]?

    public init(endValue: String?, values: [String]?, startValue: String?, value: String?, _operator: Operator?, group: [ConversationParticipantSearchCriteria]?, dateFormat: String?, type: ModelType?, fields: [String]?) {
        self.endValue = endValue
        self.values = values
        self.startValue = startValue
        self.value = value
        self._operator = _operator
        self.group = group
        self.dateFormat = dateFormat
        self.type = type
        self.fields = fields
    }

    public enum CodingKeys: String, CodingKey { 
        case endValue
        case values
        case startValue
        case value
        case _operator = "operator"
        case group
        case dateFormat
        case type
        case fields
    }


}




public class ConversationScreenShareEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}




public class ConversationSecureAttributes: Codable {





    /** The map of attribute keys to values. */
    public var attributes: [String:String]?
    /** The version used to detect conflicting updates when using PUT. Not used for PATCH. */
    public var version: Int?

    public init(attributes: [String:String]?, version: Int?) {
        self.attributes = attributes
        self.version = version
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationSocialExpressionEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationSocialExpressionEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}




public class ConversationSocialExpressionEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: ConversationSocialExpressionEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int?

    public init(agent: ConversationSocialExpressionEventTopicUriReference?, score: Int?) {
        self.agent = agent
        self.score = score
    }


}




public class ConversationSocialExpressionEventTopicSocialConversation: Codable {









    public var _id: String?
    public var name: String?
    public var participants: [ConversationSocialExpressionEventTopicSocialMediaParticipant]?
    public var otherMediaUris: [String]?

    public init(_id: String?, name: String?, participants: [ConversationSocialExpressionEventTopicSocialMediaParticipant]?, otherMediaUris: [String]?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
    }


}




public class ConversationUserDisposition: Codable {







    /** User-defined wrap-up code for the conversation. */
    public var code: String?
    /** Text entered by the user to describe the call or disposition. */
    public var notes: String?
    /** The user that wrapped up the conversation. */
    public var user: AddressableEntityRef?

    public init(code: String?, notes: String?, user: AddressableEntityRef?) {
        self.code = code
        self.notes = notes
        self.user = user
    }


}




public class ConversationVideoEventTopicDetail: Codable {









    public var errorCode: String?
    public var fieldName: String?
    public var entityId: String?
    public var entityName: String?

    public init(errorCode: String?, fieldName: String?, entityId: String?, entityName: String?) {
        self.errorCode = errorCode
        self.fieldName = fieldName
        self.entityId = entityId
        self.entityName = entityName
    }


}




public class ConversationVideoEventTopicErrorBody: Codable {





















    public var message: String?
    public var code: String?
    public var status: Int?
    public var entityId: String?
    public var entityName: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var contextId: String?
    public var details: [ConversationVideoEventTopicDetail]?
    public var errors: [ConversationVideoEventTopicErrorBody]?

    public init(message: String?, code: String?, status: Int?, entityId: String?, entityName: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, details: [ConversationVideoEventTopicDetail]?, errors: [ConversationVideoEventTopicErrorBody]?) {
        self.message = message
        self.code = code
        self.status = status
        self.entityId = entityId
        self.entityName = entityName
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.details = details
        self.errors = errors
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class ConversationVideoEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int?

    public init(_id: String?, version: Int?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}




public class ConversationVideoEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class CopyWorkPlanRotationRequest: Codable {



    /** Name to apply to the new copy of the work plan rotation */
    public var name: String?

    public init(name: String?) {
        self.name = name
    }


}




public class Coretype: Codable {























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** A positive integer denoting the core type's version */
    public var version: Int?
    /** The date the core type was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The core type's built-in schema */
    public var schema: Schema?
    /** A boolean indicating if the core type's version is the current one in use by the system */
    public var current: Bool?
    /** An array of strings naming the fields of the core type subject to validation.  Validation constraints are specified by a schema author using the core type. */
    public var validationFields: [String]?
    /** A structure denoting the system-imposed minimum and maximum string length (for text-based core types) or numeric values (for number-based) core types.  For example, the validationLimits for a text-based core type specify the min/max values for a minimum string length (minLength) constraint supplied by a schemaauthor on a text field.  Similarly, the maxLength's min/max specifies maximum string length constraint supplied by a schema author for the same field. */
    public var validationLimits: ValidationLimits?
    /** Specific to the \"tag\" core type, this is an array of strings naming the tag item fields of the core type subject to validation */
    public var itemValidationFields: [String]?
    /** A structure denoting the system-imposed minimum and maximum string length for string-array based core types such as \"tag\" and \"enum\".  Forexample, the validationLimits for a schema field using a tag core type specify the min/max values for a minimum string length (minLength) constraint supplied by a schema author on individual tags.  Similarly, the maxLength's min/max specifies maximum string length constraint supplied by a schema author for the same field's tags. */
    public var itemValidationLimits: ItemValidationLimits?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, version: Int?, dateCreated: Date?, schema: Schema?, current: Bool?, validationFields: [String]?, validationLimits: ValidationLimits?, itemValidationFields: [String]?, itemValidationLimits: ItemValidationLimits?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.version = version
        self.dateCreated = dateCreated
        self.schema = schema
        self.current = current
        self.validationFields = validationFields
        self.validationLimits = validationLimits
        self.itemValidationFields = itemValidationFields
        self.itemValidationLimits = itemValidationLimits
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case version
        case dateCreated
        case schema
        case current
        case validationFields
        case validationLimits
        case itemValidationFields
        case itemValidationLimits
        case selfUri
    }


}




public class CoretypeListing: Codable {







    public var total: Int64?
    public var entities: [Coretype]?
    public var selfUri: String?

    public init(total: Int64?, entities: [Coretype]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class CreateAgentTimeOffRequest: Codable {















    /** The ID of the activity code associated with this time off request. Activity code must be of the TimeOff category */
    public var activityCodeId: String?
    /** Notes about the time off request */
    public var notes: String?
    /** A set of dates in yyyy-MM-dd format.  Should be interpreted in the management unit's configured time zone. */
    public var fullDayManagementUnitDates: [String]?
    /** A set of start date-times in ISO-8601 format for partial day requests. */
    public var partialDayStartDateTimes: [Date]?
    /** The daily duration of this time off request in minutes */
    public var dailyDurationMinutes: Int?
    /** Daily durations for each day of this time off request in minutes */
    public var durationMinutes: [Int]?
    /** Payable minutes for each day of this time off request */
    public var payableMinutes: [Int]?

    public init(activityCodeId: String?, notes: String?, fullDayManagementUnitDates: [String]?, partialDayStartDateTimes: [Date]?, dailyDurationMinutes: Int?, durationMinutes: [Int]?, payableMinutes: [Int]?) {
        self.activityCodeId = activityCodeId
        self.notes = notes
        self.fullDayManagementUnitDates = fullDayManagementUnitDates
        self.partialDayStartDateTimes = partialDayStartDateTimes
        self.dailyDurationMinutes = dailyDurationMinutes
        self.durationMinutes = durationMinutes
        self.payableMinutes = payableMinutes
    }


}




public class CreateCallResponse: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}




public class CreateGeneralProgramTopicsDefinitionsJob: Codable {



    public enum State: String, Codable { 
        case completed = "Completed"
        case failed = "Failed"
    }

    public var _id: String?
    public var state: State?

    public init(_id: String?, state: State?) {
        self._id = _id
        self.state = state
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
    }


}




public class CreateMetric: Codable {













    public enum TimeDisplayUnit: String, Codable { 
        case _none = "None"
        case seconds = "Seconds"
        case minutes = "Minutes"
        case hours = "Hours"
    }

    /** The id of associated metric definition */
    public var metricDefinitionId: String?
    /** The id of associated external metric definition */
    public var externalMetricDefinitionId: String?
    /** Associated objective for this metric */
    public var objective: CreateObjective?
    /** Performance profile id of this metric */
    public var performanceProfileId: String?
    /** The name of this metric */
    public var name: String?
    /** The precision of the metric, must be between 0 and 5 */
    public var precision: Int?
    /** The time unit in which the metric should be displayed -- this parameter is ignored when displaying non-time values */
    public var timeDisplayUnit: TimeDisplayUnit?

    public init(metricDefinitionId: String?, externalMetricDefinitionId: String?, objective: CreateObjective?, performanceProfileId: String?, name: String?, precision: Int?, timeDisplayUnit: TimeDisplayUnit?) {
        self.metricDefinitionId = metricDefinitionId
        self.externalMetricDefinitionId = externalMetricDefinitionId
        self.objective = objective
        self.performanceProfileId = performanceProfileId
        self.name = name
        self.precision = precision
        self.timeDisplayUnit = timeDisplayUnit
    }


}




public class CreateQueueRequest: Codable {































    public enum ScoringMethod: String, Codable { 
        case timestampAndPriority = "TimestampAndPriority"
        case priorityOnly = "PriorityOnly"
    }



    public enum SkillEvaluationMethod: String, Codable { 
        case _none = "NONE"
        case best = "BEST"
        case all = "ALL"
    }











































    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The queue name */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    /** The queue description. */
    public var _description: String?
    /** The date the queue was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the queue. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the queue. */
    public var modifiedBy: String?
    /** The ID of the user that created the queue. */
    public var createdBy: String?
    /** The total number of members in the queue. */
    public var memberCount: Int?
    /** The number of user members (i.e., non-group members) in the queue. */
    public var userMemberCount: Int?
    /** The number of joined members in the queue. */
    public var joinedMemberCount: Int?
    /** The media settings for the queue. */
    public var mediaSettings: QueueMediaSettings?
    /** The routing rules for the queue, used for Preferred Agent Routing. */
    public var routingRules: [RoutingRule]?
    /** The Conditional Group Routing settings for the queue. */
    public var conditionalGroupRouting: ConditionalGroupRouting?
    /** The bullseye settings for the queue. */
    public var bullseye: Bullseye?
    /** The Scoring Method for the queue */
    public var scoringMethod: ScoringMethod?
    /** The ACW settings for the queue. */
    public var acwSettings: AcwSettings?
    /** The skill evaluation method to use when routing conversations. */
    public var skillEvaluationMethod: SkillEvaluationMethod?
    /** The groups of agents associated with the queue, if any.  Queue membership will update to match group membership changes. */
    public var memberGroups: [MemberGroup]?
    /** The in-queue flow to use for call conversations waiting in queue. */
    public var queueFlow: DomainEntityRef?
    /** The in-queue flow to use for email conversations waiting in queue. */
    public var emailInQueueFlow: DomainEntityRef?
    /** The in-queue flow to use for message conversations waiting in queue. */
    public var messageInQueueFlow: DomainEntityRef?
    /** The prompt used for whisper on the queue, if configured. */
    public var whisperPrompt: DomainEntityRef?
    /** The audio to be played when calls on this queue are on hold. If not configured, the default on-hold music will play. */
    public var onHoldPrompt: DomainEntityRef?
    /** Specifies whether the configured whisper should play for all ACD calls, or only for those which are auto-answered. */
    public var autoAnswerOnly: Bool?
    /** Indicates whether voice transcription is enabled for this queue. */
    public var enableTranscription: Bool?
    /** Indicates whether audio monitoring is enabled for this queue. */
    public var enableAudioMonitoring: Bool?
    /** Indicates whether manual assignment is enabled for this queue. */
    public var enableManualAssignment: Bool?
    /** The Agent Owned Routing settings for the queue */
    public var agentOwnedRouting: AgentOwnedRouting?
    /** The Direct Routing settings for the queue */
    public var directRouting: DirectRouting?
    /** The name to use for caller identification for outbound calls from this queue. */
    public var callingPartyName: String?
    /** The phone number to use for caller identification for outbound calls from this queue. */
    public var callingPartyNumber: String?
    /** The default script Ids for the communication types. */
    public var defaultScripts: [String:Script]?
    /** The messaging addresses for the queue. */
    public var outboundMessagingAddresses: QueueMessagingAddresses?
    public var outboundEmailAddress: QueueEmailAddress?
    /** The ID of an associated external queue. */
    public var peerId: String?
    /** Indicates whether recording in-queue calls is suppressed for this queue. */
    public var suppressInQueueCallRecording: Bool?
    /** The id of an existing queue to copy the settings (does not include GPR settings) from when creating a new queue. */
    public var sourceQueueId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, _description: String?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, memberCount: Int?, userMemberCount: Int?, joinedMemberCount: Int?, mediaSettings: QueueMediaSettings?, routingRules: [RoutingRule]?, conditionalGroupRouting: ConditionalGroupRouting?, bullseye: Bullseye?, scoringMethod: ScoringMethod?, acwSettings: AcwSettings?, skillEvaluationMethod: SkillEvaluationMethod?, memberGroups: [MemberGroup]?, queueFlow: DomainEntityRef?, emailInQueueFlow: DomainEntityRef?, messageInQueueFlow: DomainEntityRef?, whisperPrompt: DomainEntityRef?, onHoldPrompt: DomainEntityRef?, autoAnswerOnly: Bool?, enableTranscription: Bool?, enableAudioMonitoring: Bool?, enableManualAssignment: Bool?, agentOwnedRouting: AgentOwnedRouting?, directRouting: DirectRouting?, callingPartyName: String?, callingPartyNumber: String?, defaultScripts: [String:Script]?, outboundMessagingAddresses: QueueMessagingAddresses?, outboundEmailAddress: QueueEmailAddress?, peerId: String?, suppressInQueueCallRecording: Bool?, sourceQueueId: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.memberCount = memberCount
        self.userMemberCount = userMemberCount
        self.joinedMemberCount = joinedMemberCount
        self.mediaSettings = mediaSettings
        self.routingRules = routingRules
        self.conditionalGroupRouting = conditionalGroupRouting
        self.bullseye = bullseye
        self.scoringMethod = scoringMethod
        self.acwSettings = acwSettings
        self.skillEvaluationMethod = skillEvaluationMethod
        self.memberGroups = memberGroups
        self.queueFlow = queueFlow
        self.emailInQueueFlow = emailInQueueFlow
        self.messageInQueueFlow = messageInQueueFlow
        self.whisperPrompt = whisperPrompt
        self.onHoldPrompt = onHoldPrompt
        self.autoAnswerOnly = autoAnswerOnly
        self.enableTranscription = enableTranscription
        self.enableAudioMonitoring = enableAudioMonitoring
        self.enableManualAssignment = enableManualAssignment
        self.agentOwnedRouting = agentOwnedRouting
        self.directRouting = directRouting
        self.callingPartyName = callingPartyName
        self.callingPartyNumber = callingPartyNumber
        self.defaultScripts = defaultScripts
        self.outboundMessagingAddresses = outboundMessagingAddresses
        self.outboundEmailAddress = outboundEmailAddress
        self.peerId = peerId
        self.suppressInQueueCallRecording = suppressInQueueCallRecording
        self.sourceQueueId = sourceQueueId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case memberCount
        case userMemberCount
        case joinedMemberCount
        case mediaSettings
        case routingRules
        case conditionalGroupRouting
        case bullseye
        case scoringMethod
        case acwSettings
        case skillEvaluationMethod
        case memberGroups
        case queueFlow
        case emailInQueueFlow
        case messageInQueueFlow
        case whisperPrompt
        case onHoldPrompt
        case autoAnswerOnly
        case enableTranscription
        case enableAudioMonitoring
        case enableManualAssignment
        case agentOwnedRouting
        case directRouting
        case callingPartyName
        case callingPartyNumber
        case defaultScripts
        case outboundMessagingAddresses
        case outboundEmailAddress
        case peerId
        case suppressInQueueCallRecording
        case sourceQueueId
        case selfUri
    }


}




public class CreateTimeOffPlanRequest: Codable {







    public enum AutoApprovalRule: String, Codable { 
        case never = "Never"
        case always = "Always"
        case checkLimits = "CheckLimits"
    }







    /** The name of this time off plan. */
    public var name: String?
    /** The set of activity code IDs to associate with this time off plan. */
    public var activityCodeIds: [String]?
    /** The set of time off limit IDs to associate with this time off plan. */
    public var timeOffLimitIds: [String]?
    /** Auto approval rule for the time off plan. */
    public var autoApprovalRule: AutoApprovalRule?
    /** The number of days before the time off request start date for when the request will be expired from the waitlist. */
    public var daysBeforeStartToExpireFromWaitlist: Int?
    /** Time off type, if this time off plan is associated with the integration. */
    public var hrisTimeOffType: HrisTimeOffType?
    /** Whether this time off plan should be used by agents. */
    public var active: Bool?

    public init(name: String?, activityCodeIds: [String]?, timeOffLimitIds: [String]?, autoApprovalRule: AutoApprovalRule?, daysBeforeStartToExpireFromWaitlist: Int?, hrisTimeOffType: HrisTimeOffType?, active: Bool?) {
        self.name = name
        self.activityCodeIds = activityCodeIds
        self.timeOffLimitIds = timeOffLimitIds
        self.autoApprovalRule = autoApprovalRule
        self.daysBeforeStartToExpireFromWaitlist = daysBeforeStartToExpireFromWaitlist
        self.hrisTimeOffType = hrisTimeOffType
        self.active = active
    }


}




public class CreateWebChatConversationResponse: Codable {









    /** Chat Conversation identifier */
    public var _id: String?
    /** The JWT that you can use to identify subsequent calls on this conversation */
    public var jwt: String?
    /** The URI which provides the conversation event stream. */
    public var eventStreamUri: String?
    /** Chat Member */
    public var member: WebChatMemberInfo?

    public init(_id: String?, jwt: String?, eventStreamUri: String?, member: WebChatMemberInfo?) {
        self._id = _id
        self.jwt = jwt
        self.eventStreamUri = eventStreamUri
        self.member = member
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case jwt
        case eventStreamUri
        case member
    }


}



/** A singular criteria used to query executionData. */

public class CriteriaItem: Codable {

    public enum Key: String, Codable { 
        case flowStartDateTime = "FlowStartDateTime"
        case flowEndDateTime = "FlowEndDateTime"
        case conversationId = "ConversationId"
        case flowType = "FlowType"
        case flowId = "FlowId"
        case flowErrorReason = "FlowErrorReason"
        case flowWarningReason = "FlowWarningReason"
        case flowAlternateExecutionId = "FlowAlternateExecutionId"
        case flowObjectExecutionId = "FlowObjectExecutionId"
        case flowActionId = "FlowActionId"
        case flowActionType = "FlowActionType"
        case flowActionOutputPathId = "FlowActionOutputPathId"
        case flowActionOutputPathName = "FlowActionOutputPathName"
        case flowActionIdOutputPathId = "FlowActionIdOutputPathId"
        case flowActionIdOutputPathName = "FlowActionIdOutputPathName"
        case flowActionTypeOutputPathId = "FlowActionTypeOutputPathId"
        case flowActionTypeOutputPathName = "FlowActionTypeOutputPathName"
        case botId = "BotId"
        case botErrorReason = "BotErrorReason"
        case botFlowExecutionId = "BotFlowExecutionId"
        case botObjectExecutionId = "BotObjectExecutionId"
    }

    public enum Operator: String, Codable { 
        case eq = "eq"
        case gt = "gt"
        case gte = "gte"
        case lt = "lt"
        case lte = "lte"
        case not = "not"
        case begins = "begins"
        case notNull = "not_null"
    }



    /** The id of the criteria to be checked. */
    public var key: Key?
    /** The operator used to check on the criteria id. */
    public var _operator: Operator?
    /** The target value used to query on. */
    public var value: String?

    public init(key: Key?, _operator: Operator?, value: String?) {
        self.key = key
        self._operator = _operator
        self.value = value
    }

    public enum CodingKeys: String, CodingKey { 
        case key
        case _operator = "operator"
        case value
    }


}



/** Used to retrieve executionData based upon certain criteria */

public class CriteriaQuery: Codable {



    /** A list of CriteriaGroups which will be AND'd together to generate a result set. */
    public var query: [CriteriaGroup]?

    public init(query: [CriteriaGroup]?) {
        self.query = query
    }


}




public class CrossPlatformCallMediaPolicy: Codable {





    /** Actions applied when specified conditions are met */
    public var actions: CrossPlatformPolicyActions?
    /** Conditions for when actions should be applied */
    public var conditions: CallMediaPolicyConditions?

    public init(actions: CrossPlatformPolicyActions?, conditions: CallMediaPolicyConditions?) {
        self.actions = actions
        self.conditions = conditions
    }


}




public class CrossPlatformPolicy: Codable {

























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    public var order: Int?
    public var _description: String?
    public var enabled: Bool?
    /** Conditions and actions per media type */
    public var mediaPolicies: CrossPlatformMediaPolicies?
    /** Conditions */
    public var conditions: PolicyConditions?
    /** Actions */
    public var actions: CrossPlatformPolicyActions?
    public var policyErrors: PolicyErrors?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, modifiedDate: Date?, createdDate: Date?, order: Int?, _description: String?, enabled: Bool?, mediaPolicies: CrossPlatformMediaPolicies?, conditions: PolicyConditions?, actions: CrossPlatformPolicyActions?, policyErrors: PolicyErrors?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.modifiedDate = modifiedDate
        self.createdDate = createdDate
        self.order = order
        self._description = _description
        self.enabled = enabled
        self.mediaPolicies = mediaPolicies
        self.conditions = conditions
        self.actions = actions
        self.policyErrors = policyErrors
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case modifiedDate
        case createdDate
        case order
        case _description = "description"
        case enabled
        case mediaPolicies
        case conditions
        case actions
        case policyErrors
        case selfUri
    }


}




public class CrossPlatformMediaPolicies: Codable {









    /** Conditions and actions for calls */
    public var callPolicy: CrossPlatformCallMediaPolicy?
    /** Conditions and actions for chats */
    public var chatPolicy: CrossPlatformChatMediaPolicy?
    /** Conditions and actions for emails */
    public var emailPolicy: CrossPlatformEmailMediaPolicy?
    /** Conditions and actions for messages */
    public var messagePolicy: CrossPlatformMessageMediaPolicy?

    public init(callPolicy: CrossPlatformCallMediaPolicy?, chatPolicy: CrossPlatformChatMediaPolicy?, emailPolicy: CrossPlatformEmailMediaPolicy?, messagePolicy: CrossPlatformMessageMediaPolicy?) {
        self.callPolicy = callPolicy
        self.chatPolicy = chatPolicy
        self.emailPolicy = emailPolicy
        self.messagePolicy = messagePolicy
    }


}




public class Cursors: Codable {





    public var before: String?
    public var after: String?

    public init(before: String?, after: String?) {
        self.before = before
        self.after = after
    }


}



/** The localization settings for homescreen */

public class CustomI18nLabels: Codable {





    /** Language of localized labels in homescreen app (eg. en-us, de-de) */
    public var language: String?
    /** Contains localized labels used in homescreen app */
    public var localizedLabels: [LocalizedLabels]?

    public init(language: String?, localizedLabels: [LocalizedLabels]?) {
        self.language = language
        self.localizedLabels = localizedLabels
    }


}




public class CustomProvider: Codable {

























    public enum NameIdentifierFormat: String, Codable { 
        case urnOasisNamesTcSaml11NameidFormatUnspecified = "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified"
        case urnOasisNamesTcSaml11NameidFormatEmailaddress = "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
        case urnOasisNamesTcSaml11NameidFormatX509subjectname = "urn:oasis:names:tc:SAML:1.1:nameid-format:X509SubjectName"
        case urnOasisNamesTcSaml11NameidFormatWindowsdomainqualifiedname = "urn:oasis:names:tc:SAML:1.1:nameid-format:WindowsDomainQualifiedName"
        case urnOasisNamesTcSaml20NameidFormatKerberos = "urn:oasis:names:tc:SAML:2.0:nameid-format:kerberos"
        case urnOasisNamesTcSaml20NameidFormatEntity = "urn:oasis:names:tc:SAML:2.0:nameid-format:entity"
        case urnOasisNamesTcSaml20NameidFormatPersistent = "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent"
        case urnOasisNamesTcSaml20NameidFormatTransient = "urn:oasis:names:tc:SAML:2.0:nameid-format:transient"
    }

    public enum SsoBinding: String, Codable { 
        case urnOasisNamesTcSaml20BindingsHttpPost = "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
        case urnOasisNamesTcSaml20BindingsHttpRedirect = "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var disabled: Bool?
    public var issuerURI: String?
    public var ssoTargetURI: String?
    public var sloURI: String?
    public var sloBinding: String?
    public var relyingPartyIdentifier: String?
    public var certificate: String?
    public var certificates: [String]?
    public var logoImageData: String?
    public var endpointCompression: Bool?
    public var nameIdentifierFormat: NameIdentifierFormat?
    public var ssoBinding: SsoBinding?
    public var signAuthnRequests: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, disabled: Bool?, issuerURI: String?, ssoTargetURI: String?, sloURI: String?, sloBinding: String?, relyingPartyIdentifier: String?, certificate: String?, certificates: [String]?, logoImageData: String?, endpointCompression: Bool?, nameIdentifierFormat: NameIdentifierFormat?, ssoBinding: SsoBinding?, signAuthnRequests: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.disabled = disabled
        self.issuerURI = issuerURI
        self.ssoTargetURI = ssoTargetURI
        self.sloURI = sloURI
        self.sloBinding = sloBinding
        self.relyingPartyIdentifier = relyingPartyIdentifier
        self.certificate = certificate
        self.certificates = certificates
        self.logoImageData = logoImageData
        self.endpointCompression = endpointCompression
        self.nameIdentifierFormat = nameIdentifierFormat
        self.ssoBinding = ssoBinding
        self.signAuthnRequests = signAuthnRequests
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case disabled
        case issuerURI
        case ssoTargetURI
        case sloURI
        case sloBinding
        case relyingPartyIdentifier
        case certificate
        case certificates
        case logoImageData
        case endpointCompression
        case nameIdentifierFormat
        case ssoBinding
        case signAuthnRequests
        case selfUri
    }


}




public class DIDNumberEntityListing: Codable {





















    public var entities: [DIDNumber]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DIDNumber]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DataActionConditionSettings: Codable {











    /** The Data Action Id to use for this condition. */
    public var dataActionId: String?
    /** The input field from the data action that the contactId will be passed into. */
    public var contactIdField: String?
    /** The result of this condition if the data action returns a result indicating there was no data. */
    public var dataNotFoundResolution: Bool?
    /** A list of predicates defining the comparisons to use for this condition. */
    public var predicates: [DigitalDataActionConditionPredicate]?
    /** A list of mappings defining which contact data fields will be passed to which data action input fields. */
    public var contactColumnToDataActionFieldMappings: [DataActionContactColumnFieldMapping]?

    public init(dataActionId: String?, contactIdField: String?, dataNotFoundResolution: Bool?, predicates: [DigitalDataActionConditionPredicate]?, contactColumnToDataActionFieldMappings: [DataActionContactColumnFieldMapping]?) {
        self.dataActionId = dataActionId
        self.contactIdField = contactIdField
        self.dataNotFoundResolution = dataNotFoundResolution
        self.predicates = predicates
        self.contactColumnToDataActionFieldMappings = contactColumnToDataActionFieldMappings
    }


}




public class DataAvailabilityResponse: Codable {



    /** Date and time before which data is guaranteed to be available in the datalake. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dataAvailabilityDate: Date?

    public init(dataAvailabilityDate: Date?) {
        self.dataAvailabilityDate = dataAvailabilityDate
    }


}




public class DataTableImportEntityListing: Codable {











    public var entities: [DataTableImportJob]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var pageCount: Int?

    public init(entities: [DataTableImportJob]?, pageSize: Int?, pageNumber: Int?, total: Int64?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.pageCount = pageCount
    }


}




public class DataTablesDomainEntityListing: Codable {





















    public var entities: [DataTable]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DataTable]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class Dependency: Codable {







    public enum ModelType: String, Codable { 
        case acdlanguage = "ACDLANGUAGE"
        case acdskill = "ACDSKILL"
        case acdwrapupcode = "ACDWRAPUPCODE"
        case audioconnectorbot = "AUDIOCONNECTORBOT"
        case botconnectorbot = "BOTCONNECTORBOT"
        case botconnectorintegration = "BOTCONNECTORINTEGRATION"
        case botflow = "BOTFLOW"
        case bridgeaction = "BRIDGEACTION"
        case commonmoduleflow = "COMMONMODULEFLOW"
        case composerscript = "COMPOSERSCRIPT"
        case contactlist = "CONTACTLIST"
        case dataaction = "DATAACTION"
        case datatable = "DATATABLE"
        case dialogenginebot = "DIALOGENGINEBOT"
        case dialogenginebotversion = "DIALOGENGINEBOTVERSION"
        case dialogflowagent = "DIALOGFLOWAGENT"
        case dialogflowcxagent = "DIALOGFLOWCXAGENT"
        case digitalbotflow = "DIGITALBOTFLOW"
        case emailroute = "EMAILROUTE"
        case emergencygroup = "EMERGENCYGROUP"
        case flowaction = "FLOWACTION"
        case flowdatatype = "FLOWDATATYPE"
        case flowmilestone = "FLOWMILESTONE"
        case flowoutcome = "FLOWOUTCOME"
        case grammar = "GRAMMAR"
        case group = "GROUP"
        case image = "IMAGE"
        case inboundcallflow = "INBOUNDCALLFLOW"
        case inboundchatflow = "INBOUNDCHATFLOW"
        case inboundemailflow = "INBOUNDEMAILFLOW"
        case inboundshortmessageflow = "INBOUNDSHORTMESSAGEFLOW"
        case inqueuecallflow = "INQUEUECALLFLOW"
        case inqueueemailflow = "INQUEUEEMAILFLOW"
        case inqueueshortmessageflow = "INQUEUESHORTMESSAGEFLOW"
        case ivrconfiguration = "IVRCONFIGURATION"
        case knowledgebase = "KNOWLEDGEBASE"
        case knowledgebasedocument = "KNOWLEDGEBASEDOCUMENT"
        case language = "LANGUAGE"
        case lexbot = "LEXBOT"
        case lexbotalias = "LEXBOTALIAS"
        case lexv2bot = "LEXV2BOT"
        case lexv2botalias = "LEXV2BOTALIAS"
        case nludomain = "NLUDOMAIN"
        case nuancemixbot = "NUANCEMIXBOT"
        case nuancemixintegration = "NUANCEMIXINTEGRATION"
        case oauthclient = "OAUTHCLIENT"
        case outboundcallflow = "OUTBOUNDCALLFLOW"
        case queue = "QUEUE"
        case recordingpolicy = "RECORDINGPOLICY"
        case response = "RESPONSE"
        case schedule = "SCHEDULE"
        case schedulegroup = "SCHEDULEGROUP"
        case secureaction = "SECUREACTION"
        case securecallflow = "SECURECALLFLOW"
        case sttengine = "STTENGINE"
        case surveyform = "SURVEYFORM"
        case surveyinviteflow = "SURVEYINVITEFLOW"
        case systemprompt = "SYSTEMPROMPT"
        case ttsengine = "TTSENGINE"
        case ttsvoice = "TTSVOICE"
        case user = "USER"
        case userprompt = "USERPROMPT"
        case utilizationlabel = "UTILIZATIONLABEL"
        case voiceflow = "VOICEFLOW"
        case voicemailflow = "VOICEMAILFLOW"
        case voicesurveyflow = "VOICESURVEYFLOW"
        case widget = "WIDGET"
        case workflow = "WORKFLOW"
        case workitemflow = "WORKITEMFLOW"
    }









    /** The dependency identifier */
    public var _id: String?
    public var name: String?
    public var version: String?
    public var type: ModelType?
    public var deleted: Bool?
    public var updated: Bool?
    public var stateUnknown: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, version: String?, type: ModelType?, deleted: Bool?, updated: Bool?, stateUnknown: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.version = version
        self.type = type
        self.deleted = deleted
        self.updated = updated
        self.stateUnknown = stateUnknown
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case version
        case type
        case deleted
        case updated
        case stateUnknown
        case selfUri
    }


}




public class DependencyTypeEntityListing: Codable {





















    public var entities: [DependencyType]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DependencyType]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DetectedIntent: Codable {







    /** The name of the detected intent. */
    public var name: String?
    /** The probability of the detected intent. */
    public var probability: Double?
    /** The collection of named entities detected. */
    public var entities: [DetectedNamedEntity]?

    public init(name: String?, probability: Double?, entities: [DetectedNamedEntity]?) {
        self.name = name
        self.probability = probability
        self.entities = entities
    }


}




public class DetectedNamedEntityValue: Codable {







    /** The raw value of the detected named entity. */
    public var raw: String?
    /** The resolved value of the detected named entity. */
    public var resolved: String?
    /** The unit of the detected amount of money entity, e.g. EUR, USD. */
    public var unit: String?

    public init(raw: String?, resolved: String?, unit: String?) {
        self.raw = raw
        self.resolved = resolved
        self.unit = unit
    }


}




public class DevelopmentActivityAggregateQueryResponseGroupedData: Codable {





    /** The group values for this data */
    public var group: [String:String]?
    /** The metrics in this group */
    public var data: [DevelopmentActivityAggregateQueryResponseData]?

    public init(group: [String:String]?, data: [DevelopmentActivityAggregateQueryResponseData]?) {
        self.group = group
        self.data = data
    }


}




public class DialerCallabletimesetConfigChangeCallableTime: Codable {







    /** The time slots */
    public var timeSlots: [DialerCallabletimesetConfigChangeTimeSlot]?
    /** The ISO ID for the timezone */
    public var timeZoneId: String?
    public var additionalProperties: [String:JSON]?

    public init(timeSlots: [DialerCallabletimesetConfigChangeTimeSlot]?, timeZoneId: String?, additionalProperties: [String:JSON]?) {
        self.timeSlots = timeSlots
        self.timeZoneId = timeZoneId
        self.additionalProperties = additionalProperties
    }


}




public class DialerCallabletimesetConfigChangeCallableTimeSet: Codable {















    /** The list of callable times */
    public var callableTimes: [DialerCallabletimesetConfigChangeCallableTime]?
    public var additionalProperties: [String:JSON]?
    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The UI-visible name of the object */
    public var name: String?
    /** Creation time of the entity */
    public var dateCreated: Date?
    /** Last modified time of the entity */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?

    public init(callableTimes: [DialerCallabletimesetConfigChangeCallableTime]?, additionalProperties: [String:JSON]?, _id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?) {
        self.callableTimes = callableTimes
        self.additionalProperties = additionalProperties
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case callableTimes
        case additionalProperties
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
    }


}




public class DialerCampaignConfigChangeCampaign: Codable {





    public enum DialingMode: String, Codable { 
        case agentless = "agentless"
        case external = "external"
        case preview = "preview"
        case power = "power"
        case predictive = "predictive"
        case progressive = "progressive"
    }







    public enum CampaignStatus: String, Codable { 
        case on = "on"
        case off = "off"
        case complete = "complete"
        case stopping = "stopping"
        case invalid = "invalid"
    }























































    public var contactList: DialerCampaignConfigChangeUriReference?
    /** A UriReference for a resource */
    public var queue: DialerCampaignConfigChangeUriReference?
    /** dialing mode of the campaign */
    public var dialingMode: DialingMode?
    /** A UriReference for a resource */
    public var script: DialerCampaignConfigChangeUriReference?
    /** A UriReference for a resource */
    public var edgeGroup: DialerCampaignConfigChangeUriReference?
    /** A UriReference for a resource */
    public var site: DialerCampaignConfigChangeUriReference?
    public var campaignStatus: CampaignStatus?
    /** the contact list phone columns to be called for the campaign */
    public var phoneColumns: [DialerCampaignConfigChangePhoneColumn]?
    /** the targeted abandon rate percentage */
    public var abandonRate: Double?
    /** identifiers of the do not call lists */
    public var dncLists: [DialerCampaignConfigChangeUriReference]?
    /** A UriReference for a resource */
    public var callableTimeSet: DialerCampaignConfigChangeUriReference?
    /** A UriReference for a resource */
    public var callAnalysisResponseSet: DialerCampaignConfigChangeUriReference?
    /** caller id name to be displayed on the outbound call */
    public var callerName: String?
    /** caller id phone number to be displayed on the outbound call */
    public var callerAddress: String?
    /** for agentless campaigns, the number of outbound lines to be concurrently dialed */
    public var outboundLineCount: Int?
    /** a list of current error conditions associated with the campaign */
    public var errors: [DialerCampaignConfigChangeRestErrorDetail]?
    /** identifiers of the rule sets */
    public var ruleSets: [DialerCampaignConfigChangeUriReference]?
    /** for preview campaigns, indicator of whether the agent can skip a preview without placing a call */
    public var skipPreviewDisabled: Bool?
    /** for preview campaigns, number of seconds before a call will be automatically placed. A value of 0 indicates no automatic placement of calls */
    public var previewTimeOutSeconds: Int?
    /** for preview campaigns with multiple phone columns, indicator if one (true) or multiple (false) phone numbers will be available to call for each preview */
    public var singleNumberPreview: Bool?
    public var contactSort: DialerCampaignConfigChangeContactSort?
    /** List of contact sort objects. */
    public var contactSorts: [DialerCampaignConfigChangeContactSort]?
    /** for non-preview campaigns, how long to wait before dispositioning as 'no-answer', default 30 seconds */
    public var noAnswerTimeout: Int?
    /** The language the edge will use to analyze the call */
    public var callAnalysisLanguage: String?
    /** The priority of this campaign relative to other campaigns */
    public var priority: Int?
    /** List of contact filters */
    public var contactListFilters: [DialerCampaignConfigChangeUriReference]?
    /** A UriReference for a resource */
    public var division: DialerCampaignConfigChangeUriReference?
    /** For Preview Campaigns. Name of the contact column in the contact list containing the userIds of agents to assign specific contact records to. */
    public var agentOwnedColumn: String?
    public var additionalProperties: [String:JSON]?
    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The UI-visible name of the object */
    public var name: String?
    /** Creation time of the entity */
    public var dateCreated: Date?
    /** Last modified time of the entity */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?

    public init(contactList: DialerCampaignConfigChangeUriReference?, queue: DialerCampaignConfigChangeUriReference?, dialingMode: DialingMode?, script: DialerCampaignConfigChangeUriReference?, edgeGroup: DialerCampaignConfigChangeUriReference?, site: DialerCampaignConfigChangeUriReference?, campaignStatus: CampaignStatus?, phoneColumns: [DialerCampaignConfigChangePhoneColumn]?, abandonRate: Double?, dncLists: [DialerCampaignConfigChangeUriReference]?, callableTimeSet: DialerCampaignConfigChangeUriReference?, callAnalysisResponseSet: DialerCampaignConfigChangeUriReference?, callerName: String?, callerAddress: String?, outboundLineCount: Int?, errors: [DialerCampaignConfigChangeRestErrorDetail]?, ruleSets: [DialerCampaignConfigChangeUriReference]?, skipPreviewDisabled: Bool?, previewTimeOutSeconds: Int?, singleNumberPreview: Bool?, contactSort: DialerCampaignConfigChangeContactSort?, contactSorts: [DialerCampaignConfigChangeContactSort]?, noAnswerTimeout: Int?, callAnalysisLanguage: String?, priority: Int?, contactListFilters: [DialerCampaignConfigChangeUriReference]?, division: DialerCampaignConfigChangeUriReference?, agentOwnedColumn: String?, additionalProperties: [String:JSON]?, _id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?) {
        self.contactList = contactList
        self.queue = queue
        self.dialingMode = dialingMode
        self.script = script
        self.edgeGroup = edgeGroup
        self.site = site
        self.campaignStatus = campaignStatus
        self.phoneColumns = phoneColumns
        self.abandonRate = abandonRate
        self.dncLists = dncLists
        self.callableTimeSet = callableTimeSet
        self.callAnalysisResponseSet = callAnalysisResponseSet
        self.callerName = callerName
        self.callerAddress = callerAddress
        self.outboundLineCount = outboundLineCount
        self.errors = errors
        self.ruleSets = ruleSets
        self.skipPreviewDisabled = skipPreviewDisabled
        self.previewTimeOutSeconds = previewTimeOutSeconds
        self.singleNumberPreview = singleNumberPreview
        self.contactSort = contactSort
        self.contactSorts = contactSorts
        self.noAnswerTimeout = noAnswerTimeout
        self.callAnalysisLanguage = callAnalysisLanguage
        self.priority = priority
        self.contactListFilters = contactListFilters
        self.division = division
        self.agentOwnedColumn = agentOwnedColumn
        self.additionalProperties = additionalProperties
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case contactList
        case queue
        case dialingMode
        case script
        case edgeGroup
        case site
        case campaignStatus
        case phoneColumns
        case abandonRate
        case dncLists
        case callableTimeSet
        case callAnalysisResponseSet
        case callerName
        case callerAddress
        case outboundLineCount
        case errors
        case ruleSets
        case skipPreviewDisabled
        case previewTimeOutSeconds
        case singleNumberPreview
        case contactSort
        case contactSorts
        case noAnswerTimeout
        case callAnalysisLanguage
        case priority
        case contactListFilters
        case division
        case agentOwnedColumn
        case additionalProperties
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
    }


}



/** information determining the order in which the contacts will be dialed */

public class DialerCampaignConfigChangeContactSort: Codable {



    public enum Direction: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
    }





    public var fieldName: String?
    public var direction: Direction?
    /** Whether that column contains numeric data */
    public var numeric: Bool?
    public var additionalProperties: [String:JSON]?

    public init(fieldName: String?, direction: Direction?, numeric: Bool?, additionalProperties: [String:JSON]?) {
        self.fieldName = fieldName
        self.direction = direction
        self.numeric = numeric
        self.additionalProperties = additionalProperties
    }


}



/** A UriReference for a resource */

public class DialerCampaignConfigChangeUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class DialerCampaignProgressEventCampaignProgress: Codable {















    public var campaign: DialerCampaignProgressEventUriReference?
    /** The number of contacts that have been called so far */
    public var numberOfContactsCalled: Double?
    /** The number of contacts that have been messaged so far */
    public var numberOfContactsMessaged: Double?
    /** The total number of contacts in the contact list */
    public var totalNumberOfContacts: Double?
    /** numberOfContactsContacted/totalNumberOfContacts*100 */
    public var percentage: Int?
    /** A map of skipped reasons and the number of contacts associated with each. */
    public var numberOfContactsSkipped: [String:Int]?
    public var additionalProperties: [String:JSON]?

    public init(campaign: DialerCampaignProgressEventUriReference?, numberOfContactsCalled: Double?, numberOfContactsMessaged: Double?, totalNumberOfContacts: Double?, percentage: Int?, numberOfContactsSkipped: [String:Int]?, additionalProperties: [String:JSON]?) {
        self.campaign = campaign
        self.numberOfContactsCalled = numberOfContactsCalled
        self.numberOfContactsMessaged = numberOfContactsMessaged
        self.totalNumberOfContacts = totalNumberOfContacts
        self.percentage = percentage
        self.numberOfContactsSkipped = numberOfContactsSkipped
        self.additionalProperties = additionalProperties
    }


}




public class DialerContactlistConfigChangeEmailColumn: Codable {







    /** The name of the email address column */
    public var columnName: String?
    /** The type of the email address column, for example, 'work' or 'home' */
    public var type: String?
    public var additionalProperties: [String:JSON]?

    public init(columnName: String?, type: String?, additionalProperties: [String:JSON]?) {
        self.columnName = columnName
        self.type = type
        self.additionalProperties = additionalProperties
    }


}



/** A UriReference for a resource */

public class DialerContactlistConfigChangeUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class DialerContactlistfilterConfigChangeFilterClause: Codable {

    public enum FilterType: String, Codable { 
        case and = "AND"
        case or = "OR"
    }





    /** Contact list filter type */
    public var filterType: FilterType?
    /** The list of predicates in that clause */
    public var predicates: [DialerContactlistfilterConfigChangeFilterPredicate]?
    public var additionalProperties: [String:JSON]?

    public init(filterType: FilterType?, predicates: [DialerContactlistfilterConfigChangeFilterPredicate]?, additionalProperties: [String:JSON]?) {
        self.filterType = filterType
        self.predicates = predicates
        self.additionalProperties = additionalProperties
    }


}




public class DialerDnclistConfigChangeDncList: Codable {





    public enum DncSourceType: String, Codable { 
        case rds = "rds"
        case dncCom = "dnc.com"
        case gryphon = "gryphon"
    }







    public enum ContactMethod: String, Codable { 
        case email = "EMAIL"
        case phone = "PHONE"
    }















    public var importStatus: DialerDnclistConfigChangeImportStatus?
    /** the number of phone numbers in the do not call list */
    public var size: Int?
    /** the type of dnc list being created, rds (csv file), gryphon, or dnc.com */
    public var dncSourceType: DncSourceType?
    /** the loginId if the dncSourceType is dnc.com */
    public var loginId: String?
    /** the list of dnc.com codes to be treated as DNC */
    public var dncCodes: [String]?
    /** the license number if the dncSourceType is gryphon */
    public var licenseId: String?
    public var contactMethod: ContactMethod?
    public var division: DialerDnclistConfigChangeUriReference?
    public var additionalProperties: [String:JSON]?
    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The UI-visible name of the object */
    public var name: String?
    /** Creation time of the entity */
    public var dateCreated: Date?
    /** Last modified time of the entity */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?

    public init(importStatus: DialerDnclistConfigChangeImportStatus?, size: Int?, dncSourceType: DncSourceType?, loginId: String?, dncCodes: [String]?, licenseId: String?, contactMethod: ContactMethod?, division: DialerDnclistConfigChangeUriReference?, additionalProperties: [String:JSON]?, _id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?) {
        self.importStatus = importStatus
        self.size = size
        self.dncSourceType = dncSourceType
        self.loginId = loginId
        self.dncCodes = dncCodes
        self.licenseId = licenseId
        self.contactMethod = contactMethod
        self.division = division
        self.additionalProperties = additionalProperties
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case importStatus
        case size
        case dncSourceType
        case loginId
        case dncCodes
        case licenseId
        case contactMethod
        case division
        case additionalProperties
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
    }


}




public class DialerDnclistConfigChangeImportStatus: Codable {

    public enum ImportState: String, Codable { 
        case inProgress = "IN_PROGRESS"
        case failed = "FAILED"
    }















    /** current status of the import */
    public var importState: ImportState?
    /** total number of records to be imported */
    public var totalRecords: Int?
    /** number of records finished importing */
    public var completedRecords: Int?
    /** percentage of records finished importing */
    public var percentageComplete: Int?
    /** if the import has failed, the reason for the failure */
    public var failureReason: String?
    /** The ids for target contact lists */
    public var targetContactListIds: [String]?
    /** The prefix used for target contact list names */
    public var listNamePrefix: String?
    public var additionalProperties: [String:JSON]?

    public init(importState: ImportState?, totalRecords: Int?, completedRecords: Int?, percentageComplete: Int?, failureReason: String?, targetContactListIds: [String]?, listNamePrefix: String?, additionalProperties: [String:JSON]?) {
        self.importState = importState
        self.totalRecords = totalRecords
        self.completedRecords = completedRecords
        self.percentageComplete = percentageComplete
        self.failureReason = failureReason
        self.targetContactListIds = targetContactListIds
        self.listNamePrefix = listNamePrefix
        self.additionalProperties = additionalProperties
    }


}




public class DialerResponsesetConfigChangeReaction: Codable {





    public enum ReactionType: String, Codable { 
        case hangup = "hangup"
        case transfer = "transfer"
        case transferFlow = "transfer_flow"
        case playFile = "play_file"
    }



    public var data: String?
    public var name: String?
    public var reactionType: ReactionType?
    public var additionalProperties: [String:JSON]?

    public init(data: String?, name: String?, reactionType: ReactionType?, additionalProperties: [String:JSON]?) {
        self.data = data
        self.name = name
        self.reactionType = reactionType
        self.additionalProperties = additionalProperties
    }


}




public class DialerRulesetConfigChangeCondition: Codable {













    public enum ValueType: String, Codable { 
        case string = "STRING"
        case numeric = "NUMERIC"
        case datetime = "DATETIME"
        case period = "PERIOD"
    }

    public enum Operator: String, Codable { 
        case equals = "EQUALS"
        case lessThan = "LESS_THAN"
        case lessThanEquals = "LESS_THAN_EQUALS"
        case greaterThan = "GREATER_THAN"
        case greaterThanEquals = "GREATER_THAN_EQUALS"
        case contains = "CONTAINS"
        case beginsWith = "BEGINS_WITH"
        case endsWith = "ENDS_WITH"
        case before = "BEFORE"
        case after = "AFTER"
    }



    public enum PropertyType: String, Codable { 
        case lastAttemptByColumn = "LAST_ATTEMPT_BY_COLUMN"
        case lastAttemptOverall = "LAST_ATTEMPT_OVERALL"
        case lastResultByColumn = "LAST_RESULT_BY_COLUMN"
        case lastResultOverall = "LAST_RESULT_OVERALL"
    }















    /** A UriReference for a resource */
    public var dataAction: DialerRulesetConfigChangeUriReference?
    public var additionalProperties: [String:JSON]?
    /** The type of the condition */
    public var type: String?
    /** Indicates whether to evaluate for the opposite of the stated condition; default is false */
    public var inverted: Bool?
    /** An attribute name associated with the condition (applies only to certain rule conditions) */
    public var attributeName: String?
    /** A value associated with the condition */
    public var value: String?
    /** Determines the type of the value associated with the condition */
    public var valueType: ValueType?
    /** An operation type for condition evaluation */
    public var _operator: Operator?
    /** List of wrap-up code identifiers (used only in conditions of type 'wrapupCondition') */
    public var codes: [String]?
    /** Determines the type of the property associated with the condition */
    public var propertyType: PropertyType?
    /** A value associated with the property type of this condition */
    public var property: String?
    /** The result of this condition if the data action returns a result indicating there was no data. Required for a DataActionCondition. */
    public var dataNotFoundResolution: Bool?
    /** The input field from the data action that the contactId will be passed to for this condition. Valid for a dataActionCondition. */
    public var contactIdField: String?
    /** The input field from the data action that the callAnalysisResult will be passed to for this condition. Valid for a wrapup dataActionCondition. */
    public var callAnalysisResultField: String?
    /** The input field from the data action that the agentWrapup will be passed to for this condition. Valid for a wrapup dataActionCondition. */
    public var agentWrapupField: String?
    /** A list of mappings defining which contact data fields will be passed to which data action input fields for this condition. Valid for a dataActionCondition. */
    public var contactColumnToDataActionFieldMappings: [DialerRulesetConfigChangeContactColumnToDataActionFieldMapping]?
    /** A list of predicates defining the comparisons to use for this condition. Required for a dataActionCondition. */
    public var predicates: [DialerRulesetConfigChangeDataActionConditionPredicate]?

    public init(dataAction: DialerRulesetConfigChangeUriReference?, additionalProperties: [String:JSON]?, type: String?, inverted: Bool?, attributeName: String?, value: String?, valueType: ValueType?, _operator: Operator?, codes: [String]?, propertyType: PropertyType?, property: String?, dataNotFoundResolution: Bool?, contactIdField: String?, callAnalysisResultField: String?, agentWrapupField: String?, contactColumnToDataActionFieldMappings: [DialerRulesetConfigChangeContactColumnToDataActionFieldMapping]?, predicates: [DialerRulesetConfigChangeDataActionConditionPredicate]?) {
        self.dataAction = dataAction
        self.additionalProperties = additionalProperties
        self.type = type
        self.inverted = inverted
        self.attributeName = attributeName
        self.value = value
        self.valueType = valueType
        self._operator = _operator
        self.codes = codes
        self.propertyType = propertyType
        self.property = property
        self.dataNotFoundResolution = dataNotFoundResolution
        self.contactIdField = contactIdField
        self.callAnalysisResultField = callAnalysisResultField
        self.agentWrapupField = agentWrapupField
        self.contactColumnToDataActionFieldMappings = contactColumnToDataActionFieldMappings
        self.predicates = predicates
    }

    public enum CodingKeys: String, CodingKey { 
        case dataAction
        case additionalProperties
        case type
        case inverted
        case attributeName
        case value
        case valueType
        case _operator = "operator"
        case codes
        case propertyType
        case property
        case dataNotFoundResolution
        case contactIdField
        case callAnalysisResultField
        case agentWrapupField
        case contactColumnToDataActionFieldMappings
        case predicates
    }


}



/** A UriReference for a resource */

public class DialerRulesetConfigChangeUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class DialerSequenceConfigChangeCampaignSequence: Codable {





    public enum Status: String, Codable { 
        case on = "on"
        case off = "off"
        case complete = "complete"
    }

















    /** the ordered list of campaign identifiers */
    public var campaigns: [DialerSequenceConfigChangeUriReference]?
    /** the zero-based index of the current campaign in the campaigns list */
    public var currentCampaign: Int?
    public var status: Status?
    /** if a sequence has unexpectedly stopped, this message provides the reason */
    public var stopMessage: String?
    /** indicates if a sequence is to repeat from the beginning after the last campaign completes; default is false */
    public var _repeat: Bool?
    public var additionalProperties: [String:JSON]?
    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The UI-visible name of the object */
    public var name: String?
    /** Creation time of the entity */
    public var dateCreated: Date?
    /** Last modified time of the entity */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?

    public init(campaigns: [DialerSequenceConfigChangeUriReference]?, currentCampaign: Int?, status: Status?, stopMessage: String?, _repeat: Bool?, additionalProperties: [String:JSON]?, _id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?) {
        self.campaigns = campaigns
        self.currentCampaign = currentCampaign
        self.status = status
        self.stopMessage = stopMessage
        self._repeat = _repeat
        self.additionalProperties = additionalProperties
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case campaigns
        case currentCampaign
        case status
        case stopMessage
        case _repeat = "repeat"
        case additionalProperties
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
    }


}




public class DialerSequenceConfigChangeUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class DialerWrapupcodemappingConfigChangeWrapUpCodeMapping: Codable {











    public enum DefaultSet: String, Codable { 
        case contactUncallable = "CONTACT_UNCALLABLE"
        case numberUncallable = "NUMBER_UNCALLABLE"
        case rightPartyContact = "RIGHT_PARTY_CONTACT"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The UI-visible name of the object */
    public var name: String?
    /** Creation time of the entity */
    public var dateCreated: Date?
    /** Last modified time of the entity */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    public var defaultSet: [DefaultSet]?
    public var mapping: [String:[String]]?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, defaultSet: [DefaultSet]?, mapping: [String:[String]]?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.defaultSet = defaultSet
        self.mapping = mapping
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case defaultSet
        case mapping
    }


}




public class DialogflowIntent: Codable {





    /** The intent name */
    public var name: String?
    /** An object mapping parameter names to Parameter objects */
    public var parameters: [String:DialogflowParameter]?

    public init(name: String?, parameters: [String:DialogflowParameter]?) {
        self.name = name
        self.parameters = parameters
    }


}




public class DigitalAction: Codable {















    /** The settings for an 'update contact column' action. */
    public var updateContactColumnActionSettings: UpdateContactColumnActionSettings?
    /** The settings for a 'do not send' action. */
    public var doNotSendActionSettings: JSON?
    /** The settings for an 'Append to DNC' action. */
    public var appendToDncActionSettings: AppendToDncActionSettings?
    /** The settings for a 'mark contact uncontactable' action. */
    public var markContactUncontactableActionSettings: MarkContactUncontactableActionSettings?
    /** The settings for an 'mark contact address uncontactable' action. */
    public var markContactAddressUncontactableActionSettings: JSON?
    /** The settings for a 'Set content template' action. */
    public var setContentTemplateActionSettings: SetContentTemplateActionSettings?
    /** The settings for a 'set sms phone number' action. */
    public var setSmsPhoneNumberActionSettings: SetSmsPhoneNumberActionSettings?

    public init(updateContactColumnActionSettings: UpdateContactColumnActionSettings?, doNotSendActionSettings: JSON?, appendToDncActionSettings: AppendToDncActionSettings?, markContactUncontactableActionSettings: MarkContactUncontactableActionSettings?, markContactAddressUncontactableActionSettings: JSON?, setContentTemplateActionSettings: SetContentTemplateActionSettings?, setSmsPhoneNumberActionSettings: SetSmsPhoneNumberActionSettings?) {
        self.updateContactColumnActionSettings = updateContactColumnActionSettings
        self.doNotSendActionSettings = doNotSendActionSettings
        self.appendToDncActionSettings = appendToDncActionSettings
        self.markContactUncontactableActionSettings = markContactUncontactableActionSettings
        self.markContactAddressUncontactableActionSettings = markContactAddressUncontactableActionSettings
        self.setContentTemplateActionSettings = setContentTemplateActionSettings
        self.setSmsPhoneNumberActionSettings = setSmsPhoneNumberActionSettings
    }


}




public class DisallowedEntityLearningAssignmentItem: Codable {





    /** The error code associated with this disallowed entity */
    public var errorCode: String?
    /** The entity that was disallowed */
    public var entity: LearningAssignmentItem?

    public init(errorCode: String?, entity: LearningAssignmentItem?) {
        self.errorCode = errorCode
        self.entity = entity
    }


}




public class Disposition: Codable {







    /** Name of the disposition. Either a platform predefined value, or the name of the disposition in the disposition table.. */
    public var name: String?
    /** The final media analyzer result that triggered the disposition result, if any. */
    public var analyzer: String?
    /** Contains various parameters related to call analysis. */
    public var dispositionParameters: DispositionParameters?

    public init(name: String?, analyzer: String?, dispositionParameters: DispositionParameters?) {
        self.name = name
        self.analyzer = analyzer
        self.dispositionParameters = dispositionParameters
    }


}




public class DivisionReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class DocumentContentBlock: Codable {

    public enum ModelType: String, Codable { 
        case text = "Text"
        case image = "Image"
        case video = "Video"
    }







    /** The type of the paragraph block. */
    public var type: ModelType?
    /** Text. It must contain a value if the type of the block is Text. */
    public var text: DocumentText?
    /** Image. It must contain a value if the type of the block is Image. */
    public var image: DocumentBodyImage?
    /** Video. It must contain a value if the type of the block is Video. */
    public var video: DocumentBodyVideo?

    public init(type: ModelType?, text: DocumentText?, image: DocumentBodyImage?, video: DocumentBodyVideo?) {
        self.type = type
        self.text = text
        self.image = image
        self.video = video
    }


}




public class DocumentEntityListing: Codable {





















    public var entities: [Document]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Document]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DocumentQueryPredicate: Codable {

    public enum Fields: String, Codable { 
        case alternatives = "alternatives"
        case categoryid = "categoryId"
        case categoryname = "categoryName"
        case contextid = "contextId"
        case contextname = "contextName"
        case contextvalueid = "contextValueId"
        case contextvaluename = "contextValueName"
        case documentid = "documentId"
        case labelid = "labelId"
        case labelname = "labelName"
        case title = "title"
        case visible = "visible"
        case state = "state"
    }



    public enum ModelType: String, Codable { 
        case equals = "Equals"
        case notEquals = "NotEquals"
        case contains = "Contains"
        case matchAll = "MatchAll"
        case matchAny = "MatchAny"
    }

    /** Specifies the document fields to be matched against. */
    public var fields: [Fields]?
    /** Specifies the values of the fields to be matched against. */
    public var values: [String]?
    /** Specifies the matching criteria between the fields and values. */
    public var type: ModelType?

    public init(fields: [Fields]?, values: [String]?, type: ModelType?) {
        self.fields = fields
        self.values = values
        self.type = type
    }


}




public class DocumentThumbnail: Codable {









    public var resolution: String?
    public var imageUri: String?
    public var height: Int?
    public var width: Int?

    public init(resolution: String?, imageUri: String?, height: Int?, width: Int?) {
        self.resolution = resolution
        self.imageUri = imageUri
        self.height = height
        self.width = width
    }


}




public class DocumentVariationContext: Codable {





    /** The knowledge context associated with the variation. */
    public var context: KnowledgeContextReference?
    /** The list of knowledge context values associated with the variation. */
    public var values: [KnowledgeContextValueReference]?

    public init(context: KnowledgeContextReference?, values: [KnowledgeContextValueReference]?) {
        self.context = context
        self.values = values
    }


}




public class DocumentationSearchRequest: Codable {

    public enum SortOrder: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
        case score = "SCORE"
    }











    /** The sort order for results */
    public var sortOrder: SortOrder?
    /** The field in the resource that you want to sort the results by */
    public var sortBy: String?
    /** The number of results per page */
    public var pageSize: Int?
    /** The page of resources you want to retrieve */
    public var pageNumber: Int?
    /** Multi-value sort order, list of multiple sort values */
    public var sort: [SearchSort]?
    public var query: [DocumentationSearchCriteria]?

    public init(sortOrder: SortOrder?, sortBy: String?, pageSize: Int?, pageNumber: Int?, sort: [SearchSort]?, query: [DocumentationSearchCriteria]?) {
        self.sortOrder = sortOrder
        self.sortBy = sortBy
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.sort = sort
        self.query = query
    }


}




public class DomainEdgeSoftwareVersionDto: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var edgeVersion: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var publishDate: Date?
    public var edgeUri: String?
    public var latestRelease: Bool?
    public var current: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, edgeVersion: String?, publishDate: Date?, edgeUri: String?, latestRelease: Bool?, current: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.edgeVersion = edgeVersion
        self.publishDate = publishDate
        self.edgeUri = edgeUri
        self.latestRelease = latestRelease
        self.current = current
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case edgeVersion
        case publishDate
        case edgeUri
        case latestRelease
        case current
        case selfUri
    }


}




public class DomainNetworkRoute: Codable {









    public enum Family: Int, Codable { 
        case _2 = 2
        case _23 = 23
    }

    /** The IPv4 or IPv6 route prefix in CIDR notation. */
    public var _prefix: String?
    /** The IPv4 or IPv6 nexthop IP address. */
    public var nexthop: String?
    /** True if this route will persist on Edge restart.  Routes assigned by DHCP will be returned as false. */
    public var persistent: Bool?
    /** The metric being used for route. Lower values will have a higher priority. */
    public var metric: Int?
    /** The address family for this route. */
    public var family: Family?

    public init(_prefix: String?, nexthop: String?, persistent: Bool?, metric: Int?, family: Family?) {
        self._prefix = _prefix
        self.nexthop = nexthop
        self.persistent = persistent
        self.metric = metric
        self.family = family
    }

    public enum CodingKeys: String, CodingKey { 
        case _prefix = "prefix"
        case nexthop
        case persistent
        case metric
        case family
    }


}




public class DraftIntents: Codable {









    /** Id for an intent. */
    public var _id: String?
    /** Name/Label for an intent. */
    public var name: String?
    /** The utterances that are extracted for an Intent. */
    public var utterances: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, utterances: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.utterances = utterances
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case utterances
        case selfUri
    }


}




public class DraftTopicRequest: Codable {









    /** Id for a topic. */
    public var _id: String?
    /** Name/Label for a topic. */
    public var name: String?
    /** The phrases that are extracted for a topic. */
    public var phrases: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, phrases: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.phrases = phrases
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case phrases
        case selfUri
    }


}




public class DraftTopics: Codable {



















    /** Id for a topic. */
    public var _id: String?
    /** Topic name. */
    public var name: String?
    /** The miner to which the topic belongs. */
    public var miner: Miner?
    /** Number of conversations where a topic has occurred. */
    public var conversationCount: Int?
    /** Percentage of conversations where a topic has occurred. */
    public var conversationPercent: Float?
    /** Number of unique utterances where a topic has occurred. */
    public var utteranceCount: Int?
    /** Number of unique phrases (sub-utterances) where a topic has occurred. */
    public var phraseCount: Int?
    /** The phrases that are extracted for a topic. */
    public var phrases: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, miner: Miner?, conversationCount: Int?, conversationPercent: Float?, utteranceCount: Int?, phraseCount: Int?, phrases: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.miner = miner
        self.conversationCount = conversationCount
        self.conversationPercent = conversationPercent
        self.utteranceCount = utteranceCount
        self.phraseCount = phraseCount
        self.phrases = phrases
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case miner
        case conversationCount
        case conversationPercent
        case utteranceCount
        case phraseCount
        case phrases
        case selfUri
    }


}




public class DurationCondition: Codable {

    public enum DurationTarget: String, Codable { 
        case duration = "DURATION"
        case durationRange = "DURATION_RANGE"
    }





    public enum DurationMode: String, Codable { 
        case between = "Between"
        case over = "Over"
        case under = "Under"
    }

    public var durationTarget: DurationTarget?
    public var durationOperator: String?
    public var durationRange: String?
    public var durationMode: DurationMode?

    public init(durationTarget: DurationTarget?, durationOperator: String?, durationRange: String?, durationMode: DurationMode?) {
        self.durationTarget = durationTarget
        self.durationOperator = durationOperator
        self.durationRange = durationRange
        self.durationMode = durationMode
    }


}




public class Edge: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }



































    public enum StatusCode: String, Codable { 
        case new = "NEW"
        case awaitingConnection = "AWAITING_CONNECTION"
        case awaitingFingerprint = "AWAITING_FINGERPRINT"
        case awaitingFingerprintVerification = "AWAITING_FINGERPRINT_VERIFICATION"
        case fingerprintVerified = "FINGERPRINT_VERIFIED"
        case awaitingBootstrap = "AWAITING_BOOTSTRAP"
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        case rma = "RMA"
        case unpairing = "UNPAIRING"
        case unpaired = "UNPAIRED"
        case initializing = "INITIALIZING"
    }







    public enum OnlineStatus: String, Codable { 
        case online = "ONLINE"
        case offline = "OFFLINE"
    }







    public enum EdgeDeploymentType: String, Codable { 
        case hardware = "HARDWARE"
        case ldm = "LDM"
        case cdm = "CDM"
        case chs = "CHS"
        case invalid = "INVALID"
    }

    public enum CertType: String, Codable { 
        case pureCloud = "PureCloud"
        case _public = "Public"
        case china = "China"
        case notRequested = "NotRequested"
    }

    public enum CallDrainingState: String, Codable { 
        case _none = "NONE"
        case wait = "WAIT"
        case waitTimeout = "WAIT_TIMEOUT"
        case terminate = "TERMINATE"
        case complete = "COMPLETE"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** The list of interfaces for the edge. (Deprecated) Replaced by configuring trunks/ip info on the logical interface instead */
    public var interfaces: [EdgeInterface]?
    public var make: String?
    public var model: String?
    public var apiVersion: String?
    public var softwareVersion: String?
    public var softwareVersionTimestamp: String?
    public var softwareVersionPlatform: String?
    public var softwareVersionConfiguration: String?
    public var fullSoftwareVersion: String?
    /** The pairing Id for a hardware Edge in the format: 00000-00000-00000-00000-00000. This field is only required when creating an Edge with a deployment type of HARDWARE. */
    public var pairingId: String?
    public var fingerprint: String?
    public var fingerprintHint: String?
    public var currentVersion: String?
    public var stagedVersion: String?
    public var patch: String?
    /** The current status of the Edge. */
    public var statusCode: StatusCode?
    public var edgeGroup: EdgeGroup?
    /** The Site to which the Edge is assigned. */
    public var site: Site?
    /** Details about an in-progress or recently in-progress Edge software upgrade. This node appears only if a software upgrade was recently initiated for this Edge. */
    public var softwareStatus: DomainEdgeSoftwareUpdateDto?
    public var onlineStatus: OnlineStatus?
    public var serialNumber: String?
    public var physicalEdge: Bool?
    public var managed: Bool?
    public var edgeDeploymentType: EdgeDeploymentType?
    /** The type of certificate used to communicate with edge-proxy. */
    public var certType: CertType?
    /** The current state of the Edge's call draining process before it can be safely rebooted or updated. */
    public var callDrainingState: CallDrainingState?
    /** The remaining number of conversations the Edge has to drain before it can be safely rebooted or updated. When an Edge is not draining conversations, this will be NULL or 0. */
    public var conversationCount: Int?
    /** Edge HTTP proxy configuration for the WAN port. The field can be a hostname, FQDN, IPv4 or IPv6 address. If port is not included, port 80 is assumed. */
    public var proxy: String?
    /** True if the offline edge configuration endpoint has been called for this edge. */
    public var offlineConfigCalled: Bool?
    /** The name provided by the operating system of the Edge. */
    public var osName: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, interfaces: [EdgeInterface]?, make: String?, model: String?, apiVersion: String?, softwareVersion: String?, softwareVersionTimestamp: String?, softwareVersionPlatform: String?, softwareVersionConfiguration: String?, fullSoftwareVersion: String?, pairingId: String?, fingerprint: String?, fingerprintHint: String?, currentVersion: String?, stagedVersion: String?, patch: String?, statusCode: StatusCode?, edgeGroup: EdgeGroup?, site: Site?, softwareStatus: DomainEdgeSoftwareUpdateDto?, onlineStatus: OnlineStatus?, serialNumber: String?, physicalEdge: Bool?, managed: Bool?, edgeDeploymentType: EdgeDeploymentType?, certType: CertType?, callDrainingState: CallDrainingState?, conversationCount: Int?, proxy: String?, offlineConfigCalled: Bool?, osName: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.interfaces = interfaces
        self.make = make
        self.model = model
        self.apiVersion = apiVersion
        self.softwareVersion = softwareVersion
        self.softwareVersionTimestamp = softwareVersionTimestamp
        self.softwareVersionPlatform = softwareVersionPlatform
        self.softwareVersionConfiguration = softwareVersionConfiguration
        self.fullSoftwareVersion = fullSoftwareVersion
        self.pairingId = pairingId
        self.fingerprint = fingerprint
        self.fingerprintHint = fingerprintHint
        self.currentVersion = currentVersion
        self.stagedVersion = stagedVersion
        self.patch = patch
        self.statusCode = statusCode
        self.edgeGroup = edgeGroup
        self.site = site
        self.softwareStatus = softwareStatus
        self.onlineStatus = onlineStatus
        self.serialNumber = serialNumber
        self.physicalEdge = physicalEdge
        self.managed = managed
        self.edgeDeploymentType = edgeDeploymentType
        self.certType = certType
        self.callDrainingState = callDrainingState
        self.conversationCount = conversationCount
        self.proxy = proxy
        self.offlineConfigCalled = offlineConfigCalled
        self.osName = osName
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case interfaces
        case make
        case model
        case apiVersion
        case softwareVersion
        case softwareVersionTimestamp
        case softwareVersionPlatform
        case softwareVersionConfiguration
        case fullSoftwareVersion
        case pairingId
        case fingerprint
        case fingerprintHint
        case currentVersion
        case stagedVersion
        case patch
        case statusCode
        case edgeGroup
        case site
        case softwareStatus
        case onlineStatus
        case serialNumber
        case physicalEdge
        case managed
        case edgeDeploymentType
        case certType
        case callDrainingState
        case conversationCount
        case proxy
        case offlineConfigCalled
        case osName
        case selfUri
    }


}




public class EdgeGroup: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** Is this edge group being managed remotely. */
    public var managed: Bool?
    /** Is this edge group hybrid. */
    public var hybrid: Bool?
    /** A trunk base settings assignment of trunkType \"EDGE\" to use for edge-to-edge communication. */
    public var edgeTrunkBaseAssignment: TrunkBaseAssignment?
    /** Trunk base settings of trunkType \"PHONE\" to inherit to edge logical interface for phone communication. */
    public var phoneTrunkBases: [TrunkBase]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, managed: Bool?, hybrid: Bool?, edgeTrunkBaseAssignment: TrunkBaseAssignment?, phoneTrunkBases: [TrunkBase]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.managed = managed
        self.hybrid = hybrid
        self.edgeTrunkBaseAssignment = edgeTrunkBaseAssignment
        self.phoneTrunkBases = phoneTrunkBases
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case managed
        case hybrid
        case edgeTrunkBaseAssignment
        case phoneTrunkBases
        case selfUri
    }


}




public class EdgeLogsJobResponse: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }







    /** The created job id. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case selfUri
    }


}




public class EdgeMetricsMemory: Codable {







    /** Available memory in bytes. */
    public var availableBytes: Double?
    /** Type of memory. Virtual or physical. */
    public var type: String?
    /** Total memory in bytes. */
    public var totalBytes: Double?

    public init(availableBytes: Double?, type: String?, totalBytes: Double?) {
        self.availableBytes = availableBytes
        self.type = type
        self.totalBytes = totalBytes
    }


}




public class EdgeNetworkDiagnostic: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class EdgeNetworkDiagnosticRequest: Codable {



    /** IPv4/6 address or host to be probed for connectivity. No port allowed. */
    public var host: String?

    public init(host: String?) {
        self.host = host
    }


}




public class EdgeVersionInformation: Codable {



    public var softwareVersion: String?

    public init(softwareVersion: String?) {
        self.softwareVersion = softwareVersion
    }


}




public class Email: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case disconnected = "disconnected"
        case _none = "none"
        case transmitting = "transmitting"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case disconnected = "disconnected"
        case _none = "none"
        case transmitting = "transmitting"
    }











    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }





    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }































    /** The connection state of this communication. */
    public var state: State?
    /** The initial connection state of this communication. */
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** The subject for the initial email that started this conversation. */
    public var subject: String?
    /** The number of email messages sent by this participant. */
    public var messagesSent: Int?
    /** The time line of the participant's email, divided into activity segments. */
    public var segments: [Segment]?
    /** The direction of the email */
    public var direction: Direction?
    /** A globally unique identifier for the recording associated with this call. */
    public var recordingId: String?
    public var errorInfo: ErrorBody?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the email was placed on hold in the cloud clock if the email is currently on hold. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startHoldTime: Date?
    /** The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAlertingTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var disconnectedTime: Date?
    /** Indicates that the email was auto-generated like an Out of Office reply. */
    public var autoGenerated: Bool?
    /** The source provider for the email. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** A globally unique identifier for the stored content of this communication. */
    public var messageId: String?
    /** A list of uploaded attachments on the email draft. */
    public var draftAttachments: [Attachment]?
    /** Indicates if the inbound email was marked as spam. */
    public var spam: Bool?
    /** Call wrap up or disposition data. */
    public var wrapup: Wrapup?
    /** After-call work for the communication. */
    public var afterCallWork: AfterCallWork?
    /** Indicates if after-call work is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue settings for this media type. */
    public var queueMediaSettings: ConversationQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _id: String?, held: Bool?, subject: String?, messagesSent: Int?, segments: [Segment]?, direction: Direction?, recordingId: String?, errorInfo: ErrorBody?, disconnectType: DisconnectType?, startHoldTime: Date?, startAlertingTime: Date?, connectedTime: Date?, disconnectedTime: Date?, autoGenerated: Bool?, provider: String?, scriptId: String?, peerId: String?, messageId: String?, draftAttachments: [Attachment]?, spam: Bool?, wrapup: Wrapup?, afterCallWork: AfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: ConversationQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.held = held
        self.subject = subject
        self.messagesSent = messagesSent
        self.segments = segments
        self.direction = direction
        self.recordingId = recordingId
        self.errorInfo = errorInfo
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.startAlertingTime = startAlertingTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.autoGenerated = autoGenerated
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.messageId = messageId
        self.draftAttachments = draftAttachments
        self.spam = spam
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case held
        case subject
        case messagesSent
        case segments
        case direction
        case recordingId
        case errorInfo
        case disconnectType
        case startHoldTime
        case startAlertingTime
        case connectedTime
        case disconnectedTime
        case autoGenerated
        case provider
        case scriptId
        case peerId
        case messageId
        case draftAttachments
        case spam
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}




public class EmailAddress: Codable {





    public var email: String?
    public var name: String?

    public init(email: String?, name: String?) {
        self.email = email
        self.name = name
    }


}




public class EmailCampaignScheduleEntityListing: Codable {





















    public var entities: [EmailCampaignSchedule]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [EmailCampaignSchedule]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class EmailCommunicationAnsweredEvent: Codable {









    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication */
    public var communicationId: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
    }


}




public class EmailCommunicationEndedEvent: Codable {









    public enum DisconnectType: String, Codable { 
        case unknown = "Unknown"
        case _self = "Self"
        case peer = "Peer"
        case system = "System"
        case error = "Error"
        case spam = "Spam"
        case transfer = "Transfer"
        case transferACD = "TransferACD"
        case transferUser = "TransferUser"
    }

    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication. */
    public var communicationId: String?
    /** Indicates how this communication was ended. */
    public var disconnectType: DisconnectType?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, disconnectType: DisconnectType?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.disconnectType = disconnectType
    }


}




public class EmailConversation: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The list of participants involved in the conversation. */
    public var participants: [EmailMediaParticipant]?
    /** The list of other media channels involved in the conversation. */
    public var otherMediaUris: [String]?
    /** The list of the most recent 20 transfer commands applied to this conversation. */
    public var recentTransfers: [TransferResponse]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, participants: [EmailMediaParticipant]?, otherMediaUris: [String]?, recentTransfers: [TransferResponse]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
        self.recentTransfers = recentTransfers
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
        case recentTransfers
        case selfUri
    }


}




public class EmailEndTransferEvent: Codable {









    public enum FinalState: String, Codable { 
        case completed = "Completed"
        case canceled = "Canceled"
        case failed = "Failed"
    }



    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** The id (V4 UUID) used to identify the transfer already started by the external platform. */
    public var commandId: String?
    /** Indicates whether the transfer completed successfully, was cancelled, or failed for some reason. */
    public var finalState: FinalState?
    /** The id (V4 UUID) of the communication that was being transferred. */
    public var objectCommunicationId: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, commandId: String?, finalState: FinalState?, objectCommunicationId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.commandId = commandId
        self.finalState = finalState
        self.objectCommunicationId = objectCommunicationId
    }


}




public class EmailFlowEstablishedEvent: Codable {













    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication. */
    public var communicationId: String?
    /** Metadata about this communication. */
    public var initialConfiguration: EmailInitialConfiguration?
    /** Metadata about the source of this communication's interaction. */
    public var sourceConfiguration: SourceConfiguration?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, initialConfiguration: EmailInitialConfiguration?, sourceConfiguration: SourceConfiguration?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.initialConfiguration = initialConfiguration
        self.sourceConfiguration = sourceConfiguration
    }


}




public class EmailRoutingTransferEvent: Codable {







    public enum TransferType: String, Codable { 
        case attended = "Attended"
        case unattended = "Unattended"
    }















    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** Indicates the desired type of transfer. */
    public var transferType: TransferType?
    /** The id (V4 UUID) used by the external platform to refer to the transfer in subsequent *Transfer events. */
    public var commandId: String?
    /** Indicates the desired type of transfer. */
    public var initiatingCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred away from. In many cases this will be the same as the `initiatingCommunicationId`. */
    public var targetCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred. */
    public var objectCommunicationId: String?
    /** The id (V4 UUID) of the desired destination queue that the object communication should be transferred to. */
    public var destinationQueueId: String?
    /** The unique identifier (V4 UUID) for the language that should be used to determine the destination for the conversation. */
    public var languageId: String?
    /** The unique identifiers (V4 UUID) for the skills that should be used to determine the destination for the conversation. */
    public var skillIds: [String]?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, transferType: TransferType?, commandId: String?, initiatingCommunicationId: String?, targetCommunicationId: String?, objectCommunicationId: String?, destinationQueueId: String?, languageId: String?, skillIds: [String]?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.transferType = transferType
        self.commandId = commandId
        self.initiatingCommunicationId = initiatingCommunicationId
        self.targetCommunicationId = targetCommunicationId
        self.objectCommunicationId = objectCommunicationId
        self.destinationQueueId = destinationQueueId
        self.languageId = languageId
        self.skillIds = skillIds
    }


}




public class Endpoint: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }



















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Name */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    public var count: Int?
    public var properties: [String:JSON]?
    /** Schema */
    public var schema: DomainEntityRef?
    public var enabled: Bool?
    public var site: DomainEntityRef?
    public var dids: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, count: Int?, properties: [String:JSON]?, schema: DomainEntityRef?, enabled: Bool?, site: DomainEntityRef?, dids: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.count = count
        self.properties = properties
        self.schema = schema
        self.enabled = enabled
        self.site = site
        self.dids = dids
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case count
        case properties
        case schema
        case enabled
        case site
        case dids
        case selfUri
    }


}




public class EntityReference: Codable {



    /** The globally unique identifier for the object. */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class ErrorInfo: Codable {





    public var message: String?
    public var code: String?

    public init(message: String?, code: String?) {
        self.message = message
        self.code = code
    }


}




public class EstimateAvailableFullDayTimeOffResponse: Codable {









    /** Date in yyyy-MM-dd format for full day request. Should be interpreted in the business unit's configured time zone. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var date: Date?
    /** An estimation of time off request length in minutes */
    public var durationMinutes: Int?
    /** An estimation of payable part of time off request in minutes */
    public var payableMinutes: Int?
    /** Whether there is flexibility for a user to choose different hours than the system estimated */
    public var flexible: Bool?

    public init(date: Date?, durationMinutes: Int?, payableMinutes: Int?, flexible: Bool?) {
        self.date = date
        self.durationMinutes = durationMinutes
        self.payableMinutes = payableMinutes
        self.flexible = flexible
    }


}




public class EstimateJobAsyncResponse: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class EstimatedWaitTimePredictions: Codable {



    /** Returned upon a successful estimated wait time request. */
    public var results: [PredictionResults]?

    public init(results: [PredictionResults]?) {
        self.results = results
    }


}




public class Evaluation: Codable {















    public enum Status: String, Codable { 
        case pending = "PENDING"
        case inprogress = "INPROGRESS"
        case finished = "FINISHED"
        case inreview = "INREVIEW"
        case retracted = "RETRACTED"
    }



















    public enum MediaType: String, Codable { 
        case call = "CALL"
        case callback = "CALLBACK"
        case chat = "CHAT"
        case cobrowse = "COBROWSE"
        case email = "EMAIL"
        case message = "MESSAGE"
        case socialExpression = "SOCIAL_EXPRESSION"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
    }















    public enum ResourceType: String, Codable { 
        case email = "EMAIL"
    }















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var conversation: ConversationReference?
    /** Evaluation form used for evaluation. */
    public var evaluationForm: EvaluationForm?
    public var evaluator: User?
    public var agent: User?
    public var calibration: Calibration?
    public var status: Status?
    public var answers: EvaluationScoringSet?
    public var agentHasRead: Bool?
    public var assignee: User?
    /** Indicates whether an assignee is applicable for the evaluation. Set to false when assignee is not applicable. */
    public var assigneeApplicable: Bool?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var releaseDate: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var assignedDate: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var changedDate: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var revisionCreatedDate: Date?
    public var queue: Queue?
    /** List of different communication types used in conversation. */
    public var mediaType: [MediaType]?
    /** Is only true when evaluation is re-scored. */
    public var rescore: Bool?
    /** Date of conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var conversationDate: Date?
    /** End date of conversation if it had completed before evaluation creation. Null if created before the conversation ended. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var conversationEndDate: Date?
    /** Signifies if the evaluation is never to be released. This cannot be set true if release date is also set. */
    public var neverRelease: Bool?
    /** Set to false to unassign the evaluation. This cannot be set to false when assignee is also set. */
    public var assigned: Bool?
    /** Date when the assignee was last changed. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateAssigneeChanged: Date?
    /** Only used for email evaluations. Will be null for all other evaluations. */
    public var resourceId: String?
    /** The type of resource. Only used for email evaluations. Will be null for evaluations on all other resources. */
    public var resourceType: ResourceType?
    /** Is only true when the user making the request does not have sufficient permissions to see evaluation */
    public var redacted: Bool?
    /** Team of the evaluation agent */
    public var agentTeam: Team?
    public var isScoringIndex: Bool?
    /** List of user authorized actions on evaluation. Possible values: assign, edit, editScore, editAgentSignoff, delete, release, viewAudit */
    public var authorizedActions: [String]?
    /** Is true when evaluation assistance didn't execute successfully */
    public var hasAssistanceFailed: Bool?
    /** The source that created the evaluation. */
    public var evaluationSource: EvaluationSource?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, conversation: ConversationReference?, evaluationForm: EvaluationForm?, evaluator: User?, agent: User?, calibration: Calibration?, status: Status?, answers: EvaluationScoringSet?, agentHasRead: Bool?, assignee: User?, assigneeApplicable: Bool?, releaseDate: Date?, assignedDate: Date?, changedDate: Date?, revisionCreatedDate: Date?, queue: Queue?, mediaType: [MediaType]?, rescore: Bool?, conversationDate: Date?, conversationEndDate: Date?, neverRelease: Bool?, assigned: Bool?, dateAssigneeChanged: Date?, resourceId: String?, resourceType: ResourceType?, redacted: Bool?, agentTeam: Team?, isScoringIndex: Bool?, authorizedActions: [String]?, hasAssistanceFailed: Bool?, evaluationSource: EvaluationSource?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.conversation = conversation
        self.evaluationForm = evaluationForm
        self.evaluator = evaluator
        self.agent = agent
        self.calibration = calibration
        self.status = status
        self.answers = answers
        self.agentHasRead = agentHasRead
        self.assignee = assignee
        self.assigneeApplicable = assigneeApplicable
        self.releaseDate = releaseDate
        self.assignedDate = assignedDate
        self.changedDate = changedDate
        self.revisionCreatedDate = revisionCreatedDate
        self.queue = queue
        self.mediaType = mediaType
        self.rescore = rescore
        self.conversationDate = conversationDate
        self.conversationEndDate = conversationEndDate
        self.neverRelease = neverRelease
        self.assigned = assigned
        self.dateAssigneeChanged = dateAssigneeChanged
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.redacted = redacted
        self.agentTeam = agentTeam
        self.isScoringIndex = isScoringIndex
        self.authorizedActions = authorizedActions
        self.hasAssistanceFailed = hasAssistanceFailed
        self.evaluationSource = evaluationSource
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case conversation
        case evaluationForm
        case evaluator
        case agent
        case calibration
        case status
        case answers
        case agentHasRead
        case assignee
        case assigneeApplicable
        case releaseDate
        case assignedDate
        case changedDate
        case revisionCreatedDate
        case queue
        case mediaType
        case rescore
        case conversationDate
        case conversationEndDate
        case neverRelease
        case assigned
        case dateAssigneeChanged
        case resourceId
        case resourceType
        case redacted
        case agentTeam
        case isScoringIndex
        case authorizedActions
        case hasAssistanceFailed
        case evaluationSource
        case selfUri
    }


}




public class EvaluationAggregateQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case assigneeapplicable = "assigneeApplicable"
        case assigneeid = "assigneeId"
        case calibrationid = "calibrationId"
        case contextid = "contextId"
        case conversationid = "conversationId"
        case conversationstart = "conversationStart"
        case divisionid = "divisionId"
        case evaluationcontextid = "evaluationContextId"
        case evaluationcreateddate = "evaluationCreatedDate"
        case evaluationid = "evaluationId"
        case evaluationreleasedate = "evaluationReleaseDate"
        case evaluatorid = "evaluatorId"
        case formid = "formId"
        case queueid = "queueId"
        case released = "released"
        case rescored = "rescored"
        case teamid = "teamId"
        case userid = "userId"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension predicates */
    public var value: String?
    /** Right hand side for dimension predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case _operator = "operator"
        case value
        case range
    }


}




public class EvaluationAggregationQueryMe: Codable {





    public enum GroupBy: String, Codable { 
        case assigneeapplicable = "assigneeApplicable"
        case assigneeid = "assigneeId"
        case calibrationid = "calibrationId"
        case contextid = "contextId"
        case conversationid = "conversationId"
        case divisionid = "divisionId"
        case evaluationcontextid = "evaluationContextId"
        case evaluationid = "evaluationId"
        case evaluatorid = "evaluatorId"
        case formid = "formId"
        case queueid = "queueId"
        case released = "released"
        case rescored = "rescored"
        case teamid = "teamId"
        case userid = "userId"
    }

    public enum Metrics: String, Codable { 
        case nevaluations = "nEvaluations"
        case nevaluationsdeleted = "nEvaluationsDeleted"
        case nevaluationsrescored = "nEvaluationsRescored"
        case ototalcriticalscore = "oTotalCriticalScore"
        case ototalscore = "oTotalScore"
    }

    public enum AlternateTimeDimension: String, Codable { 
        case conversationstart = "conversationStart"
        case evaluationcreateddate = "evaluationCreatedDate"
        case evaluationreleasedate = "evaluationReleaseDate"
        case eventtime = "eventTime"
    }



    /** Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var timeZone: String?
    /** Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group. */
    public var groupBy: [GroupBy]?
    /** Behaves like a SQL SELECT clause. Only named metrics will be retrieved. */
    public var metrics: [Metrics]?
    /** Dimension to use as the alternative timestamp for data in the aggregate.  Choosing \"eventTime\" uses the actual time of the data event. */
    public var alternateTimeDimension: AlternateTimeDimension?
    /** Evaluation context Id */
    public var contextId: String?

    public init(interval: String?, timeZone: String?, groupBy: [GroupBy]?, metrics: [Metrics]?, alternateTimeDimension: AlternateTimeDimension?, contextId: String?) {
        self.interval = interval
        self.timeZone = timeZone
        self.groupBy = groupBy
        self.metrics = metrics
        self.alternateTimeDimension = alternateTimeDimension
        self.contextId = contextId
    }


}




public class EvaluationQualityV2TopicCalibration: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class EvaluationQualityV2TopicEvaluationScoringSet: Codable {





    public var totalScore: Int?
    public var totalCriticalScore: Int?

    public init(totalScore: Int?, totalCriticalScore: Int?) {
        self.totalScore = totalScore
        self.totalCriticalScore = totalCriticalScore
    }


}




public class EvaluationQualityV2TopicEvaluationSource: Codable {







    public var evaluationSourceType: String?
    public var evaluationSourceId: String?
    public var evaluationSourceName: String?

    public init(evaluationSourceType: String?, evaluationSourceId: String?, evaluationSourceName: String?) {
        self.evaluationSourceType = evaluationSourceType
        self.evaluationSourceId = evaluationSourceId
        self.evaluationSourceName = evaluationSourceName
    }


}




public class EvaluationScoringSet: Codable {



















    /** Score of all questions */
    public var totalScore: Float?
    /** Score of only the critical questions */
    public var totalCriticalScore: Float?
    /** Score of only the non-critical questions */
    public var totalNonCriticalScore: Float?
    public var questionGroupScores: [EvaluationQuestionGroupScore]?
    /** Indicates that at least one fatal question was answered without having the highest score available for the question */
    public var anyFailedKillQuestions: Bool?
    /** Overall comments from the evaluator */
    public var comments: String?
    /** Overall private comments from the evaluator */
    public var privateComments: String?
    /** Comments from the agent while reviewing evaluation results */
    public var agentComments: String?
    /** List of topics found within the conversation's transcripts */
    public var transcriptTopics: [TranscriptTopic]?

    public init(totalScore: Float?, totalCriticalScore: Float?, totalNonCriticalScore: Float?, questionGroupScores: [EvaluationQuestionGroupScore]?, anyFailedKillQuestions: Bool?, comments: String?, privateComments: String?, agentComments: String?, transcriptTopics: [TranscriptTopic]?) {
        self.totalScore = totalScore
        self.totalCriticalScore = totalCriticalScore
        self.totalNonCriticalScore = totalNonCriticalScore
        self.questionGroupScores = questionGroupScores
        self.anyFailedKillQuestions = anyFailedKillQuestions
        self.comments = comments
        self.privateComments = privateComments
        self.agentComments = agentComments
        self.transcriptTopics = transcriptTopics
    }


}




public class EvaluationSource: Codable {





    public enum ModelType: String, Codable { 
        case policy = "Policy"
        case user = "User"
        case unknown = "Unknown"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Type of the evaluation source. */
    public var type: ModelType?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, type: ModelType?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.type = type
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case type
        case selfUri
    }


}




public class EventMessage: Codable {

    public enum Code: String, Codable { 
        case activeCampaignsLimitExceeded = "ACTIVE_CAMPAIGNS_LIMIT_EXCEEDED"
        case allCampaignsBlacklisted = "ALL_CAMPAIGNS_BLACKLISTED"
        case approachingContactLimit = "APPROACHING_CONTACT_LIMIT"
        case approachingDncListPhoneNumberLimit = "APPROACHING_DNC_LIST_PHONE_NUMBER_LIMIT"
        case approachingDncOrganizationPhoneNumberLimit = "APPROACHING_DNC_ORGANIZATION_PHONE_NUMBER_LIMIT"
        case approachingEntityLimit = "APPROACHING_ENTITY_LIMIT"
        case automaticTimeZoneZipCodeInvalid = "AUTOMATIC_TIME_ZONE_ZIP_CODE_INVALID"
        case campaignBlacklisted = "CAMPAIGN_BLACKLISTED"
        case campaignContentTemplateSubstitutionMismatch = "CAMPAIGN_CONTENT_TEMPLATE_SUBSTITUTION_MISMATCH"
        case campaignEmailBodyCharacterLimitExceeded = "CAMPAIGN_EMAIL_BODY_CHARACTER_LIMIT_EXCEEDED"
        case campaignEmailSubjectCharacterLimitExceeded = "CAMPAIGN_EMAIL_SUBJECT_CHARACTER_LIMIT_EXCEEDED"
        case campaignInvalidated = "CAMPAIGN_INVALIDATED"
        case campaignForceStopped = "CAMPAIGN_FORCE_STOPPED"
        case campaignMessageCharacterLimitExceeded = "CAMPAIGN_MESSAGE_CHARACTER_LIMIT_EXCEEDED"
        case campaignStartError = "CAMPAIGN_START_ERROR"
        case campaignRuleStartError = "CAMPAIGN_RULE_START_ERROR"
        case campaignSetDialingModeError = "CAMPAIGN_SET_DIALING_MODE_ERROR"
        case campaignStopped = "CAMPAIGN_STOPPED"
        case campaignThrottled = "CAMPAIGN_THROTTLED"
        case campaignQueueMembersLimitExceeded = "CAMPAIGN_QUEUE_MEMBERS_LIMIT_EXCEEDED"
        case invalidCallableTimeZone = "INVALID_CALLABLE_TIME_ZONE"
        case callbackCreationInvalidNumber = "CALLBACK_CREATION_INVALID_NUMBER"
        case callRuleInvalidContactColumn = "CALL_RULE_INVALID_CONTACT_COLUMN"
        case callRuleMissingDataActionInput = "CALL_RULE_MISSING_DATA_ACTION_INPUT"
        case callRuleMismatchType = "CALL_RULE_MISMATCH_TYPE"
        case callRuleInvalidOperator = "CALL_RULE_INVALID_OPERATOR"
        case callRuleNoDncListsConfigured = "CALL_RULE_NO_DNC_LISTS_CONFIGURED"
        case callRuleUpdatedPhoneColumn = "CALL_RULE_UPDATED_PHONE_COLUMN"
        case contactListFilterEvaluationFailed = "CONTACT_LIST_FILTER_EVALUATION_FAILED"
        case contactListFilterInternalError = "CONTACT_LIST_FILTER_INTERNAL_ERROR"
        case contactColumnsLimitExceeded = "CONTACT_COLUMNS_LIMIT_EXCEEDED"
        case contactColumnLengthLimitExceeded = "CONTACT_COLUMN_LENGTH_LIMIT_EXCEEDED"
        case contactIdLengthLimitExceeded = "CONTACT_ID_LENGTH_LIMIT_EXCEEDED"
        case contactDatumLengthLimitExceeded = "CONTACT_DATUM_LENGTH_LIMIT_EXCEEDED"
        case contactZipCodeColumnValueInvalid = "CONTACT_ZIP_CODE_COLUMN_VALUE_INVALID"
        case dataActionExecutionFailed = "DATA_ACTION_EXECUTION_FAILED"
        case dataActionAuthenticationFailure = "DATA_ACTION_AUTHENTICATION_FAILURE"
        case dataActionNotFound = "DATA_ACTION_NOT_FOUND"
        case dataActionTooManyRequests = "DATA_ACTION_TOO_MANY_REQUESTS"
        case dataActionTooManyRequestsRemote = "DATA_ACTION_TOO_MANY_REQUESTS_REMOTE"
        case digitalRuleEvaluationFailed = "DIGITAL_RULE_EVALUATION_FAILED"
        case digitalRuleInternalError = "DIGITAL_RULE_INTERNAL_ERROR"
        case digitalRuleNoDncListsConfigured = "DIGITAL_RULE_NO_DNC_LISTS_CONFIGURED"
        case digitalRuleUpdatedContactAddress = "DIGITAL_RULE_UPDATED_CONTACT_ADDRESS"
        case digitalRuleSmsPhoneNumberTypeMismatch = "DIGITAL_RULE_SMS_PHONE_NUMBER_TYPE_MISMATCH"
        case digitalRuleErrorSkipped = "DIGITAL_RULE_ERROR_SKIPPED"
        case dncAuthenticationFailure = "DNC_AUTHENTICATION_FAILURE"
        case exceededContactLimit = "EXCEEDED_CONTACT_LIMIT"
        case exceededDncRecordLimit = "EXCEEDED_DNC_RECORD_LIMIT"
        case exceededDncPhoneNumberLength = "EXCEEDED_DNC_PHONE_NUMBER_LENGTH"
        case inactiveEdgesFailedPlaceCalls = "INACTIVE_EDGES_FAILED_PLACE_CALLS"
        case inactiveEdgesTurnedCampaignOff = "INACTIVE_EDGES_TURNED_CAMPAIGN_OFF"
        case invalidAgent = "INVALID_AGENT"
        case invalidEmailAddress = "INVALID_EMAIL_ADDRESS"
        case invalidPhoneNumber = "INVALID_PHONE_NUMBER"
        case importFailedToReadHeaders = "IMPORT_FAILED_TO_READ_HEADERS"
        case importCouldNotParseAnEntry = "IMPORT_COULD_NOT_PARSE_AN_ENTRY"
        case importContactDoesNotMatchListFormat = "IMPORT_CONTACT_DOES_NOT_MATCH_LIST_FORMAT"
        case importEntryDoesNotAlignWithHeaders = "IMPORT_ENTRY_DOES_NOT_ALIGN_WITH_HEADERS"
        case importInvalidCustomId = "IMPORT_INVALID_CUSTOM_ID"
        case importInvalidData = "IMPORT_INVALID_DATA"
        case importInvalidEmailAddresses = "IMPORT_INVALID_EMAIL_ADDRESSES"
        case importInvalidPhoneNumbers = "IMPORT_INVALID_PHONE_NUMBERS"
        case importInvalidExpirationDate = "IMPORT_INVALID_EXPIRATION_DATE"
        case importExpirationDateExceedsMaxDays = "IMPORT_EXPIRATION_DATE_EXCEEDS_MAX_DAYS"
        case importColumnExceedsLengthLimit = "IMPORT_COLUMN_EXCEEDS_LENGTH_LIMIT"
        case importDatumExceedsLengthLimit = "IMPORT_DATUM_EXCEEDS_LENGTH_LIMIT"
        case importMissingCustomId = "IMPORT_MISSING_CUSTOM_ID"
        case importNoColumnsDefined = "IMPORT_NO_COLUMNS_DEFINED"
        case importColumnsDoNotExistOnList = "IMPORT_COLUMNS_DO_NOT_EXIST_ON_LIST"
        case importListNoLongerExists = "IMPORT_LIST_NO_LONGER_EXISTS"
        case importNoListsCreatedNoContactsMatchFilter = "IMPORT_NO_LISTS_CREATED_NO_CONTACTS_MATCH_FILTER"
        case importTargetContactListNameExists = "IMPORT_TARGET_CONTACT_LIST_NAME_EXISTS"
        case importFailedContactZipCodeColumnValueInvalid = "IMPORT_FAILED_CONTACT_ZIP_CODE_COLUMN_VALUE_INVALID"
        case importFailedContactDataGreaterThanMaxLength = "IMPORT_FAILED_CONTACT_DATA_GREATER_THAN_MAX_LENGTH"
        case importFailedContactDataNotWithinMinMaxRange = "IMPORT_FAILED_CONTACT_DATA_NOT_WITHIN_MIN_MAX_RANGE"
        case importFailedContactDataInvalidDatatype = "IMPORT_FAILED_CONTACT_DATA_INVALID_DATATYPE"
        case importTooManyColumns = "IMPORT_TOO_MANY_COLUMNS"
        case importTooManyExtraColumns = "IMPORT_TOO_MANY_EXTRA_COLUMNS"
        case importContactListNameLengthExceeded = "IMPORT_CONTACT_LIST_NAME_LENGTH_EXCEEDED"
        case organizationHasNoDomainSet = "ORGANIZATION_HAS_NO_DOMAIN_SET"
        case recycleCampaign = "RECYCLE_CAMPAIGN"
        case scheduledCampaignInvalid = "SCHEDULED_CAMPAIGN_INVALID"
        case scheduleUnknownError = "SCHEDULE_UNKNOWN_ERROR"
    }











    public var code: Code?
    public var message: String?
    public var messageWithParams: String?
    public var messageParams: [String:JSON]?
    public var documentationUri: String?
    public var resourceURIs: [String]?

    public init(code: Code?, message: String?, messageWithParams: String?, messageParams: [String:JSON]?, documentationUri: String?, resourceURIs: [String]?) {
        self.code = code
        self.message = message
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.documentationUri = documentationUri
        self.resourceURIs = resourceURIs
    }


}




public class EventSetting: Codable {



    /** Settings regarding typing events */
    public var typing: TypingSetting?

    public init(typing: TypingSetting?) {
        self.typing = typing
    }


}



/** Represents an individual result of an execution data lookup */

public class ExecutionDataEntity: Codable {









    /** The id of the execution requested */
    public var _id: String?
    /** A downloadable link to the execution data file. */
    public var downloadUri: String?
    /** If the retrieval failed (not found, no permission, etc;), this will be set true. */
    public var failed: Bool?
    /** This will contain the http status code for the failure */
    public var statusCode: String?

    public init(_id: String?, downloadUri: String?, failed: Bool?, statusCode: String?) {
        self._id = _id
        self.downloadUri = downloadUri
        self.failed = failed
        self.statusCode = statusCode
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case downloadUri
        case failed
        case statusCode
    }


}




public class ExportScriptResponse: Codable {



    public var url: String?

    public init(url: String?) {
        self.url = url
    }


}




public class ExternalContactsContactChangedTopicFacebookScopedId: Codable {



    public var scopedId: String?

    public init(scopedId: String?) {
        self.scopedId = scopedId
    }


}




public class ExternalContactsContactChangedTopicInstagramScopedId: Codable {



    public var scopedId: String?

    public init(scopedId: String?) {
        self.scopedId = scopedId
    }


}




public class ExternalContactsContactChangedTopicPhoneNumber: Codable {















    public var display: String?
    public var _extension: Int?
    public var acceptsSMS: Bool?
    public var userInput: String?
    public var e164: String?
    public var countryCode: String?
    public var normalizationCountryCode: String?

    public init(display: String?, _extension: Int?, acceptsSMS: Bool?, userInput: String?, e164: String?, countryCode: String?, normalizationCountryCode: String?) {
        self.display = display
        self._extension = _extension
        self.acceptsSMS = acceptsSMS
        self.userInput = userInput
        self.e164 = e164
        self.countryCode = countryCode
        self.normalizationCountryCode = normalizationCountryCode
    }

    public enum CodingKeys: String, CodingKey { 
        case display
        case _extension = "extension"
        case acceptsSMS
        case userInput
        case e164
        case countryCode
        case normalizationCountryCode
    }


}




public class ExternalContactsContactChangedTopicTwitterId: Codable {











    public var _id: String?
    public var name: String?
    public var screenName: String?
    public var verified: Bool?
    public var profileUrl: String?

    public init(_id: String?, name: String?, screenName: String?, verified: Bool?, profileUrl: String?) {
        self._id = _id
        self.name = name
        self.screenName = screenName
        self.verified = verified
        self.profileUrl = profileUrl
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case screenName
        case verified
        case profileUrl
    }


}




public class ExternalContactsUnresolvedContactChangedTopicLineId: Codable {





    public var ids: [ExternalContactsUnresolvedContactChangedTopicLineUserId]?
    public var displayName: String?

    public init(ids: [ExternalContactsUnresolvedContactChangedTopicLineUserId]?, displayName: String?) {
        self.ids = ids
        self.displayName = displayName
    }


}




public class ExternalContactsUnresolvedContactChangedTopicLineUserId: Codable {



    public var userId: String?

    public init(userId: String?) {
        self.userId = userId
    }


}



/** Describes a link to a record in an external system that contributed data to a Relate record */

public class ExternalDataSource: Codable {

    public enum Platform: String, Codable { 
        case salesforce = "SALESFORCE"
    }



    /** The platform that was the source of the data.  Example: a CRM like SALESFORCE. */
    public var platform: Platform?
    /** An URL that links to the source record that contributed data to the associated entity. */
    public var url: String?

    public init(platform: Platform?, url: String?) {
        self.platform = platform
        self.url = url
    }


}




public class ExternalMetricDataWriteRequest: Codable {



    /** A list of external metric data items. A maximum of 100 items are allowed. */
    public var items: [ExternalMetricDataItem]?

    public init(items: [ExternalMetricDataItem]?) {
        self.items = items
    }


}




public class ExternalOrganizationTrustorLink: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The id of a PureCloud External Organization entity in the External Contacts system that will be used to represent the trustor org */
    public var externalOrganizationId: String?
    /** The id of a PureCloud organization that has granted trust to this PureCloud organization */
    public var trustorOrgId: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The URI for the External Organization that is linked to the trustor org */
    public var externalOrganizationUri: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, externalOrganizationId: String?, trustorOrgId: String?, dateCreated: Date?, externalOrganizationUri: String?, selfUri: String?) {
        self._id = _id
        self.externalOrganizationId = externalOrganizationId
        self.trustorOrgId = trustorOrgId
        self.dateCreated = dateCreated
        self.externalOrganizationUri = externalOrganizationUri
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case externalOrganizationId
        case trustorOrgId
        case dateCreated
        case externalOrganizationUri
        case selfUri
    }


}




public class ExternalSegment: Codable {





    public enum Source: String, Codable { 
        case adobeExperiencePlatform = "AdobeExperiencePlatform"
        case custom = "Custom"
    }

    /** Identifier for the external segment in the system where it originates from. */
    public var _id: String?
    /** Name for the external segment in the system where it originates from. */
    public var name: String?
    /** The external system where the segment originates from. */
    public var source: Source?

    public init(_id: String?, name: String?, source: Source?) {
        self._id = _id
        self.name = name
        self.source = source
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case source
    }


}



/** Scoped ID for a Facebook user interacting with a page or app */

public class FacebookScopedId: Codable {



    /** The unique page/app-specific scopedId for the user */
    public var scopedId: String?

    public init(scopedId: String?) {
        self.scopedId = scopedId
    }


}




public class Facet: Codable {





    /** The name of the field on which to facet. */
    public var name: String?
    /** The type of the facet, DATE or STRING. */
    public var type: String?

    public init(name: String?, type: String?) {
        self.name = name
        self.type = type
    }


}




public class FacetEntry: Codable {













    public enum TermType: String, Codable { 
        case term = "TERM"
        case numberrange = "NUMBERRANGE"
        case numberhistogram = "NUMBERHISTOGRAM"
        case daterange = "DATERANGE"
        case datehistogram = "DATEHISTOGRAM"
        case _id = "ID"
    }



    public var attribute: TermAttribute?
    public var statistics: FacetStatistics?
    public var other: Int64?
    public var total: Int64?
    public var missing: Int64?
    public var termCount: Int?
    public var termType: TermType?
    public var terms: [FacetTerm]?

    public init(attribute: TermAttribute?, statistics: FacetStatistics?, other: Int64?, total: Int64?, missing: Int64?, termCount: Int?, termType: TermType?, terms: [FacetTerm]?) {
        self.attribute = attribute
        self.statistics = statistics
        self.other = other
        self.total = total
        self.missing = missing
        self.termCount = termCount
        self.termType = termType
        self.terms = terms
    }


}




public class FacetKeyAttribute: Codable {







    public var _id: String?
    public var name: String?
    public var count: Int?

    public init(_id: String?, name: String?, count: Int?) {
        self._id = _id
        self.name = name
        self.count = count
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case count
    }


}




public class FailedRecordingEntityListing: Codable {





















    public var entities: [RecordingJobFailedRecording]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [RecordingJobFailedRecording]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class FaxDocument: Codable {





































    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    public var contentUri: String?
    public var workspace: DomainEntityRef?
    public var createdBy: DomainEntityRef?
    public var sharingUri: String?
    public var contentType: String?
    public var contentLength: Int64?
    public var filename: String?
    public var read: Bool?
    public var pageCount: Int64?
    public var callerAddress: String?
    public var receiverAddress: String?
    public var thumbnails: [DocumentThumbnail]?
    public var downloadSharingUri: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, contentUri: String?, workspace: DomainEntityRef?, createdBy: DomainEntityRef?, sharingUri: String?, contentType: String?, contentLength: Int64?, filename: String?, read: Bool?, pageCount: Int64?, callerAddress: String?, receiverAddress: String?, thumbnails: [DocumentThumbnail]?, downloadSharingUri: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.contentUri = contentUri
        self.workspace = workspace
        self.createdBy = createdBy
        self.sharingUri = sharingUri
        self.contentType = contentType
        self.contentLength = contentLength
        self.filename = filename
        self.read = read
        self.pageCount = pageCount
        self.callerAddress = callerAddress
        self.receiverAddress = receiverAddress
        self.thumbnails = thumbnails
        self.downloadSharingUri = downloadSharingUri
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case contentUri
        case workspace
        case createdBy
        case sharingUri
        case contentType
        case contentLength
        case filename
        case read
        case pageCount
        case callerAddress
        case receiverAddress
        case thumbnails
        case downloadSharingUri
        case selfUri
    }


}




public class FaxSendResponse: Codable {







    public enum UploadMethodType: String, Codable { 
        case singlePut = "SINGLE_PUT"
        case multipartPost = "MULTIPART_POST"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var uploadDestinationUri: String?
    public var uploadMethodType: UploadMethodType?
    public var headers: [String:String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, uploadDestinationUri: String?, uploadMethodType: UploadMethodType?, headers: [String:String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.uploadDestinationUri = uploadDestinationUri
        self.uploadMethodType = uploadMethodType
        self.headers = headers
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case uploadDestinationUri
        case uploadMethodType
        case headers
        case selfUri
    }


}




public class FeedbackAddRequest: Codable {



    public enum Rating: String, Codable { 
        case positive = "Positive"
        case negative = "Negative"
    }

    /** Agent's summary for the conversation */
    public var summary: String?
    /** Agents rating for the system-generated summary. */
    public var rating: Rating?

    public init(summary: String?, rating: Rating?) {
        self.summary = summary
        self.rating = rating
    }


}




public class Flow: Codable {









    public enum ModelType: String, Codable { 
        case bot = "BOT"
        case commonmodule = "COMMONMODULE"
        case digitalbot = "DIGITALBOT"
        case inboundcall = "INBOUNDCALL"
        case inboundchat = "INBOUNDCHAT"
        case inboundemail = "INBOUNDEMAIL"
        case inboundshortmessage = "INBOUNDSHORTMESSAGE"
        case inqueuecall = "INQUEUECALL"
        case inqueueemail = "INQUEUEEMAIL"
        case inqueueshortmessage = "INQUEUESHORTMESSAGE"
        case outboundcall = "OUTBOUNDCALL"
        case securecall = "SECURECALL"
        case speech = "SPEECH"
        case surveyinvite = "SURVEYINVITE"
        case voice = "VOICE"
        case voicemail = "VOICEMAIL"
        case voicesurvey = "VOICESURVEY"
        case workflow = "WORKFLOW"
        case workitem = "WORKITEM"
    }































    public enum CompatibleFlowTypes: String, Codable { 
        case bot = "BOT"
        case commonmodule = "COMMONMODULE"
        case digitalbot = "DIGITALBOT"
        case inboundcall = "INBOUNDCALL"
        case inboundchat = "INBOUNDCHAT"
        case inboundemail = "INBOUNDEMAIL"
        case inboundshortmessage = "INBOUNDSHORTMESSAGE"
        case inqueuecall = "INQUEUECALL"
        case inqueueemail = "INQUEUEEMAIL"
        case inqueueshortmessage = "INQUEUESHORTMESSAGE"
        case outboundcall = "OUTBOUNDCALL"
        case securecall = "SECURECALL"
        case speech = "SPEECH"
        case surveyinvite = "SURVEYINVITE"
        case voice = "VOICE"
        case voicemail = "VOICEMAIL"
        case voicesurvey = "VOICESURVEY"
        case workflow = "WORKFLOW"
        case workitem = "WORKITEM"
    }



    /** The flow identifier */
    public var _id: String?
    /** The flow name */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    public var _description: String?
    public var type: ModelType?
    /** User that has the flow locked. */
    public var lockedUser: User?
    /** OAuth client that has the flow locked. */
    public var lockedClient: DomainEntityRef?
    public var active: Bool?
    public var system: Bool?
    public var deleted: Bool?
    public var publishedVersion: FlowVersion?
    public var savedVersion: FlowVersion?
    /** json schema describing the inputs for the flow */
    public var inputSchema: JSON?
    /** json schema describing the outputs for the flow */
    public var outputSchema: JSON?
    public var checkedInVersion: FlowVersion?
    public var debugVersion: FlowVersion?
    public var publishedBy: User?
    public var currentOperation: Operation?
    /** Information about the natural language understanding configuration for the published version of the flow */
    public var nluInfo: NluInfo?
    /** List of supported languages for the published version of the flow. */
    public var supportedLanguages: [SupportedLanguage]?
    /** Compatible flow types designate which flow types are allowed to embed a flows configuration within their own flow configuration.  Currently the only flows that can be embedded are Common Module flows and the embedding flow can invoke them using the Call Common Module action. */
    public var compatibleFlowTypes: [CompatibleFlowTypes]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, _description: String?, type: ModelType?, lockedUser: User?, lockedClient: DomainEntityRef?, active: Bool?, system: Bool?, deleted: Bool?, publishedVersion: FlowVersion?, savedVersion: FlowVersion?, inputSchema: JSON?, outputSchema: JSON?, checkedInVersion: FlowVersion?, debugVersion: FlowVersion?, publishedBy: User?, currentOperation: Operation?, nluInfo: NluInfo?, supportedLanguages: [SupportedLanguage]?, compatibleFlowTypes: [CompatibleFlowTypes]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.type = type
        self.lockedUser = lockedUser
        self.lockedClient = lockedClient
        self.active = active
        self.system = system
        self.deleted = deleted
        self.publishedVersion = publishedVersion
        self.savedVersion = savedVersion
        self.inputSchema = inputSchema
        self.outputSchema = outputSchema
        self.checkedInVersion = checkedInVersion
        self.debugVersion = debugVersion
        self.publishedBy = publishedBy
        self.currentOperation = currentOperation
        self.nluInfo = nluInfo
        self.supportedLanguages = supportedLanguages
        self.compatibleFlowTypes = compatibleFlowTypes
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case type
        case lockedUser
        case lockedClient
        case active
        case system
        case deleted
        case publishedVersion
        case savedVersion
        case inputSchema
        case outputSchema
        case checkedInVersion
        case debugVersion
        case publishedBy
        case currentOperation
        case nluInfo
        case supportedLanguages
        case compatibleFlowTypes
        case selfUri
    }


}




public class FlowAggregateQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case activerouting = "activeRouting"
        case activeskillid = "activeSkillId"
        case addressfrom = "addressFrom"
        case addressto = "addressTo"
        case agentassistantid = "agentAssistantId"
        case agentbullseyering = "agentBullseyeRing"
        case agentowned = "agentOwned"
        case agentrank = "agentRank"
        case agentscore = "agentScore"
        case ani = "ani"
        case assignerid = "assignerId"
        case authenticated = "authenticated"
        case canonicalexternalcontactid = "canonicalExternalContactId"
        case conversationid = "conversationId"
        case conversationinitiator = "conversationInitiator"
        case convertedfrom = "convertedFrom"
        case convertedto = "convertedTo"
        case customerparticipation = "customerParticipation"
        case deliverystatus = "deliveryStatus"
        case destinationaddress = "destinationAddress"
        case direction = "direction"
        case disconnecttype = "disconnectType"
        case divisionid = "divisionId"
        case dnis = "dnis"
        case edgeid = "edgeId"
        case eligibleagentcount = "eligibleAgentCount"
        case endinglanguage = "endingLanguage"
        case entryreason = "entryReason"
        case entrytype = "entryType"
        case errorcode = "errorCode"
        case exitreason = "exitReason"
        case extendeddeliverystatus = "extendedDeliveryStatus"
        case externalcontactid = "externalContactId"
        case externalmediacount = "externalMediaCount"
        case externalorganizationid = "externalOrganizationId"
        case externaltag = "externalTag"
        case firstqueue = "firstQueue"
        case flaggedreason = "flaggedReason"
        case flowid = "flowId"
        case flowintype = "flowInType"
        case flowmilestoneid = "flowMilestoneId"
        case flowname = "flowName"
        case flowouttype = "flowOutType"
        case flowoutcome = "flowOutcome"
        case flowoutcomeid = "flowOutcomeId"
        case flowoutcomevalue = "flowOutcomeValue"
        case flowtype = "flowType"
        case flowversion = "flowVersion"
        case groupid = "groupId"
        case interactiontype = "interactionType"
        case journeyactionid = "journeyActionId"
        case journeyactionmapid = "journeyActionMapId"
        case journeyactionmapversion = "journeyActionMapVersion"
        case journeycustomerid = "journeyCustomerId"
        case journeycustomeridtype = "journeyCustomerIdType"
        case journeycustomersessionid = "journeyCustomerSessionId"
        case journeycustomersessionidtype = "journeyCustomerSessionIdType"
        case knowledgebaseid = "knowledgeBaseId"
        case mediacount = "mediaCount"
        case mediatype = "mediaType"
        case messagetype = "messageType"
        case originatingdirection = "originatingDirection"
        case outboundcampaignid = "outboundCampaignId"
        case outboundcontactid = "outboundContactId"
        case outboundcontactlistid = "outboundContactListId"
        case participantname = "participantName"
        case peerid = "peerId"
        case proposedagentid = "proposedAgentId"
        case provider = "provider"
        case purpose = "purpose"
        case queueid = "queueId"
        case recognitionfailurereason = "recognitionFailureReason"
        case remote = "remote"
        case removedskillid = "removedSkillId"
        case requestedlanguageid = "requestedLanguageId"
        case requestedrouting = "requestedRouting"
        case requestedroutingskillid = "requestedRoutingSkillId"
        case roomid = "roomId"
        case routingpriority = "routingPriority"
        case routingring = "routingRing"
        case routingrule = "routingRule"
        case routingruletype = "routingRuleType"
        case scoredagentid = "scoredAgentId"
        case selectedagentid = "selectedAgentId"
        case selectedagentrank = "selectedAgentRank"
        case selfserved = "selfServed"
        case sessiondnis = "sessionDnis"
        case sessionid = "sessionId"
        case startinglanguage = "startingLanguage"
        case stationid = "stationId"
        case teamid = "teamId"
        case transfertargetaddress = "transferTargetAddress"
        case transfertargetname = "transferTargetName"
        case transfertype = "transferType"
        case usedrouting = "usedRouting"
        case userid = "userId"
        case waitinginteractioncount = "waitingInteractionCount"
        case wrapupcode = "wrapUpCode"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension predicates */
    public var value: String?
    /** Right hand side for dimension predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case _operator = "operator"
        case value
        case range
    }


}




public class FlowDiagnosticInfo: Codable {



    /** The step number of the survey invite flow where the error occurred. */
    public var lastActionId: Int?

    public init(lastActionId: Int?) {
        self.lastActionId = lastActionId
    }


}




public class FlowDivisionViewEntityListing: Codable {





















    public var entities: [FlowDivisionView]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [FlowDivisionView]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class FlowEndDetailEventTopicFlowEndEvent: Codable {









    public enum DisconnectType: String, Codable { 
        case unknown = "UNKNOWN"
        case endpoint = "ENDPOINT"
        case client = "CLIENT"
        case system = "SYSTEM"
        case transfer = "TRANSFER"
        case error = "ERROR"
        case peer = "PEER"
        case other = "OTHER"
        case spam = "SPAM"
        case timeout = "TIMEOUT"
        case transportFailure = "TRANSPORT_FAILURE"
        case conferenceTransfer = "CONFERENCE_TRANSFER"
        case consultTransfer = "CONSULT_TRANSFER"
        case forwardTransfer = "FORWARD_TRANSFER"
        case noAnswerTransfer = "NO_ANSWER_TRANSFER"
        case notAvailableTransfer = "NOT_AVAILABLE_TRANSFER"
        case uncallable = "UNCALLABLE"
        case dndEndpoint = "DND_ENDPOINT"
        case dndTransfer = "DND_TRANSFER"
    }

    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
    }



    public enum Direction: String, Codable { 
        case unknown = "UNKNOWN"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }











    public enum MessageType: String, Codable { 
        case unknown = "UNKNOWN"
        case sms = "SMS"
        case twitter = "TWITTER"
        case facebook = "FACEBOOK"
        case line = "LINE"
        case whatsapp = "WHATSAPP"
        case webmessaging = "WEBMESSAGING"
        case _open = "OPEN"
        case instagram = "INSTAGRAM"
    }

    public enum FlowType: String, Codable { 
        case unknown = "UNKNOWN"
        case inboundcall = "INBOUNDCALL"
        case outboundcall = "OUTBOUNDCALL"
        case inqueuecall = "INQUEUECALL"
        case securecall = "SECURECALL"
        case inboundemail = "INBOUNDEMAIL"
        case surveyinvite = "SURVEYINVITE"
        case inboundshortmessage = "INBOUNDSHORTMESSAGE"
        case inboundchat = "INBOUNDCHAT"
        case workflow = "WORKFLOW"
        case bot = "BOT"
        case digitalbot = "DIGITALBOT"
        case commonmodule = "COMMONMODULE"
        case inqueueemail = "INQUEUEEMAIL"
        case inqueueshortmessage = "INQUEUESHORTMESSAGE"
        case voice = "VOICE"
        case voicemail = "VOICEMAIL"
        case workitem = "WORKITEM"
    }













    public enum ExitReason: String, Codable { 
        case unknown = "UNKNOWN"
        case disconnect = "DISCONNECT"
        case flowDisconnect = "FLOW_DISCONNECT"
        case flowErrorDisconnect = "FLOW_ERROR_DISCONNECT"
        case transfer = "TRANSFER"
        case sessionExpireDisconnect = "SESSION_EXPIRE_DISCONNECT"
        case recognitionFailureDisconnect = "RECOGNITION_FAILURE_DISCONNECT"
        case recognitionFailureExit = "RECOGNITION_FAILURE_EXIT"
        case userExit = "USER_EXIT"
        case flowExit = "FLOW_EXIT"
        case flowErrorExit = "FLOW_ERROR_EXIT"
    }

    public enum TransferType: String, Codable { 
        case unknown = "UNKNOWN"
        case acd = "ACD"
        case user = "USER"
        case number = "NUMBER"
        case acdVoicemail = "ACD_VOICEMAIL"
        case userVoicemail = "USER_VOICEMAIL"
        case groupVoicemail = "GROUP_VOICEMAIL"
        case group = "GROUP"
        case flow = "FLOW"
        case secureFlow = "SECURE_FLOW"
        case returnToAgent = "RETURN_TO_AGENT"
    }

    public var eventTime: Int?
    public var conversationId: String?
    public var participantId: String?
    public var sessionId: String?
    public var disconnectType: DisconnectType?
    public var mediaType: MediaType?
    public var provider: String?
    public var direction: Direction?
    public var ani: String?
    public var dnis: String?
    public var addressTo: String?
    public var addressFrom: String?
    public var subject: String?
    public var messageType: MessageType?
    public var flowType: FlowType?
    public var flowId: String?
    public var divisionId: String?
    public var flowVersion: String?
    public var connectedDurationMs: Int?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?
    public var exitReason: ExitReason?
    public var transferType: TransferType?

    public init(eventTime: Int?, conversationId: String?, participantId: String?, sessionId: String?, disconnectType: DisconnectType?, mediaType: MediaType?, provider: String?, direction: Direction?, ani: String?, dnis: String?, addressTo: String?, addressFrom: String?, subject: String?, messageType: MessageType?, flowType: FlowType?, flowId: String?, divisionId: String?, flowVersion: String?, connectedDurationMs: Int?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?, exitReason: ExitReason?, transferType: TransferType?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.sessionId = sessionId
        self.disconnectType = disconnectType
        self.mediaType = mediaType
        self.provider = provider
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.addressTo = addressTo
        self.addressFrom = addressFrom
        self.subject = subject
        self.messageType = messageType
        self.flowType = flowType
        self.flowId = flowId
        self.divisionId = divisionId
        self.flowVersion = flowVersion
        self.connectedDurationMs = connectedDurationMs
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
        self.exitReason = exitReason
        self.transferType = transferType
    }


}




public class FlowExecutionAggregateDataContainer: Codable {





    /** A mapping from dimension to value */
    public var group: [String:String]?
    public var data: [StatisticalResponse]?

    public init(group: [String:String]?, data: [StatisticalResponse]?) {
        self.group = group
        self.data = data
    }


}




public class FlowExecutionAggregateQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [FlowExecutionAggregateQueryPredicate]?

    public init(type: ModelType?, predicates: [FlowExecutionAggregateQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class FlowExecutionAggregationQuery: Codable {







    public enum GroupBy: String, Codable { 
        case divisionid = "divisionId"
        case flowid = "flowId"
        case flowobjectid = "flowObjectId"
        case flowversion = "flowVersion"
    }



    public enum Metrics: String, Codable { 
        case nflowexecutions = "nFlowExecutions"
    }





    public enum AlternateTimeDimension: String, Codable { 
        case eventtime = "eventTime"
    }

    /** Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H */
    public var granularity: String?
    /** Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var timeZone: String?
    /** Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group. */
    public var groupBy: [GroupBy]?
    /** Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters */
    public var filter: FlowExecutionAggregateQueryFilter?
    /** Behaves like a SQL SELECT clause. Only named metrics will be retrieved. */
    public var metrics: [Metrics]?
    /** Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c') */
    public var flattenMultivaluedDimensions: Bool?
    /** Custom derived metric views */
    public var views: [FlowExecutionAggregationView]?
    /** Dimension to use as the alternative timestamp for data in the aggregate.  Choosing \"eventTime\" uses the actual time of the data event. */
    public var alternateTimeDimension: AlternateTimeDimension?

    public init(interval: String?, granularity: String?, timeZone: String?, groupBy: [GroupBy]?, filter: FlowExecutionAggregateQueryFilter?, metrics: [Metrics]?, flattenMultivaluedDimensions: Bool?, views: [FlowExecutionAggregationView]?, alternateTimeDimension: AlternateTimeDimension?) {
        self.interval = interval
        self.granularity = granularity
        self.timeZone = timeZone
        self.groupBy = groupBy
        self.filter = filter
        self.metrics = metrics
        self.flattenMultivaluedDimensions = flattenMultivaluedDimensions
        self.views = views
        self.alternateTimeDimension = alternateTimeDimension
    }


}




public class FlowHealthIntentInfo: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Health computation info for each language. */
    public var languageHealth: [String:LocaleHealth]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, languageHealth: [String:LocaleHealth]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.languageHealth = languageHealth
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case languageHealth
        case selfUri
    }


}




public class FlowMetricsTopicFlowMetricRecord: Codable {

    public enum Metric: String, Codable { 
        case nflow = "nFlow"
        case nflowmilestone = "nFlowMilestone"
        case nflowoutcome = "nFlowOutcome"
        case nflowoutcomefailed = "nFlowOutcomeFailed"
        case oflowmilestone = "oFlowMilestone"
        case tflow = "tFlow"
        case tflowdisconnect = "tFlowDisconnect"
        case tflowexit = "tFlowExit"
        case tflowoutcome = "tFlowOutcome"
    }







    public enum ActiveRouting: String, Codable { 
        case bullseye = "Bullseye"
        case conditional = "Conditional"
        case direct = "Direct"
        case last = "Last"
        case manual = "Manual"
        case predictive = "Predictive"
        case preferred = "Preferred"
        case standard = "Standard"
        case vip = "Vip"
    }





















    public enum ConversationInitiator: String, Codable { 
        case acd = "acd"
        case agent = "agent"
        case api = "api"
        case botflow = "botflow"
        case campaign = "campaign"
        case customer = "customer"
        case dialer = "dialer"
        case external = "external"
        case fax = "fax"
        case group = "group"
        case inbound = "inbound"
        case ivr = "ivr"
        case manual = "manual"
        case outbound = "outbound"
        case station = "station"
        case user = "user"
        case voicemail = "voicemail"
        case workflow = "workflow"
    }







    public enum DeliveryStatus: String, Codable { 
        case deliveryFailed = "DeliveryFailed"
        case deliverySuccess = "DeliverySuccess"
        case failed = "Failed"
        case queued = "Queued"
        case read = "Read"
        case received = "Received"
        case sent = "Sent"
    }



    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case client = "client"
        case conferencetransfer = "conferenceTransfer"
        case consulttransfer = "consultTransfer"
        case endpoint = "endpoint"
        case endpointdnd = "endpointDnd"
        case error = "error"
        case forwardtransfer = "forwardTransfer"
        case noanswertransfer = "noAnswerTransfer"
        case notavailabletransfer = "notAvailableTransfer"
        case other = "other"
        case peer = "peer"
        case spam = "spam"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferdnd = "transferDnd"
        case transportfailure = "transportFailure"
        case uncallable = "uncallable"
    }













    public enum EntryType: String, Codable { 
        case agent = "agent"
        case direct = "direct"
        case dnis = "dnis"
        case flow = "flow"
        case outbound = "outbound"
    }

















    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }











    public enum FlowType: String, Codable { 
        case bot = "bot"
        case commonmodule = "commonmodule"
        case digitalbot = "digitalbot"
        case inboundcall = "inboundcall"
        case inboundchat = "inboundchat"
        case inboundemail = "inboundemail"
        case inboundshortmessage = "inboundshortmessage"
        case inqueuecall = "inqueuecall"
        case inqueueemail = "inqueueemail"
        case inqueueshortmessage = "inqueueshortmessage"
        case outboundcall = "outboundcall"
        case securecall = "securecall"
        case speech = "speech"
        case surveyinvite = "surveyinvite"
        case voice = "voice"
        case voicemail = "voicemail"
        case workflow = "workflow"
        case workitem = "workitem"
    }

























    public enum MediaType: String, Codable { 
        case callback = "callback"
        case chat = "chat"
        case cobrowse = "cobrowse"
        case email = "email"
        case message = "message"
        case screenshare = "screenshare"
        case unknown = "unknown"
        case video = "video"
        case voice = "voice"
    }



    public enum OriginatingDirection: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }













    public enum Purpose: String, Codable { 
        case acd = "acd"
        case agent = "agent"
        case api = "api"
        case botflow = "botflow"
        case campaign = "campaign"
        case customer = "customer"
        case dialer = "dialer"
        case external = "external"
        case fax = "fax"
        case group = "group"
        case inbound = "inbound"
        case ivr = "ivr"
        case manual = "manual"
        case outbound = "outbound"
        case station = "station"
        case user = "user"
        case voicemail = "voicemail"
        case workflow = "workflow"
    }













    public enum RequestedRoutings: String, Codable { 
        case bullseye = "Bullseye"
        case conditional = "Conditional"
        case direct = "Direct"
        case last = "Last"
        case manual = "Manual"
        case predictive = "Predictive"
        case preferred = "Preferred"
        case standard = "Standard"
        case vip = "Vip"
    }









    public enum RoutingRuleType: String, Codable { 
        case bullseye = "Bullseye"
        case conditional = "Conditional"
        case predictive = "Predictive"
        case preferred = "Preferred"
    }























    public enum UsedRouting: String, Codable { 
        case bullseye = "Bullseye"
        case conditional = "Conditional"
        case direct = "Direct"
        case last = "Last"
        case manual = "Manual"
        case predictive = "Predictive"
        case preferred = "Preferred"
        case standard = "Standard"
        case vip = "Vip"
    }













    /** Metric name */
    public var metric: Metric?
    /** The date and time of metric creation */
    public var metricDate: Date?
    /** Metric value */
    public var value: Int?
    /** Record identifier */
    public var recordId: String?
    /** Active routing method */
    public var activeRouting: ActiveRouting?
    /** ID(s) of Skill(s) that are active on the conversation */
    public var activeSkillIds: [String]?
    /** The address that initiated an action */
    public var addressFrom: String?
    /** The address receiving an action */
    public var addressTo: String?
    /** Unique identifier of the active virtual agent assistant */
    public var agentAssistantId: String?
    /** Bullseye ring of the targeted agent */
    public var agentBullseyeRing: Int?
    /** Flag indicating an agent-owned callback */
    public var agentOwned: Bool?
    /** Automatic Number Identification (caller's number) */
    public var ani: String?
    /** ID of the user that manually assigned a conversation */
    public var assignerId: String?
    /** Flag that indicates that the identity of the customer has been asserted as verified by the provider. */
    public var authenticated: Bool?
    /** Unique identifier for the conversation */
    public var conversationId: String?
    /** Indicates the participant purpose of the participant initiating a message conversation */
    public var conversationInitiator: ConversationInitiator?
    /** Session media type that was converted from in case of a media type conversion */
    public var convertedFrom: String?
    /** Session media type that was converted to in case of a media type conversion */
    public var convertedTo: String?
    /** Indicates a messaging conversation in which the customer participated by sending at least one message */
    public var customerParticipation: Bool?
    /** The email or SMS delivery status */
    public var deliveryStatus: DeliveryStatus?
    /** Destination address(es) of transfers or consults */
    public var destinationAddresses: [String]?
    /** The direction of the communication */
    public var direction: Direction?
    /** The session disconnect type */
    public var disconnectType: DisconnectType?
    /** Identifier(s) of division(s) associated with a conversation */
    public var divisionIds: [String]?
    /** Dialed number identification service (number dialed by the calling party) */
    public var dnis: String?
    /** Unique identifier of the edge device */
    public var edgeId: String?
    /** Number of eligible agents for each predictive routing attempt */
    public var eligibleAgentCounts: [Int]?
    /** Flow ending language, e.g. en-us */
    public var endingLanguage: String?
    /** The particular entry reason for this flow, e.g. an address, userId, or flowId */
    public var entryReason: String?
    /** The entry type for this flow, e.g. dnis, dialer, agent, flow, or direct */
    public var entryType: EntryType?
    /** A code corresponding to the error that occurred */
    public var errorCode: String?
    /** The exit reason for this flow, e.g. DISCONNECT */
    public var exitReason: String?
    /** Extended delivery status */
    public var extendedDeliveryStatus: String?
    /** External contact identifier */
    public var externalContactId: String?
    /** Count of any media (images, files, etc) included on the external session */
    public var externalMediaCount: Int?
    /** External organization identifier */
    public var externalOrganizationId: String?
    /** External tag for the conversation */
    public var externalTag: String?
    /** Marker that is set if the current queue is the first queue in a conversation */
    public var firstQueue: Bool?
    /** Reason for which participant flagged conversation */
    public var flaggedReason: FlaggedReason?
    /** The unique identifier of this flow */
    public var flowId: String?
    /** Type of flow in that occurred when entering ACD. */
    public var flowInType: String?
    /** The ID of a flow outcome milestone */
    public var flowMilestoneIds: [String]?
    /** The name of this flow at the time of flow execution */
    public var flowName: String?
    /** Type of flow out that occurred when emitting tFlowOut. */
    public var flowOutType: String?
    /** The type of this flow */
    public var flowType: FlowType?
    /** The version of this flow */
    public var flowVersion: String?
    /** Unique identifier for a PureCloud group */
    public var groupId: String?
    /** The interaction type (enterprise or contactCenter) */
    public var interactionType: String?
    /** Identifier of the journey action. */
    public var journeyActionId: String?
    /** Identifier of the journey action map that triggered the action. */
    public var journeyActionMapId: String?
    /** Version of the journey action map that triggered the action. */
    public var journeyActionMapVersion: Int?
    /** Primary identifier of the journey customer in the source where the activities originate from. */
    public var journeyCustomerId: String?
    /** Type of primary identifier of the journey customer (e.g. cookie). */
    public var journeyCustomerIdType: String?
    /** Unique identifier of the journey session. */
    public var journeyCustomerSessionId: String?
    /** Type or category of journey sessions (e.g. web, ticket, delivery, atm). */
    public var journeyCustomerSessionIdType: String?
    /** The unique identifier of the knowledge base used */
    public var knowledgeBaseId: String?
    /** Count of any media (images, files, etc) included in this session */
    public var mediaCount: Int?
    /** The session media type */
    public var mediaType: MediaType?
    /** Message type for messaging services. E.g.: sms, facebook, twitter, line */
    public var messageType: String?
    /** The original direction of the conversation */
    public var originatingDirection: OriginatingDirection?
    /** (Dialer) Unique identifier of the outbound campaign */
    public var outboundCampaignId: String?
    /** (Dialer) Unique identifier of the contact */
    public var outboundContactId: String?
    /** (Dialer) Unique identifier of the contact list that this contact belongs to */
    public var outboundContactListId: String?
    /** A human readable name identifying the participant */
    public var participantName: String?
    /** This identifies pairs of related sessions on a conversation. E.g. an external sessions peerId will be the session that the call originally connected to, e.g. if an IVR was dialed, the IVR session, which will also have the external sessions ID as its peer. After that point, any transfers of that session to other internal components (acd, agent, etc.) will all spawn new sessions whose peerIds point back to that original external session. */
    public var peerId: String?
    /** The source provider for the communication. */
    public var provider: String?
    /** The participant's purpose */
    public var purpose: Purpose?
    /** Queue identifier */
    public var queueId: String?
    /** The recognition failure reason causing to exit/disconnect */
    public var recognitionFailureReason: String?
    /** Name, phone number, or email address of the remote party. */
    public var remote: String?
    /** ID(s) of Skill(s) that have been removed by bullseye routing */
    public var removedSkillIds: [String]?
    /** Unique identifier for the language requested for an interaction */
    public var requestedLanguageId: String?
    /** Unique identifier(s) for skill(s) requested for an interaction */
    public var requestedRoutingSkillIds: [String]?
    /** Routing type(s) for requested/attempted routing methods. */
    public var requestedRoutings: [RequestedRoutings]?
    /** Unique identifier for the room */
    public var roomId: String?
    /** Routing priority for the current interaction */
    public var routingPriority: Int?
    /** Routing ring for bullseye or preferred agent routing */
    public var routingRing: Int?
    /** Routing rule for preferred, conditional and predictive routing type */
    public var routingRule: String?
    /** Routing rule type */
    public var routingRuleType: RoutingRuleType?
    /** Selected agent ID */
    public var selectedAgentId: String?
    /** Selected agent GPR rank */
    public var selectedAgentRank: Int?
    /** Indicates whether the flow session was self serviced */
    public var selfServed: Bool?
    /** Dialed number for the current session; this can be different from dnis, e.g. if the call was transferred */
    public var sessionDnis: String?
    /** The unique identifier of this session */
    public var sessionId: String?
    /** Flow starting language, e.g. en-us */
    public var startingLanguage: String?
    /** Unique identifier for a phone */
    public var stationId: String?
    /** The team ID the user is a member of */
    public var teamId: String?
    /** The address of a flow transfer target, e.g. a phone number, an email address, or a queueId */
    public var transferTargetAddress: String?
    /** The name of a flow transfer target */
    public var transferTargetName: String?
    /** The type of transfer for flows that ended with a transfer */
    public var transferType: String?
    /** Complete routing method */
    public var usedRouting: UsedRouting?
    /** Unique identifier for the user */
    public var userId: String?
    /** Number of waiting interactions for each predictive routing attempt */
    public var waitingInteractionCounts: [Int]?
    /** Wrap up code */
    public var wrapUpCode: String?
    /** Proposed agents */
    public var proposedAgents: [FlowMetricsTopicFlowProposedAgent]?
    /** Flow outcomes */
    public var outcomes: [FlowMetricsTopicFlowOutcome]?
    /** Scored agents */
    public var scoredAgents: [FlowMetricsTopicFlowScoredAgent]?

    public init(metric: Metric?, metricDate: Date?, value: Int?, recordId: String?, activeRouting: ActiveRouting?, activeSkillIds: [String]?, addressFrom: String?, addressTo: String?, agentAssistantId: String?, agentBullseyeRing: Int?, agentOwned: Bool?, ani: String?, assignerId: String?, authenticated: Bool?, conversationId: String?, conversationInitiator: ConversationInitiator?, convertedFrom: String?, convertedTo: String?, customerParticipation: Bool?, deliveryStatus: DeliveryStatus?, destinationAddresses: [String]?, direction: Direction?, disconnectType: DisconnectType?, divisionIds: [String]?, dnis: String?, edgeId: String?, eligibleAgentCounts: [Int]?, endingLanguage: String?, entryReason: String?, entryType: EntryType?, errorCode: String?, exitReason: String?, extendedDeliveryStatus: String?, externalContactId: String?, externalMediaCount: Int?, externalOrganizationId: String?, externalTag: String?, firstQueue: Bool?, flaggedReason: FlaggedReason?, flowId: String?, flowInType: String?, flowMilestoneIds: [String]?, flowName: String?, flowOutType: String?, flowType: FlowType?, flowVersion: String?, groupId: String?, interactionType: String?, journeyActionId: String?, journeyActionMapId: String?, journeyActionMapVersion: Int?, journeyCustomerId: String?, journeyCustomerIdType: String?, journeyCustomerSessionId: String?, journeyCustomerSessionIdType: String?, knowledgeBaseId: String?, mediaCount: Int?, mediaType: MediaType?, messageType: String?, originatingDirection: OriginatingDirection?, outboundCampaignId: String?, outboundContactId: String?, outboundContactListId: String?, participantName: String?, peerId: String?, provider: String?, purpose: Purpose?, queueId: String?, recognitionFailureReason: String?, remote: String?, removedSkillIds: [String]?, requestedLanguageId: String?, requestedRoutingSkillIds: [String]?, requestedRoutings: [RequestedRoutings]?, roomId: String?, routingPriority: Int?, routingRing: Int?, routingRule: String?, routingRuleType: RoutingRuleType?, selectedAgentId: String?, selectedAgentRank: Int?, selfServed: Bool?, sessionDnis: String?, sessionId: String?, startingLanguage: String?, stationId: String?, teamId: String?, transferTargetAddress: String?, transferTargetName: String?, transferType: String?, usedRouting: UsedRouting?, userId: String?, waitingInteractionCounts: [Int]?, wrapUpCode: String?, proposedAgents: [FlowMetricsTopicFlowProposedAgent]?, outcomes: [FlowMetricsTopicFlowOutcome]?, scoredAgents: [FlowMetricsTopicFlowScoredAgent]?) {
        self.metric = metric
        self.metricDate = metricDate
        self.value = value
        self.recordId = recordId
        self.activeRouting = activeRouting
        self.activeSkillIds = activeSkillIds
        self.addressFrom = addressFrom
        self.addressTo = addressTo
        self.agentAssistantId = agentAssistantId
        self.agentBullseyeRing = agentBullseyeRing
        self.agentOwned = agentOwned
        self.ani = ani
        self.assignerId = assignerId
        self.authenticated = authenticated
        self.conversationId = conversationId
        self.conversationInitiator = conversationInitiator
        self.convertedFrom = convertedFrom
        self.convertedTo = convertedTo
        self.customerParticipation = customerParticipation
        self.deliveryStatus = deliveryStatus
        self.destinationAddresses = destinationAddresses
        self.direction = direction
        self.disconnectType = disconnectType
        self.divisionIds = divisionIds
        self.dnis = dnis
        self.edgeId = edgeId
        self.eligibleAgentCounts = eligibleAgentCounts
        self.endingLanguage = endingLanguage
        self.entryReason = entryReason
        self.entryType = entryType
        self.errorCode = errorCode
        self.exitReason = exitReason
        self.extendedDeliveryStatus = extendedDeliveryStatus
        self.externalContactId = externalContactId
        self.externalMediaCount = externalMediaCount
        self.externalOrganizationId = externalOrganizationId
        self.externalTag = externalTag
        self.firstQueue = firstQueue
        self.flaggedReason = flaggedReason
        self.flowId = flowId
        self.flowInType = flowInType
        self.flowMilestoneIds = flowMilestoneIds
        self.flowName = flowName
        self.flowOutType = flowOutType
        self.flowType = flowType
        self.flowVersion = flowVersion
        self.groupId = groupId
        self.interactionType = interactionType
        self.journeyActionId = journeyActionId
        self.journeyActionMapId = journeyActionMapId
        self.journeyActionMapVersion = journeyActionMapVersion
        self.journeyCustomerId = journeyCustomerId
        self.journeyCustomerIdType = journeyCustomerIdType
        self.journeyCustomerSessionId = journeyCustomerSessionId
        self.journeyCustomerSessionIdType = journeyCustomerSessionIdType
        self.knowledgeBaseId = knowledgeBaseId
        self.mediaCount = mediaCount
        self.mediaType = mediaType
        self.messageType = messageType
        self.originatingDirection = originatingDirection
        self.outboundCampaignId = outboundCampaignId
        self.outboundContactId = outboundContactId
        self.outboundContactListId = outboundContactListId
        self.participantName = participantName
        self.peerId = peerId
        self.provider = provider
        self.purpose = purpose
        self.queueId = queueId
        self.recognitionFailureReason = recognitionFailureReason
        self.remote = remote
        self.removedSkillIds = removedSkillIds
        self.requestedLanguageId = requestedLanguageId
        self.requestedRoutingSkillIds = requestedRoutingSkillIds
        self.requestedRoutings = requestedRoutings
        self.roomId = roomId
        self.routingPriority = routingPriority
        self.routingRing = routingRing
        self.routingRule = routingRule
        self.routingRuleType = routingRuleType
        self.selectedAgentId = selectedAgentId
        self.selectedAgentRank = selectedAgentRank
        self.selfServed = selfServed
        self.sessionDnis = sessionDnis
        self.sessionId = sessionId
        self.startingLanguage = startingLanguage
        self.stationId = stationId
        self.teamId = teamId
        self.transferTargetAddress = transferTargetAddress
        self.transferTargetName = transferTargetName
        self.transferType = transferType
        self.usedRouting = usedRouting
        self.userId = userId
        self.waitingInteractionCounts = waitingInteractionCounts
        self.wrapUpCode = wrapUpCode
        self.proposedAgents = proposedAgents
        self.outcomes = outcomes
        self.scoredAgents = scoredAgents
    }


}




public class FlowMetricsTopicFlowProposedAgent: Codable {





    /** Proposed agent rank for this conversation from predictive routing (lower is better) */
    public var agentRank: Int?
    /** Unique identifier for the agent that was proposed by predictive routing */
    public var proposedAgentId: String?

    public init(agentRank: Int?, proposedAgentId: String?) {
        self.agentRank = agentRank
        self.proposedAgentId = proposedAgentId
    }


}




public class FlowObservationQueryResponse: Codable {



    public var results: [FlowObservationDataContainer]?

    public init(results: [FlowObservationDataContainer]?) {
        self.results = results
    }


}




public class FlowOutcomeDivisionView: Codable {









    /** The flow outcome identifier */
    public var _id: String?
    /** The flow outcome name */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case selfUri
    }


}



/** The response for QueryCapabilities which contains the allowed criteria, flow types and action types for the organization. */

public class FlowsQueryCriteriaResponse: Codable {



    public enum FlowTypes: String, Codable { 
        case bot = "bot"
        case commonmodule = "commonmodule"
        case digitalbot = "digitalbot"
        case inboundcall = "inboundcall"
        case inboundchat = "inboundchat"
        case inboundemail = "inboundemail"
        case inboundshortmessage = "inboundshortmessage"
        case inqueuecall = "inqueuecall"
        case inqueueshortmessage = "inqueueshortmessage"
        case inqueueemail = "inqueueemail"
        case outboundcall = "outboundcall"
        case securecall = "securecall"
        case surveyinvite = "surveyinvite"
        case voice = "voice"
        case voicemail = "voicemail"
        case voicesurvey = "voicesurvey"
        case workflow = "workflow"
        case workitem = "workitem"
    }

    public enum ActionTypes: String, Codable { 
        case actionabortsurveyinvite = "actionAbortSurveyInvite"
        case actionaddflowmilestone = "actionAddFlowMilestone"
        case actionaskforboolean = "actionAskForBoolean"
        case actionaskfornluintent = "actionAskForNLUIntent"
        case actionaskfornlunextintent = "actionAskForNLUNextIntent"
        case actionaskforslot = "actionAskForSlot"
        case actioncallbotconnector = "actionCallBotConnector"
        case actioncallbotflow = "actionCallBotFlow"
        case actioncallcommonmodule = "actionCallCommonModule"
        case actioncalldata = "actionCallData"
        case actioncalldatasecure = "actionCallDataSecure"
        case actioncalldialogenginebot = "actionCallDialogEngineBot"
        case actioncalldialogflowbot = "actionCallDialogflowBot"
        case actioncalldialogflowcxbot = "actionCallDialogflowCxBot"
        case actioncalldigitalbotflow = "actionCallDigitalBotFlow"
        case actioncalllexbot = "actionCallLexBot"
        case actioncalllexv2bot = "actionCallLexV2Bot"
        case actioncallnuancemixbot = "actionCallNuanceMixBot"
        case actioncalltask = "actionCallTask"
        case actionchangestate = "actionChangeState"
        case actionclearslot = "actionClearSlot"
        case actionclearvoicemailsnippet = "actionClearVoicemailSnippet"
        case actioncollectinput = "actionCollectInput"
        case actioncommunicate = "actionCommunicate"
        case actioncompletesurveyinvite = "actionCompleteSurveyInvite"
        case actioncreatecallback = "actionCreateCallback"
        case actiondatatablelookup = "actionDataTableLookup"
        case actiondecision = "actionDecision"
        case actiondecryptdata = "actionDecryptData"
        case actiondetectsilence = "actionDetectSilence"
        case actiondialextension = "actionDialExtension"
        case actiondialname = "actionDialName"
        case actiondigitalmenu = "actionDigitalMenu"
        case actiondisconnect = "actionDisconnect"
        case actionenableparticipantrecord = "actionEnableParticipantRecord"
        case actionencryptdata = "actionEncryptData"
        case actionendstate = "actionEndState"
        case actionendtask = "actionEndTask"
        case actionendworkflow = "actionEndWorkflow"
        case actionevaluateschedule = "actionEvaluateSchedule"
        case actionevaluateschedulegroup = "actionEvaluateScheduleGroup"
        case actionexitbotflow = "actionExitBotFlow"
        case actionexitloop = "actionExitLoop"
        case actionextractsecuredata = "actionExtractSecureData"
        case actionfindemergencygroup = "actionFindEmergencyGroup"
        case actionfindgroup = "actionFindGroup"
        case actionfindlanguageskill = "actionFindLanguageSkill"
        case actionfindqueue = "actionFindQueue"
        case actionfindqueuebyid = "actionFindQueueById"
        case actionfindschedule = "actionFindSchedule"
        case actionfindschedulegroup = "actionFindScheduleGroup"
        case actionfindskill = "actionFindSkill"
        case actionfindsystemprompt = "actionFindSystemPrompt"
        case actionfinduser = "actionFindUser"
        case actionfinduserbyid = "actionFindUserById"
        case actionfinduserprompt = "actionFindUserPrompt"
        case actionfindusersbyid = "actionFindUsersById"
        case actionflushaudio = "actionFlushAudio"
        case actiongetconversationdata = "actionGetConversationData"
        case actiongetexternalcontact = "actionGetExternalContact"
        case actiongetexternalorganization = "actionGetExternalOrganization"
        case actiongetjourneyoutcome = "actionGetJourneyOutcome"
        case actiongetjourneyoutcomescoresbysession = "actionGetJourneyOutcomeScoresBySession"
        case actiongetjourneysegment = "actionGetJourneySegment"
        case actiongetjourneysession = "actionGetJourneySession"
        case actiongetjourneysessionsbycustomer = "actionGetJourneySessionsByCustomer"
        case actiongetjourneysessionsbyexternalcontact = "actionGetJourneySessionsByExternalContact"
        case actiongetparticipantdata = "actionGetParticipantData"
        case actiongetresponse = "actionGetResponse"
        case actiongetsecureddata = "actionGetSecuredData"
        case actionholdmusic = "actionHoldMusic"
        case actioninitializeflowoutcome = "actionInitializeFlowOutcome"
        case actionjumptomenu = "actionJumpToMenu"
        case actionjumptotask = "actionJumpToTask"
        case actionloop = "actionLoop"
        case actionloopuntil = "actionLoopUntil"
        case actionnextloop = "actionNextLoop"
        case actionplayaudio = "actionPlayAudio"
        case actionplayaudioonsilence = "actionPlayAudioOnSilence"
        case actionplayestimatedwaittime = "actionPlayEstimatedWaitTime"
        case actionplaypositioninqueue = "actionPlayPositionInQueue"
        case actionplayusergreeting = "actionPlayUserGreeting"
        case actionplayusername = "actionPlayUserName"
        case actionpreviousmenu = "actionPreviousMenu"
        case actionprocessvoicemailinput = "actionProcessVoicemailInput"
        case actionrepeatmenu = "actionRepeatMenu"
        case actionreturntoagent = "actionReturnToAgent"
        case actionsaveworkitem = "actionSaveWorkitem"
        case actionscreenpop = "actionScreenPop"
        case actionsearchexternalcontacts = "actionSearchExternalContacts"
        case actionsendautoreply = "actionSendAutoReply"
        case actionsendresponse = "actionSendResponse"
        case actionsetactiveintent = "actionSetActiveIntent"
        case actionsetconversationdata = "actionSetConversationData"
        case actionsetexternaltag = "actionSetExternalTag"
        case actionsetflowoutcome = "actionSetFlowOutcome"
        case actionsetlocale = "actionSetLocale"
        case actionsetparticipantdata = "actionSetParticipantData"
        case actionsetpriority = "actionSetPriority"
        case actionsetsecureddata = "actionSetSecuredData"
        case actionsetskills = "actionSetSkills"
        case actionsetuuidata = "actionSetUUIData"
        case actionsetwhisperaudio = "actionSetWhisperAudio"
        case actionsetwrapupcode = "actionSetWrapupCode"
        case actionshowknowledgearticle = "actionShowKnowledgeArticle"
        case actionsubmitvoicemailsnippet = "actionSubmitVoicemailSnippet"
        case actionswitch = "actionSwitch"
        case actiontranscription = "actionTranscription"
        case actiontransferexternal = "actionTransferExternal"
        case actiontransferflow = "actionTransferFlow"
        case actiontransferflowsecure = "actionTransferFlowSecure"
        case actiontransfergroup = "actionTransferGroup"
        case actiontransfertoacd = "actionTransferToAcd"
        case actiontransferuser = "actionTransferUser"
        case actiontransfervoicemail = "actionTransferVoicemail"
        case actionupdatedata = "actionUpdateData"
        case actionwait = "actionWait"
        case actionwaitforinput = "actionWaitForInput"
        case menudialextension = "menuDialExtension"
        case menudialname = "menuDialName"
        case menudisconnect = "menuDisconnect"
        case menujumptomenu = "menuJumpToMenu"
        case menujumptotask = "menuJumpToTask"
        case menumenu = "menuMenu"
        case menupreviousmenu = "menuPreviousMenu"
        case menurepeatmenu = "menuRepeatMenu"
        case menushowknowledgearticle = "menuShowKnowledgeArticle"
        case menutask = "menuTask"
        case menutransfertoacd = "menuTransferToAcd"
        case menutransferflow = "menuTransferFlow"
        case menutransfergroup = "menuTransferGroup"
        case menutransferexternal = "menuTransferExternal"
        case menutransferflowsecure = "menuTransferFlowSecure"
        case menutransferuser = "menuTransferUser"
        case menutransfervoicemail = "menuTransferVoicemail"
    }





    /** The is a list of allowed criteria to query on. */
    public var criteria: [QueryCriteria]?
    /** The is a list of flow types the organization has access to. */
    public var flowTypes: [FlowTypes]?
    /** The is a list of action types the organization has access to. */
    public var actionTypes: [ActionTypes]?
    /** The is a list of potential error codes the organization may encounter. */
    public var errorCodes: [String]?
    /** The is a list of potential warning codes the organization may encounter. */
    public var warningCodes: [String]?

    public init(criteria: [QueryCriteria]?, flowTypes: [FlowTypes]?, actionTypes: [ActionTypes]?, errorCodes: [String]?, warningCodes: [String]?) {
        self.criteria = criteria
        self.flowTypes = flowTypes
        self.actionTypes = actionTypes
        self.errorCodes = errorCodes
        self.warningCodes = warningCodes
    }


}




public class ForecastPlanningGroupResponse: Codable {









    /** The ID of the planning group */
    public var _id: String?
    /** The name of the planning group */
    public var name: String?
    /** Route path configuration for this planning group */
    public var routePaths: [RoutePathResponse]?
    /** Service goals for this planning group */
    public var serviceGoalTemplate: ForecastServiceGoalTemplateResponse?

    public init(_id: String?, name: String?, routePaths: [RoutePathResponse]?, serviceGoalTemplate: ForecastServiceGoalTemplateResponse?) {
        self._id = _id
        self.name = name
        self.routePaths = routePaths
        self.serviceGoalTemplate = serviceGoalTemplate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case routePaths
        case serviceGoalTemplate
    }


}




public class ForecastPlanningGroupsResponse: Codable {





    public var entities: [ForecastPlanningGroupResponse]?
    /** A snapshot of a business units service goal impact settings taken at forecast generation time. */
    public var businessUnitServiceGoalImpact: WfmServiceGoalImpactSettings?

    public init(entities: [ForecastPlanningGroupResponse]?, businessUnitServiceGoalImpact: WfmServiceGoalImpactSettings?) {
        self.entities = entities
        self.businessUnitServiceGoalImpact = businessUnitServiceGoalImpact
    }


}




public class GDPRRequestEntityListing: Codable {





















    public var entities: [GDPRRequest]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [GDPRRequest]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class GDPRSubjectEntityListing: Codable {





















    public var entities: [GDPRSubject]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [GDPRSubject]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class GKNDocumentationResult: Codable {









    /** The text or html content for the documentation entity. Will be returned in responses for certain entities. */
    public var content: String?
    /** URL link for the documentation entity. Will be returned in responses for certain entities. */
    public var link: String?
    /** The title of the documentation entity. Will be returned in responses for certain entities. */
    public var title: String?
    /** The search type. Will be returned in responses for certain entities. */
    public var type: String?

    public init(content: String?, link: String?, title: String?, type: String?) {
        self.content = content
        self.link = link
        self.title = title
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case content
        case link
        case title
        case type = "_type"
    }


}




public class GSuite: Codable {























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var disabled: Bool?
    public var issuerURI: String?
    public var ssoTargetURI: String?
    public var sloURI: String?
    public var sloBinding: String?
    public var relyingPartyIdentifier: String?
    public var certificate: String?
    public var certificates: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, disabled: Bool?, issuerURI: String?, ssoTargetURI: String?, sloURI: String?, sloBinding: String?, relyingPartyIdentifier: String?, certificate: String?, certificates: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.disabled = disabled
        self.issuerURI = issuerURI
        self.ssoTargetURI = ssoTargetURI
        self.sloURI = sloURI
        self.sloBinding = sloBinding
        self.relyingPartyIdentifier = relyingPartyIdentifier
        self.certificate = certificate
        self.certificates = certificates
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case disabled
        case issuerURI
        case ssoTargetURI
        case sloURI
        case sloBinding
        case relyingPartyIdentifier
        case certificate
        case certificates
        case selfUri
    }


}




public class GamificationScorecardChangeTopicPerformanceMetric: Codable {











    public var metric: GamificationScorecardChangeTopicMetric?
    public var points: Int?
    public var value: Double?
    public var punctualityEvents: [GamificationScorecardChangeTopicPunctualityEvent]?
    public var evaluationDetails: [GamificationScorecardChangeTopicEvaluationDetail]?

    public init(metric: GamificationScorecardChangeTopicMetric?, points: Int?, value: Double?, punctualityEvents: [GamificationScorecardChangeTopicPunctualityEvent]?, evaluationDetails: [GamificationScorecardChangeTopicEvaluationDetail]?) {
        self.metric = metric
        self.points = points
        self.value = value
        self.punctualityEvents = punctualityEvents
        self.evaluationDetails = evaluationDetails
    }


}




public class GamificationScorecardChangeTopicPunctualityEvent: Codable {









    public var dateStart: String?
    public var dateScheduleStart: String?
    public var activityCode: String?
    public var points: Int?

    public init(dateStart: String?, dateScheduleStart: String?, activityCode: String?, points: Int?) {
        self.dateStart = dateStart
        self.dateScheduleStart = dateScheduleStart
        self.activityCode = activityCode
        self.points = points
    }


}




public class GamificationScorecardChangeTopicScorecardChange: Codable {













    public var workday: String?
    public var divisionId: String?
    public var teamId: String?
    public var performanceProfileId: String?
    public var userId: String?
    public var performanceMetrics: [GamificationScorecardChangeTopicPerformanceMetric]?

    public init(workday: String?, divisionId: String?, teamId: String?, performanceProfileId: String?, userId: String?, performanceMetrics: [GamificationScorecardChangeTopicPerformanceMetric]?) {
        self.workday = workday
        self.divisionId = divisionId
        self.teamId = teamId
        self.performanceProfileId = performanceProfileId
        self.userId = userId
        self.performanceMetrics = performanceMetrics
    }


}




public class GeneralProgramJob: Codable {



    public enum State: String, Codable { 
        case running = "Running"
        case completed = "Completed"
        case failed = "Failed"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var state: State?
    public var createdBy: AddressableEntityRef?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, state: State?, createdBy: AddressableEntityRef?, dateCreated: Date?, dateModified: Date?, selfUri: String?) {
        self._id = _id
        self.state = state
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case createdBy
        case dateCreated
        case dateModified
        case selfUri
    }


}




public class GeneralProgramJobRequest: Codable {

    public enum Dialect: String, Codable { 
        case ar001 = "ar-001"
        case arAe = "ar-AE"
        case arBh = "ar-BH"
        case arEg = "ar-EG"
        case arIl = "ar-IL"
        case arSa = "ar-SA"
        case arTn = "ar-TN"
        case daDk = "da-DK"
        case deCh = "de-CH"
        case deDe = "de-DE"
        case enAu = "en-AU"
        case enGb = "en-GB"
        case enHk = "en-HK"
        case enIe = "en-IE"
        case enIn = "en-IN"
        case enNz = "en-NZ"
        case enSg = "en-SG"
        case enUs = "en-US"
        case enZa = "en-ZA"
        case esEs = "es-ES"
        case esUs = "es-US"
        case fiFi = "fi-FI"
        case frCa = "fr-CA"
        case frFr = "fr-FR"
        case heIl = "he-IL"
        case itIt = "it-IT"
        case jaJp = "ja-JP"
        case koKr = "ko-KR"
        case nbNo = "nb-NO"
        case nlNl = "nl-NL"
        case plPl = "pl-PL"
        case ptBr = "pt-BR"
        case ptPt = "pt-PT"
        case svSe = "sv-SE"
    }

    public enum Mode: String, Codable { 
        case skip = "Skip"
        case merge = "Merge"
        case replaceMerge = "ReplaceMerge"
    }

    /** The dialect of the topics to link with the general program, dialect format is {language}-{country} where language follows ISO 639-1 standard and country follows ISO 3166-1 alpha 2 standard */
    public var dialect: Dialect?
    /** The mode to use for the general program job, default value is Skip */
    public var mode: Mode?

    public init(dialect: Dialect?, mode: Mode?) {
        self.dialect = dialect
        self.mode = mode
    }


}




public class GeneralTopic: Codable {



    public var name: String?

    public init(name: String?) {
        self.name = name
    }


}




public class GetTemplatesResponse: Codable {







    public var total: Int64?
    public var entities: [ObjectiveTemplate]?
    public var selfUri: String?

    public init(total: Int64?, entities: [ObjectiveTemplate]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class GreetingAudioFile: Codable {







    public var durationMilliseconds: Int64?
    public var sizeBytes: Int64?
    public var selfUri: String?

    public init(durationMilliseconds: Int64?, sizeBytes: Int64?, selfUri: String?) {
        self.durationMilliseconds = durationMilliseconds
        self.sizeBytes = sizeBytes
        self.selfUri = selfUri
    }


}




public class GroupGreetingEventGreetingAudioFile: Codable {





    public var durationMilliseconds: Int?
    public var sizeBytes: Int?

    public init(durationMilliseconds: Int?, sizeBytes: Int?) {
        self.durationMilliseconds = durationMilliseconds
        self.sizeBytes = sizeBytes
    }


}




public class GroupProfileEntityListing: Codable {





















    public var entities: [GroupProfile]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [GroupProfile]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class GroupSearchRequest: Codable {

    public enum SortOrder: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
        case score = "SCORE"
    }











    /** The sort order for results */
    public var sortOrder: SortOrder?
    /** The field in the resource that you want to sort the results by */
    public var sortBy: String?
    /** The number of results per page */
    public var pageSize: Int?
    /** The page of resources you want to retrieve */
    public var pageNumber: Int?
    /** Multi-value sort order, list of multiple sort values */
    public var sort: [SearchSort]?
    public var query: [GroupSearchCriteria]?

    public init(sortOrder: SortOrder?, sortBy: String?, pageSize: Int?, pageNumber: Int?, sort: [SearchSort]?, query: [GroupSearchCriteria]?) {
        self.sortOrder = sortOrder
        self.sortBy = sortBy
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.sort = sort
        self.query = query
    }


}




public class HistoricalShrinkageActivityCategoryResponse: Codable {

    public enum ActivityCategory: String, Codable { 
        case onQueueWork = "OnQueueWork"
        case _break = "Break"
        case meal = "Meal"
        case meeting = "Meeting"
        case offQueueWork = "OffQueueWork"
        case timeOff = "TimeOff"
        case training = "Training"
        case unavailable = "Unavailable"
        case unscheduled = "Unscheduled"
    }





    /** Activity category for which shrinkage data is provided */
    public var activityCategory: ActivityCategory?
    /** Aggregated shrinkage data for the activity category */
    public var shrinkageForActivityCategory: HistoricalShrinkageAggregateResponse?
    /** Shrinkage for the activity codes under this activity category */
    public var shrinkageForActivityCodes: [HistoricalShrinkageActivityCodeResponse]?

    public init(activityCategory: ActivityCategory?, shrinkageForActivityCategory: HistoricalShrinkageAggregateResponse?, shrinkageForActivityCodes: [HistoricalShrinkageActivityCodeResponse]?) {
        self.activityCategory = activityCategory
        self.shrinkageForActivityCategory = shrinkageForActivityCategory
        self.shrinkageForActivityCodes = shrinkageForActivityCodes
    }


}




public class HrisTimeOffTypeResponse: Codable {







    /** ID of the time off type configured in integration */
    public var _id: String?
    /** Name of the time off type configured in integration */
    public var name: String?
    /** Secondary ID of the time off type, if configured in integration */
    public var secondaryId: String?

    public init(_id: String?, name: String?, secondaryId: String?) {
        self._id = _id
        self.name = name
        self.secondaryId = secondaryId
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case secondaryId
    }


}




public class HrisTimeOffTypesResponse: Codable {





    /** The asynchronous job handling the query */
    public var job: HrisTimeOffTypesJobReference?
    /** List of time off types. It is available only via notification */
    public var entities: [HrisTimeOffTypeResponse]?

    public init(job: HrisTimeOffTypesJobReference?, entities: [HrisTimeOffTypeResponse]?) {
        self.job = job
        self.entities = entities
    }


}




public class Humanize: Codable {





    /** Whether or not humanize conversations setting is enabled */
    public var enabled: Bool?
    /** Bot messenger profile setting */
    public var bot: BotMessengerProfile?

    public init(enabled: Bool?, bot: BotMessengerProfile?) {
        self.enabled = enabled
        self.bot = bot
    }


}




public class IVREntityListing: Codable {





















    public var entities: [IVR]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [IVR]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class IdentifierClaimRequest: Codable {

    public enum Operation: String, Codable { 
        case claim = "Claim"
        case release = "Release"
    }



    /** The operation to perform claim/release */
    public var operation: Operation?
    /** The identifier that should be claimed/released from a contact */
    public var identifier: ContactIdentifier?

    public init(operation: Operation?, identifier: ContactIdentifier?) {
        self.operation = operation
        self.identifier = identifier
    }


}




public class IdleTokenTimeout: Codable {





    /** Token timeout length in seconds. Must be at least 5 minutes and 8 hours or less (if HIPAA is disabled) or 15 minutes or less (if HIPAA is enabled). */
    public var idleTokenTimeoutSeconds: Int?
    /** Indicates whether the Token Timeout should be enabled or disabled. */
    public var enableIdleTokenTimeout: Bool?

    public init(idleTokenTimeoutSeconds: Int?, enableIdleTokenTimeout: Bool?) {
        self.idleTokenTimeoutSeconds = idleTokenTimeoutSeconds
        self.enableIdleTokenTimeout = enableIdleTokenTimeout
    }


}




public class ImportForecastUploadResponse: Codable {









    /** The key to pass to the secondary request to start processing of the upload */
    public var uploadKey: String?
    /** The url to which to PUT the upload body */
    public var url: String?
    /** Required headers for the PUT request to the url */
    public var headers: [String:String]?
    /** Always null. Defines the schema of the json body to be PUT to the url. The json body should be gzip encoded before uploading */
    public var uploadBodySchema: BuImportShortTermForecastSchema?

    public init(uploadKey: String?, url: String?, headers: [String:String]?, uploadBodySchema: BuImportShortTermForecastSchema?) {
        self.uploadKey = uploadKey
        self.url = url
        self.headers = headers
        self.uploadBodySchema = uploadBodySchema
    }


}




public class ImportScheduleUploadResponse: Codable {









    /** The key to pass to the secondary request to start processing of the upload */
    public var uploadKey: String?
    /** The url to which to PUT the upload body */
    public var url: String?
    /** Required headers for the PUT request to the url */
    public var headers: [String:String]?
    /** Always null. Defines the schema of the json body to be PUT to the url. The json body should be gzip encoded before uploading */
    public var uploadBodySchema: ImportScheduleUploadSchema?

    public init(uploadKey: String?, url: String?, headers: [String:String]?, uploadBodySchema: ImportScheduleUploadSchema?) {
        self.uploadKey = uploadKey
        self.url = url
        self.headers = headers
        self.uploadBodySchema = uploadBodySchema
    }


}




public class ImportTemplate: Codable {



















    public enum ListNameFormat: String, Codable { 
        case listNamePrefix = "ListNamePrefix"
        case listNamePrefixMonthDayYear = "ListNamePrefixMonthDayYear"
        case listNamePrefixMonthDayYearHourMinuteSecond = "ListNamePrefixMonthDayYearHourMinuteSecond"
        case listNamePrefixPart = "ListNamePrefixPart"
        case listNamePrefixMonthDayYearPart = "ListNamePrefixMonthDayYearPart"
        case listNamePrefixMonthDayYearHourMinuteSecondPart = "ListNamePrefixMonthDayYearHourMinuteSecondPart"
        case custom = "Custom"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the import template. */
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** ContactListTemplate for this ImportTemplate. */
    public var contactListTemplate: DomainEntityRef?
    /** ContactListFilter for this ImportTemplate. */
    public var contactListFilter: DomainEntityRef?
    /** Whether or not to use splitting criteria. Default is false. */
    public var useSplittingCriteria: Bool?
    /** How to split contact records, required if useSplittingCriteria is true. */
    public var splittingInformation: SplittingInformation?
    /** The list name format for target ContactLists. When Custom is provided, customListNameFormatValue is required. */
    public var listNameFormat: ListNameFormat?
    /** Custom value for the list name format, at least %N is required. Any character other than the specified tokens will be used as is. Available tokens: %N: ListNamePrefix; %P: Part number; %F: Filter name; %C: Column value; YYYY: year; MM: month; DD: day; hh: hour; mm: minute; ss: second. */
    public var customListNameFormatValue: String?
    /** The status of the import process. */
    public var importStatus: ImportStatus?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, contactListTemplate: DomainEntityRef?, contactListFilter: DomainEntityRef?, useSplittingCriteria: Bool?, splittingInformation: SplittingInformation?, listNameFormat: ListNameFormat?, customListNameFormatValue: String?, importStatus: ImportStatus?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.contactListTemplate = contactListTemplate
        self.contactListFilter = contactListFilter
        self.useSplittingCriteria = useSplittingCriteria
        self.splittingInformation = splittingInformation
        self.listNameFormat = listNameFormat
        self.customListNameFormatValue = customListNameFormatValue
        self.importStatus = importStatus
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case contactListTemplate
        case contactListFilter
        case useSplittingCriteria
        case splittingInformation
        case listNameFormat
        case customListNameFormatValue
        case importStatus
        case selfUri
    }


}




public class InboundMessageRequest: Codable {

























    /** The ID of the queue to use for routing the email conversation. This field is mutually exclusive with flowId */
    public var queueId: String?
    /** The ID of the flow to use for routing email conversation. This field is mutually exclusive with queueId */
    public var flowId: String?
    /** The name of the provider that is sourcing the email such as Oracle, Salesforce, etc. */
    public var provider: String?
    /** The list of skill ID's to use for routing. */
    public var skillIds: [String]?
    /** The ID of the language to use for routing. */
    public var languageId: String?
    /** The priority to assign to the conversation for routing. */
    public var priority: Int?
    /** The list of attributes to associate with the customer participant. */
    public var attributes: [String:String]?
    /** The email address of the recipient of the email. */
    public var toAddress: String?
    /** The name of the recipient of the email. */
    public var toName: String?
    /** The email address of the sender of the email. */
    public var fromAddress: String?
    /** The name of the sender of the email. */
    public var fromName: String?
    /** The subject of the email */
    public var subject: String?

    public init(queueId: String?, flowId: String?, provider: String?, skillIds: [String]?, languageId: String?, priority: Int?, attributes: [String:String]?, toAddress: String?, toName: String?, fromAddress: String?, fromName: String?, subject: String?) {
        self.queueId = queueId
        self.flowId = flowId
        self.provider = provider
        self.skillIds = skillIds
        self.languageId = languageId
        self.priority = priority
        self.attributes = attributes
        self.toAddress = toAddress
        self.toName = toName
        self.fromAddress = fromAddress
        self.fromName = fromName
        self.subject = subject
    }


}




public class InboundRouteEntityListing: Codable {





















    public var entities: [InboundRoute]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [InboundRoute]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** Scoped ID for an Instagram user interacting with a page or app */

public class InstagramScopedId: Codable {



    /** The unique page/app-specific scopedId for the user */
    public var scopedId: String?

    public init(scopedId: String?) {
        self.scopedId = scopedId
    }


}




public class IntegrationEntityListing: Codable {





















    public var entities: [Integration]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Integration]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class IntegrationExport: Codable {





    /** The aws-s3-recording-bulk-actions-integration that the policy uses for exports. */
    public var integration: DomainEntityRef?
    /** True if the policy should export screen recordings in addition to the other conversation media. Default = true */
    public var shouldExportScreenRecordings: Bool?

    public init(integration: DomainEntityRef?, shouldExportScreenRecordings: Bool?) {
        self.integration = integration
        self.shouldExportScreenRecordings = shouldExportScreenRecordings
    }


}




public class InteractionStatsAlert: Codable {





    public enum Dimension: String, Codable { 
        case queueid = "queueId"
        case userid = "userId"
    }



    public enum Metric: String, Codable { 
        case tabandon = "tAbandon"
        case tanswered = "tAnswered"
        case ttalk = "tTalk"
        case noffered = "nOffered"
        case thandle = "tHandle"
        case ntransferred = "nTransferred"
        case oservicelevel = "oServiceLevel"
        case twait = "tWait"
        case theld = "tHeld"
        case tacw = "tAcw"
    }

    public enum MediaType: String, Codable { 
        case voice = "voice"
        case chat = "chat"
        case email = "email"
        case callback = "callback"
        case message = "message"
    }

    public enum NumericRange: String, Codable { 
        case gt = "gt"
        case gte = "gte"
        case lt = "lt"
        case lte = "lte"
        case eq = "eq"
        case ne = "ne"
    }

    public enum Statistic: String, Codable { 
        case count = "count"
        case min = "min"
        case ratio = "ratio"
        case max = "max"
    }














    public enum AlertTypes: String, Codable { 
        case sms = "SMS"
        case device = "DEVICE"
        case email = "EMAIL"
    }




    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Name of the rule that generated the alert */
    public var name: String?
    /** The dimension of concern. */
    public var dimension: Dimension?
    /** The value of the dimension. */
    public var dimensionValue: String?
    /** The metric to be assessed. */
    public var metric: Metric?
    /** The media type. */
    public var mediaType: MediaType?
    /** The comparison descriptor used against the metric's value. */
    public var numericRange: NumericRange?
    /** The statistic of concern for the metric. */
    public var statistic: Statistic?
    /** The threshold value. */
    public var value: Double?
    /** The id of the rule. */
    public var ruleId: String?
    /** Indicates if the alert has been read. */
    public var unread: Bool?
    /** The date/time the alert was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** The date/time the owning rule exiting in alarm status. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endDate: Date?
    /** The ids of users who were notified of alarm state change. */
    public var notificationUsers: [User]?
    /** A collection of notification methods. */
    public var alertTypes: [AlertTypes]?
    public var ruleUri: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dimension: Dimension?, dimensionValue: String?, metric: Metric?, mediaType: MediaType?, numericRange: NumericRange?, statistic: Statistic?, value: Double?, ruleId: String?, unread: Bool?, startDate: Date?, endDate: Date?, notificationUsers: [User]?, alertTypes: [AlertTypes]?, ruleUri: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dimension = dimension
        self.dimensionValue = dimensionValue
        self.metric = metric
        self.mediaType = mediaType
        self.numericRange = numericRange
        self.statistic = statistic
        self.value = value
        self.ruleId = ruleId
        self.unread = unread
        self.startDate = startDate
        self.endDate = endDate
        self.notificationUsers = notificationUsers
        self.alertTypes = alertTypes
        self.ruleUri = ruleUri
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dimension
        case dimensionValue
        case metric
        case mediaType
        case numericRange
        case statistic
        case value
        case ruleId
        case unread
        case startDate
        case endDate
        case notificationUsers
        case alertTypes
        case ruleUri
        case selfUri
    }


}




public class InteractionStatsRuleContainer: Codable {





















    public var entities: [InteractionStatsRule]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [InteractionStatsRule]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class IpAddressRange: Codable {



    public enum Service: String, Codable { 
        case dataActions = "data-actions"
        case smtp = "smtp"
        case audiohook = "audiohook"
        case api = "api"
    }



    public var cidr: String?
    public var service: Service?
    public var region: String?

    public init(cidr: String?, service: Service?, region: String?) {
        self.cidr = cidr
        self.service = service
        self.region = region
    }


}




public class IpAddressRangeListing: Codable {



    public var entities: [IpAddressRange]?

    public init(entities: [IpAddressRange]?) {
        self.entities = entities
    }


}




public class Journey: Codable {



    /** A list of zero or more patterns to match. */
    public var patterns: [JourneyPattern]?

    public init(patterns: [JourneyPattern]?) {
        self.patterns = patterns
    }


}




public class JourneyAggregateQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case containsallcondition = "containsAllCondition"
        case containsanycondition = "containsAnyCondition"
        case endswithcondition = "endsWithCondition"
        case equalcondition = "equalCondition"
        case journeyactionid = "journeyActionId"
        case journeyactionmapid = "journeyActionMapId"
        case journeyactionmapversion = "journeyActionMapVersion"
        case journeyactionmediatype = "journeyActionMediaType"
        case journeyactiontargetid = "journeyActionTargetId"
        case journeyactiontemplateid = "journeyActionTemplateId"
        case journeyblockingactionmapid = "journeyBlockingActionMapId"
        case journeyblockingemergencyschedulegroupid = "journeyBlockingEmergencyScheduleGroupId"
        case journeyblockingreason = "journeyBlockingReason"
        case journeyblockingschedulegroupid = "journeyBlockingScheduleGroupId"
        case journeydevicecategory = "journeyDeviceCategory"
        case journeydevicetype = "journeyDeviceType"
        case journeyfrequencycapreason = "journeyFrequencyCapReason"
        case journeyipgeolocationcountry = "journeyIpGeolocationCountry"
        case journeyoutcomeid = "journeyOutcomeId"
        case journeysegmentid = "journeySegmentId"
        case journeysegmentscope = "journeySegmentScope"
        case journeysessionid = "journeySessionId"
        case journeysessionsegmentid = "journeySessionSegmentId"
        case journeysessiontype = "journeySessionType"
        case notcontainsallcondition = "notContainsAllCondition"
        case notcontainsanycondition = "notContainsAnyCondition"
        case notequalcondition = "notEqualCondition"
        case startswithcondition = "startsWithCondition"
        case touchpointactionmapid = "touchpointActionMapId"
        case touchpointagentid = "touchpointAgentId"
        case touchpointattributionscope = "touchpointAttributionScope"
        case touchpointchannelmessagetype = "touchpointChannelMessageType"
        case touchpointchannelplatform = "touchpointChannelPlatform"
        case touchpointchanneltype = "touchpointChannelType"
        case touchpointconversationid = "touchpointConversationId"
        case touchpointinteractiontype = "touchpointInteractionType"
        case touchpointqueueid = "touchpointQueueId"
        case touchpointrequestedrouting = "touchpointRequestedRouting"
        case touchpointusedrouting = "touchpointUsedRouting"
        case touchpointwrapupcode = "touchpointWrapupCode"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension predicates */
    public var value: String?
    /** Right hand side for dimension predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case _operator = "operator"
        case value
        case range
    }


}




public class JourneyAppEventsNotificationCustomEventAttribute: Codable {



    public enum DataType: String, Codable { 
        case string = "STRING"
        case boolean = "BOOLEAN"
        case number = "NUMBER"
    }

    public var value: String?
    public var dataType: DataType?

    public init(value: String?, dataType: DataType?) {
        self.value = value
        self.dataType = dataType
    }


}




public class JourneyAppEventsNotificationDevice: Codable {

















    public enum Category: String, Codable { 
        case desktop = "desktop"
        case mobile = "mobile"
        case tablet = "tablet"
        case other = "other"
    }



    public var type: String?
    public var isMobile: Bool?
    public var screenHeight: Int?
    public var screenWidth: Int?
    public var screenDensity: Int?
    public var fingerprint: String?
    public var osFamily: String?
    public var osVersion: String?
    public var category: Category?
    public var manufacturer: String?

    public init(type: String?, isMobile: Bool?, screenHeight: Int?, screenWidth: Int?, screenDensity: Int?, fingerprint: String?, osFamily: String?, osVersion: String?, category: Category?, manufacturer: String?) {
        self.type = type
        self.isMobile = isMobile
        self.screenHeight = screenHeight
        self.screenWidth = screenWidth
        self.screenDensity = screenDensity
        self.fingerprint = fingerprint
        self.osFamily = osFamily
        self.osVersion = osVersion
        self.category = category
        self.manufacturer = manufacturer
    }


}




public class JourneyAppEventsNotificationOutcome: Codable {









    public var _id: String?
    public var selfUri: String?
    public var displayName: String?
    public var version: String?

    public init(_id: String?, selfUri: String?, displayName: String?, version: String?) {
        self._id = _id
        self.selfUri = selfUri
        self.displayName = displayName
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case displayName
        case version
    }


}




public class JourneyCampaign: Codable {















    /** Differentiate ads or links that point to the same URL (e.g. textlink). */
    public var content: String?
    /** Identify a medium such as email or cost-per-click (e.g. CPC). */
    public var medium: String?
    /** Identify a specific product promotion or strategic campaign (e.g. 320banner). */
    public var name: String?
    /** Identify a search engine, newsletter name, or other source (e.g. Google). */
    public var source: String?
    /** Note the keywords for this ad (e.g. running+shoes). */
    public var term: String?
    /** The click ID (unique number that is generated when a potential customer clicks on an affiliate link). */
    public var clickId: String?
    /** The ad network to which the click ID belongs. */
    public var network: String?

    public init(content: String?, medium: String?, name: String?, source: String?, term: String?, clickId: String?, network: String?) {
        self.content = content
        self.medium = medium
        self.name = name
        self.source = source
        self.term = term
        self.clickId = clickId
        self.network = network
    }


}




public class JourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}




public class JourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}




public class JourneyGeolocation: Codable {





















    /** Geolocation's ISO 3166-1 alpha-2 country code. */
    public var country: String?
    /** Geolocation's country name. */
    public var countryName: String?
    /** Geolocation's latitude. */
    public var latitude: Double?
    /** Geolocation's longitude. */
    public var longitude: Double?
    /** Geolocation's locality or city. */
    public var locality: String?
    /** Geolocation's postal code or ZIP code. */
    public var postalCode: String?
    /** Geolocation's ISO-3166-2 region code. */
    public var region: String?
    /** Geolocation's region name. */
    public var regionName: String?
    /** The source that was used to determine the geolocation information. */
    public var source: String?
    /** Geolocation's timezone. */
    public var timezone: String?

    public init(country: String?, countryName: String?, latitude: Double?, longitude: Double?, locality: String?, postalCode: String?, region: String?, regionName: String?, source: String?, timezone: String?) {
        self.country = country
        self.countryName = countryName
        self.latitude = latitude
        self.longitude = longitude
        self.locality = locality
        self.postalCode = postalCode
        self.region = region
        self.regionName = regionName
        self.source = source
        self.timezone = timezone
    }


}




public class JourneyOutcomeEventsNotificationOutcomeAchievedMessage: Codable {























    public var outcome: JourneyOutcomeEventsNotificationOutcome?
    public var browser: JourneyOutcomeEventsNotificationBrowser?
    public var visitCreatedDate: Date?
    public var ipAddress: String?
    public var ipOrganization: String?
    public var userAgentString: String?
    public var device: JourneyOutcomeEventsNotificationDevice?
    public var geolocation: JourneyOutcomeEventsNotificationGeoLocation?
    public var mktCampaign: JourneyOutcomeEventsNotificationMktCampaign?
    public var visitReferrer: JourneyOutcomeEventsNotificationReferrer?
    public var associatedValue: JourneyOutcomeEventsNotificationAssociatedValue?

    public init(outcome: JourneyOutcomeEventsNotificationOutcome?, browser: JourneyOutcomeEventsNotificationBrowser?, visitCreatedDate: Date?, ipAddress: String?, ipOrganization: String?, userAgentString: String?, device: JourneyOutcomeEventsNotificationDevice?, geolocation: JourneyOutcomeEventsNotificationGeoLocation?, mktCampaign: JourneyOutcomeEventsNotificationMktCampaign?, visitReferrer: JourneyOutcomeEventsNotificationReferrer?, associatedValue: JourneyOutcomeEventsNotificationAssociatedValue?) {
        self.outcome = outcome
        self.browser = browser
        self.visitCreatedDate = visitCreatedDate
        self.ipAddress = ipAddress
        self.ipOrganization = ipOrganization
        self.userAgentString = userAgentString
        self.device = device
        self.geolocation = geolocation
        self.mktCampaign = mktCampaign
        self.visitReferrer = visitReferrer
        self.associatedValue = associatedValue
    }


}




public class JourneyOutcomeEventsNotificationOutcomeAttributionMessage: Codable {









    public var outcome: JourneyOutcomeEventsNotificationOutcome?
    public var outcomeTouchpoints: [JourneyOutcomeEventsNotificationOutcomeTouchpoint]?
    public var segmentAssignments: [JourneyOutcomeEventsNotificationSegment]?
    public var associatedValue: JourneyOutcomeEventsNotificationAssociatedValue?

    public init(outcome: JourneyOutcomeEventsNotificationOutcome?, outcomeTouchpoints: [JourneyOutcomeEventsNotificationOutcomeTouchpoint]?, segmentAssignments: [JourneyOutcomeEventsNotificationSegment]?, associatedValue: JourneyOutcomeEventsNotificationAssociatedValue?) {
        self.outcome = outcome
        self.outcomeTouchpoints = outcomeTouchpoints
        self.segmentAssignments = segmentAssignments
        self.associatedValue = associatedValue
    }


}




public class JourneyOutcomeEventsNotificationReferrer: Codable {

















    public enum Medium: String, Codable { 
        case _internal = "internal"
        case search = "search"
        case social = "social"
        case email = "email"
        case unknown = "unknown"
        case paid = "paid"
    }

    public var url: String?
    public var domain: String?
    public var hostname: String?
    public var keywords: String?
    public var pathname: String?
    public var queryString: String?
    public var fragment: String?
    public var name: String?
    public var medium: Medium?

    public init(url: String?, domain: String?, hostname: String?, keywords: String?, pathname: String?, queryString: String?, fragment: String?, name: String?, medium: Medium?) {
        self.url = url
        self.domain = domain
        self.hostname = hostname
        self.keywords = keywords
        self.pathname = pathname
        self.queryString = queryString
        self.fragment = fragment
        self.name = name
        self.medium = medium
    }


}




public class JourneySessionEventsNotificationExternalContact: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneySessionEventsNotificationOutcomeAchievement: Codable {





    public var outcome: JourneySessionEventsNotificationOutcome?
    public var achievedDate: Date?

    public init(outcome: JourneySessionEventsNotificationOutcome?, achievedDate: Date?) {
        self.outcome = outcome
        self.achievedDate = achievedDate
    }


}




public class JourneySessionEventsNotificationPage: Codable {





















    public var url: String?
    public var title: String?
    public var domain: String?
    public var fragment: String?
    public var hostname: String?
    public var keywords: String?
    public var lang: String?
    public var pathname: String?
    public var queryString: String?
    public var breadcrumb: [String]?

    public init(url: String?, title: String?, domain: String?, fragment: String?, hostname: String?, keywords: String?, lang: String?, pathname: String?, queryString: String?, breadcrumb: [String]?) {
        self.url = url
        self.title = title
        self.domain = domain
        self.fragment = fragment
        self.hostname = hostname
        self.keywords = keywords
        self.lang = lang
        self.pathname = pathname
        self.queryString = queryString
        self.breadcrumb = breadcrumb
    }


}




public class JourneySurveyQuestion: Codable {

    public enum ModelType: String, Codable { 
        case text = "text"
        case hidden = "hidden"
        case select = "select"
        case checkbox = "checkbox"
        case textarea = "textarea"
    }



    public enum CustomerProperty: String, Codable { 
        case givenname = "givenName"
        case familyname = "familyName"
        case email = "email"
        case phone = "phone"
        case gender = "gender"
        case companyname = "companyName"
    }





    /** Type of survey question. */
    public var type: ModelType?
    /** Label of question. */
    public var label: String?
    /** The customer property that the answer maps to. */
    public var customerProperty: CustomerProperty?
    /** Choices available to user. */
    public var choices: [String]?
    /** Whether answering this question is mandatory. */
    public var isMandatory: Bool?

    public init(type: ModelType?, label: String?, customerProperty: CustomerProperty?, choices: [String]?, isMandatory: Bool?) {
        self.type = type
        self.label = label
        self.customerProperty = customerProperty
        self.choices = choices
        self.isMandatory = isMandatory
    }


}




public class JourneyWebActionEventsNotificationReferrer: Codable {

















    public enum Medium: String, Codable { 
        case _internal = "internal"
        case search = "search"
        case social = "social"
        case email = "email"
        case unknown = "unknown"
        case paid = "paid"
    }

    public var url: String?
    public var domain: String?
    public var hostname: String?
    public var keywords: String?
    public var pathname: String?
    public var queryString: String?
    public var fragment: String?
    public var name: String?
    public var medium: Medium?

    public init(url: String?, domain: String?, hostname: String?, keywords: String?, pathname: String?, queryString: String?, fragment: String?, name: String?, medium: Medium?) {
        self.url = url
        self.domain = domain
        self.hostname = hostname
        self.keywords = keywords
        self.pathname = pathname
        self.queryString = queryString
        self.fragment = fragment
        self.name = name
        self.medium = medium
    }


}




public class JourneyWebEventsNotificationBrowser: Codable {





















    public var family: String?
    public var version: String?
    public var lang: String?
    public var fingerprint: String?
    public var viewHeight: Int?
    public var viewWidth: Int?
    public var featuresFlash: Bool?
    public var featuresJava: Bool?
    public var featuresPdf: Bool?
    public var featuresWebrtc: Bool?

    public init(family: String?, version: String?, lang: String?, fingerprint: String?, viewHeight: Int?, viewWidth: Int?, featuresFlash: Bool?, featuresJava: Bool?, featuresPdf: Bool?, featuresWebrtc: Bool?) {
        self.family = family
        self.version = version
        self.lang = lang
        self.fingerprint = fingerprint
        self.viewHeight = viewHeight
        self.viewWidth = viewWidth
        self.featuresFlash = featuresFlash
        self.featuresJava = featuresJava
        self.featuresPdf = featuresPdf
        self.featuresWebrtc = featuresWebrtc
    }


}




public class JourneyWebEventsNotificationEventAction: Codable {





    public enum State: String, Codable { 
        case accepted = "accepted"
        case rejected = "rejected"
        case timedout = "timedout"
        case errored = "errored"
        case ignored = "ignored"
        case qualified = "qualified"
        case offered = "offered"
        case started = "started"
        case engaged = "engaged"
        case qualifiedoutsideschedule = "qualifiedOutsideSchedule"
        case offeredoutsideschedule = "offeredOutsideSchedule"
        case abandoned = "abandoned"
        case completed = "completed"
        case frequencycapreached = "frequencyCapReached"
    }

    public enum MediaType: String, Codable { 
        case webchat = "webchat"
        case webmessagingoffer = "webMessagingOffer"
        case contentoffer = "contentOffer"
        case architectflow = "architectFlow"
    }



    public var _id: String?
    public var createdDate: Date?
    public var state: State?
    public var mediaType: MediaType?
    public var prompt: String?

    public init(_id: String?, createdDate: Date?, state: State?, mediaType: MediaType?, prompt: String?) {
        self._id = _id
        self.createdDate = createdDate
        self.state = state
        self.mediaType = mediaType
        self.prompt = prompt
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case createdDate
        case state
        case mediaType
        case prompt
    }


}




public class JourneyWebEventsNotificationMktCampaign: Codable {















    public var content: String?
    public var medium: String?
    public var name: String?
    public var source: String?
    public var term: String?
    public var clickId: String?
    public var network: String?

    public init(content: String?, medium: String?, name: String?, source: String?, term: String?, clickId: String?, network: String?) {
        self.content = content
        self.medium = medium
        self.name = name
        self.source = source
        self.term = term
        self.clickId = clickId
        self.network = network
    }


}




public class JourneyWebEventsNotificationSession: Codable {







    public var _id: String?
    public var selfUri: String?
    public var type: String?

    public init(_id: String?, selfUri: String?, type: String?) {
        self._id = _id
        self.selfUri = selfUri
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case type
    }


}




public class JourneyWebEventsNotificationWebEventsNotification: Codable {















    public enum EventType: String, Codable { 
        case webEvent = "WebEvent"
        case webActionEvent = "WebActionEvent"
        case outcomeAchievedEvent = "OutcomeAchievedEvent"
        case segmentAssignmentEvent = "SegmentAssignmentEvent"
    }









    public var _id: String?
    public var correlationId: String?
    public var externalContact: JourneyWebEventsNotificationExternalContact?
    public var createdDate: Date?
    public var customerId: String?
    public var customerIdType: String?
    public var session: JourneyWebEventsNotificationSession?
    public var eventType: EventType?
    public var webEvent: JourneyWebEventsNotificationWebMessage?
    public var webActionEvent: JourneyWebEventsNotificationWebActionMessage?
    public var outcomeAchievedEvent: JourneyWebEventsNotificationOutcomeAchievedMessage?
    public var segmentAssignmentEvent: JourneyWebEventsNotificationSegmentAssignmentMessage?

    public init(_id: String?, correlationId: String?, externalContact: JourneyWebEventsNotificationExternalContact?, createdDate: Date?, customerId: String?, customerIdType: String?, session: JourneyWebEventsNotificationSession?, eventType: EventType?, webEvent: JourneyWebEventsNotificationWebMessage?, webActionEvent: JourneyWebEventsNotificationWebActionMessage?, outcomeAchievedEvent: JourneyWebEventsNotificationOutcomeAchievedMessage?, segmentAssignmentEvent: JourneyWebEventsNotificationSegmentAssignmentMessage?) {
        self._id = _id
        self.correlationId = correlationId
        self.externalContact = externalContact
        self.createdDate = createdDate
        self.customerId = customerId
        self.customerIdType = customerIdType
        self.session = session
        self.eventType = eventType
        self.webEvent = webEvent
        self.webActionEvent = webActionEvent
        self.outcomeAchievedEvent = outcomeAchievedEvent
        self.segmentAssignmentEvent = segmentAssignmentEvent
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case correlationId
        case externalContact
        case createdDate
        case customerId
        case customerIdType
        case session
        case eventType
        case webEvent
        case webActionEvent
        case outcomeAchievedEvent
        case segmentAssignmentEvent
    }


}




public class JourneyWebEventsNotificationWebMessage: Codable {

































    public var eventName: String?
    public var totalEventCount: Int?
    public var totalPageviewCount: Int?
    public var userAgentString: String?
    public var ipAddress: String?
    public var ipOrganization: String?
    public var searchQuery: String?
    public var authenticated: Bool?
    public var browser: JourneyWebEventsNotificationBrowser?
    public var device: JourneyWebEventsNotificationDevice?
    public var geolocation: JourneyWebEventsNotificationGeoLocation?
    public var mktCampaign: JourneyWebEventsNotificationMktCampaign?
    public var page: JourneyWebEventsNotificationPage?
    public var referrer: JourneyWebEventsNotificationReferrer?
    public var attributes: [String:JourneyWebEventsNotificationCustomEventAttribute]?
    public var traits: [String:JourneyWebEventsNotificationCustomEventAttribute]?

    public init(eventName: String?, totalEventCount: Int?, totalPageviewCount: Int?, userAgentString: String?, ipAddress: String?, ipOrganization: String?, searchQuery: String?, authenticated: Bool?, browser: JourneyWebEventsNotificationBrowser?, device: JourneyWebEventsNotificationDevice?, geolocation: JourneyWebEventsNotificationGeoLocation?, mktCampaign: JourneyWebEventsNotificationMktCampaign?, page: JourneyWebEventsNotificationPage?, referrer: JourneyWebEventsNotificationReferrer?, attributes: [String:JourneyWebEventsNotificationCustomEventAttribute]?, traits: [String:JourneyWebEventsNotificationCustomEventAttribute]?) {
        self.eventName = eventName
        self.totalEventCount = totalEventCount
        self.totalPageviewCount = totalPageviewCount
        self.userAgentString = userAgentString
        self.ipAddress = ipAddress
        self.ipOrganization = ipOrganization
        self.searchQuery = searchQuery
        self.authenticated = authenticated
        self.browser = browser
        self.device = device
        self.geolocation = geolocation
        self.mktCampaign = mktCampaign
        self.page = page
        self.referrer = referrer
        self.attributes = attributes
        self.traits = traits
    }


}




public class JsonCursorSearchResponse: Codable {









    /** Resource types the search was performed against */
    public var types: [String]?
    /** Search results */
    public var results: JSON?
    public var aggregations: JSON?
    /** The page cursor */
    public var cursor: String?

    public init(types: [String]?, results: JSON?, aggregations: JSON?, cursor: String?) {
        self.types = types
        self.results = results
        self.aggregations = aggregations
        self.cursor = cursor
    }


}




public class KeyRotationSchedule: Codable {





    public enum Period: String, Codable { 
        case disabled = "DISABLED"
        case daily = "DAILY"
        case weekly = "WEEKLY"
        case monthly = "MONTHLY"
        case yearly = "YEARLY"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Value to set schedule to */
    public var period: Period?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, period: Period?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.period = period
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case period
        case selfUri
    }


}




public class KlaxonHeartBeatRulesTopicHeartBeatRule: Codable {















    public enum AlertTypes: String, Codable { 
        case sms = "SMS"
        case device = "DEVICE"
        case email = "EMAIL"
    }

    public enum RuleType: String, Codable { 
        case edge = "EDGE"
    }

    public var _id: String?
    public var name: String?
    public var senderId: String?
    public var heartBeatTimeoutInMinutes: Double?
    public var enabled: Bool?
    public var inAlarm: Bool?
    public var notificationUsers: [KlaxonHeartBeatRulesTopicNotificationUser]?
    public var alertTypes: [AlertTypes]?
    public var ruleType: RuleType?

    public init(_id: String?, name: String?, senderId: String?, heartBeatTimeoutInMinutes: Double?, enabled: Bool?, inAlarm: Bool?, notificationUsers: [KlaxonHeartBeatRulesTopicNotificationUser]?, alertTypes: [AlertTypes]?, ruleType: RuleType?) {
        self._id = _id
        self.name = name
        self.senderId = senderId
        self.heartBeatTimeoutInMinutes = heartBeatTimeoutInMinutes
        self.enabled = enabled
        self.inAlarm = inAlarm
        self.notificationUsers = notificationUsers
        self.alertTypes = alertTypes
        self.ruleType = ruleType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case senderId
        case heartBeatTimeoutInMinutes
        case enabled
        case inAlarm
        case notificationUsers
        case alertTypes
        case ruleType
    }


}




public class KlaxonInteractionStatsAlertsTopicInteractionStatAlert: Codable {







    public enum Dimension: String, Codable { 
        case queueid = "queueId"
        case userid = "userId"
    }





    public enum Metric: String, Codable { 
        case tabandon = "tAbandon"
        case tanswered = "tAnswered"
        case ttalk = "tTalk"
        case noffered = "nOffered"
        case thandle = "tHandle"
        case ntransferred = "nTransferred"
        case oservicelevel = "oServiceLevel"
        case twait = "tWait"
        case theld = "tHeld"
        case tacw = "tAcw"
    }

    public enum MediaType: String, Codable { 
        case voice = "voice"
        case chat = "chat"
        case email = "email"
        case callback = "callback"
        case message = "message"
    }

    public enum NumericRange: String, Codable { 
        case gt = "gt"
        case gte = "gte"
        case lt = "lt"
        case lte = "lte"
        case eq = "eq"
        case ne = "ne"
    }

    public enum Statistic: String, Codable { 
        case count = "count"
        case min = "min"
        case ratio = "ratio"
        case max = "max"
    }











    public enum AlertTypes: String, Codable { 
        case sms = "SMS"
        case device = "DEVICE"
        case email = "EMAIL"
    }

    public var _id: String?
    public var name: String?
    public var ruleId: String?
    public var dimension: Dimension?
    public var dimensionValue: String?
    public var dimensionValueName: String?
    public var metric: Metric?
    public var mediaType: MediaType?
    public var numericRange: NumericRange?
    public var statistic: Statistic?
    public var value: Double?
    public var unread: Bool?
    public var startDate: Date?
    public var endDate: Date?
    public var notificationUsers: [KlaxonInteractionStatsAlertsTopicNotificationUser]?
    public var alertTypes: [AlertTypes]?

    public init(_id: String?, name: String?, ruleId: String?, dimension: Dimension?, dimensionValue: String?, dimensionValueName: String?, metric: Metric?, mediaType: MediaType?, numericRange: NumericRange?, statistic: Statistic?, value: Double?, unread: Bool?, startDate: Date?, endDate: Date?, notificationUsers: [KlaxonInteractionStatsAlertsTopicNotificationUser]?, alertTypes: [AlertTypes]?) {
        self._id = _id
        self.name = name
        self.ruleId = ruleId
        self.dimension = dimension
        self.dimensionValue = dimensionValue
        self.dimensionValueName = dimensionValueName
        self.metric = metric
        self.mediaType = mediaType
        self.numericRange = numericRange
        self.statistic = statistic
        self.value = value
        self.unread = unread
        self.startDate = startDate
        self.endDate = endDate
        self.notificationUsers = notificationUsers
        self.alertTypes = alertTypes
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case ruleId
        case dimension
        case dimensionValue
        case dimensionValueName
        case metric
        case mediaType
        case numericRange
        case statistic
        case value
        case unread
        case startDate
        case endDate
        case notificationUsers
        case alertTypes
    }


}




public class Knowledge: Codable {





    /** whether or not knowledge base is enabled */
    public var enabled: Bool?
    /** The knowledge base for messenger */
    public var knowledgeBase: AddressableEntityRef?

    public init(enabled: Bool?, knowledgeBase: AddressableEntityRef?) {
        self.enabled = enabled
        self.knowledgeBase = knowledgeBase
    }


}




public class KnowledgeAggregateQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case agentassistantid = "agentAssistantId"
        case appdeploymentid = "appDeploymentId"
        case apptype = "appType"
        case conversationchanneltype = "conversationChannelType"
        case conversationid = "conversationId"
        case documentengagementtype = "documentEngagementType"
        case externalcontactid = "externalContactId"
        case feedbackcategory = "feedbackCategory"
        case feedbackid = "feedbackId"
        case feedbackrating = "feedbackRating"
        case feedbackratingtype = "feedbackRatingType"
        case feedbackratingvalue = "feedbackRatingValue"
        case feedbackreason = "feedbackReason"
        case feedbacktype = "feedbackType"
        case hascomment = "hasComment"
        case hassearch = "hasSearch"
        case knowledgebasedocumentid = "knowledgeBaseDocumentId"
        case knowledgebasedocumentvariationid = "knowledgeBaseDocumentVariationId"
        case knowledgebasedocumentversionid = "knowledgeBaseDocumentVersionId"
        case knowledgebaseid = "knowledgeBaseId"
        case languagecode = "languageCode"
        case mediatype = "mediaType"
        case presenteddocumentscount = "presentedDocumentsCount"
        case querytype = "queryType"
        case queueid = "queueId"
        case searchid = "searchId"
        case searchquery = "searchQuery"
        case selfserved = "selfServed"
        case sessionid = "sessionId"
        case surfacingmethod = "surfacingMethod"
        case userid = "userId"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension predicates */
    public var value: String?
    /** Right hand side for dimension predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case _operator = "operator"
        case value
        case range
    }


}




public class KnowledgeBaseCreateRequest: Codable {





    public enum CoreLanguage: String, Codable { 
        case enUs = "en-US"
        case enUk = "en-UK"
        case enAu = "en-AU"
        case enCa = "en-CA"
        case enHk = "en-HK"
        case enIn = "en-IN"
        case enIe = "en-IE"
        case enNz = "en-NZ"
        case enPh = "en-PH"
        case enSg = "en-SG"
        case enZa = "en-ZA"
        case deDe = "de-DE"
        case deAt = "de-AT"
        case deCh = "de-CH"
        case esAr = "es-AR"
        case esCo = "es-CO"
        case esMx = "es-MX"
        case esUs = "es-US"
        case esEs = "es-ES"
        case frFr = "fr-FR"
        case frBe = "fr-BE"
        case frCa = "fr-CA"
        case frCh = "fr-CH"
        case ptBr = "pt-BR"
        case ptPt = "pt-PT"
        case nlNl = "nl-NL"
        case nlBe = "nl-BE"
        case itIt = "it-IT"
        case caEs = "ca-ES"
        case trTr = "tr-TR"
        case svSe = "sv-SE"
        case fiFi = "fi-FI"
        case nbNo = "nb-NO"
        case daDk = "da-DK"
        case jaJp = "ja-JP"
        case arAe = "ar-AE"
    }

    /** Knowledge base name */
    public var name: String?
    /** Knowledge base description */
    public var _description: String?
    /** Core language for knowledge base in which initial content must be created, language codes [en-US, en-UK, en-AU, de-DE] are supported currently. However, the new DX knowledge will support all these language codes, along with 'early preview' language codes [ca-ES, tr-TR, sv-SE, fi-FI, nb-NO, da-DK, ja-JP, ar-AE] which might have a lower accuracy. */
    public var coreLanguage: CoreLanguage?

    public init(name: String?, _description: String?, coreLanguage: CoreLanguage?) {
        self.name = name
        self._description = _description
        self.coreLanguage = coreLanguage
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _description = "description"
        case coreLanguage
    }


}




public class KnowledgeBaseReference: Codable {





    /** The globally unique identifier for the knowledge base. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class KnowledgeBaseUpdateRequest: Codable {





    /** Knowledge base name */
    public var name: String?
    /** Knowledge base description */
    public var _description: String?

    public init(name: String?, _description: String?) {
        self.name = name
        self._description = _description
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _description = "description"
    }


}




public class KnowledgeCategory: Codable {









    public enum LanguageCode: String, Codable { 
        case enUs = "en-US"
        case enUk = "en-UK"
        case enAu = "en-AU"
        case enCa = "en-CA"
        case enHk = "en-HK"
        case enIn = "en-IN"
        case enIe = "en-IE"
        case enNz = "en-NZ"
        case enPh = "en-PH"
        case enSg = "en-SG"
        case enZa = "en-ZA"
        case deDe = "de-DE"
        case deAt = "de-AT"
        case deCh = "de-CH"
        case esAr = "es-AR"
        case esCo = "es-CO"
        case esMx = "es-MX"
        case esUs = "es-US"
        case esEs = "es-ES"
        case frFr = "fr-FR"
        case frBe = "fr-BE"
        case frCa = "fr-CA"
        case frCh = "fr-CH"
        case ptBr = "pt-BR"
        case ptPt = "pt-PT"
        case nlNl = "nl-NL"
        case nlBe = "nl-BE"
        case itIt = "it-IT"
        case caEs = "ca-ES"
        case trTr = "tr-TR"
        case svSe = "sv-SE"
        case fiFi = "fi-FI"
        case nbNo = "nb-NO"
        case daDk = "da-DK"
        case jaJp = "ja-JP"
        case arAe = "ar-AE"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Category name */
    public var name: String?
    /** Category description */
    public var _description: String?
    /** Knowledge base which category does belong to */
    public var knowledgeBase: KnowledgeBase?
    /** Actual language of the category */
    public var languageCode: LanguageCode?
    /** Category creation date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Category last modification date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, knowledgeBase: KnowledgeBase?, languageCode: LanguageCode?, dateCreated: Date?, dateModified: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.knowledgeBase = knowledgeBase
        self.languageCode = languageCode
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case knowledgeBase
        case languageCode
        case dateCreated
        case dateModified
        case selfUri
    }


}




public class KnowledgeCategoryRequest: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Category name */
    public var name: String?
    /** Category description */
    public var _description: String?
    /** Category parent */
    public var parent: DocumentCategoryInput?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, parent: DocumentCategoryInput?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.parent = parent
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case parent
        case selfUri
    }


}




public class KnowledgeDocumentSuggestion: Codable {







    /** Query to get autocomplete suggestions for the matching knowledge documents. */
    public var query: String?
    /** Page size of the returned results. */
    public var pageSize: Int?
    /** Documents matching to the autocomplete suggestions query. */
    public var results: [KnowledgeDocumentSuggestionResult]?

    public init(query: String?, pageSize: Int?, results: [KnowledgeDocumentSuggestionResult]?) {
        self.query = query
        self.pageSize = pageSize
        self.results = results
    }


}




public class KnowledgeDocumentSuggestionRequest: Codable {











    /** Query to get autocomplete suggestions for the matching knowledge documents. */
    public var query: String?
    /** Page size of the returned results. */
    public var pageSize: Int?
    /** Indicates whether the suggestion results would also include draft documents. */
    public var includeDraftDocuments: Bool?
    /** Retrieves the documents created/modified/published in specified date and time range. */
    public var interval: DocumentQueryInterval?
    /** Filter for the document suggestions. */
    public var filter: DocumentQuery?

    public init(query: String?, pageSize: Int?, includeDraftDocuments: Bool?, interval: DocumentQueryInterval?, filter: DocumentQuery?) {
        self.query = query
        self.pageSize = pageSize
        self.includeDraftDocuments = includeDraftDocuments
        self.interval = interval
        self.filter = filter
    }


}




public class KnowledgeDocumentSuggestionResultDocument: Codable {









    /** The globally unique identifier for the document. */
    public var _id: String?
    /** The knowledge base that the document belongs to. */
    public var knowledgeBase: KnowledgeBaseReference?
    /** The title of the document. */
    public var title: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, knowledgeBase: KnowledgeBaseReference?, title: String?, selfUri: String?) {
        self._id = _id
        self.knowledgeBase = knowledgeBase
        self.title = title
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case knowledgeBase
        case title
        case selfUri
    }


}




public class KnowledgeDocumentVersionVariationReference: Codable {







    /** The ID of the document. */
    public var documentId: String?
    /** The variation of the document. */
    public var documentVariationId: String?
    /** The version of the document. */
    public var documentVersionId: String?

    public init(documentId: String?, documentVariationId: String?, documentVersionId: String?) {
        self.documentId = documentId
        self.documentVariationId = documentVariationId
        self.documentVersionId = documentVersionId
    }


}




public class KnowledgeExportJobDocumentsFilter: Codable {





    /** Retrieves the documents modified in specified date and time range. Cannot be used together with entities filter. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Retrieves the documents with the given ids. Cannot be used together with internal filter. */
    public var entities: [Entity]?

    public init(interval: String?, entities: [Entity]?) {
        self.interval = interval
        self.entities = entities
    }


}




public class KnowledgeExportJobRequest: Codable {



    public enum FileType: String, Codable { 
        case json = "Json"
        case csv = "Csv"
        case xlsx = "Xlsx"
    }



    /** What to export. */
    public var exportFilter: KnowledgeExportJobFilter?
    /** File type of the document */
    public var fileType: FileType?
    /** Requested version of the exported json file. Available versions are 2 and 3, default is 2 */
    public var jsonFileVersion: Int?

    public init(exportFilter: KnowledgeExportJobFilter?, fileType: FileType?, jsonFileVersion: Int?) {
        self.exportFilter = exportFilter
        self.fileType = fileType
        self.jsonFileVersion = jsonFileVersion
    }


}




public class KnowledgeGuestDocumentSuggestion: Codable {









    /** Query to get autocomplete suggestions for the matching knowledge documents. */
    public var query: String?
    /** Page size of the returned results. */
    public var pageSize: Int?
    /** Session ID of the guest suggestions. */
    public var sessionId: String?
    /** Suggestions matching the query. */
    public var results: [KnowledgeGuestDocumentSuggestionResult]?

    public init(query: String?, pageSize: Int?, sessionId: String?, results: [KnowledgeGuestDocumentSuggestionResult]?) {
        self.query = query
        self.pageSize = pageSize
        self.sessionId = sessionId
        self.results = results
    }


}




public class KnowledgeGuestDocumentSuggestionRequest: Codable {







    /** Query to get autocomplete suggestions for the matching knowledge documents. */
    public var query: String?
    /** Page size of the returned results. */
    public var pageSize: Int?
    /** Indicates whether the suggestion results would also include draft documents. */
    public var includeDraftDocuments: Bool?

    public init(query: String?, pageSize: Int?, includeDraftDocuments: Bool?) {
        self.query = query
        self.pageSize = pageSize
        self.includeDraftDocuments = includeDraftDocuments
    }


}




public class KnowledgeGuestSearchClientApplication: Codable {

    public enum ModelType: String, Codable { 
        case assistant = "Assistant"
        case botFlow = "BotFlow"
        case messengerKnowledgeApp = "MessengerKnowledgeApp"
        case smartAdvisor = "SmartAdvisor"
        case supportCenter = "SupportCenter"
    }







    /** Application type. */
    public var type: ModelType?
    /** Application details when type is MessengerKnowledgeApp or SupportCenter. */
    public var deployment: EntityReference?
    /** Application details when type is BotFlow. */
    public var botFlow: EntityReference?
    /** Application details when type is Assistant. */
    public var assistant: EntityReference?

    public init(type: ModelType?, deployment: EntityReference?, botFlow: EntityReference?, assistant: EntityReference?) {
        self.type = type
        self.deployment = deployment
        self.botFlow = botFlow
        self.assistant = assistant
    }


}




public class KnowledgeGuestSession: Codable {











    /** Session ID. */
    public var _id: String?
    /** The app where the session is started. */
    public var app: KnowledgeGuestSessionApp?
    /** An arbitrary ID for the customer starting the session. Used to track multiple sessions started by the same customer. */
    public var customerId: String?
    /** URL of the page where the session is started. */
    public var pageUrl: String?
    /** The session contexts. */
    public var contexts: [KnowledgeGuestSessionContext]?

    public init(_id: String?, app: KnowledgeGuestSessionApp?, customerId: String?, pageUrl: String?, contexts: [KnowledgeGuestSessionContext]?) {
        self._id = _id
        self.app = app
        self.customerId = customerId
        self.pageUrl = pageUrl
        self.contexts = contexts
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case app
        case customerId
        case pageUrl
        case contexts
    }


}




public class KnowledgeImport: Codable {







    public enum FileType: String, Codable { 
        case csv = "Csv"
        case jsonLines = "JsonLines"
    }



    public enum Status: String, Codable { 
        case created = "Created"
        case validationInProgress = "ValidationInProgress"
        case validationCompleted = "ValidationCompleted"
        case validationFailed = "ValidationFailed"
        case started = "Started"
        case inProgress = "InProgress"
        case completed = "Completed"
        case partialCompleted = "PartialCompleted"
        case failed = "Failed"
        case abortRequested = "AbortRequested"
        case aborted = "Aborted"
    }





    public enum LanguageCode: String, Codable { 
        case enUs = "en-US"
        case enUk = "en-UK"
        case enAu = "en-AU"
        case enCa = "en-CA"
        case enHk = "en-HK"
        case enIn = "en-IN"
        case enIe = "en-IE"
        case enNz = "en-NZ"
        case enPh = "en-PH"
        case enSg = "en-SG"
        case enZa = "en-ZA"
        case deDe = "de-DE"
        case deAt = "de-AT"
        case deCh = "de-CH"
        case esAr = "es-AR"
        case esCo = "es-CO"
        case esMx = "es-MX"
        case esUs = "es-US"
        case esEs = "es-ES"
        case frFr = "fr-FR"
        case frBe = "fr-BE"
        case frCa = "fr-CA"
        case frCh = "fr-CH"
        case ptBr = "pt-BR"
        case ptPt = "pt-PT"
        case nlNl = "nl-NL"
        case nlBe = "nl-BE"
        case itIt = "it-IT"
        case caEs = "ca-ES"
        case trTr = "tr-TR"
        case svSe = "sv-SE"
        case fiFi = "fi-FI"
        case nbNo = "nb-NO"
        case daDk = "da-DK"
        case jaJp = "ja-JP"
        case arAe = "ar-AE"
    }







    /** Id of the import operation */
    public var _id: String?
    /** Name of the import operation */
    public var name: String?
    /** Upload key */
    public var uploadKey: String?
    /** file type of the document */
    public var fileType: FileType?
    /** Ignore headers for the specified file */
    public var ignoreHeaders: Bool?
    /** Status of the operation */
    public var status: Status?
    /** Report of the import operation */
    public var report: ImportReport?
    /** Knowledge base which document import does belong to */
    public var knowledgeBase: KnowledgeBase?
    /** Language code */
    public var languageCode: LanguageCode?
    /** Created date. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified date. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, uploadKey: String?, fileType: FileType?, ignoreHeaders: Bool?, status: Status?, report: ImportReport?, knowledgeBase: KnowledgeBase?, languageCode: LanguageCode?, dateCreated: Date?, dateModified: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.uploadKey = uploadKey
        self.fileType = fileType
        self.ignoreHeaders = ignoreHeaders
        self.status = status
        self.report = report
        self.knowledgeBase = knowledgeBase
        self.languageCode = languageCode
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case uploadKey
        case fileType
        case ignoreHeaders
        case status
        case report
        case knowledgeBase
        case languageCode
        case dateCreated
        case dateModified
        case selfUri
    }


}




public class KnowledgeImportJobError: Codable {

























    public var message: String?
    public var code: String?
    public var status: Int?
    public var entityId: String?
    public var entityName: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var contextId: String?
    public var details: [Detail]?
    public var errors: [ErrorBody]?
    public var limit: Limit?
    /** Index of the faulty document. */
    public var documentIndex: Int?

    public init(message: String?, code: String?, status: Int?, entityId: String?, entityName: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, details: [Detail]?, errors: [ErrorBody]?, limit: Limit?, documentIndex: Int?) {
        self.message = message
        self.code = code
        self.status = status
        self.entityId = entityId
        self.entityName = entityName
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.details = details
        self.errors = errors
        self.limit = limit
        self.documentIndex = documentIndex
    }


}




public class KnowledgeImportJobResponse: Codable {









    public enum FileType: String, Codable { 
        case json = "Json"
        case csv = "Csv"
        case xlsx = "Xlsx"
    }



    public enum Status: String, Codable { 
        case created = "Created"
        case validationInProgress = "ValidationInProgress"
        case validationCompleted = "ValidationCompleted"
        case validationFailed = "ValidationFailed"
        case started = "Started"
        case inProgress = "InProgress"
        case completed = "Completed"
        case partialCompleted = "PartialCompleted"
        case failed = "Failed"
        case abortRequested = "AbortRequested"
        case aborted = "Aborted"
    }















    /** Id of the import job */
    public var _id: String?
    /** The URL of the location at which the caller can download the imported file. */
    public var downloadURL: String?
    /** The URL of the location at which the caller can download the entities in json format that failed during the import. */
    public var failedEntitiesURL: String?
    /** Upload key */
    public var uploadKey: String?
    /** File type of the document */
    public var fileType: FileType?
    /** Additional optional settings */
    public var settings: KnowledgeImportJobSettings?
    /** Status of the import job */
    public var status: Status?
    /** Report of the import job */
    public var report: KnowledgeImportJobReport?
    /** Knowledge base which document import does belong to */
    public var knowledgeBase: KnowledgeBase?
    /** The user who created the operation */
    public var createdBy: UserReference?
    /** Created date. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified date. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** If enabled pre-validation step will be skipped. */
    public var skipConfirmationStep: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, downloadURL: String?, failedEntitiesURL: String?, uploadKey: String?, fileType: FileType?, settings: KnowledgeImportJobSettings?, status: Status?, report: KnowledgeImportJobReport?, knowledgeBase: KnowledgeBase?, createdBy: UserReference?, dateCreated: Date?, dateModified: Date?, skipConfirmationStep: Bool?, selfUri: String?) {
        self._id = _id
        self.downloadURL = downloadURL
        self.failedEntitiesURL = failedEntitiesURL
        self.uploadKey = uploadKey
        self.fileType = fileType
        self.settings = settings
        self.status = status
        self.report = report
        self.knowledgeBase = knowledgeBase
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.skipConfirmationStep = skipConfirmationStep
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case downloadURL
        case failedEntitiesURL
        case uploadKey
        case fileType
        case settings
        case status
        case report
        case knowledgeBase
        case createdBy
        case dateCreated
        case dateModified
        case skipConfirmationStep
        case selfUri
    }


}




public class KnowledgeImportJobStatistics: Codable {



































    /** Number of documents will be created by the import. */
    public var countDocumentImportActivityCreate: Int?
    /** Number of documents will be updated by the import. */
    public var countDocumentImportActivityUpdate: Int?
    /** Number of documents will be imported as draft. */
    public var countDocumentStateDraft: Int?
    /** Number of documents will be imported as published. */
    public var countDocumentStatePublished: Int?
    /** Number of documents that validated successfully for import. */
    public var countDocumentValidationSuccess: Int?
    /** Number of documents that failed validation for import. */
    public var countDocumentValidationFailure: Int?
    /** Number of imported documents. */
    public var countDocumentImportSuccess: Int?
    /** Number of documents failed to import. */
    public var countDocumentImportFailure: Int?
    /** Number of categories that validated successfully for import. */
    public var countCategoryValidationSuccess: Int?
    /** Number of categories that failed validation for import. */
    public var countCategoryValidationFailure: Int?
    /** Number of imported categories. */
    public var countCategoryImportSuccess: Int?
    /** Number of categories failed to import. */
    public var countCategoryImportFailure: Int?
    /** Number of labels that validated successfully for import. */
    public var countLabelValidationSuccess: Int?
    /** Number of labels that failed validation for import. */
    public var countLabelValidationFailure: Int?
    /** Number of imported labels. */
    public var countLabelImportSuccess: Int?
    /** Number of labels failed to import. */
    public var countLabelImportFailure: Int?
    /** Shows whether the import treated as migration or not. */
    public var migrationDetected: Bool?

    public init(countDocumentImportActivityCreate: Int?, countDocumentImportActivityUpdate: Int?, countDocumentStateDraft: Int?, countDocumentStatePublished: Int?, countDocumentValidationSuccess: Int?, countDocumentValidationFailure: Int?, countDocumentImportSuccess: Int?, countDocumentImportFailure: Int?, countCategoryValidationSuccess: Int?, countCategoryValidationFailure: Int?, countCategoryImportSuccess: Int?, countCategoryImportFailure: Int?, countLabelValidationSuccess: Int?, countLabelValidationFailure: Int?, countLabelImportSuccess: Int?, countLabelImportFailure: Int?, migrationDetected: Bool?) {
        self.countDocumentImportActivityCreate = countDocumentImportActivityCreate
        self.countDocumentImportActivityUpdate = countDocumentImportActivityUpdate
        self.countDocumentStateDraft = countDocumentStateDraft
        self.countDocumentStatePublished = countDocumentStatePublished
        self.countDocumentValidationSuccess = countDocumentValidationSuccess
        self.countDocumentValidationFailure = countDocumentValidationFailure
        self.countDocumentImportSuccess = countDocumentImportSuccess
        self.countDocumentImportFailure = countDocumentImportFailure
        self.countCategoryValidationSuccess = countCategoryValidationSuccess
        self.countCategoryValidationFailure = countCategoryValidationFailure
        self.countCategoryImportSuccess = countCategoryImportSuccess
        self.countCategoryImportFailure = countCategoryImportFailure
        self.countLabelValidationSuccess = countLabelValidationSuccess
        self.countLabelValidationFailure = countLabelValidationFailure
        self.countLabelImportSuccess = countLabelImportSuccess
        self.countLabelImportFailure = countLabelImportFailure
        self.migrationDetected = migrationDetected
    }


}




public class KnowledgeSearchClientApplication: Codable {

    public enum ModelType: String, Codable { 
        case assistant = "Assistant"
        case botFlow = "BotFlow"
        case messengerKnowledgeApp = "MessengerKnowledgeApp"
        case smartAdvisor = "SmartAdvisor"
        case supportCenter = "SupportCenter"
    }







    /** Application type. */
    public var type: ModelType?
    /** Application details when type is MessengerKnowledgeApp or SupportCenter. */
    public var deployment: AddressableEntityRef?
    /** Application details when type is BotFlow. */
    public var botFlow: AddressableEntityRef?
    /** Application details when type is Assistant. */
    public var assistant: AddressableEntityRef?

    public init(type: ModelType?, deployment: AddressableEntityRef?, botFlow: AddressableEntityRef?, assistant: AddressableEntityRef?) {
        self.type = type
        self.deployment = deployment
        self.botFlow = botFlow
        self.assistant = assistant
    }


}




public class KnowledgeSearchResponse: Codable {













    /** Search Id */
    public var searchId: String?
    /** Total number of records returned */
    public var total: Int?
    /** Number of pages returned in the result calculated according to the pageSize and the total */
    public var pageCount: Int?
    /** Number of records according to the page size */
    public var pageSize: Int?
    /** Current page number for the returned records */
    public var pageNumber: Int?
    /** Results associated to the search response */
    public var results: [KnowledgeSearchDocument]?

    public init(searchId: String?, total: Int?, pageCount: Int?, pageSize: Int?, pageNumber: Int?, results: [KnowledgeSearchDocument]?) {
        self.searchId = searchId
        self.total = total
        self.pageCount = pageCount
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.results = results
    }


}




public class LastAttemptOverallConditionSettings: Codable {

    public enum MediaTypes: String, Codable { 
        case voice = "Voice"
        case email = "Email"
        case sms = "Sms"
    }

    public enum Operator: String, Codable { 
        case before = "Before"
        case after = "After"
    }



    /** A list of media types to evaluate. */
    public var mediaTypes: [MediaTypes]?
    /** The operator to use when comparing values. */
    public var _operator: Operator?
    /** The period value to compare against the contact's data. */
    public var value: String?

    public init(mediaTypes: [MediaTypes]?, _operator: Operator?, value: String?) {
        self.mediaTypes = mediaTypes
        self._operator = _operator
        self.value = value
    }

    public enum CodingKeys: String, CodingKey { 
        case mediaTypes
        case _operator = "operator"
        case value
    }


}



/** The settings for the launcher button */

public class LauncherButtonSettings: Codable {

    public enum Visibility: String, Codable { 
        case on = "On"
        case off = "Off"
        case onDemand = "OnDemand"
    }

    /** The visibility settings for the button */
    public var visibility: Visibility?

    public init(visibility: Visibility?) {
        self.visibility = visibility
    }


}




public class LeaderboardItem: Codable {







    /** The user object for this leaderboard rank */
    public var user: UserReference?
    /** The rank of the user */
    public var rank: Int?
    /** The points collected by the user */
    public var points: Int64?

    public init(user: UserReference?, rank: Int?, points: Int64?) {
        self.user = user
        self.rank = rank
        self.points = points
    }


}




public class LearningAssessment: Codable {







    public enum Status: String, Codable { 
        case pending = "Pending"
        case inProgress = "InProgress"
        case finished = "Finished"
    }









    /** The Id of the assessment */
    public var assessmentId: String?
    /** The context Id of the related assessment form */
    public var contextId: String?
    /** The Id of the related assessment form */
    public var assessmentFormId: String?
    /** Status of the assessment */
    public var status: Status?
    /** Answers for the assessment */
    public var answers: AssessmentScoringSet?
    /** Date the assessment was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date the assessment was last updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Date the assessment was submitted. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateSubmitted: Date?

    public init(assessmentId: String?, contextId: String?, assessmentFormId: String?, status: Status?, answers: AssessmentScoringSet?, dateCreated: Date?, dateModified: Date?, dateSubmitted: Date?) {
        self.assessmentId = assessmentId
        self.contextId = contextId
        self.assessmentFormId = assessmentFormId
        self.status = status
        self.answers = answers
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.dateSubmitted = dateSubmitted
    }


}




public class LearningAssessmentScoringRequest: Codable {





    /** The assessment form to score against */
    public var assessmentForm: AssessmentForm?
    /** The answers to score */
    public var answers: AssessmentScoringSet?

    public init(assessmentForm: AssessmentForm?, answers: AssessmentScoringSet?) {
        self.assessmentForm = assessmentForm
        self.answers = answers
    }


}




public class LearningAssignmentAggregateQueryResponseGroupedData: Codable {





    /** The group values for this data */
    public var group: [String:String]?
    /** The metrics in this group */
    public var data: [LearningAssignmentAggregateQueryResponseData]?

    public init(group: [String:String]?, data: [LearningAssignmentAggregateQueryResponseData]?) {
        self.group = group
        self.data = data
    }


}




public class LearningAssignmentReassign: Codable {





    /** The recommended completion date of assignment. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var recommendedCompletionDate: Date?
    /** The length in minutes of assignment */
    public var lengthInMinutes: Int?

    public init(recommendedCompletionDate: Date?, lengthInMinutes: Int?) {
        self.recommendedCompletionDate = recommendedCompletionDate
        self.lengthInMinutes = lengthInMinutes
    }


}




public class LearningAssignmentReschedule: Codable {





    /** The recommended completion date of the assignment. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateRecommendedForCompletion: Date?
    /** The length in minutes of the assignment */
    public var lengthInMinutes: Int?

    public init(dateRecommendedForCompletion: Date?, lengthInMinutes: Int?) {
        self.dateRecommendedForCompletion = dateRecommendedForCompletion
        self.lengthInMinutes = lengthInMinutes
    }


}



/** Learning module cover art response */

public class LearningModuleCoverArtResponse: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?
    /** The URL for the cover art */
    public var url: String?
    /** Thumbnails for the cover art */
    public var thumbnails: [LearningCoverArtThumbnail]?

    public init(_id: String?, selfUri: String?, url: String?, thumbnails: [LearningCoverArtThumbnail]?) {
        self._id = _id
        self.selfUri = selfUri
        self.url = url
        self.thumbnails = thumbnails
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case url
        case thumbnails
    }


}



/** Learning module job request */

public class LearningModuleJobRequest: Codable {

    public enum Action: String, Codable { 
        case reassign = "Reassign"
        case gracefulArchive = "GracefulArchive"
        case immediateArchive = "ImmediateArchive"
        case unarchive = "Unarchive"
    }

    /** The type for the learning module job */
    public var action: Action?

    public init(action: Action?) {
        self.action = action
    }


}



/** Learning module reassign summary data */

public class LearningModuleReassignSummary: Codable {











    /** The total number of users for whom assignment is reassigned */
    public var totalReassigned: Int?
    /** The total number of users who have the assignment in Completed state */
    public var completedCount: Int?
    /** The total number of users who have the assignment in InProgress state */
    public var inProgressCount: Int?
    /** The total number of users who have the assignment in Assigned state */
    public var assignedCount: Int?
    /** The total number of users who have their assignment overdue */
    public var notCompletedCount: Int?

    public init(totalReassigned: Int?, completedCount: Int?, inProgressCount: Int?, assignedCount: Int?, notCompletedCount: Int?) {
        self.totalReassigned = totalReassigned
        self.completedCount = completedCount
        self.inProgressCount = inProgressCount
        self.assignedCount = assignedCount
        self.notCompletedCount = notCompletedCount
    }


}




public class LearningModuleRule: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** If true, rule is active */
    public var isActive: Bool?
    /** The parts of a learning module rule */
    public var parts: [LearningModuleRuleParts]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, isActive: Bool?, parts: [LearningModuleRuleParts]?, selfUri: String?) {
        self._id = _id
        self.isActive = isActive
        self.parts = parts
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case isActive
        case parts
        case selfUri
    }


}




public class LearningScheduleSlotsQueryResponse: Codable {





    /** List of slots where Learning activity can be scheduled */
    public var suggestedSlots: [LearningSlot]?
    /** Detailed data for WFM scheduled activities */
    public var wfmScheduleActivities: [LearningSlotWfmScheduleActivity]?

    public init(suggestedSlots: [LearningSlot]?, wfmScheduleActivities: [LearningSlotWfmScheduleActivity]?) {
        self.suggestedSlots = suggestedSlots
        self.wfmScheduleActivities = wfmScheduleActivities
    }


}




public class LexIntent: Codable {









    /** The intent name */
    public var name: String?
    /** A description of the intent */
    public var _description: String?
    /** An object mapping slot names to Slot objects */
    public var slots: [String:LexSlot]?
    /** The intent version */
    public var version: String?

    public init(name: String?, _description: String?, slots: [String:LexSlot]?, version: String?) {
        self.name = name
        self._description = _description
        self.slots = slots
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _description = "description"
        case slots
        case version
    }


}




public class LexV2BotAliasEntityListing: Codable {





















    public var entities: [LexV2BotAlias]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [LexV2BotAlias]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class LexV2BotEntityListing: Codable {





















    public var entities: [LexV2Bot]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [LexV2Bot]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class LicenseBatchAssignmentRequest: Codable {



    /** The list of license assignment updates to make. */
    public var assignments: [LicenseAssignmentRequest]?

    public init(assignments: [LicenseAssignmentRequest]?) {
        self.assignments = assignments
    }


}




public class LicenseOrgToggle: Codable {





    public var featureName: String?
    public var enabled: Bool?

    public init(featureName: String?, enabled: Bool?) {
        self.featureName = featureName
        self.enabled = enabled
    }


}




public class LimitChangeRequestDetails: Codable {





    public enum Namespace: String, Codable { 
        case agentAssistant = "agent.assistant"
        case analyticsAlerting = "analytics.alerting"
        case analytics = "analytics"
        case analyticsRealtime = "analytics.realtime"
        case analyticsReportingSettings = "analytics.reporting.settings"
        case architect = "architect"
        case audiohook = "audiohook"
        case audit = "audit"
        case authApi = "auth.api"
        case authorization = "authorization"
        case automationTesting = "automation.testing"
        case bots = "bots"
        case botsVoice = "bots.voice"
        case callback = "callback"
        case cobrowse = "cobrowse"
        case contentManagement = "content.management"
        case conversation = "conversation"
        case dataactions = "dataactions"
        case datatables = "datatables"
        case directory = "directory"
        case email = "email"
        case employeeEngagement = "employee.engagement"
        case eventOrchestration = "event.orchestration"
        case externalContacts = "external.contacts"
        case gcv = "gcv"
        case gdpr = "gdpr"
        case groups = "groups"
        case historicalAdherence = "historical.adherence"
        case infrastructureascode = "infrastructureascode"
        case integrations = "integrations"
        case intentMiner = "intent.miner"
        case journey = "journey"
        case knowledge = "knowledge"
        case languageUnderstanding = "language.understanding"
        case learning = "learning"
        case limitRegistry = "limit.registry"
        case marketplace = "marketplace"
        case mediaCommunications = "media.communications"
        case messaging = "messaging"
        case notifications = "notifications"
        case onboarding = "onboarding"
        case outbound = "outbound"
        case platformApi = "platform.api"
        case predictiveRouting = "predictive.routing"
        case presence = "presence"
        case quality = "quality"
        case recording = "recording"
        case responseManagement = "response.management"
        case routing = "routing"
        case scim = "scim"
        case search = "search"
        case secondaryAutomationTesting = "secondary.automation.testing"
        case skills = "skills"
        case speechAndTextAnalytics = "speech.and.text.analytics"
        case speechIntegration = "speech.integration"
        case supportability = "supportability"
        case taskManagement = "task.management"
        case telephonyConfiguration = "telephony.configuration"
        case usage = "usage"
        case users = "users"
        case webDeployments = "web.deployments"
        case webMessaging = "web.messaging"
        case webchat = "webchat"
        case webhooks = "webhooks"
        case workforceManagement = "workforce.management"
    }







    public enum Status: String, Codable { 
        case approved = "Approved"
        case rejected = "Rejected"
        case rollback = "Rollback"
        case pending = "Pending"
        case _open = "Open"
        case secondaryApprovalNamespacesAdded = "SecondaryApprovalNamespacesAdded"
        case reviewerApproved = "ReviewerApproved"
        case reviewerRejected = "ReviewerRejected"
        case reviewerRollback = "ReviewerRollback"
        case implementingChange = "ImplementingChange"
        case changeImplemented = "ChangeImplemented"
        case implementingRollback = "ImplementingRollback"
        case rollbackImplemented = "RollbackImplemented"
    }









    public enum RejectReason: String, Codable { 
        case alternativeExists = "AlternativeExists"
        case increaseNotRequired = "IncreaseNotRequired"
        case platformMisuse = "PlatformMisuse"
        case platformStability = "PlatformStability"
        case otherReason = "OtherReason"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Limit key to be overridden (see https://developer.mypurecloud.com/api/rest/v2/organization/limits.html#available_limits) */
    public var key: String?
    /** Namespace the key belongs to (see https://developer.mypurecloud.com/api/rest/v2/organization/limits.html#available_limits) */
    public var namespace: Namespace?
    /** Requested limit value for a given key */
    public var requestedValue: Double?
    /** Description of the need for the limit change request */
    public var _description: String?
    /** The support case url created by Care */
    public var supportCaseUrl: String?
    /** Current status of the limit change request */
    public var status: Status?
    /** Current limit value for a given key */
    public var currentValue: Double?
    /** The date of the limit change request creation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** List of statuses that a limit change request has gone through */
    public var statusHistory: [StatusChange]?
    /** The date of the limit change request completion (ChangeImplemented, Rejected, or RollbackImplemented. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCompleted: Date?
    /** The reason for rejecting the limit override request */
    public var rejectReason: RejectReason?
    /** The approval breakdown for this override request. */
    public var approvalNamespaces: [ApprovalNamespace]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, key: String?, namespace: Namespace?, requestedValue: Double?, _description: String?, supportCaseUrl: String?, status: Status?, currentValue: Double?, dateCreated: Date?, statusHistory: [StatusChange]?, dateCompleted: Date?, rejectReason: RejectReason?, approvalNamespaces: [ApprovalNamespace]?, selfUri: String?) {
        self._id = _id
        self.key = key
        self.namespace = namespace
        self.requestedValue = requestedValue
        self._description = _description
        self.supportCaseUrl = supportCaseUrl
        self.status = status
        self.currentValue = currentValue
        self.dateCreated = dateCreated
        self.statusHistory = statusHistory
        self.dateCompleted = dateCompleted
        self.rejectReason = rejectReason
        self.approvalNamespaces = approvalNamespaces
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case key
        case namespace
        case requestedValue
        case _description = "description"
        case supportCaseUrl
        case status
        case currentValue
        case dateCreated
        case statusHistory
        case dateCompleted
        case rejectReason
        case approvalNamespaces
        case selfUri
    }


}




public class LimitsEntityListing: Codable {



    public var entities: [Limit]?

    public init(entities: [Limit]?) {
        self.entities = entities
    }


}




public class LineBaseEntityListing: Codable {





















    public var entities: [LineBase]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [LineBase]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class LineIntegration: Codable {



























    public enum CreateStatus: String, Codable { 
        case initiated = "Initiated"
        case completed = "Completed"
        case error = "Error"
    }





    /** A unique Integration Id */
    public var _id: String?
    /** The name of the LINE Integration */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    public var messagingSetting: MessagingSettingReference?
    /** The Channel Id from LINE messenger */
    public var channelId: String?
    /** The Webhook URI to be updated in LINE platform */
    public var webhookUri: String?
    /** The status of the LINE Integration */
    public var status: String?
    /** The recipient associated to the Line Integration. This recipient is used to associate a flow to an integration */
    public var recipient: DomainEntityRef?
    /** Date this Integration was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date this Integration was modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** User reference that created this Integration */
    public var createdBy: DomainEntityRef?
    /** User reference that last modified this Integration */
    public var modifiedBy: DomainEntityRef?
    /** Version number required for updates. */
    public var version: Int?
    /** Status of asynchronous create operation */
    public var createStatus: CreateStatus?
    /** Error information returned, if createStatus is set to Error */
    public var createError: ErrorBody?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingReference?, channelId: String?, webhookUri: String?, status: String?, recipient: DomainEntityRef?, dateCreated: Date?, dateModified: Date?, createdBy: DomainEntityRef?, modifiedBy: DomainEntityRef?, version: Int?, createStatus: CreateStatus?, createError: ErrorBody?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.channelId = channelId
        self.webhookUri = webhookUri
        self.status = status
        self.recipient = recipient
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.version = version
        self.createStatus = createStatus
        self.createError = createError
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case channelId
        case webhookUri
        case status
        case recipient
        case dateCreated
        case dateModified
        case createdBy
        case modifiedBy
        case version
        case createStatus
        case createError
        case selfUri
    }


}




public class LineIntegrationRequest: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the LINE Integration */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    /** Defines the message settings to be applied for this integration */
    public var messagingSetting: MessagingSettingRequestReference?
    /** The Channel Id from LINE messenger. New Official LINE account: To create a new official account, LINE requires a Webhook URL. It can be created without specifying Channel Id & Channel Secret. Once the Official account is created by LINE, use the update LINE Integration API to update Channel Id and Channel Secret.  All other accounts: Channel Id is mandatory. (NOTE: ChannelId can only be updated if the integration is set to inactive) */
    public var channelId: String?
    /** The Channel Secret from LINE messenger. New Official LINE account: To create a new official account, LINE requires a Webhook URL. It can be created without specifying Channel Id & Channel Secret. Once the Official account is created by LINE, use the update LINE Integration API to update Channel Id and Channel Secret.  All other accounts: Channel Secret is mandatory. (NOTE: ChannelSecret can only be updated if the integration is set to inactive) */
    public var channelSecret: String?
    /** The Switcher Secret from LINE messenger. Some line official accounts are switcher functionality enabled. If the LINE account used for this integration is switcher enabled, then switcher secret is a required field. This secret can be found in your create documentation provided by LINE */
    public var switcherSecret: String?
    /** The Service Code from LINE messenger. Only applicable to LINE Enterprise accounts. This service code can be found in your create documentation provided by LINE */
    public var serviceCode: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingRequestReference?, channelId: String?, channelSecret: String?, switcherSecret: String?, serviceCode: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.channelId = channelId
        self.channelSecret = channelSecret
        self.switcherSecret = switcherSecret
        self.serviceCode = serviceCode
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case channelId
        case channelSecret
        case switcherSecret
        case serviceCode
        case selfUri
    }


}



/** An entry in a List template. */

public class ListItemComponent: Codable {





    public enum ModelType: String, Codable { 
        case listItem = "ListItem"
        case listItemBig = "ListItemBig"
    }









    /** An ID assigned to this list item. */
    public var _id: String?
    /** An ID of the rich message instance. */
    public var rmid: String?
    /** The type of list item to render. */
    public var type: ModelType?
    /** URL of an image. */
    public var image: String?
    /** The main headline of the list item. */
    public var title: String?
    /** Text to show in the list item description. */
    public var _description: String?
    /** The list item actions (Deprecated). */
    public var actions: ContentActions?

    public init(_id: String?, rmid: String?, type: ModelType?, image: String?, title: String?, _description: String?, actions: ContentActions?) {
        self._id = _id
        self.rmid = rmid
        self.type = type
        self.image = image
        self.title = title
        self._description = _description
        self.actions = actions
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case rmid
        case type
        case image
        case title
        case _description = "description"
        case actions
    }


}




public class LocaleFlowVersionInfo: Codable {



    /** NLU Version Info for this flow version. */
    public var nluVersion: AddressableEntityRef?

    public init(nluVersion: AddressableEntityRef?) {
        self.nluVersion = nluVersion
    }


}




public class LocaleInfo: Codable {

    public enum Status: String, Codable { 
        case inProgress = "InProgress"
        case completed = "Completed"
        case error = "Error"
    }





    /** Status of health computation for this flow version. */
    public var status: Status?
    /** Error details for the flow version, if any. */
    public var errorInfo: FlowHealthErrorInfo?
    /** Info about given flow version. */
    public var flowVersionInfo: LocaleFlowVersionInfo?

    public init(status: Status?, errorInfo: FlowHealthErrorInfo?, flowVersionInfo: LocaleFlowVersionInfo?) {
        self.status = status
        self.errorInfo = errorInfo
        self.flowVersionInfo = flowVersionInfo
    }


}




public class LocationDefinition: Codable {











    public enum State: String, Codable { 
        case active = "active"
        case deleted = "deleted"
    }





















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Site contact for the location entity */
    public var contactUser: AddressableEntityRef?
    /** Emergency number for the location entity */
    public var emergencyNumber: LocationEmergencyNumber?
    public var address: LocationAddress?
    /** Current state of the location entity */
    public var state: State?
    /** Notes for the location entity */
    public var notes: String?
    /** Current version of the location entity, value to be supplied should be retrieved by a GET or on create/update response */
    public var version: Int?
    /** A list of ancestor IDs in order */
    public var path: [String]?
    /** Profile image of the location entity, retrieved with ?expand=images query parameter */
    public var profileImage: [LocationImage]?
    /** Floorplan images of the location entity, retrieved with ?expand=images query parameter */
    public var floorplanImage: [LocationImage]?
    /** Address verification information, retrieve dwith the ?expand=addressVerificationDetails query parameter */
    public var addressVerificationDetails: LocationAddressVerificationDetails?
    /** Boolean field which states if the address has been verified as an actual address */
    public var addressVerified: Bool?
    /** Boolean field which states if the address has been stored for E911 */
    public var addressStored: Bool?
    public var images: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, contactUser: AddressableEntityRef?, emergencyNumber: LocationEmergencyNumber?, address: LocationAddress?, state: State?, notes: String?, version: Int?, path: [String]?, profileImage: [LocationImage]?, floorplanImage: [LocationImage]?, addressVerificationDetails: LocationAddressVerificationDetails?, addressVerified: Bool?, addressStored: Bool?, images: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.contactUser = contactUser
        self.emergencyNumber = emergencyNumber
        self.address = address
        self.state = state
        self.notes = notes
        self.version = version
        self.path = path
        self.profileImage = profileImage
        self.floorplanImage = floorplanImage
        self.addressVerificationDetails = addressVerificationDetails
        self.addressVerified = addressVerified
        self.addressStored = addressStored
        self.images = images
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case contactUser
        case emergencyNumber
        case address
        case state
        case notes
        case version
        case path
        case profileImage
        case floorplanImage
        case addressVerificationDetails
        case addressVerified
        case addressStored
        case images
        case selfUri
    }


}




public class LocationImage: Codable {





    /** Height and/or width of image. ex: 640x480 or x128 */
    public var resolution: String?
    public var imageUri: String?

    public init(resolution: String?, imageUri: String?) {
        self.resolution = resolution
        self.imageUri = imageUri
    }


}




public class LocationSearchRequest: Codable {

    public enum SortOrder: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
        case score = "SCORE"
    }













    /** The sort order for results */
    public var sortOrder: SortOrder?
    /** The field in the resource that you want to sort the results by */
    public var sortBy: String?
    /** The number of results per page */
    public var pageSize: Int?
    /** The page of resources you want to retrieve */
    public var pageNumber: Int?
    /** Multi-value sort order, list of multiple sort values */
    public var sort: [SearchSort]?
    /** Provides more details about a specified resource */
    public var expand: [String]?
    public var query: [LocationSearchCriteria]?

    public init(sortOrder: SortOrder?, sortBy: String?, pageSize: Int?, pageNumber: Int?, sort: [SearchSort]?, expand: [String]?, query: [LocationSearchCriteria]?) {
        self.sortOrder = sortOrder
        self.sortBy = sortBy
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.sort = sort
        self.expand = expand
        self.query = query
    }


}




public class LogCaptureDownloadExecutionResponse: Codable {



    public enum State: String, Codable { 
        case running = "Running"
        case failed = "Failed"
        case succeeded = "Succeeded"
    }









    /** Id of file download job. */
    public var _id: String?
    /** Execution state of the download. */
    public var state: State?
    /** Start date of file download execution. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?
    /** Url of a file with query result. */
    public var fileUrl: String?
    /** The URI for this object */
    public var selfUri: String?
    /** Details of the user that created the job */
    public var user: AddressableEntityRef?

    public init(_id: String?, state: State?, dateStart: Date?, fileUrl: String?, selfUri: String?, user: AddressableEntityRef?) {
        self._id = _id
        self.state = state
        self.dateStart = dateStart
        self.fileUrl = fileUrl
        self.selfUri = selfUri
        self.user = user
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case dateStart
        case fileUrl
        case selfUri
        case user
    }


}




public class LogCaptureQueryRequest: Codable {





    public enum SortOrder: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
    }

    /** Date and time range to query. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Id of the user to query. */
    public var userId: String?
    /** Order of results. Default order is ASC. */
    public var sortOrder: SortOrder?

    public init(interval: String?, userId: String?, sortOrder: SortOrder?) {
        self.interval = interval
        self.userId = userId
        self.sortOrder = sortOrder
    }


}




public class ManagementUnitReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class ManagementUnitSettingsResponse: Codable {













    /** Adherence settings for this management unit */
    public var adherence: AdherenceSettings?
    /** Short term forecasting settings for this management unit */
    public var shortTermForecasting: ShortTermForecastingSettings?
    /** Time off request settings for this management unit */
    public var timeOff: TimeOffRequestSettings?
    /** Scheduling settings for this management unit. These settings are only available if you have the permission wfm:managementUnit:view */
    public var scheduling: SchedulingSettingsResponse?
    /** Shift trade settings for this management unit */
    public var shiftTrading: ShiftTradeSettings?
    /** Version info metadata for the associated management unit */
    public var metadata: WfmVersionedEntityMetadata?

    public init(adherence: AdherenceSettings?, shortTermForecasting: ShortTermForecastingSettings?, timeOff: TimeOffRequestSettings?, scheduling: SchedulingSettingsResponse?, shiftTrading: ShiftTradeSettings?, metadata: WfmVersionedEntityMetadata?) {
        self.adherence = adherence
        self.shortTermForecasting = shortTermForecasting
        self.timeOff = timeOff
        self.scheduling = scheduling
        self.shiftTrading = shiftTrading
        self.metadata = metadata
    }


}




public class MarkContactUncontactableActionSettings: Codable {

    public enum MediaTypes: String, Codable { 
        case voice = "Voice"
        case email = "Email"
        case sms = "Sms"
    }

    /** A list of media types to evaluate. */
    public var mediaTypes: [MediaTypes]?

    public init(mediaTypes: [MediaTypes]?) {
        self.mediaTypes = mediaTypes
    }


}



/** Information about the results being matched by the expressions */

public class MatchTestResult: Codable {





    /** The value of the field being matched */
    public var value: JSON?
    /** The json path to the json node being matched on. ex: $['things'][1] */
    public var path: String?

    public init(value: JSON?, path: String?) {
        self.value = value
        self.path = path
    }


}



/** Media type definition */

public class MediaType: Codable {



    /** The media type string as defined by RFC 2046. You can define specific types such as 'image/jpeg', 'video/mpeg', or specify wild cards for a range of types, 'image/_*', or all types '*_/_*'. See https://www.iana.org/assignments/media-types/media-types.xhtml for a list of registered media types. */
    public var type: String?

    public init(type: String?) {
        self.type = type
    }


}



/** Media types */

public class MediaTypes: Codable {



    /** Specify allowed media types for inbound and outbound messages. If this field is empty, all inbound and outbound media will be blocked. */
    public var allow: MediaTypeAccess?

    public init(allow: MediaTypeAccess?) {
        self.allow = allow
    }


}




public class MessageMediaPolicy: Codable {





    /** Actions applied when specified conditions are met */
    public var actions: PolicyActions?
    /** Conditions for when actions should be applied */
    public var conditions: MessageMediaPolicyConditions?

    public init(actions: PolicyActions?, conditions: MessageMediaPolicyConditions?) {
        self.actions = actions
        self.conditions = conditions
    }


}




public class MessageMediaPolicyConditions: Codable {















    public enum CustomerParticipation: String, Codable { 
        case yes = "YES"
        case no = "NO"
    }

    public var forUsers: [User]?
    public var dateRanges: [String]?
    public var forQueues: [Queue]?
    public var wrapupCodes: [WrapupCode]?
    public var languages: [Language]?
    public var timeAllowed: TimeAllowed?
    /** Teams to match conversations against */
    public var teams: [Team]?
    public var customerParticipation: CustomerParticipation?

    public init(forUsers: [User]?, dateRanges: [String]?, forQueues: [Queue]?, wrapupCodes: [WrapupCode]?, languages: [Language]?, timeAllowed: TimeAllowed?, teams: [Team]?, customerParticipation: CustomerParticipation?) {
        self.forUsers = forUsers
        self.dateRanges = dateRanges
        self.forQueues = forQueues
        self.wrapupCodes = wrapupCodes
        self.languages = languages
        self.timeAllowed = timeAllowed
        self.teams = teams
        self.customerParticipation = customerParticipation
    }


}




public class MessageTypingEventRequest: Codable {





    /** Typing event */
    public var typing: ConversationEventTyping?
    /** The time when the message typing event was sent. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateSent: Date?

    public init(typing: ConversationEventTyping?, dateSent: Date?) {
        self.typing = typing
        self.dateSent = dateSent
    }


}




public class MessagingCampaignEntityListing: Codable {





















    public var entities: [MessagingCampaign]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [MessagingCampaign]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class MessagingExternalEstablishedEvent: Codable {















    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication. */
    public var communicationId: String?
    /** A name for the participant if it is available for this conversation. */
    public var displayName: String?
    /** Metadata about this communication. */
    public var initialConfiguration: MessagingInitialConfiguration?
    /** Metadata about the source of this communication's interaction. */
    public var sourceConfiguration: SourceConfiguration?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, displayName: String?, initialConfiguration: MessagingInitialConfiguration?, sourceConfiguration: SourceConfiguration?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.displayName = displayName
        self.initialConfiguration = initialConfiguration
        self.sourceConfiguration = sourceConfiguration
    }


}




public class MessagingInitialConfiguration: Codable {





    public enum MessageType: String, Codable { 
        case sms = "Sms"
        case twitter = "Twitter"
        case facebook = "Facebook"
        case line = "Line"
        case whatsApp = "WhatsApp"
        case webMessage = "WebMessage"
        case _open = "Open"
        case instagram = "Instagram"
        case unknown = "Unknown"
    }











    /** Address for the participant on receiving side of the message conversation. If the address is a phone number, E.164 format is recommended. */
    public var toAddress: String?
    /** Address for the participant on the sending side of the message conversation. If the address is a phone number, E.164 format is recommended. */
    public var fromAddress: String?
    /** The type of message platform from which the message originated. */
    public var messageType: MessageType?
    /** Indicates that this communication's initial state is held. */
    public var held: Bool?
    /** Indicates that this communication's initial state is alerting. If false, the communication started in a connected state. */
    public var alerting: Bool?
    /** Indicates the direction of this communication with respect to the contact center. `true` means the communication is INBOUND. `false` means the communication is OUTBOUND. */
    public var inbound: Bool?
    /** The id of the communication (the \"peer\") that \"invited\" this communication, if this occurred. */
    public var invitedBy: String?
    /** Additional metadata about this session which should be recorded by the platform but which will not be indexed or searchable. Primarily for diagnostic value. Any information that needs to be accessible through other components like Analytics should be moved to dedicated fields. */
    public var additionalInfo: [String:String]?

    public init(toAddress: String?, fromAddress: String?, messageType: MessageType?, held: Bool?, alerting: Bool?, inbound: Bool?, invitedBy: String?, additionalInfo: [String:String]?) {
        self.toAddress = toAddress
        self.fromAddress = fromAddress
        self.messageType = messageType
        self.held = held
        self.alerting = alerting
        self.inbound = inbound
        self.invitedBy = invitedBy
        self.additionalInfo = additionalInfo
    }


}




public class MessagingStickerEntityListing: Codable {





















    public var entities: [MessagingSticker]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [MessagingSticker]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class MessagingUserEstablishedEvent: Codable {



















    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication. */
    public var communicationId: String?
    /** A unique Id (V4 UUID) identifying this userId this communication belongs to. */
    public var userId: String?
    /** A unique Id (V4 UUID) identifying the queue that the user is messaging on behalf of. Applies to outbound messages only. */
    public var queueId: String?
    /** Indicates whether or not this user will be required to complete after call work. */
    public var afterCallWorkRequired: Bool?
    /** Metadata about this communication. */
    public var initialConfiguration: MessagingInitialConfiguration?
    /** Metadata about the source of this communication's interaction. */
    public var sourceConfiguration: SourceConfiguration?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, userId: String?, queueId: String?, afterCallWorkRequired: Bool?, initialConfiguration: MessagingInitialConfiguration?, sourceConfiguration: SourceConfiguration?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.userId = userId
        self.queueId = queueId
        self.afterCallWorkRequired = afterCallWorkRequired
        self.initialConfiguration = initialConfiguration
        self.sourceConfiguration = sourceConfiguration
    }


}




public class MessengerHomeScreen: Codable {





    /** whether or not homescreen is enabled */
    public var enabled: Bool?
    /** to capture uploaded company logoUrl */
    public var logoUrl: String?

    public init(enabled: Bool?, logoUrl: String?) {
        self.enabled = enabled
        self.logoUrl = logoUrl
    }


}




public class MinerIntent: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Intent name. */
    public var name: String?
    /** The miner to which the intent belongs. */
    public var miner: Miner?
    /** The utterances that are extracted for an Intent. */
    public var utterances: [Utterance]?
    /** Percentage of conversations belonging to the intent. */
    public var analyticVolumePercent: Double?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, miner: Miner?, utterances: [Utterance]?, analyticVolumePercent: Double?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.miner = miner
        self.utterances = utterances
        self.analyticVolumePercent = analyticVolumePercent
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case miner
        case utterances
        case analyticVolumePercent
        case selfUri
    }


}




public class MinerTopic: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Topic name. */
    public var name: String?
    /** The miner to which the topic belongs. */
    public var miner: Miner?
    /** Number of conversations where a topic has occurred. */
    public var conversationCount: Int?
    /** Percentage of conversations where a topic has occurred. */
    public var conversationPercent: Float?
    /** Number of unique utterances where a topic has occurred. */
    public var utteranceCount: Int?
    /** Number of unique phrases (sub-utterances) where a topic has occurred. */
    public var phraseCount: Int?
    /** Phrases associated with a topic. */
    public var phrases: [TopicPhrase]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, miner: Miner?, conversationCount: Int?, conversationPercent: Float?, utteranceCount: Int?, phraseCount: Int?, phrases: [TopicPhrase]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.miner = miner
        self.conversationCount = conversationCount
        self.conversationPercent = conversationPercent
        self.utteranceCount = utteranceCount
        self.phraseCount = phraseCount
        self.phrases = phrases
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case miner
        case conversationCount
        case conversationPercent
        case utteranceCount
        case phraseCount
        case phrases
        case selfUri
    }


}




public class MinerTopicsListing: Codable {









    public var entities: [MinerTopic]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [MinerTopic]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class MuRescheduleResultWrapper: Codable {



    /** The list of agent schedules */
    public var agentSchedules: [BuAgentScheduleRescheduleResponse]?

    public init(agentSchedules: [BuAgentScheduleRescheduleResponse]?) {
        self.agentSchedules = agentSchedules
    }


}




public class MuteSnoozeFields: Codable {





    /** The start date of the mute/snooze period. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?
    /** The end date of the mute/snooze period. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateEnd: Date?

    public init(dateStart: Date?, dateEnd: Date?) {
        self.dateStart = dateStart
        self.dateEnd = dateEnd
    }


}




public class NamedEntityAnnotation: Codable {



    /** The name of the annotated named entity. */
    public var name: String?

    public init(name: String?) {
        self.name = name
    }


}




public class NamedEntityTypeDefinition: Codable {







    /** The name of the entity type. */
    public var name: String?
    /** Description of the of the named entity type. */
    public var _description: String?
    /** The mechanism enabling detection of the named entity type. */
    public var mechanism: NamedEntityTypeMechanism?

    public init(name: String?, _description: String?, mechanism: NamedEntityTypeMechanism?) {
        self.name = name
        self._description = _description
        self.mechanism = mechanism
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _description = "description"
        case mechanism
    }


}




public class NluDomain: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the NLU domain. */
    public var name: String?
    /** The language culture of the NLU domain, e.g. `en-us`, `de-de`. */
    public var language: String?
    /** The draft version of that NLU domain. */
    public var draftVersion: NluDomainVersion?
    /** The last published version of that NLU domain. */
    public var lastPublishedVersion: NluDomainVersion?
    /** The date when the NLU domain was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date when the NLU domain was updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The version of the NLU engine to use. */
    public var engineVersion: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, language: String?, draftVersion: NluDomainVersion?, lastPublishedVersion: NluDomainVersion?, dateCreated: Date?, dateModified: Date?, engineVersion: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.language = language
        self.draftVersion = draftVersion
        self.lastPublishedVersion = lastPublishedVersion
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.engineVersion = engineVersion
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case language
        case draftVersion
        case lastPublishedVersion
        case dateCreated
        case dateModified
        case engineVersion
        case selfUri
    }


}




public class NluDetectionInput: Codable {





    /** The text to perform NLU detection on. */
    public var text: String?
    /** Language of the version for multilingual detection, e.g. `en-us`, `de-de` */
    public var language: String?

    public init(text: String?, language: String?) {
        self.text = text
        self.language = language
    }


}




public class NluDomainListing: Codable {





















    public var entities: [NluDomain]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [NluDomain]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class NluFeedbackResponse: Codable {















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The feedback text. */
    public var text: String?
    /** Detected intent of the utterance */
    public var intents: [IntentFeedback]?
    /** The domain version of the feedback. */
    public var version: NluDomainVersion?
    /** The date when the feedback was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The language of the version to which feedback is linked, e.g. en-us, de-de */
    public var language: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, text: String?, intents: [IntentFeedback]?, version: NluDomainVersion?, dateCreated: Date?, language: String?, selfUri: String?) {
        self._id = _id
        self.text = text
        self.intents = intents
        self.version = version
        self.dateCreated = dateCreated
        self.language = language
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case text
        case intents
        case version
        case dateCreated
        case language
        case selfUri
    }


}



/** Template header object. */

public class NotificationTemplateHeader: Codable {

    public enum ModelType: String, Codable { 
        case text = "Text"
        case media = "Media"
    }







    /** Template header type. */
    public var type: ModelType?
    /** Header text. For WhatsApp, ignored. */
    public var text: String?
    /** Media template header image. */
    public var media: ContentAttachment?
    /** Template parameters for placeholders in template. */
    public var parameters: [NotificationTemplateParameter]?

    public init(type: ModelType?, text: String?, media: ContentAttachment?, parameters: [NotificationTemplateParameter]?) {
        self.type = type
        self.text = text
        self.media = media
        self.parameters = parameters
    }


}




public class OAuthClient: Codable {























    public enum AuthorizedGrantType: String, Codable { 
        case code = "CODE"
        case token = "TOKEN"
        case saml2Bearer = "SAML2-BEARER"
        case password = "PASSWORD"
        case clientCredentials = "CLIENT-CREDENTIALS"
    }





    public enum State: String, Codable { 
        case active = "active"
        case disabled = "disabled"
        case inactive = "inactive"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the OAuth client. */
    public var name: String?
    /** The number of seconds, between 5mins and 48hrs, until tokens created with this client expire. If this field is omitted, a default of 24 hours will be applied. */
    public var accessTokenValiditySeconds: Int64?
    public var _description: String?
    /** List of allowed callbacks for this client. For example: https://myap.example.com/auth/callback */
    public var registeredRedirectUri: [String]?
    /** System created secret assigned to this client. Secrets are required for code authorization and client credential grants. */
    public var secret: String?
    /** Deprecated. Use roleDivisions instead. */
    public var roleIds: [String]?
    /** Date this client was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date this client was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** User that created this client */
    public var createdBy: DomainEntityRef?
    /** User that last modified this client */
    public var modifiedBy: DomainEntityRef?
    /** The OAuth Grant/Client type supported by this client. Code Authorization Grant/Client type - Preferred client type where the Client ID and Secret are required to create tokens. Used where the secret can be secured. PKCE-Enabled Code Authorization grant type - Code grant type which requires PKCE challenge and verifier to create tokens. Used in public clients for increased security. Implicit grant type - Client ID only is required to create tokens. Used in browser and mobile apps where the secret can not be secured. SAML2-Bearer extension grant type - SAML2 assertion provider for user authentication at the token endpoint. Client Credential grant type - Used to created access tokens that are tied only to the client.  */
    public var authorizedGrantType: AuthorizedGrantType?
    /** The scope requested by this client. Scopes only apply to clients not using the client_credential grant */
    public var scope: [String]?
    /** Set of roles and their corresponding divisions associated with this client. Roles and divisions only apply to clients using the client_credential grant */
    public var roleDivisions: [RoleDivision]?
    /** The state of the OAuth client. Active: The OAuth client can be used to create access tokens. This is the default state. Disabled: Access tokens created by the client are invalid and new ones cannot be created. Inactive: Access tokens cannot be created with this OAuth client and it will be deleted. */
    public var state: State?
    /** The time at which this client will be deleted. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateToDelete: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, accessTokenValiditySeconds: Int64?, _description: String?, registeredRedirectUri: [String]?, secret: String?, roleIds: [String]?, dateCreated: Date?, dateModified: Date?, createdBy: DomainEntityRef?, modifiedBy: DomainEntityRef?, authorizedGrantType: AuthorizedGrantType?, scope: [String]?, roleDivisions: [RoleDivision]?, state: State?, dateToDelete: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.accessTokenValiditySeconds = accessTokenValiditySeconds
        self._description = _description
        self.registeredRedirectUri = registeredRedirectUri
        self.secret = secret
        self.roleIds = roleIds
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.authorizedGrantType = authorizedGrantType
        self.scope = scope
        self.roleDivisions = roleDivisions
        self.state = state
        self.dateToDelete = dateToDelete
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case accessTokenValiditySeconds
        case _description = "description"
        case registeredRedirectUri
        case secret
        case roleIds
        case dateCreated
        case dateModified
        case createdBy
        case modifiedBy
        case authorizedGrantType
        case scope
        case roleDivisions
        case state
        case dateToDelete
        case selfUri
    }


}




public class OAuthClientListing: Codable {



























    public enum State: String, Codable { 
        case active = "active"
        case disabled = "disabled"
        case inactive = "inactive"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the OAuth client. */
    public var name: String?
    /** The number of seconds, between 5mins and 48hrs, until tokens created with this client expire. If this field is omitted, a default of 24 hours will be applied. */
    public var accessTokenValiditySeconds: Int64?
    public var _description: String?
    /** List of allowed callbacks for this client. For example: https://myap.example.com/auth/callback */
    public var registeredRedirectUri: [String]?
    /** System created secret assigned to this client. Secrets are required for code authorization and client credential grants. */
    public var secret: String?
    /** Deprecated. Use roleDivisions instead. */
    public var roleIds: [String]?
    /** Date this client was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date this client was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** User that created this client */
    public var createdBy: DomainEntityRef?
    /** User that last modified this client */
    public var modifiedBy: DomainEntityRef?
    /** The scope requested by this client. Scopes only apply to clients not using the client_credential grant */
    public var scope: [String]?
    /** Set of roles and their corresponding divisions associated with this client. Roles and divisions only apply to clients using the client_credential grant */
    public var roleDivisions: [RoleDivision]?
    /** The state of the OAuth client. Active: The OAuth client can be used to create access tokens. This is the default state. Disabled: Access tokens created by the client are invalid and new ones cannot be created. Inactive: Access tokens cannot be created with this OAuth client and it will be deleted. */
    public var state: State?
    /** The time at which this client will be deleted. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateToDelete: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, accessTokenValiditySeconds: Int64?, _description: String?, registeredRedirectUri: [String]?, secret: String?, roleIds: [String]?, dateCreated: Date?, dateModified: Date?, createdBy: DomainEntityRef?, modifiedBy: DomainEntityRef?, scope: [String]?, roleDivisions: [RoleDivision]?, state: State?, dateToDelete: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.accessTokenValiditySeconds = accessTokenValiditySeconds
        self._description = _description
        self.registeredRedirectUri = registeredRedirectUri
        self.secret = secret
        self.roleIds = roleIds
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.scope = scope
        self.roleDivisions = roleDivisions
        self.state = state
        self.dateToDelete = dateToDelete
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case accessTokenValiditySeconds
        case _description = "description"
        case registeredRedirectUri
        case secret
        case roleIds
        case dateCreated
        case dateModified
        case createdBy
        case modifiedBy
        case scope
        case roleDivisions
        case state
        case dateToDelete
        case selfUri
    }


}




public class OAuthClientRequest: Codable {











    public enum AuthorizedGrantType: String, Codable { 
        case code = "CODE"
        case token = "TOKEN"
        case saml2Bearer = "SAML2-BEARER"
        case password = "PASSWORD"
        case clientCredentials = "CLIENT-CREDENTIALS"
    }





    public enum State: String, Codable { 
        case active = "active"
        case disabled = "disabled"
        case inactive = "inactive"
    }



    /** The name of the OAuth client. */
    public var name: String?
    /** The number of seconds, between 5mins and 48hrs, until tokens created with this client expire. If this field is omitted, a default of 24 hours will be applied. */
    public var accessTokenValiditySeconds: Int64?
    public var _description: String?
    /** List of allowed callbacks for this client. For example: https://myap.example.com/auth/callback */
    public var registeredRedirectUri: [String]?
    /** Deprecated. Use roleDivisions instead. */
    public var roleIds: [String]?
    /** The OAuth Grant/Client type supported by this client. Code Authorization Grant/Client type - Preferred client type where the Client ID and Secret are required to create tokens. Used where the secret can be secured. PKCE-Enabled Code Authorization grant type - Code grant type which requires PKCE challenge and verifier to create tokens. Used in public clients for increased security. Implicit grant type - Client ID only is required to create tokens. Used in browser and mobile apps where the secret can not be secured. SAML2-Bearer extension grant type - SAML2 assertion provider for user authentication at the token endpoint. Client Credential grant type - Used to created access tokens that are tied only to the client.  */
    public var authorizedGrantType: AuthorizedGrantType?
    /** The scope requested by this client. Scopes only apply to clients not using the client_credential grant */
    public var scope: [String]?
    /** Set of roles and their corresponding divisions associated with this client. Roles and divisions only apply to clients using the client_credential grant */
    public var roleDivisions: [RoleDivision]?
    /** The state of the OAuth client. Active: The OAuth client can be used to create access tokens. This is the default state. Disabled: Access tokens created by the client are invalid and new ones cannot be created. Inactive: Access tokens cannot be created with this OAuth client and it will be deleted. */
    public var state: State?
    /** The time at which this client will be deleted. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateToDelete: Date?

    public init(name: String?, accessTokenValiditySeconds: Int64?, _description: String?, registeredRedirectUri: [String]?, roleIds: [String]?, authorizedGrantType: AuthorizedGrantType?, scope: [String]?, roleDivisions: [RoleDivision]?, state: State?, dateToDelete: Date?) {
        self.name = name
        self.accessTokenValiditySeconds = accessTokenValiditySeconds
        self._description = _description
        self.registeredRedirectUri = registeredRedirectUri
        self.roleIds = roleIds
        self.authorizedGrantType = authorizedGrantType
        self.scope = scope
        self.roleDivisions = roleDivisions
        self.state = state
        self.dateToDelete = dateToDelete
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case accessTokenValiditySeconds
        case _description = "description"
        case registeredRedirectUri
        case roleIds
        case authorizedGrantType
        case scope
        case roleDivisions
        case state
        case dateToDelete
    }


}




public class Objective: Codable {









    public enum MediaTypes: String, Codable { 
        case callback = "callback"
        case chat = "chat"
        case cobrowse = "cobrowse"
        case email = "email"
        case message = "message"
        case screenshare = "screenshare"
        case unknown = "unknown"
        case video = "video"
        case voice = "voice"
    }





    public enum TopicIdsFilterType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The id of this objective's base template */
    public var templateId: String?
    /** Objective zone specifies min,max points and values for the associated metric */
    public var zones: [ObjectiveZone]?
    /** A flag for whether this objective is enabled for the related metric */
    public var enabled: Bool?
    /** A list of media types for the metric */
    public var mediaTypes: [MediaTypes]?
    /** A list of queues for the metric */
    public var queues: [AddressableEntityRef]?
    /** A list of topic ids for detected topic metrics */
    public var topics: [AddressableEntityRef]?
    /** A filter type for topic Ids. It's only used for objectives with topicIds. Default filter behavior is \"or\". */
    public var topicIdsFilterType: TopicIdsFilterType?
    /** The ids of associated evaluation form context, for Quality Evaluation Score metrics */
    public var evaluationFormContextIds: [String]?
    /** start date of the objective. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStart: Date?

    public init(_id: String?, templateId: String?, zones: [ObjectiveZone]?, enabled: Bool?, mediaTypes: [MediaTypes]?, queues: [AddressableEntityRef]?, topics: [AddressableEntityRef]?, topicIdsFilterType: TopicIdsFilterType?, evaluationFormContextIds: [String]?, dateStart: Date?) {
        self._id = _id
        self.templateId = templateId
        self.zones = zones
        self.enabled = enabled
        self.mediaTypes = mediaTypes
        self.queues = queues
        self.topics = topics
        self.topicIdsFilterType = topicIdsFilterType
        self.evaluationFormContextIds = evaluationFormContextIds
        self.dateStart = dateStart
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case templateId
        case zones
        case enabled
        case mediaTypes
        case queues
        case topics
        case topicIdsFilterType
        case evaluationFormContextIds
        case dateStart
    }


}




public class ObservationValue: Codable {

















    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }
















    public enum RequestedRoutings: String, Codable { 
        case bullseye = "Bullseye"
        case conditional = "Conditional"
        case direct = "Direct"
        case last = "Last"
        case manual = "Manual"
        case predictive = "Predictive"
        case preferred = "Preferred"
        case standard = "Standard"
        case vip = "Vip"
    }
    public enum UsedRouting: String, Codable { 
        case bullseye = "Bullseye"
        case conditional = "Conditional"
        case direct = "Direct"
        case last = "Last"
        case manual = "Manual"
        case predictive = "Predictive"
        case preferred = "Preferred"
        case standard = "Standard"
        case vip = "Vip"
    }



    /** The time at which the observation occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var observationDate: Date?
    /** Unique identifier for the conversation */
    public var conversationId: String?
    /** The unique identifier of this session */
    public var sessionId: String?
    /** Unique identifier for a skill requested for an interaction */
    public var requestedRoutingSkillIds: [String]?
    /** Unique identifier for the language requested for an interaction */
    public var requestedLanguageId: String?
    /** Routing priority for the current interaction */
    public var routingPriority: Int64?
    /** A human readable name identifying the participant */
    public var participantName: String?
    /** Unique identifier for the user */
    public var userId: String?
    /** The direction of the communication */
    public var direction: Direction?
    /** Session media type that was converted from in case of a media type conversion */
    public var convertedFrom: String?
    /** Session media type that was converted to in case of a media type conversion */
    public var convertedTo: String?
    /** The address that initiated an action */
    public var addressFrom: String?
    /** The address receiving an action */
    public var addressTo: String?
    /** Automatic Number Identification (caller's number) */
    public var ani: String?
    /** Dialed number identification service (number dialed by the calling party) */
    public var dnis: String?
    /** The team id the user is a member of */
    public var teamId: String?
    /** All routing types for requested/attempted routing methods */
    public var requestedRoutings: [RequestedRoutings]?
    /** Complete routing method */
    public var usedRouting: UsedRouting?
    public var scoredAgents: [AnalyticsScoredAgent]?

    public init(observationDate: Date?, conversationId: String?, sessionId: String?, requestedRoutingSkillIds: [String]?, requestedLanguageId: String?, routingPriority: Int64?, participantName: String?, userId: String?, direction: Direction?, convertedFrom: String?, convertedTo: String?, addressFrom: String?, addressTo: String?, ani: String?, dnis: String?, teamId: String?, requestedRoutings: [RequestedRoutings]?, usedRouting: UsedRouting?, scoredAgents: [AnalyticsScoredAgent]?) {
        self.observationDate = observationDate
        self.conversationId = conversationId
        self.sessionId = sessionId
        self.requestedRoutingSkillIds = requestedRoutingSkillIds
        self.requestedLanguageId = requestedLanguageId
        self.routingPriority = routingPriority
        self.participantName = participantName
        self.userId = userId
        self.direction = direction
        self.convertedFrom = convertedFrom
        self.convertedTo = convertedTo
        self.addressFrom = addressFrom
        self.addressTo = addressTo
        self.ani = ani
        self.dnis = dnis
        self.teamId = teamId
        self.requestedRoutings = requestedRoutings
        self.usedRouting = usedRouting
        self.scoredAgents = scoredAgents
    }


}



/** Open Channel-specific information that describes the message and the message channel/provider, with additional message information */

public class OpenInboundMessageMessagingChannel: Codable {









    /** Information about the recipient the message is received from. */
    public var from: OpenMessagingFromRecipient?
    /** Original time of the event. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var time: Date?
    /** Unique provider ID of the message. */
    public var messageId: String?
    /** Additional Custom Information about the channel. */
    public var metadata: JSON?

    public init(from: OpenMessagingFromRecipient?, time: Date?, messageId: String?, metadata: JSON?) {
        self.from = from
        self.time = time
        self.messageId = messageId
        self.metadata = metadata
    }


}




public class OpenIntegration: Codable {



























    public enum CreateStatus: String, Codable { 
        case initiated = "Initiated"
        case completed = "Completed"
        case error = "Error"
    }





    /** A unique Integration Id. */
    public var _id: String?
    /** The name of the Open messaging integration. */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    public var messagingSetting: MessagingSettingReference?
    /** The outbound notification webhook URL for the Open messaging integration. */
    public var outboundNotificationWebhookUrl: String?
    /** The outbound notification webhook signature secret token. */
    public var outboundNotificationWebhookSignatureSecretToken: String?
    /** The user specified headers for the Open messaging integration. */
    public var webhookHeaders: [String:String]?
    /** The status of the Open Integration */
    public var status: String?
    /** The recipient associated to the Open messaging Integration. This recipient is used to associate a flow to an integration */
    public var recipient: DomainEntityRef?
    /** Date this Integration was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date this Integration was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** User reference that created this Integration */
    public var createdBy: DomainEntityRef?
    /** User reference that last modified this Integration */
    public var modifiedBy: DomainEntityRef?
    /** Status of asynchronous create operation */
    public var createStatus: CreateStatus?
    /** Error information returned, if createStatus is set to Error */
    public var createError: ErrorBody?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingReference?, outboundNotificationWebhookUrl: String?, outboundNotificationWebhookSignatureSecretToken: String?, webhookHeaders: [String:String]?, status: String?, recipient: DomainEntityRef?, dateCreated: Date?, dateModified: Date?, createdBy: DomainEntityRef?, modifiedBy: DomainEntityRef?, createStatus: CreateStatus?, createError: ErrorBody?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.outboundNotificationWebhookUrl = outboundNotificationWebhookUrl
        self.outboundNotificationWebhookSignatureSecretToken = outboundNotificationWebhookSignatureSecretToken
        self.webhookHeaders = webhookHeaders
        self.status = status
        self.recipient = recipient
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.createStatus = createStatus
        self.createError = createError
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case outboundNotificationWebhookUrl
        case outboundNotificationWebhookSignatureSecretToken
        case webhookHeaders
        case status
        case recipient
        case dateCreated
        case dateModified
        case createdBy
        case modifiedBy
        case createStatus
        case createError
        case selfUri
    }


}




public class OpenIntegrationRequest: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the Open messaging integration. */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    /** Defines the message settings to be applied for this integration */
    public var messagingSetting: MessagingSettingRequestReference?
    /** The outbound notification webhook URL for the Open messaging integration. */
    public var outboundNotificationWebhookUrl: String?
    /** The outbound notification webhook signature secret token. This token must be longer than 15 characters. */
    public var outboundNotificationWebhookSignatureSecretToken: String?
    /** The user specified headers for the Open messaging integration. */
    public var webhookHeaders: [String:String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingRequestReference?, outboundNotificationWebhookUrl: String?, outboundNotificationWebhookSignatureSecretToken: String?, webhookHeaders: [String:String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.outboundNotificationWebhookUrl = outboundNotificationWebhookUrl
        self.outboundNotificationWebhookSignatureSecretToken = outboundNotificationWebhookSignatureSecretToken
        self.webhookHeaders = webhookHeaders
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case outboundNotificationWebhookUrl
        case outboundNotificationWebhookSignatureSecretToken
        case webhookHeaders
        case selfUri
    }


}



/** Information about the recipient the message is received from. */

public class OpenMessagingFromRecipient: Codable {





    public enum IdType: String, Codable { 
        case email = "Email"
        case phone = "Phone"
        case opaque = "Opaque"
    }









    /** Nickname or display name of the recipient. */
    public var nickname: String?
    /** The recipient ID specific to the provider. */
    public var _id: String?
    /** The recipient ID type. This is used to indicate the format used for the ID. */
    public var idType: IdType?
    /** First name of the recipient. */
    public var firstName: String?
    /** Last name of the recipient. */
    public var lastName: String?
    /** URL of an image that represents the recipient. */
    public var image: String?
    /** E-mail address of the recipient. */
    public var email: String?

    public init(nickname: String?, _id: String?, idType: IdType?, firstName: String?, lastName: String?, image: String?, email: String?) {
        self.nickname = nickname
        self._id = _id
        self.idType = idType
        self.firstName = firstName
        self.lastName = lastName
        self.image = image
        self.email = email
    }

    public enum CodingKeys: String, CodingKey { 
        case nickname
        case _id = "id"
        case idType
        case firstName
        case lastName
        case image
        case email
    }


}




public class OrganizationPresenceDefinition: Codable {





    public enum ModelType: String, Codable { 
        case system = "System"
        case user = "User"
    }



    public enum SystemPresence: String, Codable { 
        case available = "Available"
        case away = "Away"
        case busy = "Busy"
        case offline = "Offline"
        case idle = "Idle"
        case onQueue = "OnQueue"
        case meal = "Meal"
        case training = "Training"
        case meeting = "Meeting"
        case _break = "Break"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The type of definition */
    public var type: ModelType?
    /** The label used for the definition in each specified language */
    public var languageLabels: [String:String]?
    public var systemPresence: SystemPresence?
    public var divisionId: String?
    public var deactivated: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, type: ModelType?, languageLabels: [String:String]?, systemPresence: SystemPresence?, divisionId: String?, deactivated: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.type = type
        self.languageLabels = languageLabels
        self.systemPresence = systemPresence
        self.divisionId = divisionId
        self.deactivated = deactivated
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case type
        case languageLabels
        case systemPresence
        case divisionId
        case deactivated
        case selfUri
    }


}




public class OrganizationProductEntityListing: Codable {











    public var entities: [DomainOrganizationProduct]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var pageCount: Int?

    public init(entities: [DomainOrganizationProduct]?, pageSize: Int?, pageNumber: Int?, total: Int64?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.pageCount = pageCount
    }


}




public class OrganizationRoleEntityListing: Codable {





















    public var entities: [DomainOrganizationRole]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DomainOrganizationRole]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class OutboundDomain: Codable {









    public enum SenderType: String, Codable { 
        case unknown = "Unknown"
        case emailDomain = "EmailDomain"
        case mockEmailDomain = "MockEmailDomain"
    }



    /** Unique Id of the domain such as: example.com */
    public var _id: String?
    public var name: String?
    /** CNAME registration Status */
    public var cnameVerificationResult: VerificationResult?
    /** DKIM registration Status */
    public var dkimVerificationResult: VerificationResult?
    /** Sender Type */
    public var senderType: SenderType?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, cnameVerificationResult: VerificationResult?, dkimVerificationResult: VerificationResult?, senderType: SenderType?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.cnameVerificationResult = cnameVerificationResult
        self.dkimVerificationResult = dkimVerificationResult
        self.senderType = senderType
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case cnameVerificationResult
        case dkimVerificationResult
        case senderType
        case selfUri
    }


}




public class OutboundMessagingCampaignPostContactSmsEventTopicOutboundMessagingCampaignPostContactSMSEvent: Codable {





    public enum OutboundCampaignType: String, Codable { 
        case unknown = "UNKNOWN"
        case email = "EMAIL"
        case sms = "SMS"
    }



    public enum WrapupCode: String, Codable { 
        case unknown = "UNKNOWN"
        case outboundMessageSent = "OUTBOUND_MESSAGE_SENT"
        case outboundMessageFailed = "OUTBOUND_MESSAGE_FAILED"
        case outboundMessageThrottled = "OUTBOUND_MESSAGE_THROTTLED"
    }













    public var eventTime: Date?
    public var conversationId: String?
    public var outboundCampaignType: OutboundCampaignType?
    public var smsAttributes: OutboundMessagingCampaignPostContactSmsEventTopicSMSAttributes?
    public var wrapupCode: WrapupCode?
    public var outboundCampaignId: String?
    public var divisionId: String?
    public var contentTemplateId: String?
    public var outboundContactListId: String?
    public var outboundContactId: String?
    public var isCampaignAlwaysRunning: Bool?

    public init(eventTime: Date?, conversationId: String?, outboundCampaignType: OutboundCampaignType?, smsAttributes: OutboundMessagingCampaignPostContactSmsEventTopicSMSAttributes?, wrapupCode: WrapupCode?, outboundCampaignId: String?, divisionId: String?, contentTemplateId: String?, outboundContactListId: String?, outboundContactId: String?, isCampaignAlwaysRunning: Bool?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.outboundCampaignType = outboundCampaignType
        self.smsAttributes = smsAttributes
        self.wrapupCode = wrapupCode
        self.outboundCampaignId = outboundCampaignId
        self.divisionId = divisionId
        self.contentTemplateId = contentTemplateId
        self.outboundContactListId = outboundContactListId
        self.outboundContactId = outboundContactId
        self.isCampaignAlwaysRunning = isCampaignAlwaysRunning
    }


}




public class OutboundMessagingCampaignPreContactSmsEventTopicSMSAttributes: Codable {









    public var contactPhoneNumber: String?
    public var contactPhoneNumberColumnName: String?
    public var configuredSenderPhoneNumber: String?
    public var senderPhoneNumber: String?

    public init(contactPhoneNumber: String?, contactPhoneNumberColumnName: String?, configuredSenderPhoneNumber: String?, senderPhoneNumber: String?) {
        self.contactPhoneNumber = contactPhoneNumber
        self.contactPhoneNumberColumnName = contactPhoneNumberColumnName
        self.configuredSenderPhoneNumber = configuredSenderPhoneNumber
        self.senderPhoneNumber = senderPhoneNumber
    }


}




public class PagingSpec: Codable {





    /** How many results per page */
    public var pageSize: Int?
    /** How many pages in */
    public var pageNumber: Int?

    public init(pageSize: Int?, pageNumber: Int?) {
        self.pageSize = pageSize
        self.pageNumber = pageNumber
    }


}




public class ParticipantBasic: Codable {













































    public enum WrapupPrompt: String, Codable { 
        case mandatory = "mandatory"
        case _optional = "optional"
        case agentrequested = "agentRequested"
        case timeout = "timeout"
        case forcedtimeout = "forcedTimeout"
    }







































    public enum ScreenRecordingState: String, Codable { 
        case requested = "requested"
        case active = "active"
        case paused = "paused"
        case stopped = "stopped"
        case error = "error"
        case timeout = "timeout"
    }

    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }







    /** A globally unique identifier for this conversation. */
    public var _id: String?
    /** The timestamp when this participant joined the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startTime: Date?
    /** The timestamp when this participant disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?
    /** The timestamp when this participant was connected to the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** A human readable name identifying the participant. */
    public var name: String?
    /** If this participant represents a user, then this will be an URI that can be used to fetch the user. */
    public var userUri: String?
    /** If this participant represents a user, then this will be the globally unique identifier for the user. */
    public var userId: String?
    /** If this participant represents an external contact, then this will be the globally unique identifier for the external contact. */
    public var externalContactId: String?
    /** If this participant represents an external org, then this will be the globally unique identifier for the external org. */
    public var externalOrganizationId: String?
    /** If present, the queue id that the communication channel came in on. */
    public var queueId: String?
    /** If present, group of users the participant represents. */
    public var groupId: String?
    /** The team id that this participant is a member of when added to the conversation. */
    public var teamId: String?
    /** If present, the queue name that the communication channel came in on. */
    public var queueName: String?
    /** A well known string that specifies the purpose of this participant. */
    public var purpose: String?
    /** A well known string that specifies the type of this participant. */
    public var participantType: String?
    /** If this participant is part of a consult transfer, then this will be the participant id of the participant being transferred. */
    public var consultParticipantId: String?
    /** The address for the this participant. For a phone call this will be the ANI. */
    public var address: String?
    /** The address for the this participant. For a phone call this will be the ANI. */
    public var ani: String?
    /** The ani-based name for this participant. */
    public var aniName: String?
    /** The address for the this participant. For a phone call this will be the ANI. */
    public var dnis: String?
    /** An ISO 639 language code specifying the locale for this participant */
    public var locale: String?
    /** True iff this participant is required to enter wrapup for this conversation. */
    public var wrapupRequired: Bool?
    /** This field controls how the UI prompts the agent for a wrapup. */
    public var wrapupPrompt: WrapupPrompt?
    /** Specifies how long a timed ACW session will last. */
    public var wrapupTimeoutMs: Int?
    /** The UI sets this field when the agent chooses to skip entering a wrapup for this participant. */
    public var wrapupSkipped: Bool?
    /** Call wrap up or disposition data. */
    public var wrapup: Wrapup?
    /** List of roles this participant's media has had on the conversation, ie monitor, coach, etc. */
    public var mediaRoles: [String]?
    /** Information on how a communication should be routed to an agent. */
    public var conversationRoutingData: ConversationRoutingData?
    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutMs: Int?
    /** If this participant is a monitor, then this will be the id of the participant that is being monitored. */
    public var monitoredParticipantId: String?
    /** If this participant is a coach, then this will be the id of the participant that is being coached. */
    public var coachedParticipantId: String?
    /** Additional participant attributes */
    public var attributes: [String:String]?
    public var calls: [CallBasic]?
    public var callbacks: [CallbackBasic]?
    public var chats: [ConversationChat]?
    public var cobrowsesessions: [Cobrowsesession]?
    public var emails: [Email]?
    public var messages: [Message]?
    public var screenshares: [Screenshare]?
    public var socialExpressions: [SocialExpression]?
    public var videos: [Video]?
    public var evaluations: [Evaluation]?
    /** The current screen recording state for this participant. */
    public var screenRecordingState: ScreenRecordingState?
    /** The reason specifying why participant flagged the conversation. */
    public var flaggedReason: FlaggedReason?
    /** The timestamp when this participant started after-call work. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAcwTime: Date?
    /** The timestamp when this participant ended after-call work. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endAcwTime: Date?
    /** If this participant barged in a participant's call, then this will be the id of the targeted participant. */
    public var bargedParticipantId: String?

    public init(_id: String?, startTime: Date?, endTime: Date?, connectedTime: Date?, name: String?, userUri: String?, userId: String?, externalContactId: String?, externalOrganizationId: String?, queueId: String?, groupId: String?, teamId: String?, queueName: String?, purpose: String?, participantType: String?, consultParticipantId: String?, address: String?, ani: String?, aniName: String?, dnis: String?, locale: String?, wrapupRequired: Bool?, wrapupPrompt: WrapupPrompt?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, wrapup: Wrapup?, mediaRoles: [String]?, conversationRoutingData: ConversationRoutingData?, alertingTimeoutMs: Int?, monitoredParticipantId: String?, coachedParticipantId: String?, attributes: [String:String]?, calls: [CallBasic]?, callbacks: [CallbackBasic]?, chats: [ConversationChat]?, cobrowsesessions: [Cobrowsesession]?, emails: [Email]?, messages: [Message]?, screenshares: [Screenshare]?, socialExpressions: [SocialExpression]?, videos: [Video]?, evaluations: [Evaluation]?, screenRecordingState: ScreenRecordingState?, flaggedReason: FlaggedReason?, startAcwTime: Date?, endAcwTime: Date?, bargedParticipantId: String?) {
        self._id = _id
        self.startTime = startTime
        self.endTime = endTime
        self.connectedTime = connectedTime
        self.name = name
        self.userUri = userUri
        self.userId = userId
        self.externalContactId = externalContactId
        self.externalOrganizationId = externalOrganizationId
        self.queueId = queueId
        self.groupId = groupId
        self.teamId = teamId
        self.queueName = queueName
        self.purpose = purpose
        self.participantType = participantType
        self.consultParticipantId = consultParticipantId
        self.address = address
        self.ani = ani
        self.aniName = aniName
        self.dnis = dnis
        self.locale = locale
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.wrapup = wrapup
        self.mediaRoles = mediaRoles
        self.conversationRoutingData = conversationRoutingData
        self.alertingTimeoutMs = alertingTimeoutMs
        self.monitoredParticipantId = monitoredParticipantId
        self.coachedParticipantId = coachedParticipantId
        self.attributes = attributes
        self.calls = calls
        self.callbacks = callbacks
        self.chats = chats
        self.cobrowsesessions = cobrowsesessions
        self.emails = emails
        self.messages = messages
        self.screenshares = screenshares
        self.socialExpressions = socialExpressions
        self.videos = videos
        self.evaluations = evaluations
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.bargedParticipantId = bargedParticipantId
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case startTime
        case endTime
        case connectedTime
        case name
        case userUri
        case userId
        case externalContactId
        case externalOrganizationId
        case queueId
        case groupId
        case teamId
        case queueName
        case purpose
        case participantType
        case consultParticipantId
        case address
        case ani
        case aniName
        case dnis
        case locale
        case wrapupRequired
        case wrapupPrompt
        case wrapupTimeoutMs
        case wrapupSkipped
        case wrapup
        case mediaRoles
        case conversationRoutingData
        case alertingTimeoutMs
        case monitoredParticipantId
        case coachedParticipantId
        case attributes
        case calls
        case callbacks
        case chats
        case cobrowsesessions
        case emails
        case messages
        case screenshares
        case socialExpressions
        case videos
        case evaluations
        case screenRecordingState
        case flaggedReason
        case startAcwTime
        case endAcwTime
        case bargedParticipantId
    }


}




public class ParticipantMetrics: Codable {

















    /** Percentage of Agent duration in the conversation */
    public var agentDurationPercentage: Double?
    /** Percentage of Customer duration in the conversation */
    public var customerDurationPercentage: Double?
    /** Percentage of Silence duration in the conversation */
    public var silenceDurationPercentage: Double?
    /** Percentage of IVR duration in the conversation */
    public var ivrDurationPercentage: Double?
    /** Percentage of ACD duration in the conversation */
    public var acdDurationPercentage: Double?
    /** Percentage of Overtalk duration in the conversation */
    public var overtalkDurationPercentage: Double?
    /** Percentage of Other events duration in the conversation */
    public var otherDurationPercentage: Double?
    /** Number of Overtalks in the conversation */
    public var overtalkCount: Int?

    public init(agentDurationPercentage: Double?, customerDurationPercentage: Double?, silenceDurationPercentage: Double?, ivrDurationPercentage: Double?, acdDurationPercentage: Double?, overtalkDurationPercentage: Double?, otherDurationPercentage: Double?, overtalkCount: Int?) {
        self.agentDurationPercentage = agentDurationPercentage
        self.customerDurationPercentage = customerDurationPercentage
        self.silenceDurationPercentage = silenceDurationPercentage
        self.ivrDurationPercentage = ivrDurationPercentage
        self.acdDurationPercentage = acdDurationPercentage
        self.overtalkDurationPercentage = overtalkDurationPercentage
        self.otherDurationPercentage = otherDurationPercentage
        self.overtalkCount = overtalkCount
    }


}




public class PatchActionMap: Codable {









































    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The version of the action map. */
    public var version: Int?
    /** Whether the action map is active. */
    public var isActive: Bool?
    /** Display name of the action map. */
    public var displayName: String?
    /** Trigger action map if any segment in the list is assigned to a given customer. */
    public var triggerWithSegments: [String]?
    /** List of event conditions that must be satisfied to trigger the action map. */
    public var triggerWithEventConditions: [EventCondition]?
    /** Probability conditions for outcomes that must be satisfied to trigger the action map. */
    public var triggerWithOutcomeProbabilityConditions: [OutcomeProbabilityCondition]?
    /** (deprecated - use triggerWithOutcomeQuantileConditions instead) Percentile conditions for outcomes that must be satisfied to trigger the action map. */
    public var triggerWithOutcomePercentileConditions: [OutcomePercentileCondition]?
    /** Quantile conditions for outcomes that must be satisfied to trigger the action map. */
    public var triggerWithOutcomeQuantileConditions: [OutcomeQuantileCondition]?
    /** URL conditions that a page must match for web actions to be displayable. */
    public var pageUrlConditions: [UrlCondition]?
    /** Type of activation. */
    public var activation: Activation?
    /** Weight of the action map with higher number denoting higher weight. */
    public var weight: Int?
    /** The action that will be executed if this action map is triggered. */
    public var action: PatchAction?
    /** The action map's associated schedule groups. */
    public var actionMapScheduleGroups: PatchActionMapScheduleGroups?
    /** Override organization-level frequency cap and always offer web engagements from this action map. */
    public var ignoreFrequencyCap: Bool?
    /** The URI for this object */
    public var selfUri: String?
    /** Timestamp indicating when the action map was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    /** Timestamp indicating when the action map was last updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    /** Timestamp at which the action map is scheduled to start firing. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** Timestamp at which the action map is scheduled to stop firing. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endDate: Date?

    public init(_id: String?, version: Int?, isActive: Bool?, displayName: String?, triggerWithSegments: [String]?, triggerWithEventConditions: [EventCondition]?, triggerWithOutcomeProbabilityConditions: [OutcomeProbabilityCondition]?, triggerWithOutcomePercentileConditions: [OutcomePercentileCondition]?, triggerWithOutcomeQuantileConditions: [OutcomeQuantileCondition]?, pageUrlConditions: [UrlCondition]?, activation: Activation?, weight: Int?, action: PatchAction?, actionMapScheduleGroups: PatchActionMapScheduleGroups?, ignoreFrequencyCap: Bool?, selfUri: String?, createdDate: Date?, modifiedDate: Date?, startDate: Date?, endDate: Date?) {
        self._id = _id
        self.version = version
        self.isActive = isActive
        self.displayName = displayName
        self.triggerWithSegments = triggerWithSegments
        self.triggerWithEventConditions = triggerWithEventConditions
        self.triggerWithOutcomeProbabilityConditions = triggerWithOutcomeProbabilityConditions
        self.triggerWithOutcomePercentileConditions = triggerWithOutcomePercentileConditions
        self.triggerWithOutcomeQuantileConditions = triggerWithOutcomeQuantileConditions
        self.pageUrlConditions = pageUrlConditions
        self.activation = activation
        self.weight = weight
        self.action = action
        self.actionMapScheduleGroups = actionMapScheduleGroups
        self.ignoreFrequencyCap = ignoreFrequencyCap
        self.selfUri = selfUri
        self.createdDate = createdDate
        self.modifiedDate = modifiedDate
        self.startDate = startDate
        self.endDate = endDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
        case isActive
        case displayName
        case triggerWithSegments
        case triggerWithEventConditions
        case triggerWithOutcomeProbabilityConditions
        case triggerWithOutcomePercentileConditions
        case triggerWithOutcomeQuantileConditions
        case pageUrlConditions
        case activation
        case weight
        case action
        case actionMapScheduleGroups
        case ignoreFrequencyCap
        case selfUri
        case createdDate
        case modifiedDate
        case startDate
        case endDate
    }


}




public class PatchAssociatedValueField: Codable {

    public enum DataType: String, Codable { 
        case number = "Number"
        case integer = "Integer"
    }



    /** The data type of the value field. */
    public var dataType: DataType?
    /** The field name for extracting value from event. */
    public var name: String?

    public init(dataType: DataType?, name: String?) {
        self.dataType = dataType
        self.name = name
    }


}




public class PatchContentOfferStyleProperties: Codable {







    /** Padding of the offer. (eg. 10px) */
    public var padding: String?
    /** Text color of the offer. (eg. #FF0000) */
    public var color: String?
    /** Background color of the offer. (eg. #000000) */
    public var backgroundColor: String?

    public init(padding: String?, color: String?, backgroundColor: String?) {
        self.padding = padding
        self.color = color
        self.backgroundColor = backgroundColor
    }


}




public class PatchIntegrationAction: Codable {



    /** ID of the integration action to be invoked. */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class PatchJourneyPattern: Codable {





    public enum StreamType: String, Codable { 
        case web = "Web"
        case custom = "Custom"
        case conversation = "Conversation"
        case app = "App"
    }





    /** A list of one or more criteria to satisfy. */
    public var criteria: [PatchCriteria]?
    /** The number of times the pattern must match. */
    public var count: Int?
    /** The stream type for which this pattern can be matched on. */
    public var streamType: StreamType?
    /** The session type for which this pattern can be matched on. */
    public var sessionType: String?
    /** The name of the event for which this pattern can be matched on. */
    public var eventName: String?

    public init(criteria: [PatchCriteria]?, count: Int?, streamType: StreamType?, sessionType: String?, eventName: String?) {
        self.criteria = criteria
        self.count = count
        self.streamType = streamType
        self.sessionType = sessionType
        self.eventName = eventName
    }


}




public class PatchOutcome: Codable {

















    /** Whether or not the outcome is active. */
    public var isActive: Bool?
    /** The display name of the outcome. */
    public var displayName: String?
    /** The version of the outcome. */
    public var version: Int?
    /** A description of the outcome. */
    public var _description: String?
    /** Whether or not the outcome is positive. */
    public var isPositive: Bool?
    /** The context of the outcome. */
    public var context: PatchContext?
    /** The pattern of rules defining the filter of the outcome. */
    public var journey: PatchJourney?
    /** The field from the event indicating the associated value. */
    public var associatedValueField: PatchAssociatedValueField?

    public init(isActive: Bool?, displayName: String?, version: Int?, _description: String?, isPositive: Bool?, context: PatchContext?, journey: PatchJourney?, associatedValueField: PatchAssociatedValueField?) {
        self.isActive = isActive
        self.displayName = displayName
        self.version = version
        self._description = _description
        self.isPositive = isPositive
        self.context = context
        self.journey = journey
        self.associatedValueField = associatedValueField
    }

    public enum CodingKeys: String, CodingKey { 
        case isActive
        case displayName
        case version
        case _description = "description"
        case isPositive
        case context
        case journey
        case associatedValueField
    }


}




public class PerformancePredictionCompleteEventTopicPerformancePredictionCalculationNotification: Codable {







    public enum State: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }



    public var scheduleId: String?
    public var weekDate: String?
    public var downloadUrl: String?
    public var state: State?
    public var error: PerformancePredictionCompleteEventTopicErrorBody?

    public init(scheduleId: String?, weekDate: String?, downloadUrl: String?, state: State?, error: PerformancePredictionCompleteEventTopicErrorBody?) {
        self.scheduleId = scheduleId
        self.weekDate = weekDate
        self.downloadUrl = downloadUrl
        self.state = state
        self.error = error
    }


}




public class PerformancePredictionRecalculationCompleteEventTopicPerformancePredictionUserRecalculationNotification: Codable {





    public enum State: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }



    public var operationId: String?
    public var downloadUrl: String?
    public var state: State?
    public var error: PerformancePredictionRecalculationCompleteEventTopicErrorBody?

    public init(operationId: String?, downloadUrl: String?, state: State?, error: PerformancePredictionRecalculationCompleteEventTopicErrorBody?) {
        self.operationId = operationId
        self.downloadUrl = downloadUrl
        self.state = state
        self.error = error
    }


}




public class PermissionCollectionEntityListing: Codable {





















    public var entities: [DomainPermissionCollection]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DomainPermissionCollection]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class PhoneChangeTopicEdgeReference: Codable {







    public var _id: String?
    public var name: String?
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}




public class PhoneColumn: Codable {





    /** The name of the phone column. */
    public var columnName: String?
    /** The type of the phone column. For example, 'cell' or 'home'. */
    public var type: String?

    public init(columnName: String?, type: String?) {
        self.columnName = columnName
        self.type = type
    }


}




public class PhoneEntityListing: Codable {





















    public var entities: [Phone]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Phone]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class PhoneEstablishedEvent: Codable {



















    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication */
    public var communicationId: String?
    /** The phone number for this phone. */
    public var phoneNumber: String?
    /** The automatic number identification if it is available for this conversation. */
    public var ani: String?
    /** The dialed number identification if it is available for this conversation. */
    public var dnis: String?
    /** Metadata about this communication. */
    public var initialConfiguration: InitialConfiguration?
    /** Metadata about the source of this communication's interaction. */
    public var sourceConfiguration: SourceConfiguration?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, phoneNumber: String?, ani: String?, dnis: String?, initialConfiguration: InitialConfiguration?, sourceConfiguration: SourceConfiguration?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.phoneNumber = phoneNumber
        self.ani = ani
        self.dnis = dnis
        self.initialConfiguration = initialConfiguration
        self.sourceConfiguration = sourceConfiguration
    }


}




public class PhoneMetaBaseEntityListing: Codable {























    public var entities: [Metabase]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    /** The total organization-wide number of entities. */
    public var totalNumberOfEntities: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Metabase]?, pageSize: Int?, pageNumber: Int?, total: Int64?, totalNumberOfEntities: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.totalNumberOfEntities = totalNumberOfEntities
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class PhoneNumber: Codable {















    /** The displayed form of the phone number string. Users should input the phone number in this field, but it will be altered by the API on write. If the phone number can be read as E164, the value will be replaced with international formatted-version of the number. If the number cannot be read as E164, the value will be preserved as-is. In both cases, the provided input string will be copied to the userInput field. */
    public var display: String?
    /** An optional extension for the provided phone number. */
    public var _extension: Int64?
    /** Whether this phone number can accept SMS messages. */
    public var acceptsSMS: Bool?
    /** The country code that will be used for E164 conversion of a provided phone number. If the country code is omitted from the provided phone number, the country code provided in this field will be used during the E164 conversion attempt. If this field is left empty, the default country code for any provided phone number that does not explicitly include a country code is assumed to be +1 (North America). */
    public var normalizationCountryCode: String?
    /** The user-inputted phone number string that was provided to the display field on write. This field is not user-writeable and will always be set by the system. */
    public var userInput: String?
    /** The E164-formatted form of the provided phone number. This field is not user-writeable and will only be set when the provided phone number could be read as E164. */
    public var e164: String?
    /** The detected country code from the provided phone number. This field is not user-writeable and will only be set when the provided phone number could be read as E164. */
    public var countryCode: String?

    public init(display: String?, _extension: Int64?, acceptsSMS: Bool?, normalizationCountryCode: String?, userInput: String?, e164: String?, countryCode: String?) {
        self.display = display
        self._extension = _extension
        self.acceptsSMS = acceptsSMS
        self.normalizationCountryCode = normalizationCountryCode
        self.userInput = userInput
        self.e164 = e164
        self.countryCode = countryCode
    }

    public enum CodingKeys: String, CodingKey { 
        case display
        case _extension = "extension"
        case acceptsSMS
        case normalizationCountryCode
        case userInput
        case e164
        case countryCode
    }


}




public class PlanningGroup: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The ID of the service goal template associated with this planning group */
    public var serviceGoalTemplate: ServiceGoalTemplateReference?
    /** Set of route paths associated with the planning group */
    public var routePaths: [RoutePathResponse]?
    /** Version metadata for the planning group */
    public var metadata: WfmVersionedEntityMetadata?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, serviceGoalTemplate: ServiceGoalTemplateReference?, routePaths: [RoutePathResponse]?, metadata: WfmVersionedEntityMetadata?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.serviceGoalTemplate = serviceGoalTemplate
        self.routePaths = routePaths
        self.metadata = metadata
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case serviceGoalTemplate
        case routePaths
        case metadata
        case selfUri
    }


}




public class PlanningPeriodSettings: Codable {





    /** Planning period length in weeks */
    public var weekCount: Int?
    /** Start date of the planning period in yyyy-MM-dd format. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var startDate: Date?

    public init(weekCount: Int?, startDate: Date?) {
        self.weekCount = weekCount
        self.startDate = startDate
    }


}




public class PossibleWorkShiftsForWeek: Codable {





    /** ID of this possible weekly shift */
    public var _id: Int?
    /** Daily shifts in this possible weekly shift */
    public var dailyPossibleShifts: [DailyPossibleShift]?

    public init(_id: Int?, dailyPossibleShifts: [DailyPossibleShift]?) {
        self._id = _id
        self.dailyPossibleShifts = dailyPossibleShifts
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case dailyPossibleShifts
    }


}




public class PostTextRequest: Codable {















    public enum BotChannels: String, Codable { 
        case call = "Call"
        case callback = "Callback"
        case messaging = "Messaging"
        case webchat = "Webchat"
    }



    public enum MessagingPlatformType: String, Codable { 
        case phone = "Phone"
        case sms = "SMS"
        case genesysWebWidget = "GenesysWebWidget"
        case facebookMessenger = "FacebookMessenger"
        case weChat = "WeChat"
        case whatsapp = "Whatsapp"
        case appleBusinessChat = "AppleBusinessChat"
        case telegram = "Telegram"
        case slack = "Slack"
        case signal = "Signal"
        case line = "Line"
        case discord = "Discord"
        case twitterDirectMessage = "TwitterDirectMessage"
        case other = "Other"
        case unknown = "Unknown"
    }









    /** ID of the bot to send the text to. */
    public var botId: String?
    /** Alias/Version of the bot */
    public var botAlias: String?
    /** the integration service id for the bot's credentials */
    public var integrationId: String?
    /** GUID for this bot's session */
    public var botSessionId: String?
    /** Message to send to the bot */
    public var postTextMessage: PostTextMessage?
    /** The launguage code the bot will run under */
    public var languageCode: String?
    /** Override timeout for the bot session. This should be greater than 10 minutes. */
    public var botSessionTimeoutMinutes: Int?
    /** The channels this bot is utilizing */
    public var botChannels: [BotChannels]?
    /** Id for tracking the activity - this will be returned in the response */
    public var botCorrelationId: String?
    /** If the channels list contains a 'Messaging' item and the messaging platform is known, include it here to get accurate analytics */
    public var messagingPlatformType: MessagingPlatformType?
    /** Provider specific settings, if any */
    public var amazonLexRequest: AmazonLexRequest?
    /** Provider specific settings, if any */
    public var googleDialogflow: GoogleDialogflowCustomSettings?
    /** Provider specific settings, if any */
    public var genesysBotConnector: GenesysBotConnector?
    /** Provider specific settings, if any */
    public var nuanceMixDlg: NuanceMixDlgSettings?

    public init(botId: String?, botAlias: String?, integrationId: String?, botSessionId: String?, postTextMessage: PostTextMessage?, languageCode: String?, botSessionTimeoutMinutes: Int?, botChannels: [BotChannels]?, botCorrelationId: String?, messagingPlatformType: MessagingPlatformType?, amazonLexRequest: AmazonLexRequest?, googleDialogflow: GoogleDialogflowCustomSettings?, genesysBotConnector: GenesysBotConnector?, nuanceMixDlg: NuanceMixDlgSettings?) {
        self.botId = botId
        self.botAlias = botAlias
        self.integrationId = integrationId
        self.botSessionId = botSessionId
        self.postTextMessage = postTextMessage
        self.languageCode = languageCode
        self.botSessionTimeoutMinutes = botSessionTimeoutMinutes
        self.botChannels = botChannels
        self.botCorrelationId = botCorrelationId
        self.messagingPlatformType = messagingPlatformType
        self.amazonLexRequest = amazonLexRequest
        self.googleDialogflow = googleDialogflow
        self.genesysBotConnector = genesysBotConnector
        self.nuanceMixDlg = nuanceMixDlg
    }


}




public class PredictiveRouting: Codable {





    /** A switch used to determine if agent skills will be considered. */
    public var respectSkills: Bool?
    /** A switch used to determine if conversations are weighted by conversation score when the system attempts to assign an agent a new conversation. */
    public var enableConversationScoreBiasing: Bool?

    public init(respectSkills: Bool?, enableConversationScoreBiasing: Bool?) {
        self.respectSkills = respectSkills
        self.enableConversationScoreBiasing = enableConversationScoreBiasing
    }


}




public class PredictorModelFeature: Codable {



    public enum ModelType: String, Codable { 
        case user = "User"
        case customer = "Customer"
        case other = "Other"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The type of feature. */
    public var type: ModelType?
    /** The percentage of how important a feature is in the model. */
    public var percentageImportance: Double?

    public init(_id: String?, type: ModelType?, percentageImportance: Double?) {
        self._id = _id
        self.type = type
        self.percentageImportance = percentageImportance
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
        case percentageImportance
    }


}




public class PredictorModelFeatureListing: Codable {



    public var entities: [PredictorModelFeature]?

    public init(entities: [PredictorModelFeature]?) {
        self.entities = entities
    }


}




public class PredictorSchedule: Codable {

    public enum ScheduleType: String, Codable { 
        case hourOnHourOff = "HourOnHourOff"
        case ongoingValueMonitoring = "OngoingValueMonitoring"
    }



    /** The predictor schedule type. */
    public var scheduleType: ScheduleType?
    /** DateTime indicating when the predictor schedule was started. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStarted: Date?

    public init(scheduleType: ScheduleType?, dateStarted: Date?) {
        self.scheduleType = scheduleType
        self.dateStarted = dateStarted
    }


}




public class PreprocessingRule: Codable {









    /** The regular expression to which file lines are to be matched. */
    public var find: String?
    /** The string to be substituted for each match. */
    public var replaceWith: String?
    /** Replaces all matching substrings in every line. */
    public var global: Bool?
    /** Enables case-insensitive matching */
    public var ignoreCase: Bool?

    public init(find: String?, replaceWith: String?, global: Bool?, ignoreCase: Bool?) {
        self.find = find
        self.replaceWith = replaceWith
        self.global = global
        self.ignoreCase = ignoreCase
    }


}




public class PresenceDetailQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case organizationpresenceid = "organizationPresenceId"
        case systempresence = "systemPresence"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension predicates */
    public var value: String?
    /** Right hand side for dimension predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case _operator = "operator"
        case value
        case range
    }


}




public class ProfileWithDateRange: Codable {













    /** Profile ID */
    public var _id: String?
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** Start workday used as the date range. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStartWorkday: Date?
    /** End workday used as the date range. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEndWorkday: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, dateStartWorkday: Date?, dateEndWorkday: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.dateStartWorkday = dateStartWorkday
        self.dateEndWorkday = dateEndWorkday
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case dateStartWorkday
        case dateEndWorkday
        case selfUri
    }


}




public class Program: Codable {























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var _description: String?
    public var published: Bool?
    public var topics: [BaseTopicEntitiy]?
    public var tags: [String]?
    public var modifiedBy: AddressableEntityRef?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    public var publishedBy: AddressableEntityRef?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var datePublished: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, published: Bool?, topics: [BaseTopicEntitiy]?, tags: [String]?, modifiedBy: AddressableEntityRef?, dateModified: Date?, publishedBy: AddressableEntityRef?, datePublished: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.published = published
        self.topics = topics
        self.tags = tags
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
        self.publishedBy = publishedBy
        self.datePublished = datePublished
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case published
        case topics
        case tags
        case modifiedBy
        case dateModified
        case publishedBy
        case datePublished
        case selfUri
    }


}




public class ProgramRequest: Codable {









    /** The program name */
    public var name: String?
    /** The program description */
    public var _description: String?
    /** The ids of topics associated to the program */
    public var topicIds: [String]?
    /** The program tags */
    public var tags: [String]?

    public init(name: String?, _description: String?, topicIds: [String]?, tags: [String]?) {
        self.name = name
        self._description = _description
        self.topicIds = topicIds
        self.tags = tags
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _description = "description"
        case topicIds
        case tags
    }


}




public class ProgramTranscriptionEngines: Codable {









    /** The ID of the program */
    public var program: BaseProgramEntity?
    /** The program transcription engine settings */
    public var transcriptionEngines: [TranscriptionEngines]?
    /** The user last modified the record */
    public var modifiedBy: AddressableEntityRef?
    /** The last modified date of the record. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?

    public init(program: BaseProgramEntity?, transcriptionEngines: [TranscriptionEngines]?, modifiedBy: AddressableEntityRef?, dateModified: Date?) {
        self.program = program
        self.transcriptionEngines = transcriptionEngines
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
    }


}




public class ProgressConsultTransferEvent: Codable {













    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** The id (V4 UUID) of the communication representing the participant that is initiating the transfer. */
    public var initiatingCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred to. */
    public var destinationCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred. */
    public var objectCommunicationId: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, initiatingCommunicationId: String?, destinationCommunicationId: String?, objectCommunicationId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.initiatingCommunicationId = initiatingCommunicationId
        self.destinationCommunicationId = destinationCommunicationId
        self.objectCommunicationId = objectCommunicationId
    }


}




public class PropertyIndexRequest: Codable {







    /** Attach properties to a segment in the indicated session */
    public var sessionId: String?
    /** Attach properties to a segment covering a specific point in time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var targetDate: Date?
    /** The list of properties to index */
    public var properties: [AnalyticsProperty]?

    public init(sessionId: String?, targetDate: Date?, properties: [AnalyticsProperty]?) {
        self.sessionId = sessionId
        self.targetDate = targetDate
        self.properties = properties
    }


}



/** A criteria type that can be used in tandem with other criteria type to create queries of executionData */

public class QueryCriteria: Codable {

    public enum CriteriaKey: String, Codable { 
        case flowStartDateTime = "FlowStartDateTime"
        case flowEndDateTime = "FlowEndDateTime"
        case conversationId = "ConversationId"
        case flowType = "FlowType"
        case flowId = "FlowId"
        case flowErrorReason = "FlowErrorReason"
        case flowWarningReason = "FlowWarningReason"
        case flowAlternateExecutionId = "FlowAlternateExecutionId"
        case flowObjectExecutionId = "FlowObjectExecutionId"
        case flowActionId = "FlowActionId"
        case flowActionType = "FlowActionType"
        case flowActionOutputPathId = "FlowActionOutputPathId"
        case flowActionOutputPathName = "FlowActionOutputPathName"
        case flowActionIdOutputPathId = "FlowActionIdOutputPathId"
        case flowActionIdOutputPathName = "FlowActionIdOutputPathName"
        case flowActionTypeOutputPathId = "FlowActionTypeOutputPathId"
        case flowActionTypeOutputPathName = "FlowActionTypeOutputPathName"
        case botId = "BotId"
        case botErrorReason = "BotErrorReason"
        case botFlowExecutionId = "BotFlowExecutionId"
        case botObjectExecutionId = "BotObjectExecutionId"
    }

    public enum CriteriaGroups: String, Codable { 
        case flow = "flow"
        case bot = "bot"
    }





    public enum DataType: String, Codable { 
        case string = "string"
        case guid = "guid"
        case datetime = "dateTime"
    }



    /** The is the name of the criteria that can be queried. */
    public var criteriaKey: CriteriaKey?
    /** The executionData type that this criteria item can be used on. */
    public var criteriaGroups: [CriteriaGroups]?
    /** The is the description of the criteria. */
    public var _description: String?
    /** A list of operators that can be used on this criteria. */
    public var operators: [String]?
    /** The type of data for the criteria (string, int, etc). */
    public var dataType: DataType?
    /** A logical grouping and display order for this item. */
    public var categoryInfo: CriteriaCategoryInfo?

    public init(criteriaKey: CriteriaKey?, criteriaGroups: [CriteriaGroups]?, _description: String?, operators: [String]?, dataType: DataType?, categoryInfo: CriteriaCategoryInfo?) {
        self.criteriaKey = criteriaKey
        self.criteriaGroups = criteriaGroups
        self._description = _description
        self.operators = operators
        self.dataType = dataType
        self.categoryInfo = categoryInfo
    }

    public enum CodingKeys: String, CodingKey { 
        case criteriaKey
        case criteriaGroups
        case _description = "description"
        case operators
        case dataType
        case categoryInfo
    }


}




public class QueryFacetInfo: Codable {





    public var attributes: [FacetKeyAttribute]?
    public var facets: [FacetEntry]?

    public init(attributes: [FacetKeyAttribute]?, facets: [FacetEntry]?) {
        self.attributes = attributes
        self.facets = facets
    }


}




public class QueryRequestFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "And"
        case or = "Or"
    }



    /** The logic used to combine the clauses */
    public var type: ModelType?
    /** The list of clauses used to filter the data */
    public var clauses: [QueryRequestClause]?

    public init(type: ModelType?, clauses: [QueryRequestClause]?) {
        self.type = type
        self.clauses = clauses
    }


}




public class QueryResponseMetric: Codable {

    public enum Metric: String, Codable { 
        case nactivities = "nActivities"
        case nplannedactivities = "nPlannedActivities"
        case ninprogressactivities = "nInProgressActivities"
        case ncompleteactivities = "nCompleteActivities"
        case noverdueactivities = "nOverdueActivities"
        case ninvalidscheduleactivities = "nInvalidScheduleActivities"
    }



    /** The metric this applies to */
    public var metric: Metric?
    /** The aggregated values for this metric */
    public var stats: QueryResponseStats?

    public init(metric: Metric?, stats: QueryResponseStats?) {
        self.metric = metric
        self.stats = stats
    }


}




public class QueryResponseStats: Codable {



    /** The count for this metric */
    public var count: Int?

    public init(count: Int?) {
        self.count = count
    }


}




public class QueryResult: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var body: DomainEntity?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, body: DomainEntity?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.body = body
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case body
        case selfUri
    }


}




public class QueryResults: Codable {





    public var results: DomainEntityListingQueryResult?
    public var facetInfo: QueryFacetInfo?

    public init(results: DomainEntityListingQueryResult?, facetInfo: QueryFacetInfo?) {
        self.results = results
        self.facetInfo = facetInfo
    }


}




public class QueryTimeOffLimitValuesResponse: Codable {



    public var values: [TimeOffLimitValueRange]?

    public init(values: [TimeOffLimitValueRange]?) {
        self.values = values
    }


}




public class QueueConversationCallEventTopicCallMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case timeout = "timeout"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }







































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }

















    public enum RecordingState: String, Codable { 
        case _none = "none"
        case active = "active"
        case paused = "paused"
    }























    public var _id: String?
    public var name: String?
    public var address: String?
    public var startTime: Date?
    public var connectedTime: Date?
    public var endTime: Date?
    public var startHoldTime: Date?
    public var purpose: String?
    public var state: State?
    public var initialState: InitialState?
    public var direction: Direction?
    public var disconnectType: DisconnectType?
    public var held: Bool?
    public var wrapupRequired: Bool?
    public var wrapupPrompt: String?
    public var user: QueueConversationCallEventTopicUriReference?
    public var queue: QueueConversationCallEventTopicUriReference?
    public var team: QueueConversationCallEventTopicUriReference?
    public var attributes: [String:String]?
    public var errorInfo: QueueConversationCallEventTopicErrorBody?
    public var script: QueueConversationCallEventTopicUriReference?
    public var wrapupTimeoutMs: Int?
    public var wrapupSkipped: Bool?
    public var alertingTimeoutMs: Int?
    public var provider: String?
    public var externalContact: QueueConversationCallEventTopicUriReference?
    public var externalOrganization: QueueConversationCallEventTopicUriReference?
    public var wrapup: QueueConversationCallEventTopicWrapup?
    public var conversationRoutingData: QueueConversationCallEventTopicConversationRoutingData?
    public var peer: String?
    public var screenRecordingState: String?
    public var flaggedReason: FlaggedReason?
    public var journeyContext: QueueConversationCallEventTopicJourneyContext?
    public var startAcwTime: Date?
    public var endAcwTime: Date?
    public var mediaRoles: [String]?
    public var queueMediaSettings: QueueConversationCallEventTopicQueueMediaSettings?
    public var muted: Bool?
    public var confined: Bool?
    public var recording: Bool?
    public var recordingState: RecordingState?
    public var securePause: Bool?
    public var group: QueueConversationCallEventTopicUriReference?
    public var ani: String?
    public var dnis: String?
    public var documentId: String?
    public var monitoredParticipantId: String?
    public var coachedParticipantId: String?
    public var bargedParticipantId: String?
    public var bargedTime: Date?
    public var consultParticipantId: String?
    public var faxStatus: QueueConversationCallEventTopicFaxStatus?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, initialState: InitialState?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, user: QueueConversationCallEventTopicUriReference?, queue: QueueConversationCallEventTopicUriReference?, team: QueueConversationCallEventTopicUriReference?, attributes: [String:String]?, errorInfo: QueueConversationCallEventTopicErrorBody?, script: QueueConversationCallEventTopicUriReference?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, alertingTimeoutMs: Int?, provider: String?, externalContact: QueueConversationCallEventTopicUriReference?, externalOrganization: QueueConversationCallEventTopicUriReference?, wrapup: QueueConversationCallEventTopicWrapup?, conversationRoutingData: QueueConversationCallEventTopicConversationRoutingData?, peer: String?, screenRecordingState: String?, flaggedReason: FlaggedReason?, journeyContext: QueueConversationCallEventTopicJourneyContext?, startAcwTime: Date?, endAcwTime: Date?, mediaRoles: [String]?, queueMediaSettings: QueueConversationCallEventTopicQueueMediaSettings?, muted: Bool?, confined: Bool?, recording: Bool?, recordingState: RecordingState?, securePause: Bool?, group: QueueConversationCallEventTopicUriReference?, ani: String?, dnis: String?, documentId: String?, monitoredParticipantId: String?, coachedParticipantId: String?, bargedParticipantId: String?, bargedTime: Date?, consultParticipantId: String?, faxStatus: QueueConversationCallEventTopicFaxStatus?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.conversationRoutingData = conversationRoutingData
        self.peer = peer
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.mediaRoles = mediaRoles
        self.queueMediaSettings = queueMediaSettings
        self.muted = muted
        self.confined = confined
        self.recording = recording
        self.recordingState = recordingState
        self.securePause = securePause
        self.group = group
        self.ani = ani
        self.dnis = dnis
        self.documentId = documentId
        self.monitoredParticipantId = monitoredParticipantId
        self.coachedParticipantId = coachedParticipantId
        self.bargedParticipantId = bargedParticipantId
        self.bargedTime = bargedTime
        self.consultParticipantId = consultParticipantId
        self.faxStatus = faxStatus
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case initialState
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalOrganization
        case wrapup
        case conversationRoutingData
        case peer
        case screenRecordingState
        case flaggedReason
        case journeyContext
        case startAcwTime
        case endAcwTime
        case mediaRoles
        case queueMediaSettings
        case muted
        case confined
        case recording
        case recordingState
        case securePause
        case group
        case ani
        case dnis
        case documentId
        case monitoredParticipantId
        case coachedParticipantId
        case bargedParticipantId
        case bargedTime
        case consultParticipantId
        case faxStatus
    }


}




public class QueueConversationCallEventTopicFaxStatus: Codable {

















    public var direction: String?
    public var expectedPages: Int?
    public var activePage: Int?
    public var linesTransmitted: Int?
    public var bytesTransmitted: Int?
    public var dataRate: Int?
    public var pageErrors: Int?
    public var lineErrors: Int?

    public init(direction: String?, expectedPages: Int?, activePage: Int?, linesTransmitted: Int?, bytesTransmitted: Int?, dataRate: Int?, pageErrors: Int?, lineErrors: Int?) {
        self.direction = direction
        self.expectedPages = expectedPages
        self.activePage = activePage
        self.linesTransmitted = linesTransmitted
        self.bytesTransmitted = bytesTransmitted
        self.dataRate = dataRate
        self.pageErrors = pageErrors
        self.lineErrors = lineErrors
    }


}




public class QueueConversationCallEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}




public class QueueConversationCallbackEventTopicDetail: Codable {









    public var errorCode: String?
    public var fieldName: String?
    public var entityId: String?
    public var entityName: String?

    public init(errorCode: String?, fieldName: String?, entityId: String?, entityName: String?) {
        self.errorCode = errorCode
        self.fieldName = fieldName
        self.entityId = entityId
        self.entityName = entityName
    }


}




public class QueueConversationCallbackEventTopicErrorBody: Codable {





















    public var message: String?
    public var code: String?
    public var status: Int?
    public var entityId: String?
    public var entityName: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var contextId: String?
    public var details: [QueueConversationCallbackEventTopicDetail]?
    public var errors: [QueueConversationCallbackEventTopicErrorBody]?

    public init(message: String?, code: String?, status: Int?, entityId: String?, entityName: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, details: [QueueConversationCallbackEventTopicDetail]?, errors: [QueueConversationCallbackEventTopicErrorBody]?) {
        self.message = message
        self.code = code
        self.status = status
        self.entityId = entityId
        self.entityName = entityName
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.details = details
        self.errors = errors
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class QueueConversationCallbackEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int?

    public init(_id: String?, version: Int?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}




public class QueueConversationCallbackEventTopicPhoneNumberColumn: Codable {





    public var columnName: String?
    public var type: String?

    public init(columnName: String?, type: String?) {
        self.columnName = columnName
        self.type = type
    }


}




public class QueueConversationCallbackEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class QueueConversationChatEventTopicConversationRoutingData: Codable {











    /** A UriReference for a resource */
    public var queue: QueueConversationChatEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: QueueConversationChatEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int?
    /** The skills to use for routing decisions */
    public var skills: [QueueConversationChatEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [QueueConversationChatEventTopicScoredAgent]?

    public init(queue: QueueConversationChatEventTopicUriReference?, language: QueueConversationChatEventTopicUriReference?, priority: Int?, skills: [QueueConversationChatEventTopicUriReference]?, scoredAgents: [QueueConversationChatEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}




public class QueueConversationCobrowseEventTopicDetail: Codable {









    public var errorCode: String?
    public var fieldName: String?
    public var entityId: String?
    public var entityName: String?

    public init(errorCode: String?, fieldName: String?, entityId: String?, entityName: String?) {
        self.errorCode = errorCode
        self.fieldName = fieldName
        self.entityId = entityId
        self.entityName = entityName
    }


}




public class QueueConversationCobrowseEventTopicErrorBody: Codable {





















    public var message: String?
    public var code: String?
    public var status: Int?
    public var entityId: String?
    public var entityName: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var contextId: String?
    public var details: [QueueConversationCobrowseEventTopicDetail]?
    public var errors: [QueueConversationCobrowseEventTopicErrorBody]?

    public init(message: String?, code: String?, status: Int?, entityId: String?, entityName: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, details: [QueueConversationCobrowseEventTopicDetail]?, errors: [QueueConversationCobrowseEventTopicErrorBody]?) {
        self.message = message
        self.code = code
        self.status = status
        self.entityId = entityId
        self.entityName = entityName
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.details = details
        self.errors = errors
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class QueueConversationCobrowseEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int?

    public init(_id: String?, version: Int?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}




public class QueueConversationCobrowseEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class QueueConversationEmailEventTopicAttachment: Codable {











    /** The unique identifier for the attachment. */
    public var attachmentId: String?
    /** The name of the attachment. */
    public var name: String?
    /** The content uri of the attachment. If set, this is commonly a public api download location. */
    public var contentUri: String?
    /** The type of file the attachment is. */
    public var contentType: String?
    /** The length of the attachment file. */
    public var contentLength: Int?

    public init(attachmentId: String?, name: String?, contentUri: String?, contentType: String?, contentLength: Int?) {
        self.attachmentId = attachmentId
        self.name = name
        self.contentUri = contentUri
        self.contentType = contentType
        self.contentLength = contentLength
    }


}




public class QueueConversationEmailEventTopicEmailConversation: Codable {









    public var _id: String?
    public var name: String?
    public var participants: [QueueConversationEmailEventTopicEmailMediaParticipant]?
    public var otherMediaUris: [String]?

    public init(_id: String?, name: String?, participants: [QueueConversationEmailEventTopicEmailMediaParticipant]?, otherMediaUris: [String]?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationEmailEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationEmailEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}




public class QueueConversationEmailEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: QueueConversationEmailEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int?

    public init(agent: QueueConversationEmailEventTopicUriReference?, score: Int?) {
        self.agent = agent
        self.score = score
    }


}




public class QueueConversationEventTopicCallback: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case scheduled = "scheduled"
        case uploading = "uploading"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case scheduled = "scheduled"
        case uploading = "uploading"
        case _none = "none"
    }



    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }



    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferForward = "transfer.forward"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }











































    public var state: State?
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The direction of the call */
    public var direction: Direction?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the callback was placed on hold in the cloud clock if the callback is currently on hold. */
    public var startHoldTime: Date?
    public var dialerPreview: QueueConversationEventTopicDialerPreview?
    public var voicemail: QueueConversationEventTopicVoicemail?
    /** The phone number(s) to use to place the callback. */
    public var callbackNumbers: [String]?
    /** The name of the user requesting a callback. */
    public var callbackUserName: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** True if the call for the callback uses external dialing. */
    public var externalCampaign: Bool?
    /** True if the ability to skip a callback should be enabled. */
    public var skipEnabled: Bool?
    /** The source provider of the callback. */
    public var provider: String?
    /** The number of seconds before the system automatically places a call for a callback.  0 means the automatic placement is disabled. */
    public var timeoutSeconds: Int?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** The timestamp when this communication is scheduled in the provider clock. If this value is missing it indicates the callback will be placed immediately. */
    public var callbackScheduledTime: Date?
    /** The id of the config for automatically placing the callback (and handling the disposition). If null, the callback will not be placed automatically but routed to an agent as per normal. */
    public var automatedCallbackConfigId: String?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** The phone number displayed to recipients of the phone call. The value should conform to the E164 format. */
    public var callerId: String?
    /** The name displayed to recipients of the phone call. */
    public var callerIdName: String?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _id: String?, direction: Direction?, held: Bool?, disconnectType: DisconnectType?, startHoldTime: Date?, dialerPreview: QueueConversationEventTopicDialerPreview?, voicemail: QueueConversationEventTopicVoicemail?, callbackNumbers: [String]?, callbackUserName: String?, scriptId: String?, peerId: String?, externalCampaign: Bool?, skipEnabled: Bool?, provider: String?, timeoutSeconds: Int?, connectedTime: Date?, disconnectedTime: Date?, callbackScheduledTime: Date?, automatedCallbackConfigId: String?, wrapup: QueueConversationEventTopicWrapup?, afterCallWork: QueueConversationEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, callerId: String?, callerIdName: String?, queueMediaSettings: QueueConversationEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.direction = direction
        self.held = held
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.dialerPreview = dialerPreview
        self.voicemail = voicemail
        self.callbackNumbers = callbackNumbers
        self.callbackUserName = callbackUserName
        self.scriptId = scriptId
        self.peerId = peerId
        self.externalCampaign = externalCampaign
        self.skipEnabled = skipEnabled
        self.provider = provider
        self.timeoutSeconds = timeoutSeconds
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.callbackScheduledTime = callbackScheduledTime
        self.automatedCallbackConfigId = automatedCallbackConfigId
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.callerId = callerId
        self.callerIdName = callerIdName
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case direction
        case held
        case disconnectType
        case startHoldTime
        case dialerPreview
        case voicemail
        case callbackNumbers
        case callbackUserName
        case scriptId
        case peerId
        case externalCampaign
        case skipEnabled
        case provider
        case timeoutSeconds
        case connectedTime
        case disconnectedTime
        case callbackScheduledTime
        case automatedCallbackConfigId
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case callerId
        case callerIdName
        case queueMediaSettings
    }


}




public class QueueConversationEventTopicCobrowse: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }



































    public var state: State?
    public var initialState: InitialState?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** Address and name data for a call endpoint. */
    public var _self: QueueConversationEventTopicAddress?
    /** The room id for the chat. */
    public var roomId: String?
    /** The co-browse session ID. */
    public var cobrowseSessionId: String?
    /** This value identifies the role of the co-browse client within the co-browse session (a client is a sharer or a viewer). */
    public var cobrowseRole: String?
    /** ID of co-browse participants for which this client has been granted control (list is empty if this client cannot control any shared pages). */
    public var controlling: [String]?
    /** The URL that can be used to open co-browse session in web browser. */
    public var viewerUrl: String?
    /** The source provider of the co-browse communication. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The time when the provider event which triggered this conversation update happened in the corrected provider clock (milliseconds since 1970-01-01 00:00:00 UTC). */
    public var providerEventTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, disconnectType: DisconnectType?, _id: String?, _self: QueueConversationEventTopicAddress?, roomId: String?, cobrowseSessionId: String?, cobrowseRole: String?, controlling: [String]?, viewerUrl: String?, provider: String?, scriptId: String?, peerId: String?, providerEventTime: Date?, connectedTime: Date?, disconnectedTime: Date?, wrapup: QueueConversationEventTopicWrapup?, afterCallWork: QueueConversationEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: QueueConversationEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self.disconnectType = disconnectType
        self._id = _id
        self._self = _self
        self.roomId = roomId
        self.cobrowseSessionId = cobrowseSessionId
        self.cobrowseRole = cobrowseRole
        self.controlling = controlling
        self.viewerUrl = viewerUrl
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.providerEventTime = providerEventTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case disconnectType
        case _id = "id"
        case _self = "self"
        case roomId
        case cobrowseSessionId
        case cobrowseRole
        case controlling
        case viewerUrl
        case provider
        case scriptId
        case peerId
        case providerEventTime
        case connectedTime
        case disconnectedTime
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}



/** The preview data to be used when this callback is a Preview. */

public class QueueConversationEventTopicDialerPreview: Codable {











    public var _id: String?
    /** The contact associated with this preview data pop */
    public var contactId: String?
    /** The contactList associated with this preview data pop. */
    public var contactListId: String?
    /** The campaignId associated with this preview data pop. */
    public var campaignId: String?
    /** The phone number columns associated with this campaign */
    public var phoneNumberColumns: [QueueConversationEventTopicPhoneNumberColumn]?

    public init(_id: String?, contactId: String?, contactListId: String?, campaignId: String?, phoneNumberColumns: [QueueConversationEventTopicPhoneNumberColumn]?) {
        self._id = _id
        self.contactId = contactId
        self.contactListId = contactListId
        self.campaignId = campaignId
        self.phoneNumberColumns = phoneNumberColumns
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case contactId
        case contactListId
        case campaignId
        case phoneNumberColumns
    }


}



/** Extra information on fax transmission. */

public class QueueConversationEventTopicFaxStatus: Codable {

















    /** The fax direction, either \"send\" or \"receive\". */
    public var direction: String?
    /** Total number of expected pages, if known. */
    public var expectedPages: Int?
    /** Active page of the transmission. */
    public var activePage: Int?
    /** Number of lines that have completed transmission. */
    public var linesTransmitted: Int?
    /** Number of bytes that have competed transmission. */
    public var bytesTransmitted: Int?
    /** Current signaling rate of transmission, baud rate. */
    public var baudRate: Int?
    /** Number of page errors. */
    public var pageErrors: Int?
    /** Number of line errors. */
    public var lineErrors: Int?

    public init(direction: String?, expectedPages: Int?, activePage: Int?, linesTransmitted: Int?, bytesTransmitted: Int?, baudRate: Int?, pageErrors: Int?, lineErrors: Int?) {
        self.direction = direction
        self.expectedPages = expectedPages
        self.activePage = activePage
        self.linesTransmitted = linesTransmitted
        self.bytesTransmitted = bytesTransmitted
        self.baudRate = baudRate
        self.pageErrors = pageErrors
        self.lineErrors = lineErrors
    }


}




public class QueueConversationEventTopicMessageMetadataContent: Codable {





    /** Type of this content element. */
    public var contentType: String?
    /** Content subtype, if any */
    public var subType: String?

    public init(contentType: String?, subType: String?) {
        self.contentType = contentType
        self.subType = subType
    }


}




public class QueueConversationEventTopicParticipant: Codable {





















































    public enum ScreenRecordingState: String, Codable { 
        case requested = "requested"
        case active = "active"
        case paused = "paused"
        case stopped = "stopped"
        case error = "error"
        case timeout = "timeout"
    }

























    /** A globally unique identifier for this conversation. */
    public var _id: String?
    /** The timestamp when this participant was connected to the conversation in the provider clock. */
    public var connectedTime: Date?
    /** The timestamp when this participant disconnected from the conversation in the provider clock. */
    public var endTime: Date?
    /** If this participant represents a user, then this will be the globally unique identifier for the user. */
    public var userId: String?
    /** If this participant represents an external contact, then this will be the globally unique identifier for the external contact. */
    public var externalContactId: String?
    /** If this participant represents an external org, then this will be the globally unique identifier for the external org. */
    public var externalOrganizationId: String?
    /** A human readable name identifying the participant. */
    public var name: String?
    /** If present, the queue id that the communication channel came in on. */
    public var queueId: String?
    /** If present, the group id that the participant represents. */
    public var groupId: String?
    /** The team id that this participant is a member of when added to the conversation. */
    public var teamId: String?
    /** A well known string that specifies the purpose or type of this participant. */
    public var purpose: String?
    /** If this participant is part of a consult transfer, then this will be the participant id of the participant being transferred. */
    public var consultParticipantId: String?
    /** The address for the this participant. For a phone call this will be the ANI. */
    public var address: String?
    /** True iff this participant is required to enter wrapup for this conversation. */
    public var wrapupRequired: Bool?
    /** True when a participant is expected to enter a wrapup code once the call connects. */
    public var wrapupExpected: Bool?
    /** This field controls how the UI prompts the agent for a wrapup. */
    public var wrapupPrompt: String?
    /** Specifies how long a timed ACW session will last. */
    public var wrapupTimeoutMs: Int?
    public var wrapup: QueueConversationEventTopicWrapup?
    /** The timestamp when this participant started after-call work. */
    public var startAcwTime: Date?
    /** The timestamp when this participant ended after-call work. */
    public var endAcwTime: Date?
    public var conversationRoutingData: QueueConversationEventTopicConversationRoutingData?
    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutMs: Int?
    /** If this participant is a monitor, then this will be the id of the participant that is being monitored. */
    public var monitoredParticipantId: String?
    /** If this participant is a coach, then this will be the id of the participant that is being coached. */
    public var coachedParticipantId: String?
    /** If this participant created a barge in conference, then this will be the id of the participant that is barged in. */
    public var bargedParticipantId: String?
    /** List of roles this participant's media has had on the conversation, ie monitor, coach, etc. */
    public var mediaRoles: [String]?
    /** The current screen recording state for this participant. */
    public var screenRecordingState: ScreenRecordingState?
    /** If this participant has flagged the conversation, the reason code given. */
    public var flaggedReason: String?
    /** Additional participant attributes */
    public var attributes: [String:String]?
    public var calls: [QueueConversationEventTopicCall]?
    public var callbacks: [QueueConversationEventTopicCallback]?
    public var chats: [QueueConversationEventTopicChat]?
    public var cobrowsesessions: [QueueConversationEventTopicCobrowse]?
    public var emails: [QueueConversationEventTopicEmail]?
    public var messages: [QueueConversationEventTopicMessage]?
    public var screenshares: [QueueConversationEventTopicScreenshare]?
    public var socialExpressions: [QueueConversationEventTopicSocialExpression]?
    public var videos: [QueueConversationEventTopicVideo]?
    public var workflow: QueueConversationEventTopicWorkflow?

    public init(_id: String?, connectedTime: Date?, endTime: Date?, userId: String?, externalContactId: String?, externalOrganizationId: String?, name: String?, queueId: String?, groupId: String?, teamId: String?, purpose: String?, consultParticipantId: String?, address: String?, wrapupRequired: Bool?, wrapupExpected: Bool?, wrapupPrompt: String?, wrapupTimeoutMs: Int?, wrapup: QueueConversationEventTopicWrapup?, startAcwTime: Date?, endAcwTime: Date?, conversationRoutingData: QueueConversationEventTopicConversationRoutingData?, alertingTimeoutMs: Int?, monitoredParticipantId: String?, coachedParticipantId: String?, bargedParticipantId: String?, mediaRoles: [String]?, screenRecordingState: ScreenRecordingState?, flaggedReason: String?, attributes: [String:String]?, calls: [QueueConversationEventTopicCall]?, callbacks: [QueueConversationEventTopicCallback]?, chats: [QueueConversationEventTopicChat]?, cobrowsesessions: [QueueConversationEventTopicCobrowse]?, emails: [QueueConversationEventTopicEmail]?, messages: [QueueConversationEventTopicMessage]?, screenshares: [QueueConversationEventTopicScreenshare]?, socialExpressions: [QueueConversationEventTopicSocialExpression]?, videos: [QueueConversationEventTopicVideo]?, workflow: QueueConversationEventTopicWorkflow?) {
        self._id = _id
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.userId = userId
        self.externalContactId = externalContactId
        self.externalOrganizationId = externalOrganizationId
        self.name = name
        self.queueId = queueId
        self.groupId = groupId
        self.teamId = teamId
        self.purpose = purpose
        self.consultParticipantId = consultParticipantId
        self.address = address
        self.wrapupRequired = wrapupRequired
        self.wrapupExpected = wrapupExpected
        self.wrapupPrompt = wrapupPrompt
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapup = wrapup
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.conversationRoutingData = conversationRoutingData
        self.alertingTimeoutMs = alertingTimeoutMs
        self.monitoredParticipantId = monitoredParticipantId
        self.coachedParticipantId = coachedParticipantId
        self.bargedParticipantId = bargedParticipantId
        self.mediaRoles = mediaRoles
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.attributes = attributes
        self.calls = calls
        self.callbacks = callbacks
        self.chats = chats
        self.cobrowsesessions = cobrowsesessions
        self.emails = emails
        self.messages = messages
        self.screenshares = screenshares
        self.socialExpressions = socialExpressions
        self.videos = videos
        self.workflow = workflow
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case connectedTime
        case endTime
        case userId
        case externalContactId
        case externalOrganizationId
        case name
        case queueId
        case groupId
        case teamId
        case purpose
        case consultParticipantId
        case address
        case wrapupRequired
        case wrapupExpected
        case wrapupPrompt
        case wrapupTimeoutMs
        case wrapup
        case startAcwTime
        case endAcwTime
        case conversationRoutingData
        case alertingTimeoutMs
        case monitoredParticipantId
        case coachedParticipantId
        case bargedParticipantId
        case mediaRoles
        case screenRecordingState
        case flaggedReason
        case attributes
        case calls
        case callbacks
        case chats
        case cobrowsesessions
        case emails
        case messages
        case screenshares
        case socialExpressions
        case videos
        case workflow
    }


}



/** Represents the queue setting for this media. */

public class QueueConversationEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}




public class QueueConversationEventTopicRecentTransfer: Codable {



    public enum State: String, Codable { 
        case pending = "pending"
        case active = "active"
        case complete = "complete"
        case canceled = "canceled"
        case failed = "failed"
        case timeout = "timeout"
        case unknown = "unknown"
    }









    public enum TransferType: String, Codable { 
        case attended = "attended"
        case unattended = "unattended"
    }

    /** The id of the command. */
    public var _id: String?
    public var state: State?
    /** The date/time that this command was issued. */
    public var dateIssued: Date?
    public var initiator: QueueConversationEventTopicInitiator?
    public var modifiedBy: QueueConversationEventTopicModifiedBy?
    public var destination: QueueConversationEventTopicDestination?
    /** The type of transfer to perform. */
    public var transferType: TransferType?

    public init(_id: String?, state: State?, dateIssued: Date?, initiator: QueueConversationEventTopicInitiator?, modifiedBy: QueueConversationEventTopicModifiedBy?, destination: QueueConversationEventTopicDestination?, transferType: TransferType?) {
        self._id = _id
        self.state = state
        self.dateIssued = dateIssued
        self.initiator = initiator
        self.modifiedBy = modifiedBy
        self.destination = destination
        self.transferType = transferType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case dateIssued
        case initiator
        case modifiedBy
        case destination
        case transferType
    }


}



/** The voicemail data to be used when this callback is an ACD voicemail. */

public class QueueConversationEventTopicVoicemail: Codable {



    public enum UploadStatus: String, Codable { 
        case pending = "pending"
        case complete = "complete"
        case failed = "failed"
        case timeout = "timeout"
        case _none = "none"
    }

    /** The voicemail id */
    public var _id: String?
    /** current state of the voicemail upload */
    public var uploadStatus: UploadStatus?

    public init(_id: String?, uploadStatus: UploadStatus?) {
        self._id = _id
        self.uploadStatus = uploadStatus
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case uploadStatus
    }


}




public class QueueConversationMessageEventTopicConversationRoutingData: Codable {











    /** A UriReference for a resource */
    public var queue: QueueConversationMessageEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: QueueConversationMessageEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int?
    /** The skills to use for routing decisions */
    public var skills: [QueueConversationMessageEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [QueueConversationMessageEventTopicScoredAgent]?

    public init(queue: QueueConversationMessageEventTopicUriReference?, language: QueueConversationMessageEventTopicUriReference?, priority: Int?, skills: [QueueConversationMessageEventTopicUriReference]?, scoredAgents: [QueueConversationMessageEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}




public class QueueConversationMessageEventTopicErrorDetails: Codable {















    /** The HTTP status code for this message (400, 401, 403, 404, 500, etc. */
    public var status: Int?
    /** A code unique to this error. */
    public var code: String?
    /** Friendly description of this error. */
    public var message: String?
    /** This is the same as message except it uses template fields for variable replacement. For instance: 'User {username} was not found' */
    public var messageWithParams: String?
    /** Used in conjunction with messageWithParams. These are the template parameters. For instance: UserParam.key = 'username', UserParam.value = 'john.doe' */
    public var messageParams: [String:String]?
    /** The correlation Id or context Id for this message. If left blank the Public API will look at the HTTP response header 'ININ-Correlation-Id' instead. */
    public var contextId: String?
    public var uri: String?

    public init(status: Int?, code: String?, message: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, uri: String?) {
        self.status = status
        self.code = code
        self.message = message
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.uri = uri
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class QueueConversationScreenShareEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: QueueConversationScreenShareEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: QueueConversationScreenShareEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}




public class QueueConversationScreenShareEventTopicJourneyContext: Codable {







    public var customer: QueueConversationScreenShareEventTopicJourneyCustomer?
    public var customerSession: QueueConversationScreenShareEventTopicJourneyCustomerSession?
    public var triggeringAction: QueueConversationScreenShareEventTopicJourneyAction?

    public init(customer: QueueConversationScreenShareEventTopicJourneyCustomer?, customerSession: QueueConversationScreenShareEventTopicJourneyCustomerSession?, triggeringAction: QueueConversationScreenShareEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class QueueConversationScreenShareEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}




public class QueueConversationSocialExpressionEventTopicCallback: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case scheduled = "scheduled"
        case uploading = "uploading"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case scheduled = "scheduled"
        case uploading = "uploading"
        case _none = "none"
    }



    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }



    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferForward = "transfer.forward"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }











































    public var state: State?
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The direction of the call */
    public var direction: Direction?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the callback was placed on hold in the cloud clock if the callback is currently on hold. */
    public var startHoldTime: Date?
    public var dialerPreview: QueueConversationSocialExpressionEventTopicDialerPreview?
    public var voicemail: QueueConversationSocialExpressionEventTopicVoicemail?
    /** The phone number(s) to use to place the callback. */
    public var callbackNumbers: [String]?
    /** The name of the user requesting a callback. */
    public var callbackUserName: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** True if the call for the callback uses external dialing. */
    public var externalCampaign: Bool?
    /** True if the ability to skip a callback should be enabled. */
    public var skipEnabled: Bool?
    /** The source provider of the callback. */
    public var provider: String?
    /** The number of seconds before the system automatically places a call for a callback.  0 means the automatic placement is disabled. */
    public var timeoutSeconds: Int?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** The timestamp when this communication is scheduled in the provider clock. If this value is missing it indicates the callback will be placed immediately. */
    public var callbackScheduledTime: Date?
    /** The id of the config for automatically placing the callback (and handling the disposition). If null, the callback will not be placed automatically but routed to an agent as per normal. */
    public var automatedCallbackConfigId: String?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationSocialExpressionEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationSocialExpressionEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** The phone number displayed to recipients of the phone call. The value should conform to the E164 format. */
    public var callerId: String?
    /** The name displayed to recipients of the phone call. */
    public var callerIdName: String?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationSocialExpressionEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _id: String?, direction: Direction?, held: Bool?, disconnectType: DisconnectType?, startHoldTime: Date?, dialerPreview: QueueConversationSocialExpressionEventTopicDialerPreview?, voicemail: QueueConversationSocialExpressionEventTopicVoicemail?, callbackNumbers: [String]?, callbackUserName: String?, scriptId: String?, peerId: String?, externalCampaign: Bool?, skipEnabled: Bool?, provider: String?, timeoutSeconds: Int?, connectedTime: Date?, disconnectedTime: Date?, callbackScheduledTime: Date?, automatedCallbackConfigId: String?, wrapup: QueueConversationSocialExpressionEventTopicWrapup?, afterCallWork: QueueConversationSocialExpressionEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, callerId: String?, callerIdName: String?, queueMediaSettings: QueueConversationSocialExpressionEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.direction = direction
        self.held = held
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.dialerPreview = dialerPreview
        self.voicemail = voicemail
        self.callbackNumbers = callbackNumbers
        self.callbackUserName = callbackUserName
        self.scriptId = scriptId
        self.peerId = peerId
        self.externalCampaign = externalCampaign
        self.skipEnabled = skipEnabled
        self.provider = provider
        self.timeoutSeconds = timeoutSeconds
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.callbackScheduledTime = callbackScheduledTime
        self.automatedCallbackConfigId = automatedCallbackConfigId
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.callerId = callerId
        self.callerIdName = callerIdName
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case direction
        case held
        case disconnectType
        case startHoldTime
        case dialerPreview
        case voicemail
        case callbackNumbers
        case callbackUserName
        case scriptId
        case peerId
        case externalCampaign
        case skipEnabled
        case provider
        case timeoutSeconds
        case connectedTime
        case disconnectedTime
        case callbackScheduledTime
        case automatedCallbackConfigId
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case callerId
        case callerIdName
        case queueMediaSettings
    }


}




public class QueueConversationSocialExpressionEventTopicCobrowse: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }



































    public var state: State?
    public var initialState: InitialState?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** Address and name data for a call endpoint. */
    public var _self: QueueConversationSocialExpressionEventTopicAddress?
    /** The room id for the chat. */
    public var roomId: String?
    /** The co-browse session ID. */
    public var cobrowseSessionId: String?
    /** This value identifies the role of the co-browse client within the co-browse session (a client is a sharer or a viewer). */
    public var cobrowseRole: String?
    /** ID of co-browse participants for which this client has been granted control (list is empty if this client cannot control any shared pages). */
    public var controlling: [String]?
    /** The URL that can be used to open co-browse session in web browser. */
    public var viewerUrl: String?
    /** The source provider of the co-browse communication. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The time when the provider event which triggered this conversation update happened in the corrected provider clock (milliseconds since 1970-01-01 00:00:00 UTC). */
    public var providerEventTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationSocialExpressionEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationSocialExpressionEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationSocialExpressionEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, disconnectType: DisconnectType?, _id: String?, _self: QueueConversationSocialExpressionEventTopicAddress?, roomId: String?, cobrowseSessionId: String?, cobrowseRole: String?, controlling: [String]?, viewerUrl: String?, provider: String?, scriptId: String?, peerId: String?, providerEventTime: Date?, connectedTime: Date?, disconnectedTime: Date?, wrapup: QueueConversationSocialExpressionEventTopicWrapup?, afterCallWork: QueueConversationSocialExpressionEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: QueueConversationSocialExpressionEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self.disconnectType = disconnectType
        self._id = _id
        self._self = _self
        self.roomId = roomId
        self.cobrowseSessionId = cobrowseSessionId
        self.cobrowseRole = cobrowseRole
        self.controlling = controlling
        self.viewerUrl = viewerUrl
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.providerEventTime = providerEventTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case disconnectType
        case _id = "id"
        case _self = "self"
        case roomId
        case cobrowseSessionId
        case cobrowseRole
        case controlling
        case viewerUrl
        case provider
        case scriptId
        case peerId
        case providerEventTime
        case connectedTime
        case disconnectedTime
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}



/** The preview data to be used when this callback is a Preview. */

public class QueueConversationSocialExpressionEventTopicDialerPreview: Codable {











    public var _id: String?
    /** The contact associated with this preview data pop */
    public var contactId: String?
    /** The contactList associated with this preview data pop. */
    public var contactListId: String?
    /** The campaignId associated with this preview data pop. */
    public var campaignId: String?
    /** The phone number columns associated with this campaign */
    public var phoneNumberColumns: [QueueConversationSocialExpressionEventTopicPhoneNumberColumn]?

    public init(_id: String?, contactId: String?, contactListId: String?, campaignId: String?, phoneNumberColumns: [QueueConversationSocialExpressionEventTopicPhoneNumberColumn]?) {
        self._id = _id
        self.contactId = contactId
        self.contactListId = contactListId
        self.campaignId = campaignId
        self.phoneNumberColumns = phoneNumberColumns
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case contactId
        case contactListId
        case campaignId
        case phoneNumberColumns
    }


}



/** Extra information on fax transmission. */

public class QueueConversationSocialExpressionEventTopicFaxStatus: Codable {

















    /** The fax direction, either \"send\" or \"receive\". */
    public var direction: String?
    /** Total number of expected pages, if known. */
    public var expectedPages: Int?
    /** Active page of the transmission. */
    public var activePage: Int?
    /** Number of lines that have completed transmission. */
    public var linesTransmitted: Int?
    /** Number of bytes that have competed transmission. */
    public var bytesTransmitted: Int?
    /** Current signaling rate of transmission, baud rate. */
    public var baudRate: Int?
    /** Number of page errors. */
    public var pageErrors: Int?
    /** Number of line errors. */
    public var lineErrors: Int?

    public init(direction: String?, expectedPages: Int?, activePage: Int?, linesTransmitted: Int?, bytesTransmitted: Int?, baudRate: Int?, pageErrors: Int?, lineErrors: Int?) {
        self.direction = direction
        self.expectedPages = expectedPages
        self.activePage = activePage
        self.linesTransmitted = linesTransmitted
        self.bytesTransmitted = bytesTransmitted
        self.baudRate = baudRate
        self.pageErrors = pageErrors
        self.lineErrors = lineErrors
    }


}




public class QueueConversationSocialExpressionEventTopicMessageMetadataContent: Codable {





    /** Type of this content element. */
    public var contentType: String?
    /** Content subtype, if any */
    public var subType: String?

    public init(contentType: String?, subType: String?) {
        self.contentType = contentType
        self.subType = subType
    }


}




public class QueueConversationSocialExpressionEventTopicParticipant: Codable {





















































    public enum ScreenRecordingState: String, Codable { 
        case requested = "requested"
        case active = "active"
        case paused = "paused"
        case stopped = "stopped"
        case error = "error"
        case timeout = "timeout"
    }

























    /** A globally unique identifier for this conversation. */
    public var _id: String?
    /** The timestamp when this participant was connected to the conversation in the provider clock. */
    public var connectedTime: Date?
    /** The timestamp when this participant disconnected from the conversation in the provider clock. */
    public var endTime: Date?
    /** If this participant represents a user, then this will be the globally unique identifier for the user. */
    public var userId: String?
    /** If this participant represents an external contact, then this will be the globally unique identifier for the external contact. */
    public var externalContactId: String?
    /** If this participant represents an external org, then this will be the globally unique identifier for the external org. */
    public var externalOrganizationId: String?
    /** A human readable name identifying the participant. */
    public var name: String?
    /** If present, the queue id that the communication channel came in on. */
    public var queueId: String?
    /** If present, the group id that the participant represents. */
    public var groupId: String?
    /** The team id that this participant is a member of when added to the conversation. */
    public var teamId: String?
    /** A well known string that specifies the purpose or type of this participant. */
    public var purpose: String?
    /** If this participant is part of a consult transfer, then this will be the participant id of the participant being transferred. */
    public var consultParticipantId: String?
    /** The address for the this participant. For a phone call this will be the ANI. */
    public var address: String?
    /** True iff this participant is required to enter wrapup for this conversation. */
    public var wrapupRequired: Bool?
    /** True when a participant is expected to enter a wrapup code once the call connects. */
    public var wrapupExpected: Bool?
    /** This field controls how the UI prompts the agent for a wrapup. */
    public var wrapupPrompt: String?
    /** Specifies how long a timed ACW session will last. */
    public var wrapupTimeoutMs: Int?
    public var wrapup: QueueConversationSocialExpressionEventTopicWrapup?
    /** The timestamp when this participant started after-call work. */
    public var startAcwTime: Date?
    /** The timestamp when this participant ended after-call work. */
    public var endAcwTime: Date?
    public var conversationRoutingData: QueueConversationSocialExpressionEventTopicConversationRoutingData?
    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutMs: Int?
    /** If this participant is a monitor, then this will be the id of the participant that is being monitored. */
    public var monitoredParticipantId: String?
    /** If this participant is a coach, then this will be the id of the participant that is being coached. */
    public var coachedParticipantId: String?
    /** If this participant created a barge in conference, then this will be the id of the participant that is barged in. */
    public var bargedParticipantId: String?
    /** List of roles this participant's media has had on the conversation, ie monitor, coach, etc. */
    public var mediaRoles: [String]?
    /** The current screen recording state for this participant. */
    public var screenRecordingState: ScreenRecordingState?
    /** If this participant has flagged the conversation, the reason code given. */
    public var flaggedReason: String?
    /** Additional participant attributes */
    public var attributes: [String:String]?
    public var calls: [QueueConversationSocialExpressionEventTopicCall]?
    public var callbacks: [QueueConversationSocialExpressionEventTopicCallback]?
    public var chats: [QueueConversationSocialExpressionEventTopicChat]?
    public var cobrowsesessions: [QueueConversationSocialExpressionEventTopicCobrowse]?
    public var emails: [QueueConversationSocialExpressionEventTopicEmail]?
    public var messages: [QueueConversationSocialExpressionEventTopicMessage]?
    public var screenshares: [QueueConversationSocialExpressionEventTopicScreenshare]?
    public var socialExpressions: [QueueConversationSocialExpressionEventTopicSocialExpression]?
    public var videos: [QueueConversationSocialExpressionEventTopicVideo]?
    public var workflow: QueueConversationSocialExpressionEventTopicWorkflow?

    public init(_id: String?, connectedTime: Date?, endTime: Date?, userId: String?, externalContactId: String?, externalOrganizationId: String?, name: String?, queueId: String?, groupId: String?, teamId: String?, purpose: String?, consultParticipantId: String?, address: String?, wrapupRequired: Bool?, wrapupExpected: Bool?, wrapupPrompt: String?, wrapupTimeoutMs: Int?, wrapup: QueueConversationSocialExpressionEventTopicWrapup?, startAcwTime: Date?, endAcwTime: Date?, conversationRoutingData: QueueConversationSocialExpressionEventTopicConversationRoutingData?, alertingTimeoutMs: Int?, monitoredParticipantId: String?, coachedParticipantId: String?, bargedParticipantId: String?, mediaRoles: [String]?, screenRecordingState: ScreenRecordingState?, flaggedReason: String?, attributes: [String:String]?, calls: [QueueConversationSocialExpressionEventTopicCall]?, callbacks: [QueueConversationSocialExpressionEventTopicCallback]?, chats: [QueueConversationSocialExpressionEventTopicChat]?, cobrowsesessions: [QueueConversationSocialExpressionEventTopicCobrowse]?, emails: [QueueConversationSocialExpressionEventTopicEmail]?, messages: [QueueConversationSocialExpressionEventTopicMessage]?, screenshares: [QueueConversationSocialExpressionEventTopicScreenshare]?, socialExpressions: [QueueConversationSocialExpressionEventTopicSocialExpression]?, videos: [QueueConversationSocialExpressionEventTopicVideo]?, workflow: QueueConversationSocialExpressionEventTopicWorkflow?) {
        self._id = _id
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.userId = userId
        self.externalContactId = externalContactId
        self.externalOrganizationId = externalOrganizationId
        self.name = name
        self.queueId = queueId
        self.groupId = groupId
        self.teamId = teamId
        self.purpose = purpose
        self.consultParticipantId = consultParticipantId
        self.address = address
        self.wrapupRequired = wrapupRequired
        self.wrapupExpected = wrapupExpected
        self.wrapupPrompt = wrapupPrompt
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapup = wrapup
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.conversationRoutingData = conversationRoutingData
        self.alertingTimeoutMs = alertingTimeoutMs
        self.monitoredParticipantId = monitoredParticipantId
        self.coachedParticipantId = coachedParticipantId
        self.bargedParticipantId = bargedParticipantId
        self.mediaRoles = mediaRoles
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.attributes = attributes
        self.calls = calls
        self.callbacks = callbacks
        self.chats = chats
        self.cobrowsesessions = cobrowsesessions
        self.emails = emails
        self.messages = messages
        self.screenshares = screenshares
        self.socialExpressions = socialExpressions
        self.videos = videos
        self.workflow = workflow
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case connectedTime
        case endTime
        case userId
        case externalContactId
        case externalOrganizationId
        case name
        case queueId
        case groupId
        case teamId
        case purpose
        case consultParticipantId
        case address
        case wrapupRequired
        case wrapupExpected
        case wrapupPrompt
        case wrapupTimeoutMs
        case wrapup
        case startAcwTime
        case endAcwTime
        case conversationRoutingData
        case alertingTimeoutMs
        case monitoredParticipantId
        case coachedParticipantId
        case bargedParticipantId
        case mediaRoles
        case screenRecordingState
        case flaggedReason
        case attributes
        case calls
        case callbacks
        case chats
        case cobrowsesessions
        case emails
        case messages
        case screenshares
        case socialExpressions
        case videos
        case workflow
    }


}



/** Represents the queue setting for this media. */

public class QueueConversationSocialExpressionEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}




public class QueueConversationSocialExpressionEventTopicRecentTransfer: Codable {



    public enum State: String, Codable { 
        case pending = "pending"
        case active = "active"
        case complete = "complete"
        case canceled = "canceled"
        case failed = "failed"
        case timeout = "timeout"
        case unknown = "unknown"
    }









    public enum TransferType: String, Codable { 
        case attended = "attended"
        case unattended = "unattended"
    }

    /** The id of the command. */
    public var _id: String?
    public var state: State?
    /** The date/time that this command was issued. */
    public var dateIssued: Date?
    public var initiator: QueueConversationSocialExpressionEventTopicInitiator?
    public var modifiedBy: QueueConversationSocialExpressionEventTopicModifiedBy?
    public var destination: QueueConversationSocialExpressionEventTopicDestination?
    /** The type of transfer to perform. */
    public var transferType: TransferType?

    public init(_id: String?, state: State?, dateIssued: Date?, initiator: QueueConversationSocialExpressionEventTopicInitiator?, modifiedBy: QueueConversationSocialExpressionEventTopicModifiedBy?, destination: QueueConversationSocialExpressionEventTopicDestination?, transferType: TransferType?) {
        self._id = _id
        self.state = state
        self.dateIssued = dateIssued
        self.initiator = initiator
        self.modifiedBy = modifiedBy
        self.destination = destination
        self.transferType = transferType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case dateIssued
        case initiator
        case modifiedBy
        case destination
        case transferType
    }


}



/** The voicemail data to be used when this callback is an ACD voicemail. */

public class QueueConversationSocialExpressionEventTopicVoicemail: Codable {



    public enum UploadStatus: String, Codable { 
        case pending = "pending"
        case complete = "complete"
        case failed = "failed"
        case timeout = "timeout"
        case _none = "none"
    }

    /** The voicemail id */
    public var _id: String?
    /** current state of the voicemail upload */
    public var uploadStatus: UploadStatus?

    public init(_id: String?, uploadStatus: UploadStatus?) {
        self._id = _id
        self.uploadStatus = uploadStatus
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case uploadStatus
    }


}




public class QueueConversationVideoEventTopicAttachment: Codable {











    /** The unique identifier for the attachment. */
    public var attachmentId: String?
    /** The name of the attachment. */
    public var name: String?
    /** The content uri of the attachment. If set, this is commonly a public api download location. */
    public var contentUri: String?
    /** The type of file the attachment is. */
    public var contentType: String?
    /** The length of the attachment file. */
    public var contentLength: Int?

    public init(attachmentId: String?, name: String?, contentUri: String?, contentType: String?, contentLength: Int?) {
        self.attachmentId = attachmentId
        self.name = name
        self.contentUri = contentUri
        self.contentType = contentType
        self.contentLength = contentLength
    }


}




public class QueueConversationVideoEventTopicEmail: Codable {



    public enum State: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case disconnected = "disconnected"
        case _none = "none"
        case transmitting = "transmitting"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case disconnected = "disconnected"
        case _none = "none"
        case transmitting = "transmitting"
    }

















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }









    public enum Direction: String, Codable { 
        case outbound = "outbound"
        case inbound = "inbound"
    }













    /** A globally unique identifier for this communication. */
    public var _id: String?
    public var state: State?
    public var initialState: InitialState?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** Indicates that the email was auto-generated like an Out of Office reply. */
    public var autoGenerated: Bool?
    /** The subject for the initial email that started this conversation. */
    public var subject: String?
    /** The source provider of the email. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The number of email messages sent by this participant. */
    public var messagesSent: Int?
    /** Detailed information about an error response. */
    public var errorInfo: QueueConversationVideoEventTopicErrorDetails?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the email was placed on hold in the cloud clock if the email is currently on hold. */
    public var startHoldTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** A globally unique identifier for the stored content of this communication. */
    public var messageId: String?
    /** Whether an email is inbound or outbound. */
    public var direction: Direction?
    /** A list of uploaded attachments on the email draft. */
    public var draftAttachments: [QueueConversationVideoEventTopicAttachment]?
    /** Indicates if the inbound email was marked as spam. */
    public var spam: Bool?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationVideoEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationVideoEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationVideoEventTopicQueueMediaSettings?

    public init(_id: String?, state: State?, initialState: InitialState?, held: Bool?, autoGenerated: Bool?, subject: String?, provider: String?, scriptId: String?, peerId: String?, messagesSent: Int?, errorInfo: QueueConversationVideoEventTopicErrorDetails?, disconnectType: DisconnectType?, startHoldTime: Date?, connectedTime: Date?, disconnectedTime: Date?, messageId: String?, direction: Direction?, draftAttachments: [QueueConversationVideoEventTopicAttachment]?, spam: Bool?, wrapup: QueueConversationVideoEventTopicWrapup?, afterCallWork: QueueConversationVideoEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: QueueConversationVideoEventTopicQueueMediaSettings?) {
        self._id = _id
        self.state = state
        self.initialState = initialState
        self.held = held
        self.autoGenerated = autoGenerated
        self.subject = subject
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.messagesSent = messagesSent
        self.errorInfo = errorInfo
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.messageId = messageId
        self.direction = direction
        self.draftAttachments = draftAttachments
        self.spam = spam
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case initialState
        case held
        case autoGenerated
        case subject
        case provider
        case scriptId
        case peerId
        case messagesSent
        case errorInfo
        case disconnectType
        case startHoldTime
        case connectedTime
        case disconnectedTime
        case messageId
        case direction
        case draftAttachments
        case spam
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationVideoEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationVideoEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}



/** Fields identifying the entity that updated the command. */

public class QueueConversationVideoEventTopicModifiedBy: Codable {





    /** The id of the user if the updater is an internal user. */
    public var _id: String?
    /** The URI for the user if the updater is an internal user. */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class QueueConversationVideoEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: QueueConversationVideoEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int?

    public init(agent: QueueConversationVideoEventTopicUriReference?, score: Int?) {
        self.agent = agent
        self.score = score
    }


}




public class QueueConversationVideoEventTopicVideo: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }





















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }















    public var state: State?
    public var initialState: InitialState?
    /** Address and name data for a call endpoint. */
    public var _self: QueueConversationVideoEventTopicAddress?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The room id context (xmpp jid) for the conference session. */
    public var context: String?
    /** Indicates whether this participant has muted their outgoing audio. */
    public var audioMuted: Bool?
    /** Indicates whether this participant has muted/paused their outgoing video. */
    public var videoMuted: Bool?
    /** Indicates whether this participant is sharing their screen to the session. */
    public var sharingScreen: Bool?
    /** The number of peer participants from the perspective of the participant in the conference. */
    public var peerCount: JSON?
    /** The media provider controlling the video. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** List of media stream ids */
    public var msids: [String]?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationVideoEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationVideoEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationVideoEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _self: QueueConversationVideoEventTopicAddress?, _id: String?, context: String?, audioMuted: Bool?, videoMuted: Bool?, sharingScreen: Bool?, peerCount: JSON?, provider: String?, scriptId: String?, peerId: String?, disconnectType: DisconnectType?, connectedTime: Date?, disconnectedTime: Date?, msids: [String]?, wrapup: QueueConversationVideoEventTopicWrapup?, afterCallWork: QueueConversationVideoEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: QueueConversationVideoEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._self = _self
        self._id = _id
        self.context = context
        self.audioMuted = audioMuted
        self.videoMuted = videoMuted
        self.sharingScreen = sharingScreen
        self.peerCount = peerCount
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.disconnectType = disconnectType
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.msids = msids
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _self = "self"
        case _id = "id"
        case context
        case audioMuted
        case videoMuted
        case sharingScreen
        case peerCount
        case provider
        case scriptId
        case peerId
        case disconnectType
        case connectedTime
        case disconnectedTime
        case msids
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}




public class QueueObservationQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case mediatype = "mediaType"
        case queueid = "queueId"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension predicates */
    public var value: String?
    /** Right hand side for dimension predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case _operator = "operator"
        case value
        case range
    }


}




public class QueueReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class QueueUserEventTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class QuickReply: Codable {







    public enum Action: String, Codable { 
        case message = "Message"
    }



    /** Text to show inside the quick reply. This is also used as the response text after clicking on the quick reply. */
    public var text: String?
    /** Content of the textback payload after clicking a quick reply */
    public var payload: String?
    /** The location of the image file associated with quick reply */
    public var url: String?
    /** Specifies the type of action that is triggered upon clicking the quick reply. Currently, the only supported action is \"Message\" which sends a message using the quick reply text. */
    public var action: Action?
    /** Indicates if the quick reply option is selected by end customer */
    public var isSelected: Bool?

    public init(text: String?, payload: String?, url: String?, action: Action?, isSelected: Bool?) {
        self.text = text
        self.payload = payload
        self.url = url
        self.action = action
        self.isSelected = isSelected
    }


}




public class RateLimitAggregateQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [RateLimitAggregateQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [RateLimitAggregateQueryPredicate]?

    public init(type: ModelType?, clauses: [RateLimitAggregateQueryClause]?, predicates: [RateLimitAggregateQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class RecordingAnnotationQueue: Codable {





    /** The queue name */
    public var name: String?
    /** The queue Id */
    public var _id: String?

    public init(name: String?, _id: String?) {
        self.name = name
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _id = "id"
    }


}



/** Structured template button object. */

public class RecordingButtonComponent: Codable {







    public var title: String?
    public var actions: RecordingContentActions?
    public var isSelected: Bool?

    public init(title: String?, actions: RecordingContentActions?, isSelected: Bool?) {
        self.title = title
        self.actions = actions
        self.isSelected = isSelected
    }


}




public class RecordingEventMediaResult: Codable {









    public var channelId: String?
    public var waveUri: String?
    public var mediaUri: String?
    public var waveformData: [Double]?

    public init(channelId: String?, waveUri: String?, mediaUri: String?, waveformData: [Double]?) {
        self.channelId = channelId
        self.waveUri = waveUri
        self.mediaUri = mediaUri
        self.waveformData = waveformData
    }


}




public class RecordingJob: Codable {



    public enum State: String, Codable { 
        case fulfilled = "FULFILLED"
        case pending = "PENDING"
        case ready = "READY"
        case processing = "PROCESSING"
        case cancelled = "CANCELLED"
        case failed = "FAILED"
    }

























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The current state of the job. */
    public var state: State?
    /** Original query of the job. */
    public var recordingJobsQuery: RecordingJobsQuery?
    /** Date when the job was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Total number of conversations affected. */
    public var totalConversations: Int?
    /** Total number of recordings affected. */
    public var totalRecordings: Int?
    /** Total number of recordings that have been skipped. */
    public var totalSkippedRecordings: Int?
    /** Total number of recordings that the bulk job failed to process. */
    public var totalFailedRecordings: Int?
    /** Total number of recordings have been processed. */
    public var totalProcessedRecordings: Int?
    /** Progress in percentage based on the number of recordings */
    public var percentProgress: Int?
    /** Error occurred during the job execution */
    public var errorMessage: String?
    /** Get IDs of recordings that the bulk job failed for */
    public var failedRecordings: String?
    /** The URI for this object */
    public var selfUri: String?
    /** Details of the user created the job */
    public var user: AddressableEntityRef?

    public init(_id: String?, state: State?, recordingJobsQuery: RecordingJobsQuery?, dateCreated: Date?, totalConversations: Int?, totalRecordings: Int?, totalSkippedRecordings: Int?, totalFailedRecordings: Int?, totalProcessedRecordings: Int?, percentProgress: Int?, errorMessage: String?, failedRecordings: String?, selfUri: String?, user: AddressableEntityRef?) {
        self._id = _id
        self.state = state
        self.recordingJobsQuery = recordingJobsQuery
        self.dateCreated = dateCreated
        self.totalConversations = totalConversations
        self.totalRecordings = totalRecordings
        self.totalSkippedRecordings = totalSkippedRecordings
        self.totalFailedRecordings = totalFailedRecordings
        self.totalProcessedRecordings = totalProcessedRecordings
        self.percentProgress = percentProgress
        self.errorMessage = errorMessage
        self.failedRecordings = failedRecordings
        self.selfUri = selfUri
        self.user = user
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case recordingJobsQuery
        case dateCreated
        case totalConversations
        case totalRecordings
        case totalSkippedRecordings
        case totalFailedRecordings
        case totalProcessedRecordings
        case percentProgress
        case errorMessage
        case failedRecordings
        case selfUri
        case user
    }


}




public class RegionTimeZone: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var offset: Int64?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, offset: Int64?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.offset = offset
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case offset
        case selfUri
    }


}




public class ReportingTurnIntentSlot: Codable {









    /** The name of the slot. */
    public var name: String?
    /** The value of the slot. */
    public var value: String?
    /** The NLU entity type of the slot (either builtin or user defined) */
    public var type: String?
    /** The confidence score this slot received during detection. */
    public var confidence: Double?

    public init(name: String?, value: String?, type: String?, confidence: Double?) {
        self.name = name
        self.value = value
        self.type = type
        self.confidence = confidence
    }


}




public class ReportingTurnKnowledgeDocument: Codable {









    /** The ID of the knowledge document. */
    public var _id: String?
    /** The the question that was used to match against the search query. */
    public var question: String?
    /** The corresponding answer to the question. */
    public var answer: String?
    /** The confidence score of how well the question matched the search query. */
    public var confidence: Double?

    public init(_id: String?, question: String?, answer: String?, confidence: Double?) {
        self._id = _id
        self.question = question
        self.answer = answer
        self.confidence = confidence
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case question
        case answer
        case confidence
    }


}



/** Defines response components of the Action Request. */

public class RequestConfig: Codable {











    /** URL that may include placeholders for requests to 3rd party service. This value is read only for Function Integrations and will be set when a draft is created. */
    public var requestUrlTemplate: String?
    /** Velocity template to define request body sent to 3rd party service. */
    public var requestTemplate: String?
    /** URI to retrieve requestTemplate */
    public var requestTemplateUri: String?
    /** HTTP method to use for request */
    public var requestType: String?
    /** Headers to include in request in (Header Name, Value) pairs. */
    public var headers: [String:String]?

    public init(requestUrlTemplate: String?, requestTemplate: String?, requestTemplateUri: String?, requestType: String?, headers: [String:String]?) {
        self.requestUrlTemplate = requestUrlTemplate
        self.requestTemplate = requestTemplate
        self.requestTemplateUri = requestTemplateUri
        self.requestType = requestType
        self.headers = headers
    }


}




public class RequestExternalSegment: Codable {





    public enum Source: String, Codable { 
        case adobeExperiencePlatform = "AdobeExperiencePlatform"
        case custom = "Custom"
    }

    /** Identifier for the external segment in the system where it originates from. */
    public var _id: String?
    /** Name for the external segment in the system where it originates from. */
    public var name: String?
    /** The external system where the segment originates from. */
    public var source: Source?

    public init(_id: String?, name: String?, source: Source?) {
        self._id = _id
        self.name = name
        self.source = source
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case source
    }


}




public class RequestJourney: Codable {



    /** A list of zero or more patterns to match. */
    public var patterns: [RequestJourneyPattern]?

    public init(patterns: [RequestJourneyPattern]?) {
        self.patterns = patterns
    }


}




public class RequestScoredAgent: Codable {





    /** Agent's user ID */
    public var _id: String?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int?

    public init(_id: String?, score: Int?) {
        self._id = _id
        self.score = score
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case score
    }


}




public class ResolutionDetailQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Metric: String, Codable { 
        case nnextcontactavoided = "nNextContactAvoided"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for metric predicates */
    public var metric: Metric?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for metric predicates */
    public var value: String?
    /** Right hand side for metric predicates */
    public var range: NumericRange?

    public init(type: ModelType?, metric: Metric?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.metric = metric
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case metric
        case _operator = "operator"
        case value
        case range
    }


}




public class ResponseAssetFilter: Codable {











    public enum ModelType: String, Codable { 
        case term = "TERM"
        case terms = "TERMS"
        case startsWith = "STARTS_WITH"
        case range = "RANGE"
        case greaterThanEqualTo = "GREATER_THAN_EQUAL_TO"
        case lessThanEqualTo = "LESS_THAN_EQUAL_TO"
        case dateRange = "DATE_RANGE"
    }

    /** The end value of the range. This field is used for range search types. Accepts numbers and date in ISO8601 format */
    public var endValue: String?
    /** A list of values for the search to match against */
    public var values: [String]?
    /** The start value of the range. This field is used for range search types. Accepts numbers and date in ISO8601 format */
    public var startValue: String?
    /** Field name to search against. Allowed Values: divisionId, name, contentLength, contentType, dateCreated */
    public var fields: [String]?
    /** A value for the search to match against */
    public var value: String?
    /** How to apply this search criteria against other criteria. Filter type supported for each field:- name:[STARTS_WITH, TERM], divisionId:[TERM, TERMS], contentLength:[RANGE, GREATER_THAN_EQUAL_TO, LESS_THAN_EQUAL_TO], contentType:[STARTS_WITH, TERM] dateCreated:[DATE_RANGE] */
    public var type: ModelType?

    public init(endValue: String?, values: [String]?, startValue: String?, fields: [String]?, value: String?, type: ModelType?) {
        self.endValue = endValue
        self.values = values
        self.startValue = startValue
        self.fields = fields
        self.value = value
        self.type = type
    }


}




public class ResponseAssetStatus: Codable {



    public enum Status: String, Codable { 
        case inProgress = "InProgress"
        case uploaded = "Uploaded"
        case failed = "Failed"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Upload status of the asset */
    public var status: Status?
    /** Error code. Used for localization */
    public var errorCode: String?
    /** Error message that explains upload failure status  */
    public var errorMessage: String?

    public init(_id: String?, status: Status?, errorCode: String?, errorMessage: String?) {
        self._id = _id
        self.status = status
        self.errorCode = errorCode
        self.errorMessage = errorMessage
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case status
        case errorCode
        case errorMessage
    }


}



/** Contains information about the text associated with a response. */

public class ResponseText: Codable {



    public enum ContentType: String, Codable { 
        case textPlain = "text/plain"
        case textHtml = "text/html"
    }

    /** Response text content. */
    public var content: String?
    /** Response text content type. */
    public var contentType: ContentType?

    public init(content: String?, contentType: ContentType?) {
        self.content = content
        self.contentType = contentType
    }


}




public class RoutingSettings: Codable {



    /** Reset agent score when agent presence changes from off-queue to on-queue */
    public var resetAgentScoreOnPresenceChange: Bool?

    public init(resetAgentScoreOnPresenceChange: Bool?) {
        self.resetAgentScoreOnPresenceChange = resetAgentScoreOnPresenceChange
    }


}




public class RoutingStatus: Codable {



    public enum Status: String, Codable { 
        case offQueue = "OFF_QUEUE"
        case idle = "IDLE"
        case interacting = "INTERACTING"
        case notResponding = "NOT_RESPONDING"
        case communicating = "COMMUNICATING"
    }



    /** The userId of the agent */
    public var userId: String?
    /** Indicates the Routing State of the agent.  A value of OFF_QUEUE will be returned if the specified user does not exist. */
    public var status: Status?
    /** The timestamp when the agent went into this state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startTime: Date?

    public init(userId: String?, status: Status?, startTime: Date?) {
        self.userId = userId
        self.status = status
        self.startTime = startTime
    }


}




public class RuleSet: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the RuleSet. */
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** A ContactList to provide user-interface suggestions for contact columns on relevant conditions and actions. */
    public var contactList: DomainEntityRef?
    /** A Queue to provide user-interface suggestions for wrap-up codes on relevant conditions and actions. */
    public var queue: DomainEntityRef?
    /** The list of rules. */
    public var rules: [DialerRule]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, contactList: DomainEntityRef?, queue: DomainEntityRef?, rules: [DialerRule]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.contactList = contactList
        self.queue = queue
        self.rules = rules
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case contactList
        case queue
        case rules
        case selfUri
    }


}



/** Defines a period of time to perform a specific action.  Each schedule must be associated with one or more schedule groups to be used. */

public class Schedule: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** Date time is represented as an ISO-8601 string without a timezone. For example: yyyy-MM-ddTHH:mm:ss.SSS */
    public var start: String?
    /** Date time is represented as an ISO-8601 string without a timezone. For example: yyyy-MM-ddTHH:mm:ss.SSS */
    public var end: String?
    /** An iCal Recurrence Rule (RRULE) string. It is required to be set for schedules determining when upgrades to the Edge software can be applied. */
    public var rrule: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, start: String?, end: String?, rrule: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.start = start
        self.end = end
        self.rrule = rrule
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case start
        case end
        case rrule
        case selfUri
    }


}




public class ScheduleActivity: Codable {















    public enum ExternalActivityType: String, Codable { 
        case activityPlan = "ActivityPlan"
        case coaching = "Coaching"
        case learning = "Learning"
    }

    /** The start date/time of this activity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?
    /** The length of this activity in minutes */
    public var lengthMinutes: Int?
    /** The description of this activity */
    public var _description: String?
    /** The ID of the activity code associated with this activity */
    public var activityCodeId: String?
    /** Whether this activity is paid */
    public var paid: Bool?
    /** The ID of the time off request associated with this activity, if applicable */
    public var timeOffRequestId: String?
    /** The ID of the external activity associated with this activity, if applicable */
    public var externalActivityId: String?
    /** The type of the external activity associated with this activity, if applicable */
    public var externalActivityType: ExternalActivityType?

    public init(dateStart: Date?, lengthMinutes: Int?, _description: String?, activityCodeId: String?, paid: Bool?, timeOffRequestId: String?, externalActivityId: String?, externalActivityType: ExternalActivityType?) {
        self.dateStart = dateStart
        self.lengthMinutes = lengthMinutes
        self._description = _description
        self.activityCodeId = activityCodeId
        self.paid = paid
        self.timeOffRequestId = timeOffRequestId
        self.externalActivityId = externalActivityId
        self.externalActivityType = externalActivityType
    }

    public enum CodingKeys: String, CodingKey { 
        case dateStart
        case lengthMinutes
        case _description = "description"
        case activityCodeId
        case paid
        case timeOffRequestId
        case externalActivityId
        case externalActivityType
    }


}




public class ScheduleDivisionViewEntityListing: Codable {





















    public var entities: [SchedulesDivisionView]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [SchedulesDivisionView]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ScheduleGenerationMessage: Codable {

    public enum ModelType: String, Codable { 
        case agentNotFound = "AgentNotFound"
        case agentNotInSelectedManagementUnit = "AgentNotInSelectedManagementUnit"
        case agentNotLicensed = "AgentNotLicensed"
        case agentWithoutWorkPlan = "AgentWithoutWorkPlan"
        case workPlanNotEnabled = "WorkPlanNotEnabled"
        case workPlanNotFound = "WorkPlanNotFound"
        case agentWithoutCapability = "AgentWithoutCapability"
        case noNeedDays = "NoNeedDays"
        case unableToProduceAgentSchedule = "UnableToProduceAgentSchedule"
        case unableToScheduleMaxConsecutiveWorkingDaysFromAgentHistory = "UnableToScheduleMaxConsecutiveWorkingDaysFromAgentHistory"
        case unableToScheduleMaxConsecutiveWorkingWeekendsFromAgentHistory = "UnableToScheduleMaxConsecutiveWorkingWeekendsFromAgentHistory"
        case unableToScheduleMaxWeeklyPaidTimeFromTimeOff = "UnableToScheduleMaxWeeklyPaidTimeFromTimeOff"
        case unableToScheduleMaxWorkDayPaidTimeFromTimeOff = "UnableToScheduleMaxWorkDayPaidTimeFromTimeOff"
        case unableToScheduleMinIntershiftTimeFromAgentHistory = "UnableToScheduleMinIntershiftTimeFromAgentHistory"
        case unableToScheduleMinIntershiftTimeFromDst = "UnableToScheduleMinIntershiftTimeFromDst"
        case unableToScheduleMinShiftStartDistanceFromAgentHistory = "UnableToScheduleMinShiftStartDistanceFromAgentHistory"
        case unableToScheduleMinShiftStartDistanceFromDst = "UnableToScheduleMinShiftStartDistanceFromDst"
        case unableToScheduleMinWeeklyPaidTimeFromTimeOff = "UnableToScheduleMinWeeklyPaidTimeFromTimeOff"
        case unableToScheduleMinWeeklyWorkDaysFromTimeOff = "UnableToScheduleMinWeeklyWorkDaysFromTimeOff"
        case unableToScheduleMinWorkDayPaidTimeFromTimeOff = "UnableToScheduleMinWorkDayPaidTimeFromTimeOff"
        case unableToSchedulePlanningPeriodMaxDaysOffFromAgentHistory = "UnableToSchedulePlanningPeriodMaxDaysOffFromAgentHistory"
        case unableToSchedulePlanningPeriodMaxDaysOffFromTimeOff = "UnableToSchedulePlanningPeriodMaxDaysOffFromTimeOff"
        case unableToSchedulePlanningPeriodMaxPaidTimeFromAgentHistory = "UnableToSchedulePlanningPeriodMaxPaidTimeFromAgentHistory"
        case unableToSchedulePlanningPeriodMaxPaidTimeFromTimeOff = "UnableToSchedulePlanningPeriodMaxPaidTimeFromTimeOff"
        case unableToSchedulePlanningPeriodMinDaysOffFromAgentHistory = "UnableToSchedulePlanningPeriodMinDaysOffFromAgentHistory"
        case unableToSchedulePlanningPeriodMinPaidTimeFromAgentHistory = "UnableToSchedulePlanningPeriodMinPaidTimeFromAgentHistory"
        case unableToSchedulePlanningPeriodMinPaidTimeFromTimeOff = "UnableToSchedulePlanningPeriodMinPaidTimeFromTimeOff"
        case unableToScheduleWorkDayFromTimeOff = "UnableToScheduleWorkDayFromTimeOff"
        case unableToScheduleMaxConsecutiveWorkingDays = "UnableToScheduleMaxConsecutiveWorkingDays"
        case unableToScheduleMaxConsecutiveWorkingWeekends = "UnableToScheduleMaxConsecutiveWorkingWeekends"
        case unableToScheduleMaxWeeklyPaidTime = "UnableToScheduleMaxWeeklyPaidTime"
        case unableToScheduleMaxWeeklyWorkDays = "UnableToScheduleMaxWeeklyWorkDays"
        case unableToScheduleMaxWorkDayPaidTime = "UnableToScheduleMaxWorkDayPaidTime"
        case unableToScheduleMinConsecutiveNonWorkingTimePerWeek = "UnableToScheduleMinConsecutiveNonWorkingTimePerWeek"
        case unableToScheduleMinIntershiftTime = "UnableToScheduleMinIntershiftTime"
        case unableToScheduleMinShiftStartDistance = "UnableToScheduleMinShiftStartDistance"
        case unableToScheduleMinWeeklyPaidTime = "UnableToScheduleMinWeeklyPaidTime"
        case unableToScheduleMinWeeklyWorkDays = "UnableToScheduleMinWeeklyWorkDays"
        case unableToScheduleMinWorkDayPaidTime = "UnableToScheduleMinWorkDayPaidTime"
        case unableToSchedulePlanningPeriodMaxDaysOff = "UnableToSchedulePlanningPeriodMaxDaysOff"
        case unableToSchedulePlanningPeriodMaxPaidTime = "UnableToSchedulePlanningPeriodMaxPaidTime"
        case unableToSchedulePlanningPeriodMinDaysOff = "UnableToSchedulePlanningPeriodMinDaysOff"
        case unableToSchedulePlanningPeriodMinPaidTime = "UnableToSchedulePlanningPeriodMinPaidTime"
        case unableToScheduleShiftVariance = "UnableToScheduleShiftVariance"
        case unableToScheduleWorkDay = "UnableToScheduleWorkDay"
    }



    /** The type of the message */
    public var type: ModelType?
    /** The arguments describing the message */
    public var arguments: [SchedulerMessageArgument]?

    public init(type: ModelType?, arguments: [SchedulerMessageArgument]?) {
        self.type = type
        self.arguments = arguments
    }


}




public class ScheduleGenerationResult: Codable {











    /** Whether the schedule generation run failed */
    public var failed: Bool?
    /** The ID of the schedule generation run. Reference this when requesting support */
    public var runId: String?
    /** The number of schedule generation messages for this schedule generation run */
    public var messageCount: Int?
    /** User facing messages related to the schedule generation run */
    public var messages: [ScheduleGenerationMessage]?
    /** The list of messages by severity in this schedule generation run */
    public var messageSeverities: [SchedulerMessageTypeSeverity]?

    public init(failed: Bool?, runId: String?, messageCount: Int?, messages: [ScheduleGenerationMessage]?, messageSeverities: [SchedulerMessageTypeSeverity]?) {
        self.failed = failed
        self.runId = runId
        self.messageCount = messageCount
        self.messages = messages
        self.messageSeverities = messageSeverities
    }


}




public class ScheduleGenerationResultSummary: Codable {









    /** Whether the schedule generation run failed */
    public var failed: Bool?
    /** The ID of the schedule generation run. Reference this when requesting support */
    public var runId: String?
    /** The number of schedule generation messages for this schedule generation run */
    public var messageCount: Int?
    /** The list of schedule generation message counts by severity for this schedule generation run */
    public var messageSeverityCounts: [SchedulerMessageSeverityCount]?

    public init(failed: Bool?, runId: String?, messageCount: Int?, messageSeverityCounts: [SchedulerMessageSeverityCount]?) {
        self.failed = failed
        self.runId = runId
        self.messageCount = messageCount
        self.messageSeverityCounts = messageSeverityCounts
    }


}



/** A group of schedules that define the operating hours of an organization. */

public class ScheduleGroup: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** The timezone the schedules are a part of.  This is not a schedule property to allow a schedule to be used in multiple timezones. */
    public var timeZone: String?
    /** The schedules defining the hours an organization is open. */
    public var openSchedules: [DomainEntityRef]?
    /** The schedules defining the hours an organization is closed. */
    public var closedSchedules: [DomainEntityRef]?
    /** The schedules defining the hours an organization is closed for the holidays. */
    public var holidaySchedules: [DomainEntityRef]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, timeZone: String?, openSchedules: [DomainEntityRef]?, closedSchedules: [DomainEntityRef]?, holidaySchedules: [DomainEntityRef]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.timeZone = timeZone
        self.openSchedules = openSchedules
        self.closedSchedules = closedSchedules
        self.holidaySchedules = holidaySchedules
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case timeZone
        case openSchedules
        case closedSchedules
        case holidaySchedules
        case selfUri
    }


}




public class ScheduleGroupDivisionViewEntityListing: Codable {





















    public var entities: [ScheduleGroupDivisionView]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ScheduleGroupDivisionView]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class SchedulerMessageTypeSeverity: Codable {

    public enum ModelType: String, Codable { 
        case agentNotFound = "AgentNotFound"
        case agentNotInSelectedManagementUnit = "AgentNotInSelectedManagementUnit"
        case agentNotLicensed = "AgentNotLicensed"
        case agentWithoutWorkPlan = "AgentWithoutWorkPlan"
        case workPlanNotEnabled = "WorkPlanNotEnabled"
        case workPlanNotFound = "WorkPlanNotFound"
        case agentWithoutCapability = "AgentWithoutCapability"
        case noNeedDays = "NoNeedDays"
        case unableToProduceAgentSchedule = "UnableToProduceAgentSchedule"
        case unableToScheduleMaxConsecutiveWorkingDaysFromAgentHistory = "UnableToScheduleMaxConsecutiveWorkingDaysFromAgentHistory"
        case unableToScheduleMaxConsecutiveWorkingWeekendsFromAgentHistory = "UnableToScheduleMaxConsecutiveWorkingWeekendsFromAgentHistory"
        case unableToScheduleMaxWeeklyPaidTimeFromTimeOff = "UnableToScheduleMaxWeeklyPaidTimeFromTimeOff"
        case unableToScheduleMaxWorkDayPaidTimeFromTimeOff = "UnableToScheduleMaxWorkDayPaidTimeFromTimeOff"
        case unableToScheduleMinIntershiftTimeFromAgentHistory = "UnableToScheduleMinIntershiftTimeFromAgentHistory"
        case unableToScheduleMinIntershiftTimeFromDst = "UnableToScheduleMinIntershiftTimeFromDst"
        case unableToScheduleMinShiftStartDistanceFromAgentHistory = "UnableToScheduleMinShiftStartDistanceFromAgentHistory"
        case unableToScheduleMinShiftStartDistanceFromDst = "UnableToScheduleMinShiftStartDistanceFromDst"
        case unableToScheduleMinWeeklyPaidTimeFromTimeOff = "UnableToScheduleMinWeeklyPaidTimeFromTimeOff"
        case unableToScheduleMinWeeklyWorkDaysFromTimeOff = "UnableToScheduleMinWeeklyWorkDaysFromTimeOff"
        case unableToScheduleMinWorkDayPaidTimeFromTimeOff = "UnableToScheduleMinWorkDayPaidTimeFromTimeOff"
        case unableToSchedulePlanningPeriodMaxDaysOffFromAgentHistory = "UnableToSchedulePlanningPeriodMaxDaysOffFromAgentHistory"
        case unableToSchedulePlanningPeriodMaxDaysOffFromTimeOff = "UnableToSchedulePlanningPeriodMaxDaysOffFromTimeOff"
        case unableToSchedulePlanningPeriodMaxPaidTimeFromAgentHistory = "UnableToSchedulePlanningPeriodMaxPaidTimeFromAgentHistory"
        case unableToSchedulePlanningPeriodMaxPaidTimeFromTimeOff = "UnableToSchedulePlanningPeriodMaxPaidTimeFromTimeOff"
        case unableToSchedulePlanningPeriodMinDaysOffFromAgentHistory = "UnableToSchedulePlanningPeriodMinDaysOffFromAgentHistory"
        case unableToSchedulePlanningPeriodMinPaidTimeFromAgentHistory = "UnableToSchedulePlanningPeriodMinPaidTimeFromAgentHistory"
        case unableToSchedulePlanningPeriodMinPaidTimeFromTimeOff = "UnableToSchedulePlanningPeriodMinPaidTimeFromTimeOff"
        case unableToScheduleWorkDayFromTimeOff = "UnableToScheduleWorkDayFromTimeOff"
        case unableToScheduleMaxConsecutiveWorkingDays = "UnableToScheduleMaxConsecutiveWorkingDays"
        case unableToScheduleMaxConsecutiveWorkingWeekends = "UnableToScheduleMaxConsecutiveWorkingWeekends"
        case unableToScheduleMaxWeeklyPaidTime = "UnableToScheduleMaxWeeklyPaidTime"
        case unableToScheduleMaxWeeklyWorkDays = "UnableToScheduleMaxWeeklyWorkDays"
        case unableToScheduleMaxWorkDayPaidTime = "UnableToScheduleMaxWorkDayPaidTime"
        case unableToScheduleMinConsecutiveNonWorkingTimePerWeek = "UnableToScheduleMinConsecutiveNonWorkingTimePerWeek"
        case unableToScheduleMinIntershiftTime = "UnableToScheduleMinIntershiftTime"
        case unableToScheduleMinShiftStartDistance = "UnableToScheduleMinShiftStartDistance"
        case unableToScheduleMinWeeklyPaidTime = "UnableToScheduleMinWeeklyPaidTime"
        case unableToScheduleMinWeeklyWorkDays = "UnableToScheduleMinWeeklyWorkDays"
        case unableToScheduleMinWorkDayPaidTime = "UnableToScheduleMinWorkDayPaidTime"
        case unableToSchedulePlanningPeriodMaxDaysOff = "UnableToSchedulePlanningPeriodMaxDaysOff"
        case unableToSchedulePlanningPeriodMaxPaidTime = "UnableToSchedulePlanningPeriodMaxPaidTime"
        case unableToSchedulePlanningPeriodMinDaysOff = "UnableToSchedulePlanningPeriodMinDaysOff"
        case unableToSchedulePlanningPeriodMinPaidTime = "UnableToSchedulePlanningPeriodMinPaidTime"
        case unableToScheduleShiftVariance = "UnableToScheduleShiftVariance"
        case unableToScheduleWorkDay = "UnableToScheduleWorkDay"
    }

    public enum Severity: String, Codable { 
        case ignore = "Ignore"
        case information = "Information"
        case warning = "Warning"
        case error = "Error"
    }

    /** The type of the message */
    public var type: ModelType?
    /** The severity of the message */
    public var severity: Severity?

    public init(type: ModelType?, severity: Severity?) {
        self.type = type
        self.severity = severity
    }


}




public class SchedulingOptionsRequest: Codable {



    /** Schedule generation options to apply if no forecast is supplied */
    public var noForecastOptions: SchedulingNoForecastOptionsRequest?

    public init(noForecastOptions: SchedulingNoForecastOptionsRequest?) {
        self.noForecastOptions = noForecastOptions
    }


}




public class Schema: Codable {











    /** A core type's title */
    public var title: String?
    /** A core type's description */
    public var _description: String?
    /** An array of fundamental JSON Schema primitive types on which the core type is based */
    public var type: [String]?
    /** Denotes the type and pattern of the items in an enum core type */
    public var items: Items?
    /** For the \"date\" and \"datetime\" core types, denotes the regex prescribing the allowable date/datetime format */
    public var pattern: String?

    public init(title: String?, _description: String?, type: [String]?, items: Items?, pattern: String?) {
        self.title = title
        self._description = _description
        self.type = type
        self.items = items
        self.pattern = pattern
    }

    public enum CodingKeys: String, CodingKey { 
        case title
        case _description = "description"
        case type
        case items
        case pattern
    }


}



/** Defines a SCIM error. */

public class ScimError: Codable {





    public enum ScimType: String, Codable { 
        case invalidfilter = "invalidFilter"
        case toomany = "tooMany"
        case uniqueness = "uniqueness"
        case mutability = "mutability"
        case invalidsyntax = "invalidSyntax"
        case invalidpath = "invalidPath"
        case notarget = "noTarget"
        case invalidvalue = "invalidValue"
        case invalidvers = "invalidVers"
        case sensitive = "sensitive"
    }



    /** The list of schemas for the SCIM error. */
    public var schemas: [String]?
    /** The HTTP status code returned for the SCIM error. */
    public var status: String?
    /** The type of SCIM error when httpStatus is a \"400\" error. */
    public var scimType: ScimType?
    /** The detailed description of the SCIM error. */
    public var detail: String?

    public init(schemas: [String]?, status: String?, scimType: ScimType?, detail: String?) {
        self.schemas = schemas
        self.status = status
        self.scimType = scimType
        self.detail = detail
    }


}



/** External Identifiers of user. The external identifier must be unique within the organization and the 'authority' */

public class ScimGenesysUserExternalId: Codable {





    /** Authority, or scope, of \"externalId\". Allows multiple external identifiers to be defined. Represents the source of the external identifier. */
    public var authority: String?
    /** Identifier of the user in an external system. */
    public var value: String?

    public init(authority: String?, value: String?) {
        self.authority = authority
        self.value = value
    }


}



/** Defines a SCIM service provider's configuration. */

public class ScimServiceProviderConfig: Codable {





















    /** The list of supported schemas. */
    public var schemas: [String]?
    /** The HTTP-addressable URL that points to the service provider's documentation. */
    public var documentationUri: String?
    /** The \"patch\" configuration options. */
    public var patch: ScimServiceProviderConfigSimpleFeature?
    /** The \"filter\" configuration options. */
    public var filter: ScimServiceProviderConfigFilterFeature?
    /** The \"etag\" configuration options. */
    public var etag: ScimServiceProviderConfigSimpleFeature?
    /** The \"sort\" configuration options. */
    public var sort: ScimServiceProviderConfigSimpleFeature?
    /** The \"bulk\" configuration options. */
    public var bulk: ScimServiceProviderConfigBulkFeature?
    /** The \"changePassword\" configuration options. */
    public var changePassword: ScimServiceProviderConfigSimpleFeature?
    /** The list of supported authentication schemes. */
    public var authenticationSchemes: [ScimServiceProviderConfigAuthenticationScheme]?
    /** The metadata of the SCIM resource. Metadata is defined as immutable per SCIM RFC. */
    public var meta: ScimMetadata?

    public init(schemas: [String]?, documentationUri: String?, patch: ScimServiceProviderConfigSimpleFeature?, filter: ScimServiceProviderConfigFilterFeature?, etag: ScimServiceProviderConfigSimpleFeature?, sort: ScimServiceProviderConfigSimpleFeature?, bulk: ScimServiceProviderConfigBulkFeature?, changePassword: ScimServiceProviderConfigSimpleFeature?, authenticationSchemes: [ScimServiceProviderConfigAuthenticationScheme]?, meta: ScimMetadata?) {
        self.schemas = schemas
        self.documentationUri = documentationUri
        self.patch = patch
        self.filter = filter
        self.etag = etag
        self.sort = sort
        self.bulk = bulk
        self.changePassword = changePassword
        self.authenticationSchemes = authenticationSchemes
        self.meta = meta
    }


}



/** Defines a \"filter\" request in the SCIM service provider's configuration. */

public class ScimServiceProviderConfigFilterFeature: Codable {





    /** Indicates whether configuration options are supported. */
    public var supported: Bool?
    /** The maximum number of results returned from a filtered query. */
    public var maxResults: Int?

    public init(supported: Bool?, maxResults: Int?) {
        self.supported = supported
        self.maxResults = maxResults
    }


}



/** Genesys Cloud user extensions to SCIM RFC. */

public class ScimUserExtensions: Codable {







    /** The list of routing skills assigned to a user. Maximum 50 skills. */
    public var routingSkills: [ScimUserRoutingSkill]?
    /** The list of routing languages assigned to a user. Maximum 50 languages. */
    public var routingLanguages: [ScimUserRoutingLanguage]?
    /** The list of external identifiers assigned to user. Always includes an immutable SCIM authority prefixed with \"x-pc:scimv2:v1\". ExternalIds are searchable with complex filter query parameter using 'authority' and 'value', e.g., filter=urn:ietf:params:scim:schemas:extension:genesys:purecloud:2.0:User:externalIds[authority eq \"matchAuthName\" and value eq \"matchingExternalKeyValue\"]. */
    public var externalIds: [ScimGenesysUserExternalId]?

    public init(routingSkills: [ScimUserRoutingSkill]?, routingLanguages: [ScimUserRoutingLanguage]?, externalIds: [ScimGenesysUserExternalId]?) {
        self.routingSkills = routingSkills
        self.routingLanguages = routingLanguages
        self.externalIds = externalIds
    }


}



/** Defines a user role. */

public class ScimUserRole: Codable {



    /** The role of the Genesys Cloud user. */
    public var value: String?

    public init(value: String?) {
        self.value = value
    }


}



/** Defines the creation of a SCIM user. */

public class ScimV2CreateUser: Codable {



























    /** The list of supported schemas. */
    public var schemas: [String]?
    /** Indicates whether the user's administrative status is active. */
    public var active: Bool?
    /** The user's Genesys Cloud email address. Must be unique. */
    public var userName: String?
    /** The display name of the user. */
    public var displayName: String?
    /** The new password for the Genesys Cloud user. Does not return an existing password. When creating a user, if a password is not supplied, then a password will be randomly generated that is 40 characters in length and contains five characters from each of the password policy groups. */
    public var password: String?
    /** The user's title. */
    public var title: String?
    /** The list of the user's phone numbers. */
    public var phoneNumbers: [ScimPhoneNumber]?
    /** The list of the user's email addresses. */
    public var emails: [ScimEmail]?
    /** The external ID of the user. Set by the provisioning client. \"caseExact\" is set to \"true\". \"mutability\" is set to \"readWrite\". */
    public var externalId: String?
    /** The list of groups that the user is a member of. This list is immutable per SCIM RFC and may only be updated using the GROUPS resource endpoint. */
    public var groups: [ScimV2GroupReference]?
    /** The list of roles assigned to the user. */
    public var roles: [ScimUserRole]?
    /** The URI of the schema for the enterprise user. */
    public var urnietfparamsscimschemasextensionenterprise20User: ScimV2EnterpriseUser?
    /** The URI of the schema for the Genesys Cloud user. */
    public var urnietfparamsscimschemasextensiongenesyspurecloud20User: ScimUserExtensions?

    public init(schemas: [String]?, active: Bool?, userName: String?, displayName: String?, password: String?, title: String?, phoneNumbers: [ScimPhoneNumber]?, emails: [ScimEmail]?, externalId: String?, groups: [ScimV2GroupReference]?, roles: [ScimUserRole]?, urnietfparamsscimschemasextensionenterprise20User: ScimV2EnterpriseUser?, urnietfparamsscimschemasextensiongenesyspurecloud20User: ScimUserExtensions?) {
        self.schemas = schemas
        self.active = active
        self.userName = userName
        self.displayName = displayName
        self.password = password
        self.title = title
        self.phoneNumbers = phoneNumbers
        self.emails = emails
        self.externalId = externalId
        self.groups = groups
        self.roles = roles
        self.urnietfparamsscimschemasextensionenterprise20User = urnietfparamsscimschemasextensionenterprise20User
        self.urnietfparamsscimschemasextensiongenesyspurecloud20User = urnietfparamsscimschemasextensiongenesyspurecloud20User
    }

    public enum CodingKeys: String, CodingKey { 
        case schemas
        case active
        case userName
        case displayName
        case password
        case title
        case phoneNumbers
        case emails
        case externalId
        case groups
        case roles
        case urnietfparamsscimschemasextensionenterprise20User = "urn:ietf:params:scim:schemas:extension:enterprise:2.0:User"
        case urnietfparamsscimschemasextensiongenesyspurecloud20User = "urn:ietf:params:scim:schemas:extension:genesys:purecloud:2.0:User"
    }


}



/** Defines a reference to SCIM groups. */

public class ScimV2GroupReference: Codable {

    public enum ModelType: String, Codable { 
        case user = "User"
        case group = "Group"
        case serviceProviderConfig = "ServiceProviderConfig"
        case resourceType = "ResourceType"
        case schema = "Schema"
    }





    /** The type of SCIM resource. */
    public var type: ModelType?
    /** The ID of the group member. Can be \"userId\" or \"groupId\". */
    public var value: String?
    /** The reference URI of the SCIM resource. */
    public var ref: String?

    public init(type: ModelType?, value: String?, ref: String?) {
        self.type = type
        self.value = value
        self.ref = ref
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case value
        case ref = "$ref"
    }


}



/** Defines a reference to SCIM group members. */

public class ScimV2MemberReference: Codable {

    public enum ModelType: String, Codable { 
        case user = "User"
        case group = "Group"
        case serviceProviderConfig = "ServiceProviderConfig"
        case resourceType = "ResourceType"
        case schema = "Schema"
    }





    /** The type of SCIM resource. */
    public var type: ModelType?
    /** The ID of the group member. Can be \"userId\" or \"groupId\". */
    public var value: String?
    /** The reference URI of the SCIM resource. */
    public var ref: String?

    public init(type: ModelType?, value: String?, ref: String?) {
        self.type = type
        self.value = value
        self.ref = ref
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case value
        case ref = "$ref"
    }


}



/** Defines a SCIM PATCH operation. The path and value follow very specific rules based on operation types. See section 3.5.2 \"Modifying with PATCH\" in RFC 7644 for details. */

public class ScimV2PatchOperation: Codable {

    public enum Op: String, Codable { 
        case add = "add"
        case replace = "replace"
        case remove = "remove"
    }





    /** The PATCH operation to perform. */
    public var op: Op?
    /** The attribute path that describes the target of the operation. Required for a \"remove\" operation. */
    public var path: String?
    /** The value to set in the path. */
    public var value: JSON?

    public init(op: Op?, path: String?, value: JSON?) {
        self.op = op
        self.path = path
        self.value = value
    }


}



/** Defines a SCIM PATCH request. See section 3.5.2 \"Modifying with PATCH\" in RFC 7644 for details. */

public class ScimV2PatchRequest: Codable {





    /** The list of schemas used in the PATCH request. */
    public var schemas: [String]?
    /** The list of operations to perform for the PATCH request. */
    public var operations: [ScimV2PatchOperation]?

    public init(schemas: [String]?, operations: [ScimV2PatchOperation]?) {
        self.schemas = schemas
        self.operations = operations
    }

    public enum CodingKeys: String, CodingKey { 
        case schemas
        case operations = "Operations"
    }


}



/** A complex type that defines service provider attributes or subattributes and their qualities. */

public class ScimV2SchemaAttribute: Codable {



    public enum ModelType: String, Codable { 
        case string = "string"
        case boolean = "boolean"
        case decimal = "decimal"
        case integer = "integer"
        case datetime = "dateTime"
        case reference = "reference"
        case complex = "complex"
    }













    public enum Mutability: String, Codable { 
        case readwrite = "readWrite"
        case readonly = "readOnly"
        case immutable = "immutable"
        case writeonly = "writeOnly"
    }

    public enum Returned: String, Codable { 
        case always = "always"
        case never = "never"
        case _default = "default"
        case request = "request"
    }

    public enum Uniqueness: String, Codable { 
        case _none = "none"
        case server = "server"
        case global = "global"
    }

    public enum ReferenceTypes: String, Codable { 
        case user = "User"
        case group = "Group"
        case external = "external"
        case uri = "uri"
    }

    /** The name of the attribute. */
    public var name: String?
    /** The data type of the attribute. */
    public var type: ModelType?
    /** The list of subattributes for an attribute of the type \"complex\". Uses the same schema as \"attributes\". */
    public var subAttributes: [ScimV2SchemaAttribute]?
    /** Indicates whether an attribute contains multiple values. */
    public var multiValued: Bool?
    /** The description of the attribute. */
    public var _description: String?
    /** Indicates whether an attribute is required. */
    public var _required: Bool?
    /** The list of standard values that service providers may use. Service providers may ignore unsupported values. */
    public var canonicalValues: [String]?
    /** Indicates whether a string attribute is case-sensitive. If set to \"true\", the server preserves case sensitivity. If set to \"false\", the server may change the case. The server also uses case sensitivity when evaluating filters. See section 3.4.2.2 \"Filtering\" in RFC 7644 for details. */
    public var caseExact: Bool?
    /** The circumstances under which an attribute can be defined or redefined. The default is \"readWrite\". */
    public var mutability: Mutability?
    /** The circumstances under which an attribute and its values are returned in response to a GET, PUT, POST, or PATCH request. */
    public var returned: Returned?
    /** The method by which the service provider enforces the uniqueness of an attribute value. A server can reject a value by returning the HTTP response code 400 (Bad Request). A client can enforce uniqueness to a greater degree than the server provider enforces. For example, a client could make a value unique even though the server has \"uniqueness\" set to \"none\". */
    public var uniqueness: Uniqueness?
    /** The list of SCIM resource types that may be referenced. Only applies when \"type\" is set to \"reference\". */
    public var referenceTypes: [ReferenceTypes]?

    public init(name: String?, type: ModelType?, subAttributes: [ScimV2SchemaAttribute]?, multiValued: Bool?, _description: String?, _required: Bool?, canonicalValues: [String]?, caseExact: Bool?, mutability: Mutability?, returned: Returned?, uniqueness: Uniqueness?, referenceTypes: [ReferenceTypes]?) {
        self.name = name
        self.type = type
        self.subAttributes = subAttributes
        self.multiValued = multiValued
        self._description = _description
        self._required = _required
        self.canonicalValues = canonicalValues
        self.caseExact = caseExact
        self.mutability = mutability
        self.returned = returned
        self.uniqueness = uniqueness
        self.referenceTypes = referenceTypes
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case type
        case subAttributes
        case multiValued
        case _description = "description"
        case _required = "required"
        case canonicalValues
        case caseExact
        case mutability
        case returned
        case uniqueness
        case referenceTypes
    }


}



/** Defines a SCIM schema. */

public class ScimV2SchemaDefinition: Codable {











    /** The ID of the SCIM resource. Set by the service provider. \"caseExact\" is set to \"true\". \"mutability\" is set to \"readOnly\". \"returned\" is set to \"always\". */
    public var _id: String?
    /** The name of the schema. */
    public var name: String?
    /** The description of the schema. */
    public var _description: String?
    /** The list of service provider attributes. */
    public var attributes: [ScimV2SchemaAttribute]?
    /** The metadata of the SCIM resource. Only \"location\" and \"resourceType\" are set for \"Schema\" resources. */
    public var meta: ScimMetadata?

    public init(_id: String?, name: String?, _description: String?, attributes: [ScimV2SchemaAttribute]?, meta: ScimMetadata?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.attributes = attributes
        self.meta = meta
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case attributes
        case meta
    }


}




public class ScoredAgent: Codable {





    /** The agent */
    public var agent: DomainEntityRef?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int?

    public init(agent: DomainEntityRef?, score: Int?) {
        self.agent = agent
        self.score = score
    }


}




public class ScreenRecordingSession: Codable {















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var user: User?
    /** The id of the communication that is being recorded on the conversation */
    public var communicationId: String?
    public var conversation: Conversation?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startTime: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, user: User?, communicationId: String?, conversation: Conversation?, startTime: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.user = user
        self.communicationId = communicationId
        self.conversation = conversation
        self.startTime = startTime
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case user
        case communicationId
        case conversation
        case startTime
        case selfUri
    }


}




public class ScreenRecordingSessionListing: Codable {





















    public var entities: [ScreenRecordingSession]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ScreenRecordingSession]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ScreenRecordingSessionRequest: Codable {

    public enum State: String, Codable { 
        case stopped = "STOPPED"
    }





    /** The screen recording session's state.  Values can be: 'stopped' */
    public var state: State?
    /** The screen recording session's archive date. Must be greater than 1 day from now if set. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var archiveDate: Date?
    /** The screen recording session's delete date. Must be greater than archiveDate if set, otherwise one day from now. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var deleteDate: Date?

    public init(state: State?, archiveDate: Date?, deleteDate: Date?) {
        self.state = state
        self.archiveDate = archiveDate
        self.deleteDate = deleteDate
    }


}



/** Details about a scroll percentage event trigger */

public class ScrollPercentageEventTrigger: Codable {





    /** Percentage of a webpage at which an event is triggered. */
    public var percentage: Int?
    /** Name of event triggered after scrolling to the specified percentage. */
    public var eventName: String?

    public init(percentage: Int?, eventName: String?) {
        self.percentage = percentage
        self.eventName = eventName
    }


}




public class SearchRequest: Codable {

    public enum SortOrder: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
        case score = "SCORE"
    }



















    /** The sort order for results */
    public var sortOrder: SortOrder?
    /** The field in the resource that you want to sort the results by */
    public var sortBy: String?
    /** The number of results per page */
    public var pageSize: Int?
    /** The page of resources you want to retrieve */
    public var pageNumber: Int?
    /** Multi-value sort order, list of multiple sort values */
    public var sort: [SearchSort]?
    /** A List of strings.  Possible values are any field in the resource you are searching on.  The other option is to use ALL_FIELDS, when this is provided all fields in the resource will be returned in the search results. */
    public var returnFields: [String]?
    /** Provides more details about a specified resource */
    public var expand: [String]?
    /** Resource domain type to search */
    public var types: [String]?
    /** The search criteria */
    public var query: [SearchCriteria]?
    /** Aggregation criteria */
    public var aggregations: [SearchAggregation]?

    public init(sortOrder: SortOrder?, sortBy: String?, pageSize: Int?, pageNumber: Int?, sort: [SearchSort]?, returnFields: [String]?, expand: [String]?, types: [String]?, query: [SearchCriteria]?, aggregations: [SearchAggregation]?) {
        self.sortOrder = sortOrder
        self.sortBy = sortBy
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.sort = sort
        self.returnFields = returnFields
        self.expand = expand
        self.types = types
        self.query = query
        self.aggregations = aggregations
    }


}




public class Segment: Codable {











    /** The timestamp when this segment began. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startTime: Date?
    /** The timestamp when this segment ended. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?
    /** The activity taking place for the participant in the segment. */
    public var type: String?
    /** A description of the event that ended the segment. */
    public var howEnded: String?
    /** A description of the event that disconnected the segment */
    public var disconnectType: String?

    public init(startTime: Date?, endTime: Date?, type: String?, howEnded: String?, disconnectType: String?) {
        self.startTime = startTime
        self.endTime = endTime
        self.type = type
        self.howEnded = howEnded
        self.disconnectType = disconnectType
    }


}




public class SegmentListing: Codable {





















    public var entities: [JourneySegment]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [JourneySegment]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class SelectedAnswer: Codable {



    /** The search result document chosen as the answer. */
    public var document: AddressableEntityRef?

    public init(document: AddressableEntityRef?) {
        self.document = document
    }


}




public class SequenceSchedule: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** A list of intervals during which to run the associated CampaignSequence. */
    public var intervals: [ScheduleInterval]?
    /** The time zone for this SequenceSchedule. For example, Africa/Abidjan. */
    public var timeZone: String?
    /** The CampaignSequence that this SequenceSchedule is for. */
    public var sequence: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, intervals: [ScheduleInterval]?, timeZone: String?, sequence: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.intervals = intervals
        self.timeZone = timeZone
        self.sequence = sequence
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case intervals
        case timeZone
        case sequence
        case selfUri
    }


}




public class ServerDate: Codable {



    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var currentDate: Date?

    public init(currentDate: Date?) {
        self.currentDate = currentDate
    }


}




public class ServiceGoalTemplateList: Codable {





    public var entities: [ServiceGoalTemplate]?
    /** Version metadata for the service goal templates */
    public var metadata: WfmVersionedEntityMetadata?

    public init(entities: [ServiceGoalTemplate]?, metadata: WfmVersionedEntityMetadata?) {
        self.entities = entities
        self.metadata = metadata
    }


}




public class SessionLastEvent: Codable {







    /** The ID of the last event. */
    public var _id: String?
    /** The name of the event. */
    public var eventName: String?
    /** Timestamp indicating when the event was published. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?

    public init(_id: String?, eventName: String?, createdDate: Date?) {
        self._id = _id
        self.eventName = eventName
        self.createdDate = createdDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case eventName
        case createdDate
    }


}




public class SetRecordingState: Codable {

    public enum RecordingState: String, Codable { 
        case active = "ACTIVE"
        case paused = "PAUSED"
        case _none = "NONE"
    }

    /** On update, 'paused' initiates a secure pause, 'active' resumes any paused recordings. */
    public var recordingState: RecordingState?

    public init(recordingState: RecordingState?) {
        self.recordingState = recordingState
    }


}




public class SetWrapperString: Codable {



    public var values: [String]?

    public init(values: [String]?) {
        self.values = values
    }


}




public class SettingDirection: Codable {

    public enum Inbound: String, Codable { 
        case enabled = "Enabled"
        case disabled = "Disabled"
    }

    public enum Outbound: String, Codable { 
        case enabled = "Enabled"
        case disabled = "Disabled"
    }

    /** Status for the Inbound Direction */
    public var inbound: Inbound?
    /** Status for the Outbound Direction */
    public var outbound: Outbound?

    public init(inbound: Inbound?, outbound: Outbound?) {
        self.inbound = inbound
        self.outbound = outbound
    }


}




public class ShiftTradeMatchViolation: Codable {

    public enum ModelType: String, Codable { 
        case agentCapabilityMismatch = "AgentCapabilityMismatch"
        case cannotTradeWithYourself = "CannotTradeWithYourself"
        case directTradeForOtherUser = "DirectTradeForOtherUser"
        case initiatingAgentScheduleDoesNotExist = "InitiatingAgentScheduleDoesNotExist"
        case initiatingShiftDisallowedActivityCategory = "InitiatingShiftDisallowedActivityCategory"
        case initiatingShiftDoesNotExist = "InitiatingShiftDoesNotExist"
        case initiatingShiftHasExternalActivities = "InitiatingShiftHasExternalActivities"
        case initiatingShiftOverlapsExisting = "InitiatingShiftOverlapsExisting"
        case initiatingShiftStartTooClose = "InitiatingShiftStartTooClose"
        case initiatingShiftTimesChanged = "InitiatingShiftTimesChanged"
        case initiatingWeeklyMaxPaidTime = "InitiatingWeeklyMaxPaidTime"
        case initiatingWeeklyMinPaidTime = "InitiatingWeeklyMinPaidTime"
        case invalidState = "InvalidState"
        case oneSidedTradeCreation = "OneSidedTradeCreation"
        case receivingAgentScheduleDoesNotExist = "ReceivingAgentScheduleDoesNotExist"
        case receivingShiftDisallowedActivityCategory = "ReceivingShiftDisallowedActivityCategory"
        case receivingShiftDoesNotExist = "ReceivingShiftDoesNotExist"
        case receivingShiftForOneSidedTrade = "ReceivingShiftForOneSidedTrade"
        case receivingShiftHasExternalActivities = "ReceivingShiftHasExternalActivities"
        case receivingShiftMissingForTwoSidedTrade = "ReceivingShiftMissingForTwoSidedTrade"
        case receivingShiftOutsideAcceptableIntervals = "ReceivingShiftOutsideAcceptableIntervals"
        case receivingShiftOverlapsExisting = "ReceivingShiftOverlapsExisting"
        case receivingShiftStartTooClose = "ReceivingShiftStartTooClose"
        case receivingShiftTimesChanged = "ReceivingShiftTimesChanged"
        case receivingWeeklyMaxPaidTime = "ReceivingWeeklyMaxPaidTime"
        case receivingWeeklyMinPaidTime = "ReceivingWeeklyMinPaidTime"
        case shiftTradingNotEnabled = "ShiftTradingNotEnabled"
        case unequalPaidTime = "UnequalPaidTime"
        case weekScheduleDifferent = "WeekScheduleDifferent"
        case weekScheduleDoesNotExist = "WeekScheduleDoesNotExist"
        case weekScheduleUnpublished = "WeekScheduleUnpublished"
    }



    /** The type of constraint violation */
    public var type: ModelType?
    /** Clarifying user params for constructing helpful error messages */
    public var params: [String:String]?

    public init(type: ModelType?, params: [String:String]?) {
        self.type = type
        self.params = params
    }


}




public class ShiftTradeResponse: Codable {







    public enum State: String, Codable { 
        case unmatched = "Unmatched"
        case matched = "Matched"
        case approved = "Approved"
        case denied = "Denied"
        case expired = "Expired"
        case canceled = "Canceled"
    }





























    /** The ID of this shift trade */
    public var _id: String?
    /** The start week date of the associated schedule in yyyy-MM-dd format. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekDate: Date?
    /** A reference to the associated schedule */
    public var schedule: BuScheduleReferenceForMuRoute?
    /** The state of this shift trade */
    public var state: State?
    /** The user who initiated this trade */
    public var initiatingUser: UserReference?
    /** The ID of the shift offered for trade by the initiating user */
    public var initiatingShiftId: String?
    /** The start date/time of the shift being offered for trade. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var initiatingShiftStart: Date?
    /** The end date/time of the shift being offered for trade. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var initiatingShiftEnd: Date?
    /** The user matching the trade, or if the state is not Matched, the user to whom the trade request was sent */
    public var receivingUser: UserReference?
    /** The ID of the shift being exchanged for the initiating shift, null if the receiving user is picking up a shift */
    public var receivingShiftId: String?
    /** The start date/time of the receiving shift. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var receivingShiftStart: Date?
    /** The end date/time of the receiving shift. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var receivingShiftEnd: Date?
    /** When this shift trade offer will expire if not matched or approved. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var expiration: Date?
    /** Whether this is a one-sided shift trade (e.g. the initiating user is not asking for a shift in return) */
    public var oneSided: Bool?
    public var acceptableIntervals: [String]?
    /** The user who reviewed this shift trade */
    public var reviewedBy: UserReference?
    /** The timestamp when this shift trade was reviewed. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var reviewedDate: Date?
    /** Version data for this trade */
    public var metadata: WfmVersionedEntityMetadata?

    public init(_id: String?, weekDate: Date?, schedule: BuScheduleReferenceForMuRoute?, state: State?, initiatingUser: UserReference?, initiatingShiftId: String?, initiatingShiftStart: Date?, initiatingShiftEnd: Date?, receivingUser: UserReference?, receivingShiftId: String?, receivingShiftStart: Date?, receivingShiftEnd: Date?, expiration: Date?, oneSided: Bool?, acceptableIntervals: [String]?, reviewedBy: UserReference?, reviewedDate: Date?, metadata: WfmVersionedEntityMetadata?) {
        self._id = _id
        self.weekDate = weekDate
        self.schedule = schedule
        self.state = state
        self.initiatingUser = initiatingUser
        self.initiatingShiftId = initiatingShiftId
        self.initiatingShiftStart = initiatingShiftStart
        self.initiatingShiftEnd = initiatingShiftEnd
        self.receivingUser = receivingUser
        self.receivingShiftId = receivingShiftId
        self.receivingShiftStart = receivingShiftStart
        self.receivingShiftEnd = receivingShiftEnd
        self.expiration = expiration
        self.oneSided = oneSided
        self.acceptableIntervals = acceptableIntervals
        self.reviewedBy = reviewedBy
        self.reviewedDate = reviewedDate
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case schedule
        case state
        case initiatingUser
        case initiatingShiftId
        case initiatingShiftStart
        case initiatingShiftEnd
        case receivingUser
        case receivingShiftId
        case receivingShiftStart
        case receivingShiftEnd
        case expiration
        case oneSided
        case acceptableIntervals
        case reviewedBy
        case reviewedDate
        case metadata
    }


}




public class SingleWorkdayAveragePoints: Codable {









    /** Queried target workday. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateWorkday: Date?
    /** The targeted division for the average points */
    public var division: Division?
    /** The average points per agent earned within the division */
    public var averagePoints: Double?
    /** The targeted performance profile for the average points */
    public var performanceProfile: AddressableEntityRef?

    public init(dateWorkday: Date?, division: Division?, averagePoints: Double?, performanceProfile: AddressableEntityRef?) {
        self.dateWorkday = dateWorkday
        self.division = division
        self.averagePoints = averagePoints
        self.performanceProfile = performanceProfile
    }


}




public class SkillEntityListing: Codable {





















    public var entities: [RoutingSkill]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [RoutingSkill]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class SkillGroupEntityListing: Codable {









    public var entities: [SkillGroupDefinition]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [SkillGroupDefinition]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class SkillGroupMemberDivisions: Codable {





    public var addDivisionIds: [String]?
    public var removeDivisionIds: [String]?

    public init(addDivisionIds: [String]?, removeDivisionIds: [String]?) {
        self.addDivisionIds = addDivisionIds
        self.removeDivisionIds = removeDivisionIds
    }


}




public class SkillGroupMemberEntityListing: Codable {









    public var entities: [UserReferenceWithName]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [UserReferenceWithName]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class SkillsToRemove: Codable {







    public var name: String?
    public var _id: String?
    public var selfUri: String?

    public init(name: String?, _id: String?, selfUri: String?) {
        self.name = name
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _id = "id"
        case selfUri
    }


}




public class SmsProvisioningStatus: Codable {

    public enum Action: String, Codable { 
        case unknown = "Unknown"
        case create = "Create"
        case update = "Update"
        case delete = "Delete"
    }

    public enum State: String, Codable { 
        case running = "Running"
        case completed = "Completed"
        case failed = "Failed"
    }





    /** Provisioning action */
    public var action: Action?
    /** Provisioning state */
    public var state: State?
    /** Any error associated with a Failed state */
    public var error: ErrorBody?
    /** The phone number version associated with the provisioning action */
    public var version: Int64?

    public init(action: Action?, state: State?, error: ErrorBody?, version: Int64?) {
        self.action = action
        self.state = state
        self.error = error
        self.version = version
    }


}




public class SortItem: Codable {





    public var name: String?
    public var ascending: Bool?

    public init(name: String?, ascending: Bool?) {
        self.name = name
        self.ascending = ascending
    }


}




public class SourceConfiguration: Codable {







    /** Identifies the external platform that is the source of the conversation. */
    public var sourceId: String?
    /** The customer's unique external identifier associated with the conversation that comes from the external platform. */
    public var interactionId: String?
    /** The customer's external identifier or tag associated with the conversation. If set, it will be used to tag the conversation. */
    public var tagId: String?

    public init(sourceId: String?, interactionId: String?, tagId: String?) {
        self.sourceId = sourceId
        self.interactionId = interactionId
        self.tagId = tagId
    }


}




public class SourcePlanningGroupRequest: Codable {





    /** The ID of the planning group */
    public var _id: String?
    /** Version metadata for the planning group */
    public var metadata: WfmVersionedEntityMetadata?

    public init(_id: String?, metadata: WfmVersionedEntityMetadata?) {
        self._id = _id
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case metadata
    }


}




public class SpeechTextAnalyticsSettingsResponse: Codable {









    /** Setting to choose name for the default program for topic detection */
    public var defaultProgram: AddressableEntityRef?
    /** Setting to choose expected dialects */
    public var expectedDialects: [String]?
    /** Setting to enable/disable text analytics */
    public var textAnalyticsEnabled: Bool?
    /** Setting to enable/disable Agent Empathy setting */
    public var agentEmpathyEnabled: Bool?

    public init(defaultProgram: AddressableEntityRef?, expectedDialects: [String]?, textAnalyticsEnabled: Bool?, agentEmpathyEnabled: Bool?) {
        self.defaultProgram = defaultProgram
        self.expectedDialects = expectedDialects
        self.textAnalyticsEnabled = textAnalyticsEnabled
        self.agentEmpathyEnabled = agentEmpathyEnabled
    }


}




public class StaffingRequirementsPlanningGroupData: Codable {





    /** The ID of the planning group to which this data applies */
    public var planningGroupId: String?
    /** Staffing requirements per interval for this week forecast */
    public var staffingRequirementsPerInterval: [Double]?

    public init(planningGroupId: String?, staffingRequirementsPerInterval: [Double]?) {
        self.planningGroupId = planningGroupId
        self.staffingRequirementsPerInterval = staffingRequirementsPerInterval
    }


}




public class StatEventQueueTopicIntervalMetrics: Codable {





    public var interval: String?
    public var metrics: [StatEventQueueTopicMetricStats]?

    public init(interval: String?, metrics: [StatEventQueueTopicMetricStats]?) {
        self.interval = interval
        self.metrics = metrics
    }


}




public class StatEventQueueTopicMetricStats: Codable {







    public var metric: String?
    public var qualifier: String?
    public var stats: [String:Double]?

    public init(metric: String?, qualifier: String?, stats: [String:Double]?) {
        self.metric = metric
        self.qualifier = qualifier
        self.stats = stats
    }


}




public class Station: Codable {







    public enum Status: String, Codable { 
        case available = "AVAILABLE"
        case associated = "ASSOCIATED"
    }

























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var _description: String?
    public var status: Status?
    /** The Id of the user currently logged in and associated with the station. */
    public var userId: String?
    /** The Id of the user configured for the station if it is of type inin_webrtc_softphone. Empty if station type is not inin_webrtc_softphone. */
    public var webRtcUserId: String?
    public var primaryEdge: DomainEntityRef?
    public var secondaryEdge: DomainEntityRef?
    public var type: String?
    public var lineAppearanceId: String?
    /** The default or configured value of media dscp for the station. Empty if station type is not inin_webrtc_softphone. */
    public var webRtcMediaDscp: Int?
    /** The default or configured value of persistent connection setting for the station. Empty if station type is not inin_webrtc_softphone. */
    public var webRtcPersistentEnabled: Bool?
    /** Whether the station is configured to require TURN for routing WebRTC calls. Empty if station type is not inin_webrtc_softphone. */
    public var webRtcForceTurn: Bool?
    /** The number of call appearances on the station. */
    public var webRtcCallAppearances: Int?
    /** True when the media helper required. */
    public var webRtcRequireMediaHelper: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, status: Status?, userId: String?, webRtcUserId: String?, primaryEdge: DomainEntityRef?, secondaryEdge: DomainEntityRef?, type: String?, lineAppearanceId: String?, webRtcMediaDscp: Int?, webRtcPersistentEnabled: Bool?, webRtcForceTurn: Bool?, webRtcCallAppearances: Int?, webRtcRequireMediaHelper: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.status = status
        self.userId = userId
        self.webRtcUserId = webRtcUserId
        self.primaryEdge = primaryEdge
        self.secondaryEdge = secondaryEdge
        self.type = type
        self.lineAppearanceId = lineAppearanceId
        self.webRtcMediaDscp = webRtcMediaDscp
        self.webRtcPersistentEnabled = webRtcPersistentEnabled
        self.webRtcForceTurn = webRtcForceTurn
        self.webRtcCallAppearances = webRtcCallAppearances
        self.webRtcRequireMediaHelper = webRtcRequireMediaHelper
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case status
        case userId
        case webRtcUserId
        case primaryEdge
        case secondaryEdge
        case type
        case lineAppearanceId
        case webRtcMediaDscp
        case webRtcPersistentEnabled
        case webRtcForceTurn
        case webRtcCallAppearances
        case webRtcRequireMediaHelper
        case selfUri
    }


}




public class SupportCenterCustomMessage: Codable {



    public enum ModelType: String, Codable { 
        case welcome = "Welcome"
        case fallback = "Fallback"
    }

    /** Default value for the message */
    public var defaultValue: String?
    /** Type of the message */
    public var type: ModelType?

    public init(defaultValue: String?, type: ModelType?) {
        self.defaultValue = defaultValue
        self.type = type
    }


}



/** Settings concerning knowledge portal (previously support center) */

public class SupportCenterSettings: Codable {







    public enum RouterType: String, Codable { 
        case hash = "Hash"
        case browser = "Browser"
    }









    /** Whether or not knowledge portal (previously support center) is enabled */
    public var enabled: Bool?
    /** The knowledge base for knowledge portal (previously support center) */
    public var knowledgeBase: AddressableEntityRef?
    /** Customizable display texts for knowledge portal (previously support center) */
    public var customMessages: [SupportCenterCustomMessage]?
    /** Router type for knowledge portal (previously support center) */
    public var routerType: RouterType?
    /** Available screens for the knowledge portal (previously support center) with its modules */
    public var screens: [SupportCenterScreen]?
    /** Featured categories for knowledge portal (previously support center) home screen */
    public var enabledCategories: [SupportCenterCategory]?
    /** Style attributes for knowledge portal (previously support center) */
    public var styleSetting: SupportCenterStyleSetting?
    /** Customer feedback settings */
    public var feedback: SupportCenterFeedbackSettings?

    public init(enabled: Bool?, knowledgeBase: AddressableEntityRef?, customMessages: [SupportCenterCustomMessage]?, routerType: RouterType?, screens: [SupportCenterScreen]?, enabledCategories: [SupportCenterCategory]?, styleSetting: SupportCenterStyleSetting?, feedback: SupportCenterFeedbackSettings?) {
        self.enabled = enabled
        self.knowledgeBase = knowledgeBase
        self.customMessages = customMessages
        self.routerType = routerType
        self.screens = screens
        self.enabledCategories = enabledCategories
        self.styleSetting = styleSetting
        self.feedback = feedback
    }


}



/** Reference to supported content profile associated with the integration */

public class SupportedContentReference: Codable {









    /** The SupportedContent unique identifier associated with this integration */
    public var _id: String?
    /** The SupportedContent profile name */
    public var name: String?
    /** The SupportedContent profile URI */
    public var selfUri: String?
    /** Media types definition for the supported content */
    public var mediaTypes: MediaTypes?

    public init(_id: String?, name: String?, selfUri: String?, mediaTypes: MediaTypes?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
        self.mediaTypes = mediaTypes
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
        case mediaTypes
    }


}




public class SurveyAggregateQueryResponse: Codable {



    public var results: [SurveyAggregateDataContainer]?

    public init(results: [SurveyAggregateDataContainer]?) {
        self.results = results
    }


}




public class SurveyAggregationView: Codable {

    public enum Target: String, Codable { 
        case nsurveyerrors = "nSurveyErrors"
        case nsurveynpsdetractors = "nSurveyNpsDetractors"
        case nsurveynpspromoters = "nSurveyNpsPromoters"
        case nsurveynpsresponses = "nSurveyNpsResponses"
        case nsurveyquestiongroupresponses = "nSurveyQuestionGroupResponses"
        case nsurveyquestionresponses = "nSurveyQuestionResponses"
        case nsurveyresponses = "nSurveyResponses"
        case nsurveysabandoned = "nSurveysAbandoned"
        case nsurveysdeleted = "nSurveysDeleted"
        case nsurveysexpired = "nSurveysExpired"
        case nsurveyssent = "nSurveysSent"
        case nsurveysstarted = "nSurveysStarted"
        case osurveyquestiongroupscore = "oSurveyQuestionGroupScore"
        case osurveyquestionscore = "oSurveyQuestionScore"
        case osurveytotalscore = "oSurveyTotalScore"
    }



    public enum Function: String, Codable { 
        case rangebound = "rangeBound"
    }



    /** Target metric name */
    public var target: Target?
    /** A unique name for this view. Must be distinct from other views and built-in metric names. */
    public var name: String?
    /** Type of view you wish to create */
    public var function: Function?
    /** Range of numbers for slicing up data */
    public var range: AggregationRange?

    public init(target: Target?, name: String?, function: Function?, range: AggregationRange?) {
        self.target = target
        self.name = name
        self.function = function
        self.range = range
    }


}




public class SurveyAssignment: Codable {











    /** The survey form used for this survey. */
    public var surveyForm: PublishedSurveyFormReference?
    /** The URI reference to the flow associated with this survey. */
    public var flow: DomainEntityRef?
    /** An ISO 8601 repeated interval consisting of the number of repetitions, the start datetime, and the interval (e.g. R2/2018-03-01T13:00:00Z/P1M10DT2H30M). Total duration must not exceed 90 days. */
    public var inviteTimeInterval: String?
    /** User together with sendingDomain used to send email, null to use no-reply */
    public var sendingUser: String?
    /** Validated email domain, required */
    public var sendingDomain: String?

    public init(surveyForm: PublishedSurveyFormReference?, flow: DomainEntityRef?, inviteTimeInterval: String?, sendingUser: String?, sendingDomain: String?) {
        self.surveyForm = surveyForm
        self.flow = flow
        self.inviteTimeInterval = inviteTimeInterval
        self.sendingUser = sendingUser
        self.sendingDomain = sendingDomain
    }


}




public class SurveyDetailQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [SurveyDetailQueryPredicate]?

    public init(type: ModelType?, predicates: [SurveyDetailQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class SurveyForm: Codable {

























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The survey form name */
    public var name: String?
    /** Last modified date. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    /** Is this form published */
    public var published: Bool?
    /** Is this form disabled */
    public var disabled: Bool?
    /** Unique Id for all versions of this form */
    public var contextId: String?
    /** Language for survey viewer localization. Currently localized languages: da, de, en-US, es, fi, fr, it, ja, ko, nl, no, pl, pt-BR, sv, th, tr, zh-CH, zh-TW */
    public var language: String?
    /** Markdown text for the top of the form. */
    public var header: String?
    /** Markdown text for the bottom of the form. */
    public var footer: String?
    /** A list of question groups */
    public var questionGroups: [SurveyQuestionGroup]?
    /** List of published version of this form */
    public var publishedVersions: DomainEntityListingSurveyForm?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, modifiedDate: Date?, published: Bool?, disabled: Bool?, contextId: String?, language: String?, header: String?, footer: String?, questionGroups: [SurveyQuestionGroup]?, publishedVersions: DomainEntityListingSurveyForm?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.modifiedDate = modifiedDate
        self.published = published
        self.disabled = disabled
        self.contextId = contextId
        self.language = language
        self.header = header
        self.footer = footer
        self.questionGroups = questionGroups
        self.publishedVersions = publishedVersions
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case modifiedDate
        case published
        case disabled
        case contextId
        case language
        case header
        case footer
        case questionGroups
        case publishedVersions
        case selfUri
    }


}




public class SurveyFormAndScoringSet: Codable {





    public var surveyForm: SurveyForm?
    public var answers: SurveyScoringSet?

    public init(surveyForm: SurveyForm?, answers: SurveyScoringSet?) {
        self.surveyForm = surveyForm
        self.answers = answers
    }


}




public class SurveyQuestionGroupScore: Codable {













    public var questionGroupId: String?
    /** Score of all questions in the group */
    public var totalScore: Float?
    /** Maximum possible score of all questions in the group */
    public var maxTotalScore: Float?
    /** True when the evaluation is submitted with a question group that does not have any answers. Only allowed when naEnabled is true or if set by the system */
    public var markedNA: Bool?
    /** If markedNA is true, systemMarkedNA indicates whether it was marked by a user or by the system due to visibility conditions. Always false if markedNA is false. */
    public var systemMarkedNA: Bool?
    public var questionScores: [SurveyQuestionScore]?

    public init(questionGroupId: String?, totalScore: Float?, maxTotalScore: Float?, markedNA: Bool?, systemMarkedNA: Bool?, questionScores: [SurveyQuestionScore]?) {
        self.questionGroupId = questionGroupId
        self.totalScore = totalScore
        self.maxTotalScore = maxTotalScore
        self.markedNA = markedNA
        self.systemMarkedNA = systemMarkedNA
        self.questionScores = questionScores
    }


}




public class SurveyQuestionScore: Codable {



















    public var questionId: String?
    public var answerId: String?
    /** Unweighted score of the question */
    public var score: Int?
    /** True when the evaluation is submitted with a question that does not have an answer. Only allowed when naEnabled is true or if set by the system */
    public var markedNA: Bool?
    /** If markedNA is true, systemMarkedNA indicates whether it was marked by a user or by the system due to visibility conditions. Always false if markedNA is false. */
    public var systemMarkedNA: Bool?
    /** AnswerId found with evaluation assistance conditions */
    public var assistedAnswerId: String?
    public var npsScore: Int?
    public var npsTextAnswer: String?
    public var freeTextAnswer: String?

    public init(questionId: String?, answerId: String?, score: Int?, markedNA: Bool?, systemMarkedNA: Bool?, assistedAnswerId: String?, npsScore: Int?, npsTextAnswer: String?, freeTextAnswer: String?) {
        self.questionId = questionId
        self.answerId = answerId
        self.score = score
        self.markedNA = markedNA
        self.systemMarkedNA = systemMarkedNA
        self.assistedAnswerId = assistedAnswerId
        self.npsScore = npsScore
        self.npsTextAnswer = npsTextAnswer
        self.freeTextAnswer = freeTextAnswer
    }


}




public class SystemMessageSystemMessage: Codable {



    public enum SystemTopicType: String, Codable { 
        case noLongerSubscribed = "no_longer_subscribed"
        case subscriptionChanged = "subscription_changed"
        case tokenRevoked = "token_revoked"
    }









    public enum Reason: String, Codable { 
        case anotherChannelSubscribed = "another_channel_subscribed"
        case userTokensRevoked = "user_tokens_revoked"
    }





    public var channelId: String?
    public var systemTopicType: SystemTopicType?
    public var correlationId: String?
    public var organizationId: String?
    public var userId: String?
    public var oauthClientId: String?
    public var reason: Reason?
    public var message: String?
    public var data: [String:JSON]?

    public init(channelId: String?, systemTopicType: SystemTopicType?, correlationId: String?, organizationId: String?, userId: String?, oauthClientId: String?, reason: Reason?, message: String?, data: [String:JSON]?) {
        self.channelId = channelId
        self.systemTopicType = systemTopicType
        self.correlationId = correlationId
        self.organizationId = organizationId
        self.userId = userId
        self.oauthClientId = oauthClientId
        self.reason = reason
        self.message = message
        self.data = data
    }


}




public class TagQueryRequest: Codable {







    public var query: String?
    public var pageNumber: Int?
    public var pageSize: Int?

    public init(query: String?, pageNumber: Int?, pageSize: Int?) {
        self.query = query
        self.pageNumber = pageNumber
        self.pageSize = pageSize
    }


}




public class TagValue: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The workspace tag name. */
    public var name: String?
    public var inUse: Bool?
    public var acl: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, inUse: Bool?, acl: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.inUse = inUse
        self.acl = acl
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case inUse
        case acl
        case selfUri
    }


}




public class TeamAddMemberFailure: Codable {



    public enum Reason: String, Codable { 
        case userNotFound = "UserNotFound"
        case userGroupLimitExceeded = "UserGroupLimitExceeded"
        case userGroupDivisionMismatch = "UserGroupDivisionMismatch"
    }

    public var _id: String?
    /** Specific reason the member could not be added. */
    public var reason: Reason?

    public init(_id: String?, reason: Reason?) {
        self._id = _id
        self.reason = reason
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case reason
    }


}




public class TeamEntityListing: Codable {









    public var entities: [Team]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [Team]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class TeamMemberAddListingResponse: Codable {





    public var entities: [UserReference]?
    /** List of any user ids that were not added. */
    public var failures: [TeamAddMemberFailure]?

    public init(entities: [UserReference]?, failures: [TeamAddMemberFailure]?) {
        self.entities = entities
        self.failures = failures
    }


}




public class TeamMemberEntityListing: Codable {









    public var entities: [UserReferenceWithName]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [UserReferenceWithName]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class TeamSearchCriteria: Codable {









    public enum Operator: String, Codable { 
        case and = "AND"
        case or = "OR"
        case not = "NOT"
    }







    public enum ModelType: String, Codable { 
        case exact = "EXACT"
        case startsWith = "STARTS_WITH"
    }

    /** The end value of the range. This field is used for range search types. */
    public var endValue: String?
    /** A list of values for the search to match against */
    public var values: [String]?
    /** The start value of the range. This field is used for range search types. */
    public var startValue: String?
    /** A value for the search to match against */
    public var value: String?
    /** How to apply this search criteria against other criteria */
    public var _operator: Operator?
    /** Groups multiple conditions */
    public var group: [TeamSearchCriteria]?
    /** Set date format for criteria values when using date range search type.  Supports Java date format syntax, example yyyy-MM-dd'T'HH:mm:ss.SSSX. */
    public var dateFormat: String?
    /** Field names to search against */
    public var fields: [String]?
    /** Search Type */
    public var type: ModelType?

    public init(endValue: String?, values: [String]?, startValue: String?, value: String?, _operator: Operator?, group: [TeamSearchCriteria]?, dateFormat: String?, fields: [String]?, type: ModelType?) {
        self.endValue = endValue
        self.values = values
        self.startValue = startValue
        self.value = value
        self._operator = _operator
        self.group = group
        self.dateFormat = dateFormat
        self.fields = fields
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case endValue
        case values
        case startValue
        case value
        case _operator = "operator"
        case group
        case dateFormat
        case fields
        case type
    }


}




public class TestExecutionOperationResult: Codable {











    /** The step number to indicate the order in which the operation was performed */
    public var step: Int?
    /** Name of the operation performed */
    public var name: String?
    /** Indicated whether or not the operation was successful */
    public var success: Bool?
    /** The result of the operation */
    public var result: JSON?
    /** Error that occurred during the operation */
    public var error: ErrorBody?

    public init(step: Int?, name: String?, success: Bool?, result: JSON?, error: ErrorBody?) {
        self.step = step
        self.name = name
        self.success = success
        self.result = result
        self.error = error
    }


}




public class TestExecutionResult: Codable {









    /** Execution operations performed as part of the test */
    public var operations: [TestExecutionOperationResult]?
    /** The final error encountered during the test that resulted in test failure */
    public var error: ErrorBody?
    /** The final result of the test. This is the response that would be returned during normal action execution */
    public var finalResult: JSON?
    /** Indicates whether or not the test was a success */
    public var success: Bool?

    public init(operations: [TestExecutionOperationResult]?, error: ErrorBody?, finalResult: JSON?, success: Bool?) {
        self.operations = operations
        self.error = error
        self.finalResult = finalResult
        self.success = success
    }


}



/** Information about event test mode execution */

public class TestModeEventResults: Codable {





    /** Information about the validation of the schema of the event body passed in to test mode */
    public var schemaValidation: TestSchemaOperation?
    /** Information about matched and unmatched triggers */
    public var triggerMatchValidation: TestMatchesEventOperation?

    public init(schemaValidation: TestSchemaOperation?, triggerMatchValidation: TestMatchesEventOperation?) {
        self.schemaValidation = schemaValidation
        self.triggerMatchValidation = triggerMatchValidation
    }


}



/** Settings for an input event to the bot flow indicating an error has occurred. */

public class TextBotErrorInputEvent: Codable {





    /** The error code. */
    public var code: String?
    /** The error message. */
    public var message: String?

    public init(code: String?, message: String?) {
        self.code = code
        self.message = message
    }


}



/** Prompt information related to a bot flow turn. */

public class TextBotOutputPrompts: Codable {





    /** The ISO code of the output language for this prompt item. */
    public var outputLanguage: String?
    /** Text output prompts, if any. */
    public var textPrompts: TextBotModeOutputPrompts?

    public init(outputLanguage: String?, textPrompts: TextBotModeOutputPrompts?) {
        self.outputLanguage = outputLanguage
        self.textPrompts = textPrompts
    }


}



/** User input data used in a bot flow turn. */

public class TextBotUserInputAlternative: Codable {



    /** The user input transcript. */
    public var transcript: TextBotTranscript?

    public init(transcript: TextBotTranscript?) {
        self.transcript = transcript
    }


}



/** Settings for a next-action of waiting for additional user input and sending the data as an input action to the bot flow. */

public class TextBotWaitForInputAction: Codable {



    /** The mode constraints for the user input. */
    public var modeConstraints: TextBotModeConstraints?

    public init(modeConstraints: TextBotModeConstraints?) {
        self.modeConstraints = modeConstraints
    }


}




public class TimeOffLimit: Codable {



    public enum Granularity: String, Codable { 
        case daily = "Daily"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Granularity choice for the time off limit */
    public var granularity: Granularity?
    /** The default time off limit value in minutes per granularity interval */
    public var defaultLimitMinutes: Int?
    /** Version metadata for the time off limit */
    public var metadata: WfmVersionedEntityMetadata?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, granularity: Granularity?, defaultLimitMinutes: Int?, metadata: WfmVersionedEntityMetadata?, selfUri: String?) {
        self._id = _id
        self.granularity = granularity
        self.defaultLimitMinutes = defaultLimitMinutes
        self.metadata = metadata
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case granularity
        case defaultLimitMinutes
        case metadata
        case selfUri
    }


}




public class TimeOffLimitListing: Codable {



    public var entities: [TimeOffLimit]?

    public init(entities: [TimeOffLimit]?) {
        self.entities = entities
    }


}




public class TimeOffRequestReference: Codable {





    /** The id of the time off request */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class TimeZoneEntityListing: Codable {





















    public var entities: [RegionTimeZone]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [RegionTimeZone]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class TopicsEntityListing: Codable {













    public var entities: [ListedTopic]?
    public var pageSize: Int?
    public var total: Int?
    public var nextUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ListedTopic]?, pageSize: Int?, total: Int?, nextUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.total = total
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class TrainingListing: Codable {









    public var entities: [KnowledgeTraining]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [KnowledgeTraining]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class TranscriptAggregateDataContainer: Codable {





    /** A mapping from dimension to value */
    public var group: [String:String]?
    public var data: [StatisticalResponse]?

    public init(group: [String:String]?, data: [StatisticalResponse]?) {
        self.group = group
        self.data = data
    }


}




public class TranscriptAggregateQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [TranscriptAggregateQueryPredicate]?

    public init(type: ModelType?, predicates: [TranscriptAggregateQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class TranscriptAggregationQuery: Codable {







    public enum GroupBy: String, Codable { 
        case addressfrom = "addressFrom"
        case addressto = "addressTo"
        case ani = "ani"
        case channel = "channel"
        case conversationid = "conversationId"
        case direction = "direction"
        case divisionid = "divisionId"
        case dnis = "dnis"
        case flowid = "flowId"
        case flowversion = "flowVersion"
        case mediatype = "mediaType"
        case messagetype = "messageType"
        case queueid = "queueId"
        case teamid = "teamId"
        case topicid = "topicId"
        case userid = "userId"
        case wrapupcode = "wrapUpCode"
    }



    public enum Metrics: String, Codable { 
        case ntopiccommunications = "nTopicCommunications"
        case ocustomersentiment = "oCustomerSentiment"
        case oovertalkspeechinstances = "oOverTalkSpeechInstances"
        case osentimentscore = "oSentimentScore"
        case tagentspeech = "tAgentSpeech"
        case tcustomerspeech = "tCustomerSpeech"
        case totheraudio = "tOtherAudio"
        case tovertalkspeech = "tOverTalkSpeech"
        case tsilence = "tSilence"
        case ttotalspeechandsilence = "tTotalSpeechAndSilence"
    }





    public enum AlternateTimeDimension: String, Codable { 
        case eventtime = "eventTime"
    }

    /** Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H */
    public var granularity: String?
    /** Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var timeZone: String?
    /** Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group. */
    public var groupBy: [GroupBy]?
    /** Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters */
    public var filter: TranscriptAggregateQueryFilter?
    /** Behaves like a SQL SELECT clause. Only named metrics will be retrieved. */
    public var metrics: [Metrics]?
    /** Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c') */
    public var flattenMultivaluedDimensions: Bool?
    /** Custom derived metric views */
    public var views: [TranscriptAggregationView]?
    /** Dimension to use as the alternative timestamp for data in the aggregate.  Choosing \"eventTime\" uses the actual time of the data event. */
    public var alternateTimeDimension: AlternateTimeDimension?

    public init(interval: String?, granularity: String?, timeZone: String?, groupBy: [GroupBy]?, filter: TranscriptAggregateQueryFilter?, metrics: [Metrics]?, flattenMultivaluedDimensions: Bool?, views: [TranscriptAggregationView]?, alternateTimeDimension: AlternateTimeDimension?) {
        self.interval = interval
        self.granularity = granularity
        self.timeZone = timeZone
        self.groupBy = groupBy
        self.filter = filter
        self.metrics = metrics
        self.flattenMultivaluedDimensions = flattenMultivaluedDimensions
        self.views = views
        self.alternateTimeDimension = alternateTimeDimension
    }


}




public class TranscriptConversationDetailSearchCriteria: Codable {









    public enum Operator: String, Codable { 
        case and = "AND"
        case or = "OR"
        case not = "NOT"
    }







    public enum ModelType: String, Codable { 
        case exact = "EXACT"
        case exactPhrase = "EXACT_PHRASE"
        case phrase = "PHRASE"
        case dateRange = "DATE_RANGE"
    }

    /** The end value of the range. This field is used for range search types. */
    public var endValue: String?
    /** A list of values for the search to match against */
    public var values: [String]?
    /** The start value of the range. This field is used for range search types. */
    public var startValue: String?
    /** A value for the search to match against */
    public var value: String?
    /** How to apply this search criteria against other criteria */
    public var _operator: Operator?
    /** Groups multiple conditions */
    public var group: [TranscriptConversationDetailSearchCriteria]?
    /** Set date format for criteria values when using date range search type.  Supports Java date format syntax, example yyyy-MM-dd'T'HH:mm:ss.SSSX. */
    public var dateFormat: String?
    /** Field names to search against */
    public var fields: [String]?
    public var type: ModelType?

    public init(endValue: String?, values: [String]?, startValue: String?, value: String?, _operator: Operator?, group: [TranscriptConversationDetailSearchCriteria]?, dateFormat: String?, fields: [String]?, type: ModelType?) {
        self.endValue = endValue
        self.values = values
        self.startValue = startValue
        self.value = value
        self._operator = _operator
        self.group = group
        self.dateFormat = dateFormat
        self.fields = fields
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case endValue
        case values
        case startValue
        case value
        case _operator = "operator"
        case group
        case dateFormat
        case fields
        case type
    }


}




public class TranscriptSearchCriteria: Codable {









    public enum Operator: String, Codable { 
        case and = "AND"
        case or = "OR"
        case not = "NOT"
    }





    public enum ModelType: String, Codable { 
        case exact = "EXACT"
        case exactPhrase = "EXACT_PHRASE"
        case phrase = "PHRASE"
        case dateRange = "DATE_RANGE"
        case range = "RANGE"
        case greaterThan = "GREATER_THAN"
        case lessThan = "LESS_THAN"
    }



    /** The end value of the range. This field is used for range search types. */
    public var endValue: String?
    /** A list of values for the search to match against */
    public var values: [String]?
    /** The start value of the range. This field is used for range search types. */
    public var startValue: String?
    /** A value for the search to match against */
    public var value: String?
    /** How to apply this search criteria against other criteria */
    public var _operator: Operator?
    /** Groups multiple conditions */
    public var group: [TranscriptSearchCriteria]?
    /** Set date format for criteria values when using date range search type.  Supports Java date format syntax, example yyyy-MM-dd'T'HH:mm:ss.SSSX. */
    public var dateFormat: String?
    public var type: ModelType?
    /** Field names to search against */
    public var fields: [String]?

    public init(endValue: String?, values: [String]?, startValue: String?, value: String?, _operator: Operator?, group: [TranscriptSearchCriteria]?, dateFormat: String?, type: ModelType?, fields: [String]?) {
        self.endValue = endValue
        self.values = values
        self.startValue = startValue
        self.value = value
        self._operator = _operator
        self.group = group
        self.dateFormat = dateFormat
        self.type = type
        self.fields = fields
    }

    public enum CodingKeys: String, CodingKey { 
        case endValue
        case values
        case startValue
        case value
        case _operator = "operator"
        case group
        case dateFormat
        case type
        case fields
    }


}




public class TranscriptUrl: Codable {



    /** The pre-signed S3 URL of the transcript */
    public var url: String?

    public init(url: String?) {
        self.url = url
    }


}




public class TranscriptUrls: Codable {







    /** The Conversation Reference */
    public var conversation: AddressableEntityRef?
    /** The Communication ID */
    public var communicationId: String?
    /** List of Transcript URLs */
    public var urls: [SegmentUrl]?

    public init(conversation: AddressableEntityRef?, communicationId: String?, urls: [SegmentUrl]?) {
        self.conversation = conversation
        self.communicationId = communicationId
        self.urls = urls
    }


}




public class TranscriptionTopicTranscriptResult: Codable {





    public enum Channel: String, Codable { 
        case unknown = "UNKNOWN"
        case _internal = "INTERNAL"
        case external = "EXTERNAL"
        case both = "BOTH"
    }















    public var utteranceId: String?
    public var isFinal: Bool?
    public var channel: Channel?
    public var alternatives: [TranscriptionTopicTranscriptAlternative]?
    public var agentAssistantId: String?
    public var engineId: String?
    public var dialect: String?
    public var speechTextAnalyticsProgramId: String?
    public var agentAssistEnabled: Bool?
    public var voiceTranscriptionEnabled: Bool?

    public init(utteranceId: String?, isFinal: Bool?, channel: Channel?, alternatives: [TranscriptionTopicTranscriptAlternative]?, agentAssistantId: String?, engineId: String?, dialect: String?, speechTextAnalyticsProgramId: String?, agentAssistEnabled: Bool?, voiceTranscriptionEnabled: Bool?) {
        self.utteranceId = utteranceId
        self.isFinal = isFinal
        self.channel = channel
        self.alternatives = alternatives
        self.agentAssistantId = agentAssistantId
        self.engineId = engineId
        self.dialect = dialect
        self.speechTextAnalyticsProgramId = speechTextAnalyticsProgramId
        self.agentAssistEnabled = agentAssistEnabled
        self.voiceTranscriptionEnabled = voiceTranscriptionEnabled
    }


}




public class TrunkBaseEntityListing: Codable {





















    public var entities: [TrunkBase]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [TrunkBase]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class TrunkMetricsNetworkTypeIp: Codable {





    /** Assigned IP Address for the interface */
    public var address: String?
    /** Information about the error. */
    public var errorInfo: TrunkErrorInfo?

    public init(address: String?, errorInfo: TrunkErrorInfo?) {
        self.address = address
        self.errorInfo = errorInfo
    }


}




public class TrustEntityListing: Codable {





















    public var entities: [Trustee]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Trustee]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class TrustGroupEntityListing: Codable {





















    public var entities: [TrustGroup]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [TrustGroup]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class TrustUserEntityListing: Codable {





















    public var entities: [TrustUser]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [TrustUser]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class Trustee: Codable {

















    /** Organization Id for this trust. */
    public var _id: String?
    /** If disabled no trustee user will have access, even if they were previously added. */
    public var enabled: Bool?
    /** Denotes if trustee uses admin role by default. */
    public var usesDefaultRole: Bool?
    /** Date Trust was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The expiration date of the trust. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateExpired: Date?
    /** User that created trust. */
    public var createdBy: OrgUser?
    /** Organization associated with this trust. */
    public var organization: Organization?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, enabled: Bool?, usesDefaultRole: Bool?, dateCreated: Date?, dateExpired: Date?, createdBy: OrgUser?, organization: Organization?, selfUri: String?) {
        self._id = _id
        self.enabled = enabled
        self.usesDefaultRole = usesDefaultRole
        self.dateCreated = dateCreated
        self.dateExpired = dateExpired
        self.createdBy = createdBy
        self.organization = organization
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case enabled
        case usesDefaultRole
        case dateCreated
        case dateExpired
        case createdBy
        case organization
        case selfUri
    }


}




public class TrusteeBillingOverview: Codable {











    public enum SubscriptionType: String, Codable { 
        case inin = "ININ"
        case monthToMonth = "MONTH_TO_MONTH"
        case freeTrialMonthToMonth = "FREE_TRIAL_MONTH_TO_MONTH"
        case prepayMonthlyCommitment = "PREPAY_MONTHLY_COMMITMENT"
        case prepay = "PREPAY"
        case devOrgMonthToMonth = "DEV_ORG_MONTH_TO_MONTH"
        case devOrgPrepayMonthlyCommitment = "DEV_ORG_PREPAY_MONTHLY_COMMITMENT"
        case devOrgPrepay = "DEV_ORG_PREPAY"
    }























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Organization */
    public var organization: NamedEntity?
    /** The currency type. */
    public var currency: String?
    /** The charge short names for products enabled during the specified period. */
    public var enabledProducts: [String]?
    /** The subscription type. */
    public var subscriptionType: SubscriptionType?
    /** Date-time the ramp period starts. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var rampPeriodStartDate: Date?
    /** Date-time the ramp period ends. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var rampPeriodEndDate: Date?
    /** Date-time the billing period started. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var billingPeriodStartDate: Date?
    /** Date-time the billing period ended. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var billingPeriodEndDate: Date?
    /** Usages for the specified period. */
    public var usages: [SubscriptionOverviewUsage]?
    /** Date-time the contract was last amended. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var contractAmendmentDate: Date?
    /** Date-time the contract became effective. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var contractEffectiveDate: Date?
    /** Date-time the contract ends. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var contractEndDate: Date?
    /** Minimum amount that will be charged for the month */
    public var minimumMonthlyAmount: String?
    public var inRampPeriod: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, organization: NamedEntity?, currency: String?, enabledProducts: [String]?, subscriptionType: SubscriptionType?, rampPeriodStartDate: Date?, rampPeriodEndDate: Date?, billingPeriodStartDate: Date?, billingPeriodEndDate: Date?, usages: [SubscriptionOverviewUsage]?, contractAmendmentDate: Date?, contractEffectiveDate: Date?, contractEndDate: Date?, minimumMonthlyAmount: String?, inRampPeriod: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.organization = organization
        self.currency = currency
        self.enabledProducts = enabledProducts
        self.subscriptionType = subscriptionType
        self.rampPeriodStartDate = rampPeriodStartDate
        self.rampPeriodEndDate = rampPeriodEndDate
        self.billingPeriodStartDate = billingPeriodStartDate
        self.billingPeriodEndDate = billingPeriodEndDate
        self.usages = usages
        self.contractAmendmentDate = contractAmendmentDate
        self.contractEffectiveDate = contractEffectiveDate
        self.contractEndDate = contractEndDate
        self.minimumMonthlyAmount = minimumMonthlyAmount
        self.inRampPeriod = inRampPeriod
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case organization
        case currency
        case enabledProducts
        case subscriptionType
        case rampPeriodStartDate
        case rampPeriodEndDate
        case billingPeriodStartDate
        case billingPeriodEndDate
        case usages
        case contractAmendmentDate
        case contractEffectiveDate
        case contractEndDate
        case minimumMonthlyAmount
        case inRampPeriod
        case selfUri
    }


}




public class TrustorAuditQueryRequest: Codable {















    /** Limit returned audits to this trustor organizationId. */
    public var trustorOrganizationId: String?
    /** Limit returned audits to these trustee userIds. */
    public var trusteeUserIds: [String]?
    /** Starting date/time for the audit search. ISO-8601 formatted date-time, UTC. */
    public var startDate: Date?
    /** Ending date/time for the audit search. ISO-8601 formatted date-time, UTC. */
    public var endDate: Date?
    /** Word or phrase to look for in audit bodies. */
    public var queryPhrase: String?
    /** Facet information to be returned with the query results. */
    public var facets: [Facet]?
    /** Additional custom filters to be applied to the query. */
    public var filters: [Filter]?

    public init(trustorOrganizationId: String?, trusteeUserIds: [String]?, startDate: Date?, endDate: Date?, queryPhrase: String?, facets: [Facet]?, filters: [Filter]?) {
        self.trustorOrganizationId = trustorOrganizationId
        self.trusteeUserIds = trusteeUserIds
        self.startDate = startDate
        self.endDate = endDate
        self.queryPhrase = queryPhrase
        self.facets = facets
        self.filters = filters
    }


}




public class TrustorEntityListing: Codable {





















    public var entities: [Trustor]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Trustor]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** User information for a twitter account */

public class TwitterId: Codable {











    /** twitter user.id_str */
    public var _id: String?
    /** twitter user.name */
    public var name: String?
    /** twitter user.screen_name */
    public var screenName: String?
    /** whether this data has been verified using the twitter API */
    public var verified: Bool?
    /** url of user's twitter profile */
    public var profileUrl: String?

    public init(_id: String?, name: String?, screenName: String?, verified: Bool?, profileUrl: String?) {
        self._id = _id
        self.name = name
        self.screenName = screenName
        self.verified = verified
        self.profileUrl = profileUrl
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case screenName
        case verified
        case profileUrl
    }


}




public class TwitterIntegrationEntityListing: Codable {





















    public var entities: [TwitterIntegration]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [TwitterIntegration]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** UC Integration UI configuration data */

public class UCIntegration: Codable {







    public enum IntegrationPresenceSource: String, Codable { 
        case microsoftTeams = "MicrosoftTeams"
        case zoomPhone = "ZoomPhone"
        case eightByEight = "EightByEight"
    }















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** ucIntegrationKey */
    public var ucIntegrationKey: String?
    /** integrationPresenceType */
    public var integrationPresenceSource: IntegrationPresenceSource?
    /** pbxPermission */
    public var pbxPermission: String?
    /** icon */
    public var icon: UCIcon?
    /** badgeIcon */
    public var badgeIcons: [String:UCIcon]?
    /** i10n */
    public var i10n: [String:UCI10n]?
    /** polledPresence */
    public var polledPresence: Bool?
    /** userPermissions */
    public var userPermissions: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, ucIntegrationKey: String?, integrationPresenceSource: IntegrationPresenceSource?, pbxPermission: String?, icon: UCIcon?, badgeIcons: [String:UCIcon]?, i10n: [String:UCI10n]?, polledPresence: Bool?, userPermissions: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.ucIntegrationKey = ucIntegrationKey
        self.integrationPresenceSource = integrationPresenceSource
        self.pbxPermission = pbxPermission
        self.icon = icon
        self.badgeIcons = badgeIcons
        self.i10n = i10n
        self.polledPresence = polledPresence
        self.userPermissions = userPermissions
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case ucIntegrationKey
        case integrationPresenceSource
        case pbxPermission
        case icon
        case badgeIcons
        case i10n
        case polledPresence
        case userPermissions
        case selfUri
    }


}




public class UCIntegrationListing: Codable {





















    public var entities: [UCIntegration]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [UCIntegration]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** Update a Genesys Cloud user's presence from a given 3rd-party integration */

public class UCThirdPartyPresence: Codable {









    /** Primary Email address of the associated Genesys Cloud user. */
    public var email: String?
    /** Integration presence value. */
    public var presence: String?
    /** Integration presence message. */
    public var message: String?
    /** ISO 8601 timestamp of presence value change. */
    public var dateModified: Date?

    public init(email: String?, presence: String?, message: String?, dateModified: Date?) {
        self.email = email
        self.presence = presence
        self.message = message
        self.dateModified = dateModified
    }


}




public class UnansweredPhrase: Codable {







    /** Id of an unanswered phrase */
    public var _id: String?
    /** Phrase text of an unanswered phrase */
    public var text: String?
    /** Hit count of an unlinked phrase */
    public var unlinkedPhraseHitCount: Int?

    public init(_id: String?, text: String?, unlinkedPhraseHitCount: Int?) {
        self._id = _id
        self.text = text
        self.unlinkedPhraseHitCount = unlinkedPhraseHitCount
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case text
        case unlinkedPhraseHitCount
    }


}




public class UnansweredPhraseGroup: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Knowledge base phrase group label */
    public var label: String?
    /** List of unanswered phrases in a phrase group */
    public var phrases: [UnansweredPhrase]?
    /** Hit count of the unlinked phrase group */
    public var unlinkedPhraseHitCount: Int?
    /** Unique phrase count of the unlinked phrase group */
    public var unlinkedPhraseCount: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, label: String?, phrases: [UnansweredPhrase]?, unlinkedPhraseHitCount: Int?, unlinkedPhraseCount: Int?, selfUri: String?) {
        self._id = _id
        self.label = label
        self.phrases = phrases
        self.unlinkedPhraseHitCount = unlinkedPhraseHitCount
        self.unlinkedPhraseCount = unlinkedPhraseCount
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case label
        case phrases
        case unlinkedPhraseHitCount
        case unlinkedPhraseCount
        case selfUri
    }


}




public class UnifiedGeneralTopicEntityListing: Codable {



    public var entities: [UnifiedGeneralTopic]?

    public init(entities: [UnifiedGeneralTopic]?) {
        self.entities = entities
    }


}




public class UpdateManagementUnitRequest: Codable {







    /** The new name of the management unit */
    public var name: String?
    /** The new division id for the management unit */
    public var divisionId: String?
    /** Updated settings for the management unit */
    public var settings: ManagementUnitSettingsRequest?

    public init(name: String?, divisionId: String?, settings: ManagementUnitSettingsRequest?) {
        self.name = name
        self.divisionId = divisionId
        self.settings = settings
    }


}




public class UpdateNotificationResponse: Codable {





    /** The mutableGroupId of the notification */
    public var mutableGroupId: String?
    /** The id of the notification for mapping the potentially new mutableGroupId */
    public var _id: String?

    public init(mutableGroupId: String?, _id: String?) {
        self.mutableGroupId = mutableGroupId
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case mutableGroupId
        case _id = "id"
    }


}




public class UpdateNotificationsResponse: Codable {



    public var entities: [UpdateNotificationResponse]?

    public init(entities: [UpdateNotificationResponse]?) {
        self.entities = entities
    }


}




public class UpdateTimeOffPlanRequest: Codable {







    public enum AutoApprovalRule: String, Codable { 
        case never = "Never"
        case always = "Always"
        case checkLimits = "CheckLimits"
    }









    /** The name of this time off plan. */
    public var name: String?
    /** The set of activity code IDs to associate with this time off plan. */
    public var activityCodeIds: SetWrapperString?
    /** The set of time off limit IDs to associate with this time off plan. */
    public var timeOffLimitIds: SetWrapperString?
    /** Auto approval rule for the time off plan. */
    public var autoApprovalRule: AutoApprovalRule?
    /** The number of days before the time off request start date for when the request will be expired from the waitlist. */
    public var daysBeforeStartToExpireFromWaitlist: Int?
    /** Time off type, if this time off plan is associated with the integration. */
    public var hrisTimeOffType: ValueWrapperHrisTimeOffType?
    /** Whether this time off plan should be used by agents. */
    public var active: Bool?
    /** Version metadata for the time off plan */
    public var metadata: WfmVersionedEntityMetadata?

    public init(name: String?, activityCodeIds: SetWrapperString?, timeOffLimitIds: SetWrapperString?, autoApprovalRule: AutoApprovalRule?, daysBeforeStartToExpireFromWaitlist: Int?, hrisTimeOffType: ValueWrapperHrisTimeOffType?, active: Bool?, metadata: WfmVersionedEntityMetadata?) {
        self.name = name
        self.activityCodeIds = activityCodeIds
        self.timeOffLimitIds = timeOffLimitIds
        self.autoApprovalRule = autoApprovalRule
        self.daysBeforeStartToExpireFromWaitlist = daysBeforeStartToExpireFromWaitlist
        self.hrisTimeOffType = hrisTimeOffType
        self.active = active
        self.metadata = metadata
    }


}




public class UpdateWorkPlanRotationAgentRequest: Codable {









    /** The ID of an agent in this work plan rotation */
    public var userId: String?
    /** The date range to which this agent is effective in the work plan rotation */
    public var dateRange: DateRangeWithOptionalEnd?
    /** Start position of the work plan in the pattern for this agent in the work plan rotation. Position value starts from 0 */
    public var position: Int?
    /** If marked true for this agent when updating, then this agent will be removed from this work plan rotation */
    public var delete: Bool?

    public init(userId: String?, dateRange: DateRangeWithOptionalEnd?, position: Int?, delete: Bool?) {
        self.userId = userId
        self.dateRange = dateRange
        self.position = position
        self.delete = delete
    }


}




public class UpdateWorkPlanRotationRequest: Codable {













    /** Name of this work plan rotation */
    public var name: String?
    /** Whether the work plan rotation is enabled for scheduling */
    public var enabled: Bool?
    /** The date range to which this work plan rotation applies */
    public var dateRange: DateRangeWithOptionalEnd?
    /** Agents in this work plan rotation */
    public var agents: [UpdateWorkPlanRotationAgentRequest]?
    /** Pattern with list of work plan IDs that rotate on a weekly basis */
    public var pattern: WorkPlanPatternRequest?
    /** Version metadata for this work plan rotation */
    public var metadata: WfmVersionedEntityMetadata?

    public init(name: String?, enabled: Bool?, dateRange: DateRangeWithOptionalEnd?, agents: [UpdateWorkPlanRotationAgentRequest]?, pattern: WorkPlanPatternRequest?, metadata: WfmVersionedEntityMetadata?) {
        self.name = name
        self.enabled = enabled
        self.dateRange = dateRange
        self.agents = agents
        self.pattern = pattern
        self.metadata = metadata
    }


}




public class UploadUrlRequestBody: Codable {



    /** The expected content length (in bytes) of the gzip-encoded data that will be PUT to the returned signed URL */
    public var contentLengthBytes: Int64?

    public init(contentLengthBytes: Int64?) {
        self.contentLengthBytes = contentLengthBytes
    }


}




public class UsageExecutionResult: Codable {





    /** The id of the query execution */
    public var executionId: String?
    /** URI where the query results can be retrieved */
    public var resultsUri: String?

    public init(executionId: String?, resultsUri: String?) {
        self.executionId = executionId
        self.resultsUri = resultsUri
    }


}



/** Configuration information for the integration */

public class UserAppConfigurationInfo: Codable {





    /** The current, active configuration for the integration. */
    public var current: IntegrationConfiguration?
    /** The effective configuration for the app, containing the integration specific configuration along with overrides specified in the integration type. */
    public var effective: EffectiveConfiguration?

    public init(current: IntegrationConfiguration?, effective: EffectiveConfiguration?) {
        self.current = current
        self.effective = effective
    }


}




public class UserAuthorization: Codable {









    public var roles: [DomainRole]?
    /** A collection of the roles the user is not using */
    public var unusedRoles: [DomainRole]?
    /** A collection of the permissions granted by all assigned roles */
    public var permissions: [String]?
    /** The policies configured for assigned permissions. */
    public var permissionPolicies: [ResourcePermissionPolicy]?

    public init(roles: [DomainRole]?, unusedRoles: [DomainRole]?, permissions: [String]?, permissionPolicies: [ResourcePermissionPolicy]?) {
        self.roles = roles
        self.unusedRoles = unusedRoles
        self.permissions = permissions
        self.permissionPolicies = permissionPolicies
    }


}




public class UserDetailQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [UserDetailQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [UserDetailQueryPredicate]?

    public init(type: ModelType?, clauses: [UserDetailQueryClause]?, predicates: [UserDetailQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class UserDetailsDatalakeAvailabilityTopicDataAvailabilityChangeNotification: Codable {



    /** Date and time before which data is guaranteed to be available in the datalake */
    public var dataAvailabilityDate: Date?

    public init(dataAvailabilityDate: Date?) {
        self.dataAvailabilityDate = dataAvailabilityDate
    }


}




public class UserExpands: Codable {

















    /** ACD routing status */
    public var routingStatus: RoutingStatus?
    /** Active presence */
    public var presence: UserPresence?
    /** Active 3rd party presence */
    public var integrationPresence: UserPresence?
    /** Summary of conversion statistics for conversation types. */
    public var conversationSummary: UserConversationSummary?
    /** Determine if out of office is enabled */
    public var outOfOffice: OutOfOffice?
    /** Current geolocation position */
    public var geolocation: Geolocation?
    /** Effective, default, and last station information */
    public var station: UserStations?
    /** Roles and permissions assigned to the user */
    public var authorization: UserAuthorization?

    public init(routingStatus: RoutingStatus?, presence: UserPresence?, integrationPresence: UserPresence?, conversationSummary: UserConversationSummary?, outOfOffice: OutOfOffice?, geolocation: Geolocation?, station: UserStations?, authorization: UserAuthorization?) {
        self.routingStatus = routingStatus
        self.presence = presence
        self.integrationPresence = integrationPresence
        self.conversationSummary = conversationSummary
        self.outOfOffice = outOfOffice
        self.geolocation = geolocation
        self.station = station
        self.authorization = authorization
    }


}




public class UserGreetingEventGreetingAudioFile: Codable {





    public var durationMilliseconds: Int?
    public var sizeBytes: Int?

    public init(durationMilliseconds: Int?, sizeBytes: Int?) {
        self.durationMilliseconds = durationMilliseconds
        self.sizeBytes = sizeBytes
    }


}




public class UserImage: Codable {





    /** Height and/or width of image. ex: 640x480 or x128 */
    public var resolution: String?
    public var imageUri: String?

    public init(resolution: String?, imageUri: String?) {
        self.resolution = resolution
        self.imageUri = imageUri
    }


}




public class UserListScheduleRequestBody: Codable {









    /** The user ids for which to fetch schedules */
    public var userIds: [String]?
    /** Beginning of the range of schedules to fetch, in ISO-8601 format */
    public var startDate: Date?
    /** End of the range of schedules to fetch, in ISO-8601 format */
    public var endDate: Date?
    /** Whether to load the full week's schedule (for the requested users) of any week overlapping the start/end date query parameters, defaults to false */
    public var loadFullWeeks: Bool?

    public init(userIds: [String]?, startDate: Date?, endDate: Date?, loadFullWeeks: Bool?) {
        self.userIds = userIds
        self.startDate = startDate
        self.endDate = endDate
        self.loadFullWeeks = loadFullWeeks
    }


}




public class UserMe: Codable {

















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }

























































































    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    public var chat: Chat?
    public var department: String?
    public var email: String?
    /** Auto populated from addresses. */
    public var primaryContactInfo: [Contact]?
    /** Email addresses and phone numbers for this user */
    public var addresses: [Contact]?
    /** The current state for this user. */
    public var state: State?
    public var title: String?
    public var username: String?
    public var manager: User?
    public var images: [UserImage]?
    /** Required when updating a user, this value should be the current version of the user.  The current version can be obtained with a GET on the user before doing a PATCH. */
    public var version: Int?
    public var certifications: [String]?
    public var biography: Biography?
    public var employerInfo: EmployerInfo?
    /** Preferred full name of the agent */
    public var preferredName: String?
    /** ACD routing status */
    public var routingStatus: RoutingStatus?
    /** Active presence */
    public var presence: UserPresence?
    /** Integration presence */
    public var integrationPresence: UserPresence?
    /** Summary of conversion statistics for conversation types. */
    public var conversationSummary: UserConversationSummary?
    /** Determine if out of office is enabled */
    public var outOfOffice: OutOfOffice?
    /** Current geolocation position */
    public var geolocation: Geolocation?
    /** Effective, default, and last station information */
    public var station: UserStations?
    /** Roles and permissions assigned to the user */
    public var authorization: UserAuthorization?
    /** Profile skills possessed by the user */
    public var profileSkills: [String]?
    /** The user placement at each site location. */
    public var locations: [Location]?
    /** The groups the user is a member of */
    public var groups: [Group]?
    /** The team the user is a member of */
    public var team: Team?
    /** Routing (ACD) skills possessed by the user */
    public var skills: [UserRoutingSkill]?
    /** Routing (ACD) languages possessed by the user */
    public var languages: [UserRoutingLanguage]?
    /** acd auto answer */
    public var acdAutoAnswer: Bool?
    /** preferred language by the user */
    public var languagePreference: String?
    public var lastTokenIssued: OAuthLastTokenIssued?
    /** The last time the user logged in using username and password. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateLastLogin: Date?
    /** The PureCloud system date time. */
    public var date: ServerDate?
    /** Geolocation settings for user's organization. */
    public var geolocationSettings: GeolocationSettings?
    /** Organization details for this user. */
    public var organization: Organization?
    /** The first 100 non-divisioned presence definitions for user's organization. */
    public var presenceDefinitions: [OrganizationPresence]?
    /** The presence definitions that the user has access to */
    public var divisionedPresenceDefinitions: [OrganizationPresenceDefinition]?
    /** The first 100 site locations for user's organization */
    public var locationDefinitions: [LocationDefinition]?
    /** The first 100 organization roles, with applicable permission policies, for user's organization. */
    public var orgAuthorization: [DomainOrganizationRole]?
    /** The first 50 favorited users. */
    public var favorites: [User]?
    /** The first 50 superiors of this user. */
    public var superiors: [User]?
    /** The first 50 direct reports to this user. */
    public var directReports: [User]?
    /** The first 50 superiors, direct reports, and siblings of this user. Mutually exclusive with superiors and direct reports expands. */
    public var adjacents: Adjacents?
    /** The first 50 routing skills for user's organizations */
    public var routingSkills: [RoutingSkill]?
    /** The field config for all entities types of user's organization */
    public var fieldConfigs: FieldConfigs?
    /** Information about the current token */
    public var token: TokenInfo?
    /** Organizations having this user as a trustee */
    public var trustors: [Trustor]?
    /** Products enabled in this organization */
    public var orgProducts: [DomainOrganizationProduct]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, chat: Chat?, department: String?, email: String?, primaryContactInfo: [Contact]?, addresses: [Contact]?, state: State?, title: String?, username: String?, manager: User?, images: [UserImage]?, version: Int?, certifications: [String]?, biography: Biography?, employerInfo: EmployerInfo?, preferredName: String?, routingStatus: RoutingStatus?, presence: UserPresence?, integrationPresence: UserPresence?, conversationSummary: UserConversationSummary?, outOfOffice: OutOfOffice?, geolocation: Geolocation?, station: UserStations?, authorization: UserAuthorization?, profileSkills: [String]?, locations: [Location]?, groups: [Group]?, team: Team?, skills: [UserRoutingSkill]?, languages: [UserRoutingLanguage]?, acdAutoAnswer: Bool?, languagePreference: String?, lastTokenIssued: OAuthLastTokenIssued?, dateLastLogin: Date?, date: ServerDate?, geolocationSettings: GeolocationSettings?, organization: Organization?, presenceDefinitions: [OrganizationPresence]?, divisionedPresenceDefinitions: [OrganizationPresenceDefinition]?, locationDefinitions: [LocationDefinition]?, orgAuthorization: [DomainOrganizationRole]?, favorites: [User]?, superiors: [User]?, directReports: [User]?, adjacents: Adjacents?, routingSkills: [RoutingSkill]?, fieldConfigs: FieldConfigs?, token: TokenInfo?, trustors: [Trustor]?, orgProducts: [DomainOrganizationProduct]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.chat = chat
        self.department = department
        self.email = email
        self.primaryContactInfo = primaryContactInfo
        self.addresses = addresses
        self.state = state
        self.title = title
        self.username = username
        self.manager = manager
        self.images = images
        self.version = version
        self.certifications = certifications
        self.biography = biography
        self.employerInfo = employerInfo
        self.preferredName = preferredName
        self.routingStatus = routingStatus
        self.presence = presence
        self.integrationPresence = integrationPresence
        self.conversationSummary = conversationSummary
        self.outOfOffice = outOfOffice
        self.geolocation = geolocation
        self.station = station
        self.authorization = authorization
        self.profileSkills = profileSkills
        self.locations = locations
        self.groups = groups
        self.team = team
        self.skills = skills
        self.languages = languages
        self.acdAutoAnswer = acdAutoAnswer
        self.languagePreference = languagePreference
        self.lastTokenIssued = lastTokenIssued
        self.dateLastLogin = dateLastLogin
        self.date = date
        self.geolocationSettings = geolocationSettings
        self.organization = organization
        self.presenceDefinitions = presenceDefinitions
        self.divisionedPresenceDefinitions = divisionedPresenceDefinitions
        self.locationDefinitions = locationDefinitions
        self.orgAuthorization = orgAuthorization
        self.favorites = favorites
        self.superiors = superiors
        self.directReports = directReports
        self.adjacents = adjacents
        self.routingSkills = routingSkills
        self.fieldConfigs = fieldConfigs
        self.token = token
        self.trustors = trustors
        self.orgProducts = orgProducts
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case chat
        case department
        case email
        case primaryContactInfo
        case addresses
        case state
        case title
        case username
        case manager
        case images
        case version
        case certifications
        case biography
        case employerInfo
        case preferredName
        case routingStatus
        case presence
        case integrationPresence
        case conversationSummary
        case outOfOffice
        case geolocation
        case station
        case authorization
        case profileSkills
        case locations
        case groups
        case team
        case skills
        case languages
        case acdAutoAnswer
        case languagePreference
        case lastTokenIssued
        case dateLastLogin
        case date
        case geolocationSettings
        case organization
        case presenceDefinitions
        case divisionedPresenceDefinitions
        case locationDefinitions
        case orgAuthorization
        case favorites
        case superiors
        case directReports
        case adjacents
        case routingSkills
        case fieldConfigs
        case token
        case trustors
        case orgProducts
        case selfUri
    }


}




public class UserObservationDataContainer: Codable {





    /** A mapping from dimension to value */
    public var group: [String:String]?
    public var data: [ObservationMetricData]?

    public init(group: [String:String]?, data: [ObservationMetricData]?) {
        self.group = group
        self.data = data
    }


}




public class UserObservationQuery: Codable {



    public enum Metrics: String, Codable { 
        case oactivequeues = "oActiveQueues"
        case omemberqueues = "oMemberQueues"
    }

    public enum DetailMetrics: String, Codable { 
        case oactivequeues = "oActiveQueues"
        case omemberqueues = "oMemberQueues"
    }

    /** Filter to return a subset of observations. Expresses boolean logical predicates as well as dimensional filters */
    public var filter: UserObservationQueryFilter?
    /** Behaves like a SQL SELECT clause. Only named metrics will be retrieved. */
    public var metrics: [Metrics]?
    /** Metrics for which to include additional detailed observations */
    public var detailMetrics: [DetailMetrics]?

    public init(filter: UserObservationQueryFilter?, metrics: [Metrics]?, detailMetrics: [DetailMetrics]?) {
        self.filter = filter
        self.metrics = metrics
        self.detailMetrics = detailMetrics
    }


}




public class UserObservationQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [UserObservationQueryPredicate]?

    public init(type: ModelType?, predicates: [UserObservationQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class UserProfileEntityListing: Codable {





















    public var entities: [UserProfile]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [UserProfile]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class UserReferenceWithName: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}



/** Represents an organization language assigned to a user. When assigning to a user specify the organization language id as the id. */

public class UserRoutingLanguage: Codable {







    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** A rating from 0.0 to 5.0 that indicates how fluent an agent is in a particular language. ACD interactions are routed to agents with higher proficiency ratings. */
    public var proficiency: Double?
    /** Activate or deactivate this routing language. */
    public var state: State?
    /** URI to the organization language used by this user language. */
    public var languageUri: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, proficiency: Double?, state: State?, languageUri: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.proficiency = proficiency
        self.state = state
        self.languageUri = languageUri
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case proficiency
        case state
        case languageUri
        case selfUri
    }


}




public class UserSchedule: Codable {











    /** The shifts that belong to this schedule */
    public var shifts: [UserScheduleShift]?
    /** Markers to indicate a full day time off request, relative to the management unit time zone */
    public var fullDayTimeOffMarkers: [UserScheduleFullDayTimeOffMarker]?
    /** If marked true for updating an existing user schedule, it will be deleted */
    public var delete: Bool?
    /** Version metadata for this schedule */
    public var metadata: WfmVersionedEntityMetadata?
    /** ID of the work plan associated with the user during schedule creation */
    public var workPlanId: String?

    public init(shifts: [UserScheduleShift]?, fullDayTimeOffMarkers: [UserScheduleFullDayTimeOffMarker]?, delete: Bool?, metadata: WfmVersionedEntityMetadata?, workPlanId: String?) {
        self.shifts = shifts
        self.fullDayTimeOffMarkers = fullDayTimeOffMarkers
        self.delete = delete
        self.metadata = metadata
        self.workPlanId = workPlanId
    }


}




public class UserScheduleActivity: Codable {















    /** The id for the activity code.  Look up a map of activity codes with the activities route */
    public var activityCodeId: String?
    /** Start time in UTC for this activity, in ISO-8601 format */
    public var startDate: Date?
    /** Length in minutes for this activity */
    public var lengthInMinutes: Int?
    /** Description for this activity */
    public var _description: String?
    /** Whether this activity is paid */
    public var countsAsPaidTime: Bool?
    /** Whether this activity spans a DST fallback */
    public var isDstFallback: Bool?
    /** Time off request id of this activity */
    public var timeOffRequestId: String?

    public init(activityCodeId: String?, startDate: Date?, lengthInMinutes: Int?, _description: String?, countsAsPaidTime: Bool?, isDstFallback: Bool?, timeOffRequestId: String?) {
        self.activityCodeId = activityCodeId
        self.startDate = startDate
        self.lengthInMinutes = lengthInMinutes
        self._description = _description
        self.countsAsPaidTime = countsAsPaidTime
        self.isDstFallback = isDstFallback
        self.timeOffRequestId = timeOffRequestId
    }

    public enum CodingKeys: String, CodingKey { 
        case activityCodeId
        case startDate
        case lengthInMinutes
        case _description = "description"
        case countsAsPaidTime
        case isDstFallback
        case timeOffRequestId
    }


}




public class UserScheduleAdherence: Codable {













    public enum ScheduledActivityCategory: String, Codable { 
        case onQueueWork = "OnQueueWork"
        case _break = "Break"
        case meal = "Meal"
        case meeting = "Meeting"
        case offQueueWork = "OffQueueWork"
        case timeOff = "TimeOff"
        case training = "Training"
        case unavailable = "Unavailable"
        case unscheduled = "Unscheduled"
    }



    public enum SystemPresence: String, Codable { 
        case available = "Available"
        case away = "Away"
        case busy = "Busy"
        case offline = "Offline"
        case idle = "Idle"
        case onQueue = "OnQueue"
        case meal = "Meal"
        case training = "Training"
        case meeting = "Meeting"
        case _break = "Break"
    }



    public enum RoutingStatus: String, Codable { 
        case offQueue = "OFF_QUEUE"
        case idle = "IDLE"
        case interacting = "INTERACTING"
        case notResponding = "NOT_RESPONDING"
        case communicating = "COMMUNICATING"
    }

    public enum ActualActivityCategory: String, Codable { 
        case onQueueWork = "OnQueueWork"
        case _break = "Break"
        case meal = "Meal"
        case meeting = "Meeting"
        case offQueueWork = "OffQueueWork"
        case timeOff = "TimeOff"
        case training = "Training"
        case unavailable = "Unavailable"
        case unscheduled = "Unscheduled"
    }



    public enum AdherenceState: String, Codable { 
        case inAdherence = "InAdherence"
        case outOfAdherence = "OutOfAdherence"
        case unscheduled = "Unscheduled"
        case unknown = "Unknown"
        case ignored = "Ignored"
        case explained = "Explained"
    }

    public enum Impact: String, Codable { 
        case positive = "Positive"
        case negative = "Negative"
        case neutral = "Neutral"
        case unknown = "Unknown"
    }















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The user for whom this status applies */
    public var user: UserReference?
    /** The business unit to which this user belongs */
    public var businessUnit: BusinessUnitReference?
    /** The management unit to which this user belongs */
    public var managementUnit: ManagementUnitReference?
    /** The team to which this user belongs */
    public var team: TeamReference?
    /** Activity for which the user is scheduled */
    public var scheduledActivityCategory: ScheduledActivityCategory?
    /** Activity code for which the user is currently scheduled */
    public var scheduledActivityCode: ActivityCodeReference?
    /** Actual underlying system presence value */
    public var systemPresence: SystemPresence?
    /** Organization Secondary Presence Id. */
    public var organizationSecondaryPresenceId: String?
    /** Actual underlying routing status, used to determine whether a user is actually in adherence when OnQueue */
    public var routingStatus: RoutingStatus?
    /** Activity in which the user is actually engaged */
    public var actualActivityCategory: ActualActivityCategory?
    /** Whether the user is marked OutOfOffice */
    public var isOutOfOffice: Bool?
    /** The user's current adherence state */
    public var adherenceState: AdherenceState?
    /** The impact of the user's current adherenceState */
    public var impact: Impact?
    /** Currently applicable explanation for the adherence state */
    public var adherenceExplanation: RealTimeAdherenceExplanation?
    /** Time when the user entered the current adherenceState in ISO-8601 format */
    public var timeOfAdherenceChange: Date?
    /** Time when presence was last updated. Used to calculate time in current status. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var presenceUpdateTime: Date?
    /** The list of queues to which this user is joined */
    public var activeQueues: [QueueReference]?
    /** Time when the list of active queues for this user was last updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var activeQueuesModifiedTime: Date?
    /** For notification purposes. Used to indicate that a user was removed from the management unit */
    public var removedFromManagementUnit: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, user: UserReference?, businessUnit: BusinessUnitReference?, managementUnit: ManagementUnitReference?, team: TeamReference?, scheduledActivityCategory: ScheduledActivityCategory?, scheduledActivityCode: ActivityCodeReference?, systemPresence: SystemPresence?, organizationSecondaryPresenceId: String?, routingStatus: RoutingStatus?, actualActivityCategory: ActualActivityCategory?, isOutOfOffice: Bool?, adherenceState: AdherenceState?, impact: Impact?, adherenceExplanation: RealTimeAdherenceExplanation?, timeOfAdherenceChange: Date?, presenceUpdateTime: Date?, activeQueues: [QueueReference]?, activeQueuesModifiedTime: Date?, removedFromManagementUnit: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.user = user
        self.businessUnit = businessUnit
        self.managementUnit = managementUnit
        self.team = team
        self.scheduledActivityCategory = scheduledActivityCategory
        self.scheduledActivityCode = scheduledActivityCode
        self.systemPresence = systemPresence
        self.organizationSecondaryPresenceId = organizationSecondaryPresenceId
        self.routingStatus = routingStatus
        self.actualActivityCategory = actualActivityCategory
        self.isOutOfOffice = isOutOfOffice
        self.adherenceState = adherenceState
        self.impact = impact
        self.adherenceExplanation = adherenceExplanation
        self.timeOfAdherenceChange = timeOfAdherenceChange
        self.presenceUpdateTime = presenceUpdateTime
        self.activeQueues = activeQueues
        self.activeQueuesModifiedTime = activeQueuesModifiedTime
        self.removedFromManagementUnit = removedFromManagementUnit
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case user
        case businessUnit
        case managementUnit
        case team
        case scheduledActivityCategory
        case scheduledActivityCode
        case systemPresence
        case organizationSecondaryPresenceId
        case routingStatus
        case actualActivityCategory
        case isOutOfOffice
        case adherenceState
        case impact
        case adherenceExplanation
        case timeOfAdherenceChange
        case presenceUpdateTime
        case activeQueues
        case activeQueuesModifiedTime
        case removedFromManagementUnit
        case selfUri
    }


}




public class UserScheduleAdherenceListing: Codable {





    public var entities: [UserScheduleAdherence]?
    /** The downloadUrl if the response is too large to send directly via http response */
    public var downloadUrl: String?

    public init(entities: [UserScheduleAdherence]?, downloadUrl: String?) {
        self.entities = entities
        self.downloadUrl = downloadUrl
    }


}




public class UserScheduleShift: Codable {















    /** The schedule to which this shift belongs */
    public var weekSchedule: WeekScheduleReference?
    /** ID of the schedule shift. This is only for the case of updating and deleting an existing shift */
    public var _id: String?
    /** Start time in UTC for this shift. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** Length of this shift in minutes */
    public var lengthInMinutes: Int?
    /** List of activities in this shift */
    public var activities: [UserScheduleActivity]?
    /** If marked true for updating this schedule shift, it will be deleted */
    public var delete: Bool?
    /** Whether the shift was set as manually edited */
    public var manuallyEdited: Bool?

    public init(weekSchedule: WeekScheduleReference?, _id: String?, startDate: Date?, lengthInMinutes: Int?, activities: [UserScheduleActivity]?, delete: Bool?, manuallyEdited: Bool?) {
        self.weekSchedule = weekSchedule
        self._id = _id
        self.startDate = startDate
        self.lengthInMinutes = lengthInMinutes
        self.activities = activities
        self.delete = delete
        self.manuallyEdited = manuallyEdited
    }

    public enum CodingKeys: String, CodingKey { 
        case weekSchedule
        case _id = "id"
        case startDate
        case lengthInMinutes
        case activities
        case delete
        case manuallyEdited
    }


}




public class UserSearchRequest: Codable {

    public enum SortOrder: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
        case score = "SCORE"
    }













    public enum IntegrationPresenceSource: String, Codable { 
        case microsoftTeams = "MicrosoftTeams"
        case zoomPhone = "ZoomPhone"
        case eightByEight = "EightByEight"
    }



    /** The sort order for results */
    public var sortOrder: SortOrder?
    /** The field in the resource that you want to sort the results by */
    public var sortBy: String?
    /** The number of results per page */
    public var pageSize: Int?
    /** The page of resources you want to retrieve */
    public var pageNumber: Int?
    /** Multi-value sort order, list of multiple sort values */
    public var sort: [SearchSort]?
    /** Provides more details about a specified resource */
    public var expand: [String]?
    public var query: [UserSearchCriteria]?
    /** Gets an integration presence for users instead of their defaults. This parameter will only be used when presence is provided as an \"expand\". When using this parameter the maximum number of users that can be returned is 100. */
    public var integrationPresenceSource: IntegrationPresenceSource?
    /** This property only applies to api/v2/user/search; when set to true add additional search criteria to filter users by: directory:user:view */
    public var enforcePermissions: Bool?

    public init(sortOrder: SortOrder?, sortBy: String?, pageSize: Int?, pageNumber: Int?, sort: [SearchSort]?, expand: [String]?, query: [UserSearchCriteria]?, integrationPresenceSource: IntegrationPresenceSource?, enforcePermissions: Bool?) {
        self.sortOrder = sortOrder
        self.sortBy = sortBy
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.sort = sort
        self.expand = expand
        self.query = query
        self.integrationPresenceSource = integrationPresenceSource
        self.enforcePermissions = enforcePermissions
    }


}




public class UserSkillEntityListing: Codable {





















    public var entities: [UserRoutingSkill]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [UserRoutingSkill]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class UserSkillGroupEntityListing: Codable {









    public var entities: [SkillGroup]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [SkillGroup]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class UserState: Codable {

    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }



    public enum StateChangeReason: String, Codable { 
        case voluntary = "Voluntary"
        case seasonal = "Seasonal"
        case leave = "Leave"
        case performance = "Performance"
        case conduct = "Conduct"
        case unknown = "Unknown"
    }



    /** User's current state. */
    public var state: State?
    /** Version of this user. */
    public var version: Int?
    /** Reason for a change in the user's state. */
    public var stateChangeReason: StateChangeReason?
    /** Date that the state was last changed. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var stateChangeDate: Date?

    public init(state: State?, version: Int?, stateChangeReason: StateChangeReason?, stateChangeDate: Date?) {
        self.state = state
        self.version = version
        self.stateChangeReason = stateChangeReason
        self.stateChangeDate = stateChangeDate
    }


}




public class UserStation: Codable {

















    /** A globally unique identifier for this station */
    public var _id: String?
    public var name: String?
    public var type: String?
    public var associatedUser: User?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var associatedDate: Date?
    public var defaultUser: User?
    /** Provider-specific info for this station, e.g. { \"edgeGroupId\": \"ffe7b15c-a9cc-4f4c-88f5-781327819a49\" } */
    public var providerInfo: [String:String]?
    /** The number of call appearances on the station. */
    public var webRtcCallAppearances: Int?

    public init(_id: String?, name: String?, type: String?, associatedUser: User?, associatedDate: Date?, defaultUser: User?, providerInfo: [String:String]?, webRtcCallAppearances: Int?) {
        self._id = _id
        self.name = name
        self.type = type
        self.associatedUser = associatedUser
        self.associatedDate = associatedDate
        self.defaultUser = defaultUser
        self.providerInfo = providerInfo
        self.webRtcCallAppearances = webRtcCallAppearances
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case type
        case associatedUser
        case associatedDate
        case defaultUser
        case providerInfo
        case webRtcCallAppearances
    }


}




public class UserStations: Codable {









    /** Current associated station for this user. */
    public var associatedStation: UserStation?
    /** The station where the user can be reached based on their default and associated station. */
    public var effectiveStation: UserStation?
    /** Default station to be used if not associated with a station. */
    public var defaultStation: UserStation?
    /** Last associated station for this user. */
    public var lastAssociatedStation: UserStation?

    public init(associatedStation: UserStation?, effectiveStation: UserStation?, defaultStation: UserStation?, lastAssociatedStation: UserStation?) {
        self.associatedStation = associatedStation
        self.effectiveStation = effectiveStation
        self.defaultStation = defaultStation
        self.lastAssociatedStation = lastAssociatedStation
    }


}




public class UserTimeOffRequestReference: Codable {







    /** The id of the time off request */
    public var _id: String?
    /** The ID of the user to whom the time off request applies */
    public var user: UserReference?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, user: UserReference?, selfUri: String?) {
        self._id = _id
        self.user = user
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case user
        case selfUri
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationButtonComponent: Codable {





    public var title: String?
    public var actions: V2ConversationMessageTypingEventForUserTopicConversationContentActions?

    public init(title: String?, actions: V2ConversationMessageTypingEventForUserTopicConversationContentActions?) {
        self.title = title
        self.actions = actions
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationEventCoBrowse: Codable {

    public enum ModelType: String, Codable { 
        case offering = "Offering"
        case offeringExpired = "OfferingExpired"
        case offeringAccepted = "OfferingAccepted"
        case offeringRejected = "OfferingRejected"
    }





    public var type: ModelType?
    public var sessionId: String?
    public var sessionJoinToken: String?

    public init(type: ModelType?, sessionId: String?, sessionJoinToken: String?) {
        self.type = type
        self.sessionId = sessionId
        self.sessionJoinToken = sessionJoinToken
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationMessageEvent: Codable {

    public enum EventType: String, Codable { 
        case coBrowse = "CoBrowse"
        case typing = "Typing"
    }





    public var eventType: EventType?
    public var coBrowse: V2ConversationMessageTypingEventForUserTopicConversationEventCoBrowse?
    public var typing: V2ConversationMessageTypingEventForUserTopicConversationEventTyping?

    public init(eventType: EventType?, coBrowse: V2ConversationMessageTypingEventForUserTopicConversationEventCoBrowse?, typing: V2ConversationMessageTypingEventForUserTopicConversationEventTyping?) {
        self.eventType = eventType
        self.coBrowse = coBrowse
        self.typing = typing
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationMessagingChannel: Codable {



    public enum Platform: String, Codable { 
        case twitter = "Twitter"
        case facebook = "Facebook"
        case instagram = "Instagram"
        case line = "Line"
        case whatsapp = "Whatsapp"
        case webMessaging = "WebMessaging"
        case _open = "Open"
        case sms = "Sms"
    }















    public var _id: String?
    public var platform: Platform?
    public var messageId: String?
    public var to: V2ConversationMessageTypingEventForUserTopicConversationMessagingToRecipient?
    public var from: V2ConversationMessageTypingEventForUserTopicConversationMessagingFromRecipient?
    public var time: Date?
    public var dateModified: Date?
    public var dateDeleted: Date?
    public var metadata: V2ConversationMessageTypingEventForUserTopicConversationMessagingChannelMetadata?

    public init(_id: String?, platform: Platform?, messageId: String?, to: V2ConversationMessageTypingEventForUserTopicConversationMessagingToRecipient?, from: V2ConversationMessageTypingEventForUserTopicConversationMessagingFromRecipient?, time: Date?, dateModified: Date?, dateDeleted: Date?, metadata: V2ConversationMessageTypingEventForUserTopicConversationMessagingChannelMetadata?) {
        self._id = _id
        self.platform = platform
        self.messageId = messageId
        self.to = to
        self.from = from
        self.time = time
        self.dateModified = dateModified
        self.dateDeleted = dateDeleted
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case platform
        case messageId
        case to
        case from
        case time
        case dateModified
        case dateDeleted
        case metadata
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationNotificationTemplateHeader: Codable {

    public enum ModelType: String, Codable { 
        case text = "Text"
        case media = "Media"
    }







    public var type: ModelType?
    public var text: String?
    public var media: V2ConversationMessageTypingEventForUserTopicConversationContentAttachment?
    public var parameters: [V2ConversationMessageTypingEventForUserTopicConversationNotificationTemplateParameter]?

    public init(type: ModelType?, text: String?, media: V2ConversationMessageTypingEventForUserTopicConversationContentAttachment?, parameters: [V2ConversationMessageTypingEventForUserTopicConversationNotificationTemplateParameter]?) {
        self.type = type
        self.text = text
        self.media = media
        self.parameters = parameters
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationContentAttachment: Codable {



    public enum MediaType: String, Codable { 
        case image = "Image"
        case video = "Video"
        case audio = "Audio"
        case file = "File"
        case link = "Link"
    }











    public var _id: String?
    public var mediaType: MediaType?
    public var url: String?
    public var mime: String?
    public var text: String?
    public var sha256: String?
    public var filename: String?

    public init(_id: String?, mediaType: MediaType?, url: String?, mime: String?, text: String?, sha256: String?, filename: String?) {
        self._id = _id
        self.mediaType = mediaType
        self.url = url
        self.mime = mime
        self.text = text
        self.sha256 = sha256
        self.filename = filename
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case mediaType
        case url
        case mime
        case text
        case sha256
        case filename
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationContentButtonResponse: Codable {

    public enum ModelType: String, Codable { 
        case button = "Button"
        case quickReply = "QuickReply"
    }





    public var type: ModelType?
    public var text: String?
    public var payload: String?

    public init(type: ModelType?, text: String?, payload: String?) {
        self.type = type
        self.text = text
        self.payload = payload
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationContentNotificationTemplate: Codable {











    public var _id: String?
    public var language: String?
    public var header: V2ConversationMessageTypingEventForWorkflowTopicConversationNotificationTemplateHeader?
    public var body: V2ConversationMessageTypingEventForWorkflowTopicConversationNotificationTemplateBody?
    public var footer: V2ConversationMessageTypingEventForWorkflowTopicConversationNotificationTemplateFooter?

    public init(_id: String?, language: String?, header: V2ConversationMessageTypingEventForWorkflowTopicConversationNotificationTemplateHeader?, body: V2ConversationMessageTypingEventForWorkflowTopicConversationNotificationTemplateBody?, footer: V2ConversationMessageTypingEventForWorkflowTopicConversationNotificationTemplateFooter?) {
        self._id = _id
        self.language = language
        self.header = header
        self.body = body
        self.footer = footer
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case language
        case header
        case body
        case footer
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationContentQuickReply: Codable {







    public enum Action: String, Codable { 
        case message = "Message"
    }

    public var text: String?
    public var payload: String?
    public var image: String?
    public var action: Action?

    public init(text: String?, payload: String?, image: String?, action: Action?) {
        self.text = text
        self.payload = payload
        self.image = image
        self.action = action
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationEventTyping: Codable {

    public enum ModelType: String, Codable { 
        case on = "On"
    }



    public var type: ModelType?
    public var duration: Int?

    public init(type: ModelType?, duration: Int?) {
        self.type = type
        self.duration = duration
    }


}




public class Verifier: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Indicates whether this verifier is enabled. */
    public var enabled: Bool?
    /** Indicates whether this is the default verifier. */
    public var _default: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, enabled: Bool?, _default: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.enabled = enabled
        self._default = _default
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case enabled
        case _default = "default"
        case selfUri
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationMessagingChannelMetadata: Codable {



    public var customAttributes: [String:String]?

    public init(customAttributes: [String:String]?) {
        self.customAttributes = customAttributes
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationNormalizedMessage: Codable {





    public enum ModelType: String, Codable { 
        case text = "Text"
        case structured = "Structured"
        case receipt = "Receipt"
        case event = "Event"
    }







    public enum Status: String, Codable { 
        case sent = "Sent"
        case delivered = "Delivered"
        case read = "Read"
        case failed = "Failed"
        case published = "Published"
        case removed = "Removed"
    }



    public enum OriginatingEntity: String, Codable { 
        case human = "Human"
        case bot = "Bot"
    }



    public enum Direction: String, Codable { 
        case inbound = "Inbound"
        case outbound = "Outbound"
    }



    public var _id: String?
    public var channel: V2ConversationMessageTypingEventForWorkflowTopicConversationMessagingChannel?
    public var type: ModelType?
    public var text: String?
    public var content: [V2ConversationMessageTypingEventForWorkflowTopicConversationMessageContent]?
    public var events: [V2ConversationMessageTypingEventForWorkflowTopicConversationMessageEvent]?
    public var status: Status?
    public var reasons: [V2ConversationMessageTypingEventForWorkflowTopicConversationReason]?
    public var originatingEntity: OriginatingEntity?
    public var isFinalReceipt: Bool?
    public var direction: Direction?
    public var metadata: [String:String]?

    public init(_id: String?, channel: V2ConversationMessageTypingEventForWorkflowTopicConversationMessagingChannel?, type: ModelType?, text: String?, content: [V2ConversationMessageTypingEventForWorkflowTopicConversationMessageContent]?, events: [V2ConversationMessageTypingEventForWorkflowTopicConversationMessageEvent]?, status: Status?, reasons: [V2ConversationMessageTypingEventForWorkflowTopicConversationReason]?, originatingEntity: OriginatingEntity?, isFinalReceipt: Bool?, direction: Direction?, metadata: [String:String]?) {
        self._id = _id
        self.channel = channel
        self.type = type
        self.text = text
        self.content = content
        self.events = events
        self.status = status
        self.reasons = reasons
        self.originatingEntity = originatingEntity
        self.isFinalReceipt = isFinalReceipt
        self.direction = direction
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case channel
        case type
        case text
        case content
        case events
        case status
        case reasons
        case originatingEntity
        case isFinalReceipt
        case direction
        case metadata
    }


}




public class V2MobiusAlertsTopicAlert: Codable {





























    public enum Action: String, Codable { 
        case unknown = "UNKNOWN"
        case create = "CREATE"
        case update = "UPDATE"
        case delete = "DELETE"
        case close = "CLOSE"
        case renotify = "RENOTIFY"
        case bulkDelete = "BULK_DELETE"
        case bulkUpdate = "BULK_UPDATE"
    }





    public var rule: V2MobiusAlertsTopicAlertRuleProperties?
    public var _id: UUID?
    public var userId: UUID?
    public var notifications: [V2MobiusAlertsTopicAlertNotification]?
    public var dateStart: Date?
    public var dateEnd: Date?
    public var conditions: V2MobiusAlertsTopicCondition?
    public var additionalProperties: [String:String]?
    public var active: Bool?
    public var unread: Bool?
    public var muted: Bool?
    public var snoozed: Bool?
    public var dateMutedUntil: Date?
    public var dateSnoozedUntil: Date?
    public var action: Action?
    public var alertSummary: V2MobiusAlertsTopicAlertSummary?
    public var sendExitingAlarmNotification: Bool?

    public init(rule: V2MobiusAlertsTopicAlertRuleProperties?, _id: UUID?, userId: UUID?, notifications: [V2MobiusAlertsTopicAlertNotification]?, dateStart: Date?, dateEnd: Date?, conditions: V2MobiusAlertsTopicCondition?, additionalProperties: [String:String]?, active: Bool?, unread: Bool?, muted: Bool?, snoozed: Bool?, dateMutedUntil: Date?, dateSnoozedUntil: Date?, action: Action?, alertSummary: V2MobiusAlertsTopicAlertSummary?, sendExitingAlarmNotification: Bool?) {
        self.rule = rule
        self._id = _id
        self.userId = userId
        self.notifications = notifications
        self.dateStart = dateStart
        self.dateEnd = dateEnd
        self.conditions = conditions
        self.additionalProperties = additionalProperties
        self.active = active
        self.unread = unread
        self.muted = muted
        self.snoozed = snoozed
        self.dateMutedUntil = dateMutedUntil
        self.dateSnoozedUntil = dateSnoozedUntil
        self.action = action
        self.alertSummary = alertSummary
        self.sendExitingAlarmNotification = sendExitingAlarmNotification
    }

    public enum CodingKeys: String, CodingKey { 
        case rule
        case _id = "id"
        case userId
        case notifications
        case dateStart
        case dateEnd
        case conditions
        case additionalProperties
        case active
        case unread
        case muted
        case snoozed
        case dateMutedUntil
        case dateSnoozedUntil
        case action
        case alertSummary
        case sendExitingAlarmNotification
    }


}




public class V2MobiusAlertsTopicAlertNotification: Codable {



    public enum NotificationTypes: String, Codable { 
        case device = "Device"
        case email = "Email"
        case sms = "Sms"
        case push = "Push"
        case unknown = "Unknown"
    }

    public var recipient: String?
    public var notificationTypes: [NotificationTypes]?

    public init(recipient: String?, notificationTypes: [NotificationTypes]?) {
        self.recipient = recipient
        self.notificationTypes = notificationTypes
    }


}




public class V2MobiusAlertsTopicAlertSummary: Codable {





    public enum MetricType: String, Codable { 
        case interval = "Interval"
        case instance = "Instance"
        case unknown = "Unknown"
    }





    public var entities: [V2MobiusAlertsTopicAlertSummaryEntity]?
    public var conversation: V2MobiusAlertsTopicAddressableEntityRef?
    public var metricType: MetricType?
    public var isTeamMemberRuleSummary: Bool?
    public var teamMemberRuleSummary: Bool?

    public init(entities: [V2MobiusAlertsTopicAlertSummaryEntity]?, conversation: V2MobiusAlertsTopicAddressableEntityRef?, metricType: MetricType?, isTeamMemberRuleSummary: Bool?, teamMemberRuleSummary: Bool?) {
        self.entities = entities
        self.conversation = conversation
        self.metricType = metricType
        self.isTeamMemberRuleSummary = isTeamMemberRuleSummary
        self.teamMemberRuleSummary = teamMemberRuleSummary
    }


}




public class V2MobiusRulesTopicCondition: Codable {





    public enum ModelType: String, Codable { 
        case and = "And"
        case or = "Or"
        case not = "Not"
        case unknown = "Unknown"
    }

    public var conditions: [V2MobiusRulesTopicCondition]?
    public var predicates: [V2MobiusRulesTopicConditionRulePredicate]?
    public var type: ModelType?

    public init(conditions: [V2MobiusRulesTopicCondition]?, predicates: [V2MobiusRulesTopicConditionRulePredicate]?, type: ModelType?) {
        self.conditions = conditions
        self.predicates = predicates
        self.type = type
    }


}




public class ValidateAssignUsers: Codable {



    /** List of user ids to assign to a performance profile */
    public var membersToAssign: [String]?

    public init(membersToAssign: [String]?) {
        self.membersToAssign = membersToAssign
    }


}




public class ValidateWorkPlanMessages: Codable {





    /** Messages for work plan violating some rules such as no shifts in a work plan */
    public var violationMessages: [WorkPlanConfigurationViolationMessage]?
    /** This field is not null when there is a set of work plan constraints that conflict thus agent schedules cannot be generated */
    public var constraintConflictMessage: ConstraintConflictMessage?

    public init(violationMessages: [WorkPlanConfigurationViolationMessage]?, constraintConflictMessage: ConstraintConflictMessage?) {
        self.violationMessages = violationMessages
        self.constraintConflictMessage = constraintConflictMessage
    }


}




public class ValueWrapperDate: Codable {



    /** The value for the associated field. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var value: Date?

    public init(value: Date?) {
        self.value = value
    }


}




public class Video: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }













    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }





















    /** The connection state of this communication. */
    public var state: State?
    /** The initial connection state of this communication. */
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The room id context (xmpp jid) for the conference session. */
    public var context: String?
    /** Indicates whether this participant has muted their outgoing audio. */
    public var audioMuted: Bool?
    /** Indicates whether this participant has muted/paused their outgoing video. */
    public var videoMuted: Bool?
    /** Indicates whether this participant is sharing their screen to the session. */
    public var sharingScreen: Bool?
    /** The number of peer participants from the perspective of the participant in the conference. */
    public var peerCount: Int?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAlertingTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var disconnectedTime: Date?
    /** The source provider for the video. */
    public var provider: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** List of media stream ids */
    public var msids: [String]?
    /** Address and name data for a call endpoint. */
    public var _self: Address?
    /** Call wrap up or disposition data. */
    public var wrapup: Wrapup?
    /** After-call work for the communication. */
    public var afterCallWork: AfterCallWork?
    /** Indicates if after-call work is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?

    public init(state: State?, initialState: InitialState?, _id: String?, context: String?, audioMuted: Bool?, videoMuted: Bool?, sharingScreen: Bool?, peerCount: Int?, disconnectType: DisconnectType?, startAlertingTime: Date?, connectedTime: Date?, disconnectedTime: Date?, provider: String?, peerId: String?, msids: [String]?, _self: Address?, wrapup: Wrapup?, afterCallWork: AfterCallWork?, afterCallWorkRequired: Bool?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.context = context
        self.audioMuted = audioMuted
        self.videoMuted = videoMuted
        self.sharingScreen = sharingScreen
        self.peerCount = peerCount
        self.disconnectType = disconnectType
        self.startAlertingTime = startAlertingTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.provider = provider
        self.peerId = peerId
        self.msids = msids
        self._self = _self
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case context
        case audioMuted
        case videoMuted
        case sharingScreen
        case peerCount
        case disconnectType
        case startAlertingTime
        case connectedTime
        case disconnectedTime
        case provider
        case peerId
        case msids
        case _self = "self"
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
    }


}




public class VideoConferenceUpdateTopicParticipantInfo: Codable {





    public var activeParticipantCount: Int?
    public var version: Int?

    public init(activeParticipantCount: Int?, version: Int?) {
        self.activeParticipantCount = activeParticipantCount
        self.version = version
    }


}




public class VoicemailMailboxInfo: Codable {













    /** The total number of bytes for all voicemail message audio recordings */
    public var usageSizeBytes: Int64?
    /** The total number of voicemail messages */
    public var totalCount: Int?
    /** The total number of voicemail messages marked as unread */
    public var unreadCount: Int?
    /** The total number of voicemail messages marked as deleted */
    public var deletedCount: Int?
    /** The date of the oldest voicemail message. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    /** The date of the most recent voicemail message. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?

    public init(usageSizeBytes: Int64?, totalCount: Int?, unreadCount: Int?, deletedCount: Int?, createdDate: Date?, modifiedDate: Date?) {
        self.usageSizeBytes = usageSizeBytes
        self.totalCount = totalCount
        self.unreadCount = unreadCount
        self.deletedCount = deletedCount
        self.createdDate = createdDate
        self.modifiedDate = modifiedDate
    }


}




public class VoicemailSearchCriteria: Codable {









    public enum Operator: String, Codable { 
        case and = "AND"
        case or = "OR"
        case not = "NOT"
    }







    public enum ModelType: String, Codable { 
        case exact = "EXACT"
        case startsWith = "STARTS_WITH"
        case contains = "CONTAINS"
        case regex = "REGEX"
        case term = "TERM"
        case terms = "TERMS"
        case requiredFields = "REQUIRED_FIELDS"
        case matchAll = "MATCH_ALL"
    }

    /** The end value of the range. This field is used for range search types. */
    public var endValue: String?
    /** A list of values for the search to match against */
    public var values: [String]?
    /** The start value of the range. This field is used for range search types. */
    public var startValue: String?
    /** A value for the search to match against */
    public var value: String?
    /** How to apply this search criteria against other criteria */
    public var _operator: Operator?
    /** Groups multiple conditions */
    public var group: [VoicemailSearchCriteria]?
    /** Set date format for criteria values when using date range search type.  Supports Java date format syntax, example yyyy-MM-dd'T'HH:mm:ss.SSSX. */
    public var dateFormat: String?
    /** Field names to search against */
    public var fields: [String]?
    /** Search Type */
    public var type: ModelType?

    public init(endValue: String?, values: [String]?, startValue: String?, value: String?, _operator: Operator?, group: [VoicemailSearchCriteria]?, dateFormat: String?, fields: [String]?, type: ModelType?) {
        self.endValue = endValue
        self.values = values
        self.startValue = startValue
        self.value = value
        self._operator = _operator
        self.group = group
        self.dateFormat = dateFormat
        self.fields = fields
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case endValue
        case values
        case startValue
        case value
        case _operator = "operator"
        case group
        case dateFormat
        case fields
        case type
    }


}




public class VoicemailStartDetailEventTopicVoicemailStartEvent: Codable {









    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
    }



    public enum Direction: String, Codable { 
        case unknown = "UNKNOWN"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }















    public var eventTime: Int?
    public var conversationId: String?
    public var participantId: String?
    public var sessionId: String?
    public var mediaType: MediaType?
    public var provider: String?
    public var direction: Direction?
    public var ani: String?
    public var dnis: String?
    public var userId: String?
    public var queueId: String?
    public var divisionId: String?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?

    public init(eventTime: Int?, conversationId: String?, participantId: String?, sessionId: String?, mediaType: MediaType?, provider: String?, direction: Direction?, ani: String?, dnis: String?, userId: String?, queueId: String?, divisionId: String?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.sessionId = sessionId
        self.mediaType = mediaType
        self.provider = provider
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.userId = userId
        self.queueId = queueId
        self.divisionId = divisionId
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
    }


}




public class WebChatConfig: Codable {

    public enum WebChatSkin: String, Codable { 
        case basic = "basic"
        case modernCaretSkin = "modern-caret-skin"
    }

    /** css class to be applied to the web chat widget. */
    public var webChatSkin: WebChatSkin?

    public init(webChatSkin: WebChatSkin?) {
        self.webChatSkin = webChatSkin
    }


}




public class WebChatMessageEntityList: Codable {











    public var pageSize: Int?
    public var entities: [WebChatMessage]?
    public var previousPage: String?
    public var next: String?
    public var selfUri: String?

    public init(pageSize: Int?, entities: [WebChatMessage]?, previousPage: String?, next: String?, selfUri: String?) {
        self.pageSize = pageSize
        self.entities = entities
        self.previousPage = previousPage
        self.next = next
        self.selfUri = selfUri
    }


}



/** Details about a Web Deployment */

public class WebDeployment: Codable {























    public enum Status: String, Codable { 
        case pending = "Pending"
        case active = "Active"
        case inactive = "Inactive"
        case error = "Error"
        case deleting = "Deleting"
    }





    /** The deployment ID */
    public var _id: String?
    /** The deployment name */
    public var name: String?
    /** The description of the config */
    public var _description: String?
    /** Property indicates whether all domains are allowed or not. allowedDomains must be empty when this is set as true. */
    public var allowAllDomains: Bool?
    /** The list of domains that are approved to use this deployment; the list will be added to CORS headers for ease of web use. */
    public var allowedDomains: [String]?
    /** The supported content profile for a deployment */
    public var supportedContent: SupportedContentReference?
    /** Javascript snippet used to load the config */
    public var snippet: String?
    /** The date the deployment was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date the deployment was most recently modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** A reference to the user who most recently modified the deployment */
    public var lastModifiedUser: AddressableEntityRef?
    /** A reference to the inboundshortmessage flow used by this deployment */
    public var flow: DomainEntityRef?
    /** The current status of the deployment */
    public var status: Status?
    /** The config version this deployment uses */
    public var configuration: WebDeploymentConfigurationVersionEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, allowAllDomains: Bool?, allowedDomains: [String]?, supportedContent: SupportedContentReference?, snippet: String?, dateCreated: Date?, dateModified: Date?, lastModifiedUser: AddressableEntityRef?, flow: DomainEntityRef?, status: Status?, configuration: WebDeploymentConfigurationVersionEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.allowAllDomains = allowAllDomains
        self.allowedDomains = allowedDomains
        self.supportedContent = supportedContent
        self.snippet = snippet
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.lastModifiedUser = lastModifiedUser
        self.flow = flow
        self.status = status
        self.configuration = configuration
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case allowAllDomains
        case allowedDomains
        case supportedContent
        case snippet
        case dateCreated
        case dateModified
        case lastModifiedUser
        case flow
        case status
        case configuration
        case selfUri
    }


}



/** Details about the configuration version of a Web Deployment */

public class WebDeploymentConfigurationVersion: Codable {









































    public enum Status: String, Codable { 
        case pending = "Pending"
        case active = "Active"
        case inactive = "Inactive"
        case error = "Error"
        case deleting = "Deleting"
    }



    /** The configuration version ID */
    public var _id: String?
    /** The configuration version name */
    public var name: String?
    /** The version of the configuration */
    public var version: String?
    /** Headless Mode Support which Controls UI components. When enabled, native UI components will be disabled and allows for custom-built UI. */
    public var headlessMode: WebDeploymentHeadlessMode?
    /** The description of the configuration */
    public var _description: String?
    /** A list of languages supported on the configuration required if the messenger is enabled */
    public var languages: [String]?
    /** The default language to use for the configuration required if the messenger is enabled */
    public var defaultLanguage: String?
    /** The localization settings for homescreen app */
    public var customI18nLabels: [CustomI18nLabels]?
    /** The settings for messenger */
    public var messenger: MessengerSettings?
    /** The settings for position */
    public var position: PositionSettings?
    /** The settings for knowledge portal (previously support center) */
    public var supportCenter: SupportCenterSettings?
    /** The settings for cobrowse */
    public var cobrowse: CobrowseSettings?
    /** The settings for journey events */
    public var journeyEvents: JourneyEventsSettings?
    /** The settings for authenticated deployments */
    public var authenticationSettings: AuthenticationSettings?
    /** The date the configuration version was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date the configuration version was most recently modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The date the configuration version was most recently published. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var datePublished: Date?
    /** A reference to the user who most recently modified the configuration version */
    public var lastModifiedUser: AddressableEntityRef?
    /** A reference to the user who created the configuration version */
    public var createdUser: AddressableEntityRef?
    /** A reference to the user who published the configuration version */
    public var publishedUser: AddressableEntityRef?
    /** The current status of the configuration version */
    public var status: Status?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, version: String?, headlessMode: WebDeploymentHeadlessMode?, _description: String?, languages: [String]?, defaultLanguage: String?, customI18nLabels: [CustomI18nLabels]?, messenger: MessengerSettings?, position: PositionSettings?, supportCenter: SupportCenterSettings?, cobrowse: CobrowseSettings?, journeyEvents: JourneyEventsSettings?, authenticationSettings: AuthenticationSettings?, dateCreated: Date?, dateModified: Date?, datePublished: Date?, lastModifiedUser: AddressableEntityRef?, createdUser: AddressableEntityRef?, publishedUser: AddressableEntityRef?, status: Status?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.version = version
        self.headlessMode = headlessMode
        self._description = _description
        self.languages = languages
        self.defaultLanguage = defaultLanguage
        self.customI18nLabels = customI18nLabels
        self.messenger = messenger
        self.position = position
        self.supportCenter = supportCenter
        self.cobrowse = cobrowse
        self.journeyEvents = journeyEvents
        self.authenticationSettings = authenticationSettings
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.datePublished = datePublished
        self.lastModifiedUser = lastModifiedUser
        self.createdUser = createdUser
        self.publishedUser = publishedUser
        self.status = status
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case version
        case headlessMode
        case _description = "description"
        case languages
        case defaultLanguage
        case customI18nLabels
        case messenger
        case position
        case supportCenter
        case cobrowse
        case journeyEvents
        case authenticationSettings
        case dateCreated
        case dateModified
        case datePublished
        case lastModifiedUser
        case createdUser
        case publishedUser
        case status
        case selfUri
    }


}




public class WebDeploymentsAuthorizationResponse: Codable {





    /** Refresh token used to issue a new JWT. */
    public var refreshToken: String?
    public var jwt: String?

    public init(refreshToken: String?, jwt: String?) {
        self.refreshToken = refreshToken
        self.jwt = jwt
    }


}




public class WebDeploymentsOAuthRequestParameters: Codable {













    /** The authorization code to be sent to the authentication server during the token request.  Refer to https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest */
    public var code: String?
    /** Redirect URI sent in the \"Authentication Request\"Refer to https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest */
    public var redirectUri: String?
    /** Required if provided in the \"Authentication Request\". Otherwise should be empty.String value used to associate a Client session with an ID Token, and to mitigate replay attacks. The value is passed through unmodified from the Authentication Request to the ID Token. Refer to https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest */
    public var nonce: String?
    /** Required if provided in the  \"Authentication Request\". Otherwise should be empty.Specifies the allowable elapsed time in seconds since the last time the End-User was actively authenticated.Refer to https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest */
    public var maxAge: Int?
    /** Required if authorizing using Proof Key for Code Exchange (PKCE). Otherwise should be empty.Random URL-safe string with a minimum length of 43 characters generated at start of authorization flow to mitigate the threat of having the authorization code intercepted. Refer to https://datatracker.ietf.org/doc/html/rfc7636 */
    public var codeVerifier: String?
    /** Optional parameter. Set it if authorization server discovery metadata authorization_response_iss_parameter_supported is enabled. Refer to https://datatracker.ietf.org/doc/html/rfc9207 */
    public var iss: String?

    public init(code: String?, redirectUri: String?, nonce: String?, maxAge: Int?, codeVerifier: String?, iss: String?) {
        self.code = code
        self.redirectUri = redirectUri
        self.nonce = nonce
        self.maxAge = maxAge
        self.codeVerifier = codeVerifier
        self.iss = iss
    }


}



/** Message content element. */

public class WebMessagingContent: Codable {

    public enum ContentType: String, Codable { 
        case attachment = "Attachment"
        case quickReply = "QuickReply"
        case buttonResponse = "ButtonResponse"
        case genericTemplate = "GenericTemplate"
        case card = "Card"
        case carousel = "Carousel"
    }













    /** Type of this content element. If contentType = \"Attachment\" only one item is allowed. */
    public var contentType: ContentType?
    /** Attachment content. */
    public var attachment: WebMessagingAttachment?
    /** Quick reply content. */
    public var quickReply: WebMessagingQuickReply?
    /** Button response content. */
    public var buttonResponse: WebMessagingButtonResponse?
    /** Generic content (Deprecated). */
    public var generic: WebMessagingGeneric?
    /** Card content */
    public var card: ContentCard?
    /** Carousel content */
    public var carousel: ContentCarousel?

    public init(contentType: ContentType?, attachment: WebMessagingAttachment?, quickReply: WebMessagingQuickReply?, buttonResponse: WebMessagingButtonResponse?, generic: WebMessagingGeneric?, card: ContentCard?, carousel: ContentCarousel?) {
        self.contentType = contentType
        self.attachment = attachment
        self.quickReply = quickReply
        self.buttonResponse = buttonResponse
        self.generic = generic
        self.card = card
        self.carousel = carousel
    }


}



/** Generic content object. (Deprecated */

public class WebMessagingGeneric: Codable {











    /** Text to show in the title. */
    public var title: String?
    /** Text to show in the description. */
    public var _description: String?
    /** URL of an image. */
    public var image: String?
    /** Actions to be taken. */
    public var actions: ContentActions?
    /** An array of component objects. */
    public var components: [ButtonComponent]?

    public init(title: String?, _description: String?, image: String?, actions: ContentActions?, components: [ButtonComponent]?) {
        self.title = title
        self._description = _description
        self.image = image
        self.actions = actions
        self.components = components
    }

    public enum CodingKeys: String, CodingKey { 
        case title
        case _description = "description"
        case image
        case actions
        case components
    }


}



/** Information about the recipient the message is sent to or received from. */

public class WebMessagingRecipient: Codable {











    /** First name of the recipient. */
    public var firstName: String?
    /** Last name of the recipient. */
    public var lastName: String?
    /** Nickname or display name of the recipient. */
    public var nickname: String?
    /** URL of an image that represents the recipient. */
    public var image: String?
    /** List of recipient additional identifiers */
    public var additionalIds: [RecipientAdditionalIdentifier]?

    public init(firstName: String?, lastName: String?, nickname: String?, image: String?, additionalIds: [RecipientAdditionalIdentifier]?) {
        self.firstName = firstName
        self.lastName = lastName
        self.nickname = nickname
        self.image = image
        self.additionalIds = additionalIds
    }


}




public class WeekScheduleListResponse: Codable {



    public var entities: [WeekScheduleListItemResponse]?

    public init(entities: [WeekScheduleListItemResponse]?) {
        self.entities = entities
    }


}




public class WeekShiftTradeMatchesSummaryResponse: Codable {





    /** The schedule week date in yyyy-MM-dd format. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekDate: Date?
    /** The number of trades in the Matched state for the given week */
    public var count: Int?

    public init(weekDate: Date?, count: Int?) {
        self.weekDate = weekDate
        self.count = count
    }


}




public class WemCoachingUserNotificationTopicCoachingAppointmentReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmAdherenceExplanationJobCompleteTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmAgent: Codable {























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The user associated with this data */
    public var user: UserReference?
    /** The work plan associated with this agent, if applicable */
    public var workPlan: WorkPlanReference?
    /** The work plan rotation associated with this agent, if applicable */
    public var workPlanRotation: WorkPlanRotationReference?
    /** Whether the agent accepts direct shift trade requests */
    public var acceptDirectShiftTrades: Bool?
    /** List of queues to which this agent is capable of handling */
    public var queues: [QueueReference]?
    /** The list of languages this agent is capable of handling */
    public var languages: [LanguageReference]?
    /** The list of skills this agent is capable of handling */
    public var skills: [RoutingSkillReference]?
    /** Whether the agent can be included in schedule generation */
    public var schedulable: Bool?
    /** Metadata for this agent */
    public var metadata: WfmVersionedEntityMetadata?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, user: UserReference?, workPlan: WorkPlanReference?, workPlanRotation: WorkPlanRotationReference?, acceptDirectShiftTrades: Bool?, queues: [QueueReference]?, languages: [LanguageReference]?, skills: [RoutingSkillReference]?, schedulable: Bool?, metadata: WfmVersionedEntityMetadata?, selfUri: String?) {
        self._id = _id
        self.user = user
        self.workPlan = workPlan
        self.workPlanRotation = workPlanRotation
        self.acceptDirectShiftTrades = acceptDirectShiftTrades
        self.queues = queues
        self.languages = languages
        self.skills = skills
        self.schedulable = schedulable
        self.metadata = metadata
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case user
        case workPlan
        case workPlanRotation
        case acceptDirectShiftTrades
        case queues
        case languages
        case skills
        case schedulable
        case metadata
        case selfUri
    }


}




public class WfmAgentAdherenceExplanationChangedAgentTopicAdherenceExplanationChangedNotification: Codable {









    public enum ModelType: String, Codable { 
        case late = "Late"
    }

    public enum Status: String, Codable { 
        case pending = "Pending"
        case approved = "Approved"
        case denied = "Denied"
    }











    public var _id: String?
    public var agent: WfmAgentAdherenceExplanationChangedAgentTopicUserReference?
    public var managementUnit: WfmAgentAdherenceExplanationChangedAgentTopicManagementUnit?
    public var businessUnit: WfmAgentAdherenceExplanationChangedAgentTopicBusinessUnit?
    public var type: ModelType?
    public var status: Status?
    public var startDate: Date?
    public var lengthMinutes: Int?
    public var notes: String?
    public var reviewedBy: WfmAgentAdherenceExplanationChangedAgentTopicUserReference?
    public var reviewedDate: Date?

    public init(_id: String?, agent: WfmAgentAdherenceExplanationChangedAgentTopicUserReference?, managementUnit: WfmAgentAdherenceExplanationChangedAgentTopicManagementUnit?, businessUnit: WfmAgentAdherenceExplanationChangedAgentTopicBusinessUnit?, type: ModelType?, status: Status?, startDate: Date?, lengthMinutes: Int?, notes: String?, reviewedBy: WfmAgentAdherenceExplanationChangedAgentTopicUserReference?, reviewedDate: Date?) {
        self._id = _id
        self.agent = agent
        self.managementUnit = managementUnit
        self.businessUnit = businessUnit
        self.type = type
        self.status = status
        self.startDate = startDate
        self.lengthMinutes = lengthMinutes
        self.notes = notes
        self.reviewedBy = reviewedBy
        self.reviewedDate = reviewedDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case agent
        case managementUnit
        case businessUnit
        case type
        case status
        case startDate
        case lengthMinutes
        case notes
        case reviewedBy
        case reviewedDate
    }


}




public class WfmAgentAdherenceExplanationChangedAgentTopicManagementUnit: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmAgentAdherenceExplanationChangedBusinessUnitTopicAdherenceExplanationChangedNotification: Codable {









    public enum ModelType: String, Codable { 
        case late = "Late"
    }

    public enum Status: String, Codable { 
        case pending = "Pending"
        case approved = "Approved"
        case denied = "Denied"
    }











    public var _id: String?
    public var agent: WfmAgentAdherenceExplanationChangedBusinessUnitTopicUserReference?
    public var managementUnit: WfmAgentAdherenceExplanationChangedBusinessUnitTopicManagementUnit?
    public var businessUnit: WfmAgentAdherenceExplanationChangedBusinessUnitTopicBusinessUnit?
    public var type: ModelType?
    public var status: Status?
    public var startDate: Date?
    public var lengthMinutes: Int?
    public var notes: String?
    public var reviewedBy: WfmAgentAdherenceExplanationChangedBusinessUnitTopicUserReference?
    public var reviewedDate: Date?

    public init(_id: String?, agent: WfmAgentAdherenceExplanationChangedBusinessUnitTopicUserReference?, managementUnit: WfmAgentAdherenceExplanationChangedBusinessUnitTopicManagementUnit?, businessUnit: WfmAgentAdherenceExplanationChangedBusinessUnitTopicBusinessUnit?, type: ModelType?, status: Status?, startDate: Date?, lengthMinutes: Int?, notes: String?, reviewedBy: WfmAgentAdherenceExplanationChangedBusinessUnitTopicUserReference?, reviewedDate: Date?) {
        self._id = _id
        self.agent = agent
        self.managementUnit = managementUnit
        self.businessUnit = businessUnit
        self.type = type
        self.status = status
        self.startDate = startDate
        self.lengthMinutes = lengthMinutes
        self.notes = notes
        self.reviewedBy = reviewedBy
        self.reviewedDate = reviewedDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case agent
        case managementUnit
        case businessUnit
        case type
        case status
        case startDate
        case lengthMinutes
        case notes
        case reviewedBy
        case reviewedDate
    }


}




public class WfmAgentAdherenceExplanationChangedBusinessUnitTopicManagementUnit: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmBuIntradayDataUpdateTopicBuIntradayDataGroup: Codable {

    public enum MediaType: String, Codable { 
        case voice = "Voice"
        case chat = "Chat"
        case email = "Email"
        case callback = "Callback"
        case message = "Message"
    }













    public var mediaType: MediaType?
    public var forecastDataSummary: WfmBuIntradayDataUpdateTopicBuIntradayForecastData?
    public var forecastDataPerInterval: [WfmBuIntradayDataUpdateTopicBuIntradayForecastData]?
    public var scheduleDataSummary: WfmBuIntradayDataUpdateTopicBuIntradayScheduleData?
    public var scheduleDataPerInterval: [WfmBuIntradayDataUpdateTopicBuIntradayScheduleData]?
    public var performancePredictionDataSummary: WfmBuIntradayDataUpdateTopicIntradayPerformancePredictionData?
    public var performancePredictionDataPerInterval: [WfmBuIntradayDataUpdateTopicIntradayPerformancePredictionData]?

    public init(mediaType: MediaType?, forecastDataSummary: WfmBuIntradayDataUpdateTopicBuIntradayForecastData?, forecastDataPerInterval: [WfmBuIntradayDataUpdateTopicBuIntradayForecastData]?, scheduleDataSummary: WfmBuIntradayDataUpdateTopicBuIntradayScheduleData?, scheduleDataPerInterval: [WfmBuIntradayDataUpdateTopicBuIntradayScheduleData]?, performancePredictionDataSummary: WfmBuIntradayDataUpdateTopicIntradayPerformancePredictionData?, performancePredictionDataPerInterval: [WfmBuIntradayDataUpdateTopicIntradayPerformancePredictionData]?) {
        self.mediaType = mediaType
        self.forecastDataSummary = forecastDataSummary
        self.forecastDataPerInterval = forecastDataPerInterval
        self.scheduleDataSummary = scheduleDataSummary
        self.scheduleDataPerInterval = scheduleDataPerInterval
        self.performancePredictionDataSummary = performancePredictionDataSummary
        self.performancePredictionDataPerInterval = performancePredictionDataPerInterval
    }


}




public class WfmBuScheduleTopicBuManagementUnitScheduleSummary: Codable {











    public var managementUnit: WfmBuScheduleTopicManagementUnit?
    public var startDate: Date?
    public var endDate: Date?
    public var agents: [WfmBuScheduleTopicUserReference]?
    public var agentCount: Int?

    public init(managementUnit: WfmBuScheduleTopicManagementUnit?, startDate: Date?, endDate: Date?, agents: [WfmBuScheduleTopicUserReference]?, agentCount: Int?) {
        self.managementUnit = managementUnit
        self.startDate = startDate
        self.endDate = endDate
        self.agents = agents
        self.agentCount = agentCount
    }


}




public class WfmBuScheduleTopicBuShortTermForecastReference: Codable {







    public var _id: String?
    public var weekDate: String?
    public var _description: String?

    public init(_id: String?, weekDate: String?, _description: String?) {
        self._id = _id
        self.weekDate = weekDate
        self._description = _description
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case _description = "description"
    }


}




public class WfmBuShortTermForecastCopyCompleteTopicForecastSourceDayPointer: Codable {

    public enum DayOfWeek: String, Codable { 
        case sunday = "Sunday"
        case monday = "Monday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
        case thursday = "Thursday"
        case friday = "Friday"
        case saturday = "Saturday"
        case eighthDay = "EighthDay"
    }









    public var dayOfWeek: DayOfWeek?
    public var weight: Int?
    public var date: String?
    public var fileName: String?
    public var dataKey: String?

    public init(dayOfWeek: DayOfWeek?, weight: Int?, date: String?, fileName: String?, dataKey: String?) {
        self.dayOfWeek = dayOfWeek
        self.weight = weight
        self.date = date
        self.fileName = fileName
        self.dataKey = dataKey
    }


}




public class WfmBuShortTermForecastCopyCompleteTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmBuShortTermForecastImportCompleteTopicBuShortTermForecast: Codable {





    public enum CreationMethod: String, Codable { 
        case _import = "Import"
        case importedHistoricalWeightedAverage = "ImportedHistoricalWeightedAverage"
        case historicalWeightedAverage = "HistoricalWeightedAverage"
        case advanced = "Advanced"
    }





















    public var _id: String?
    public var weekDate: String?
    public var creationMethod: CreationMethod?
    public var _description: String?
    public var legacy: Bool?
    public var referenceStartDate: Date?
    public var sourceDays: [WfmBuShortTermForecastImportCompleteTopicForecastSourceDayPointer]?
    public var modifications: [WfmBuShortTermForecastImportCompleteTopicBuForecastModification]?
    public var timeZone: String?
    public var planningGroupsVersion: Int?
    public var weekCount: Int?
    public var metadata: WfmBuShortTermForecastImportCompleteTopicWfmVersionedEntityMetadata?
    public var canUseForScheduling: Bool?

    public init(_id: String?, weekDate: String?, creationMethod: CreationMethod?, _description: String?, legacy: Bool?, referenceStartDate: Date?, sourceDays: [WfmBuShortTermForecastImportCompleteTopicForecastSourceDayPointer]?, modifications: [WfmBuShortTermForecastImportCompleteTopicBuForecastModification]?, timeZone: String?, planningGroupsVersion: Int?, weekCount: Int?, metadata: WfmBuShortTermForecastImportCompleteTopicWfmVersionedEntityMetadata?, canUseForScheduling: Bool?) {
        self._id = _id
        self.weekDate = weekDate
        self.creationMethod = creationMethod
        self._description = _description
        self.legacy = legacy
        self.referenceStartDate = referenceStartDate
        self.sourceDays = sourceDays
        self.modifications = modifications
        self.timeZone = timeZone
        self.planningGroupsVersion = planningGroupsVersion
        self.weekCount = weekCount
        self.metadata = metadata
        self.canUseForScheduling = canUseForScheduling
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case creationMethod
        case _description = "description"
        case legacy
        case referenceStartDate
        case sourceDays
        case modifications
        case timeZone
        case planningGroupsVersion
        case weekCount
        case metadata
        case canUseForScheduling
    }


}




public class WfmBuShortTermForecastImportCompleteTopicBuShortTermForecastNotification: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }





    public var status: Status?
    public var result: WfmBuShortTermForecastImportCompleteTopicBuShortTermForecast?
    public var operationId: String?

    public init(status: Status?, result: WfmBuShortTermForecastImportCompleteTopicBuShortTermForecast?, operationId: String?) {
        self.status = status
        self.result = result
        self.operationId = operationId
    }


}




public class WfmBuShortTermForecastStaffingRequirementsGenerateCompleteTopicBuForecastShortTermStaffingRequirementsNotification: Codable {



    public enum State: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }











    public var businessUnitId: String?
    public var state: State?
    public var forecast: WfmBuShortTermForecastStaffingRequirementsGenerateCompleteTopicBuShortTermForecastReference?
    public var weekCount: Int?
    public var intervalLengthMinutes: Int?
    public var referenceStartDate: Date?
    public var results: [WfmBuShortTermForecastStaffingRequirementsGenerateCompleteTopicBuForecastShortTermStaffingRequirementsResults]?

    public init(businessUnitId: String?, state: State?, forecast: WfmBuShortTermForecastStaffingRequirementsGenerateCompleteTopicBuShortTermForecastReference?, weekCount: Int?, intervalLengthMinutes: Int?, referenceStartDate: Date?, results: [WfmBuShortTermForecastStaffingRequirementsGenerateCompleteTopicBuForecastShortTermStaffingRequirementsResults]?) {
        self.businessUnitId = businessUnitId
        self.state = state
        self.forecast = forecast
        self.weekCount = weekCount
        self.intervalLengthMinutes = intervalLengthMinutes
        self.referenceStartDate = referenceStartDate
        self.results = results
    }


}




public class WfmBuShortTermForecastUpdateCompleteTopicForecastSourceDayPointer: Codable {

    public enum DayOfWeek: String, Codable { 
        case sunday = "Sunday"
        case monday = "Monday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
        case thursday = "Thursday"
        case friday = "Friday"
        case saturday = "Saturday"
        case eighthDay = "EighthDay"
    }









    public var dayOfWeek: DayOfWeek?
    public var weight: Int?
    public var date: String?
    public var fileName: String?
    public var dataKey: String?

    public init(dayOfWeek: DayOfWeek?, weight: Int?, date: String?, fileName: String?, dataKey: String?) {
        self.dayOfWeek = dayOfWeek
        self.weight = weight
        self.date = date
        self.fileName = fileName
        self.dataKey = dataKey
    }


}




public class WfmBuShortTermForecastUpdateCompleteTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmBulkShiftTradeStateUpdateNotificationTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmIntegrationsHrisTimeOffTypesJobTopicHrisTimeOffTypesJobNotification: Codable {





    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case error = "Error"
    }



    public var _id: String?
    public var entities: [WfmIntegrationsHrisTimeOffTypesJobTopicHrisTimeOffType]?
    public var status: Status?
    public var error: WfmIntegrationsHrisTimeOffTypesJobTopicErrorBody?

    public init(_id: String?, entities: [WfmIntegrationsHrisTimeOffTypesJobTopicHrisTimeOffType]?, status: Status?, error: WfmIntegrationsHrisTimeOffTypesJobTopicErrorBody?) {
        self._id = _id
        self.entities = entities
        self.status = status
        self.error = error
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case entities
        case status
        case error
    }


}




public class WfmIntradayDataUpdateTopicIntradayDataUpdate: Codable {















    public var startDate: Date?
    public var endDate: Date?
    public var intervalLengthMinutes: Int?
    public var numberOfIntervals: Int?
    public var metrics: [WfmIntradayDataUpdateTopicIntradayMetric]?
    public var queueIds: [String]?
    public var intradayDataGroupings: [WfmIntradayDataUpdateTopicIntradayDataGroup]?

    public init(startDate: Date?, endDate: Date?, intervalLengthMinutes: Int?, numberOfIntervals: Int?, metrics: [WfmIntradayDataUpdateTopicIntradayMetric]?, queueIds: [String]?, intradayDataGroupings: [WfmIntradayDataUpdateTopicIntradayDataGroup]?) {
        self.startDate = startDate
        self.endDate = endDate
        self.intervalLengthMinutes = intervalLengthMinutes
        self.numberOfIntervals = numberOfIntervals
        self.metrics = metrics
        self.queueIds = queueIds
        self.intradayDataGroupings = intradayDataGroupings
    }


}




public class WfmIntradayDataUpdateTopicIntradayPerformancePredictionQueueData: Codable {







    public var serviceLevelPercent: Double?
    public var averageSpeedOfAnswerSeconds: Double?
    public var numberOfInteractions: Double?

    public init(serviceLevelPercent: Double?, averageSpeedOfAnswerSeconds: Double?, numberOfInteractions: Double?) {
        self.serviceLevelPercent = serviceLevelPercent
        self.averageSpeedOfAnswerSeconds = averageSpeedOfAnswerSeconds
        self.numberOfInteractions = numberOfInteractions
    }


}




public class WfmMoveAgentsCompleteTopicManagementUnit: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmMoveManagementUnitTopicBusinessUnit: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmScheduleTopicWfmScheduleNotification: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }







    public enum EventType: String, Codable { 
        case update = "Update"
        case _import = "Import"
        case copy = "Copy"
        case generate = "Generate"
        case reschedule = "Reschedule"
    }

    public var status: Status?
    public var operationId: String?
    public var downloadUrl: String?
    public var percentComplete: Int?
    public var eventType: EventType?

    public init(status: Status?, operationId: String?, downloadUrl: String?, percentComplete: Int?, eventType: EventType?) {
        self.status = status
        self.operationId = operationId
        self.downloadUrl = downloadUrl
        self.percentComplete = percentComplete
        self.eventType = eventType
    }


}




public class WfmTimeOffRequestUpdateTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmUserNotification: Codable {







    public enum ModelType: String, Codable { 
        case adherenceExplanation = "AdherenceExplanation"
        case shiftTrade = "ShiftTrade"
        case timeOffRequest = "TimeOffRequest"
    }













    /** The immutable globally unique identifier for the object. */
    public var _id: String?
    /** The group ID of the notification (mutable, may change  on update) */
    public var mutableGroupId: String?
    /** The timestamp for this notification. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var timestamp: Date?
    /** The type of this notification */
    public var type: ModelType?
    /** A shift trade notification.  Only set if type == ShiftTrade */
    public var shiftTrade: ShiftTradeNotification?
    /** A time off request notification.  Only set if type == TimeOffRequest */
    public var timeOffRequest: TimeOffRequestNotification?
    /** An adherence explanation notification.  Only set if type == AdherenceExplanation */
    public var adherenceExplanation: AdherenceExplanationNotification?
    /** Whether this notification has been marked \"read\" */
    public var markedAsRead: Bool?
    /** Whether this notification is for an agent */
    public var agentNotification: Bool?
    /** Other notification IDs in group.  This field is only populated in real-time notifications */
    public var otherNotificationIdsInGroup: [String]?

    public init(_id: String?, mutableGroupId: String?, timestamp: Date?, type: ModelType?, shiftTrade: ShiftTradeNotification?, timeOffRequest: TimeOffRequestNotification?, adherenceExplanation: AdherenceExplanationNotification?, markedAsRead: Bool?, agentNotification: Bool?, otherNotificationIdsInGroup: [String]?) {
        self._id = _id
        self.mutableGroupId = mutableGroupId
        self.timestamp = timestamp
        self.type = type
        self.shiftTrade = shiftTrade
        self.timeOffRequest = timeOffRequest
        self.adherenceExplanation = adherenceExplanation
        self.markedAsRead = markedAsRead
        self.agentNotification = agentNotification
        self.otherNotificationIdsInGroup = otherNotificationIdsInGroup
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case mutableGroupId
        case timestamp
        case type
        case shiftTrade
        case timeOffRequest
        case adherenceExplanation
        case markedAsRead
        case agentNotification
        case otherNotificationIdsInGroup
    }


}




public class WfmUserScheduleAdherenceUpdatedMuTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmUserScheduleAdherenceUpdatedTeamTopicUserScheduleAdherenceUpdate: Codable {















    public enum RoutingStatus: String, Codable { 
        case empty = "__EMPTY__"
        case offQueue = "OFF_QUEUE"
        case idle = "IDLE"
        case interacting = "INTERACTING"
        case notResponding = "NOT_RESPONDING"
        case communicating = "COMMUNICATING"
        case offline = "OFFLINE"
    }





    public enum AdherenceState: String, Codable { 
        case inAdherence = "InAdherence"
        case outOfAdherence = "OutOfAdherence"
        case unscheduled = "Unscheduled"
        case unknown = "Unknown"
        case ignored = "Ignored"
        case explained = "Explained"
    }















    public var user: WfmUserScheduleAdherenceUpdatedTeamTopicUserReference?
    public var managementUnitId: String?
    public var team: WfmUserScheduleAdherenceUpdatedTeamTopicUriReference?
    public var scheduledActivityCategory: String?
    public var scheduledActivityCode: WfmUserScheduleAdherenceUpdatedTeamTopicActivityCodeReference?
    public var systemPresence: String?
    public var organizationSecondaryPresenceId: String?
    public var routingStatus: RoutingStatus?
    public var actualActivityCategory: String?
    public var isOutOfOffice: Bool?
    public var adherenceState: AdherenceState?
    public var impact: String?
    public var adherenceExplanation: WfmUserScheduleAdherenceUpdatedTeamTopicRealTimeAdherenceExplanation?
    public var adherenceChangeTime: Date?
    public var presenceUpdateTime: Date?
    public var activeQueues: [WfmUserScheduleAdherenceUpdatedTeamTopicQueueReference]?
    public var activeQueuesModifiedTime: Date?
    public var removedFromManagementUnit: Bool?

    public init(user: WfmUserScheduleAdherenceUpdatedTeamTopicUserReference?, managementUnitId: String?, team: WfmUserScheduleAdherenceUpdatedTeamTopicUriReference?, scheduledActivityCategory: String?, scheduledActivityCode: WfmUserScheduleAdherenceUpdatedTeamTopicActivityCodeReference?, systemPresence: String?, organizationSecondaryPresenceId: String?, routingStatus: RoutingStatus?, actualActivityCategory: String?, isOutOfOffice: Bool?, adherenceState: AdherenceState?, impact: String?, adherenceExplanation: WfmUserScheduleAdherenceUpdatedTeamTopicRealTimeAdherenceExplanation?, adherenceChangeTime: Date?, presenceUpdateTime: Date?, activeQueues: [WfmUserScheduleAdherenceUpdatedTeamTopicQueueReference]?, activeQueuesModifiedTime: Date?, removedFromManagementUnit: Bool?) {
        self.user = user
        self.managementUnitId = managementUnitId
        self.team = team
        self.scheduledActivityCategory = scheduledActivityCategory
        self.scheduledActivityCode = scheduledActivityCode
        self.systemPresence = systemPresence
        self.organizationSecondaryPresenceId = organizationSecondaryPresenceId
        self.routingStatus = routingStatus
        self.actualActivityCategory = actualActivityCategory
        self.isOutOfOffice = isOutOfOffice
        self.adherenceState = adherenceState
        self.impact = impact
        self.adherenceExplanation = adherenceExplanation
        self.adherenceChangeTime = adherenceChangeTime
        self.presenceUpdateTime = presenceUpdateTime
        self.activeQueues = activeQueues
        self.activeQueuesModifiedTime = activeQueuesModifiedTime
        self.removedFromManagementUnit = removedFromManagementUnit
    }


}




public class WfmUserScheduleAdherenceUpdatedTopicActivityCodeReference: Codable {





    public var _id: String?
    public var secondaryPresences: [WfmUserScheduleAdherenceUpdatedTopicSecondaryPresenceReference]?

    public init(_id: String?, secondaryPresences: [WfmUserScheduleAdherenceUpdatedTopicSecondaryPresenceReference]?) {
        self._id = _id
        self.secondaryPresences = secondaryPresences
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case secondaryPresences
    }


}




public class WfmUserScheduleAdherenceUpdatedTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class WhatsAppAvailablePhoneNumberDetails: Codable {







    /** The verified name associated with this phone number. */
    public var name: String?
    /** The display name associated with this phone number. It's typically the E.164 representation of the number. */
    public var phoneNumber: String?
    /** The status of this phone number. */
    public var status: String?

    public init(name: String?, phoneNumber: String?, status: String?) {
        self.name = name
        self.phoneNumber = phoneNumber
        self.status = status
    }


}




public class WhatsAppAvailablePhoneNumberDetailsListing: Codable {



    public var entities: [WhatsAppAvailablePhoneNumberDetails]?

    public init(entities: [WhatsAppAvailablePhoneNumberDetails]?) {
        self.entities = entities
    }


}




public class WidgetClientConfigV1Http: Codable {

    public enum WebChatSkin: String, Codable { 
        case basic = "basic"
        case modernCaretSkin = "modern-caret-skin"
    }



    public var webChatSkin: WebChatSkin?
    public var authenticationUrl: String?

    public init(webChatSkin: WebChatSkin?, authenticationUrl: String?) {
        self.webChatSkin = webChatSkin
        self.authenticationUrl = authenticationUrl
    }


}




public class WorkPlanListResponse: Codable {



    public var entities: [WorkPlanListItemResponse]?

    public init(entities: [WorkPlanListItemResponse]?) {
        self.entities = entities
    }


}




public class WorkPlanPatternRequest: Codable {



    /** List of work plan IDs in order of rotation on a weekly basis. Values in the list cannot be null or empty */
    public var workPlanIds: [String]?

    public init(workPlanIds: [String]?) {
        self.workPlanIds = workPlanIds
    }


}




public class WorkPlanRotationReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class WorkPlanValidationMessageArgument: Codable {

    public enum ModelType: String, Codable { 
        case activityId = "ActivityId"
        case activityId2 = "ActivityId2"
        case activityPaidTimeMinutes = "ActivityPaidTimeMinutes"
        case activityStartTimeMinutes = "ActivityStartTimeMinutes"
        case activityValidationId = "ActivityValidationId"
        case activityValidationId2 = "ActivityValidationId2"
        case applicableDays = "ApplicableDays"
        case count = "Count"
        case dailyPaidTimeMinutes = "DailyPaidTimeMinutes"
        case maximumDays = "MaximumDays"
        case maxShiftCount = "MaxShiftCount"
        case minutes = "Minutes"
        case paidTimeGranularityMinutes = "PaidTimeGranularityMinutes"
        case requiredDays = "RequiredDays"
        case shiftId = "ShiftId"
        case shiftPaidTimeMinutes = "ShiftPaidTimeMinutes"
        case shiftStartTimeMinutes = "ShiftStartTimeMinutes"
        case shiftStopTimeMinutes = "ShiftStopTimeMinutes"
        case shiftValidationId = "ShiftValidationId"
        case weeklyPaidTimeMinutes = "WeeklyPaidTimeMinutes"
        case weeks = "Weeks"
        case workTimeMinutes = "WorkTimeMinutes"
    }



    /** The type of the argument associated with violation messages */
    public var type: ModelType?
    /** The value of the argument */
    public var value: String?

    public init(type: ModelType?, value: String?) {
        self.type = type
        self.value = value
    }


}




public class WorkdayPeriod: Codable {





    /** Start workday used as the date range. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStartWorkday: Date?
    /** End workday used as the date range. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEndWorkday: Date?

    public init(dateStartWorkday: Date?, dateEndWorkday: Date?) {
        self.dateStartWorkday = dateStartWorkday
        self.dateEndWorkday = dateEndWorkday
    }


}




public class WorkdayPointsTrend: Codable {







    public enum DayOfWeek: String, Codable { 
        case sunday = "Sunday"
        case monday = "Monday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
        case thursday = "Thursday"
        case friday = "Friday"
        case saturday = "Saturday"
    }





    /** The start workday for the query range for the gamification points trend. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStartWorkday: Date?
    /** The end workday for the query range for the gamification points trend. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEndWorkday: Date?
    /** The targeted user for the query */
    public var user: UserReference?
    /** Aggregated for same day comparison */
    public var dayOfWeek: DayOfWeek?
    /** The total average points */
    public var averagePoints: Double?
    /** Daily points trends */
    public var trend: [WorkdayPointsTrendItem]?

    public init(dateStartWorkday: Date?, dateEndWorkday: Date?, user: UserReference?, dayOfWeek: DayOfWeek?, averagePoints: Double?, trend: [WorkdayPointsTrendItem]?) {
        self.dateStartWorkday = dateStartWorkday
        self.dateEndWorkday = dateEndWorkday
        self.user = user
        self.dayOfWeek = dayOfWeek
        self.averagePoints = averagePoints
        self.trend = trend
    }


}




public class WorkflowTargetSettings: Codable {

    public enum DataFormat: String, Codable { 
        case json = "Json"
        case topLevelPrimitives = "TopLevelPrimitives"
    }

    /** The data format to use when invoking target. */
    public var dataFormat: DataFormat?

    public init(dataFormat: DataFormat?) {
        self.dataFormat = dataFormat
    }


}




public class WorkitemsEventsNotificationWrapup: Codable {





    public enum Op: String, Codable { 
        case unknown = "Unknown"
        case add = "Add"
        case remove = "Remove"
    }

    public enum Action: String, Codable { 
        case unknown = "Unknown"
        case add = "Add"
        case remove = "Remove"
    }

    public var code: String?
    public var userId: String?
    public var op: Op?
    public var action: Action?

    public init(code: String?, userId: String?, op: Op?, action: Action?) {
        self.code = code
        self.userId = userId
        self.op = op
        self.action = action
    }


}




public class WorkitemsQueueEventsNotificationAssignmentSegment: Codable {

    public enum StartState: String, Codable { 
        case unknown = "Unknown"
        case idle = "Idle"
        case acdStarted = "AcdStarted"
        case alerting = "Alerting"
        case alertTimeout = "AlertTimeout"
        case declined = "Declined"
        case connected = "Connected"
        case disconnected = "Disconnected"
        case parked = "Parked"
        case held = "Held"
        case acdCancelled = "AcdCancelled"
        case terminated = "Terminated"
        case acdExpired = "AcdExpired"
    }

    public enum EndState: String, Codable { 
        case unknown = "Unknown"
        case idle = "Idle"
        case acdStarted = "AcdStarted"
        case alerting = "Alerting"
        case alertTimeout = "AlertTimeout"
        case declined = "Declined"
        case connected = "Connected"
        case disconnected = "Disconnected"
        case parked = "Parked"
        case held = "Held"
        case acdCancelled = "AcdCancelled"
        case terminated = "Terminated"
        case acdExpired = "AcdExpired"
    }



    public var startState: StartState?
    public var endState: EndState?
    public var durationMs: Int?

    public init(startState: StartState?, endState: EndState?, durationMs: Int?) {
        self.startState = startState
        self.endState = endState
        self.durationMs = durationMs
    }


}




public class WorkitemsUserEventsNotificationWrapup: Codable {





    public enum Op: String, Codable { 
        case unknown = "Unknown"
        case add = "Add"
        case remove = "Remove"
    }

    public enum Action: String, Codable { 
        case unknown = "Unknown"
        case add = "Add"
        case remove = "Remove"
    }

    public var code: String?
    public var userId: String?
    public var op: Op?
    public var action: Action?

    public init(code: String?, userId: String?, op: Op?, action: Action?) {
        self.code = code
        self.userId = userId
        self.op = op
        self.action = action
    }


}




public class Workspace: Codable {





    public enum ModelType: String, Codable { 
        case user = "USER"
        case group = "GROUP"
    }



















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The current name of the workspace. */
    public var name: String?
    public var type: ModelType?
    public var isCurrentUserWorkspace: Bool?
    public var user: DomainEntityRef?
    public var bucket: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    public var summary: WorkspaceSummary?
    public var acl: [String]?
    public var _description: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, type: ModelType?, isCurrentUserWorkspace: Bool?, user: DomainEntityRef?, bucket: String?, dateCreated: Date?, dateModified: Date?, summary: WorkspaceSummary?, acl: [String]?, _description: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.type = type
        self.isCurrentUserWorkspace = isCurrentUserWorkspace
        self.user = user
        self.bucket = bucket
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.summary = summary
        self.acl = acl
        self._description = _description
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case type
        case isCurrentUserWorkspace
        case user
        case bucket
        case dateCreated
        case dateModified
        case summary
        case acl
        case _description = "description"
        case selfUri
    }


}




public class WorkspaceMember: Codable {







    public enum MemberType: String, Codable { 
        case user = "USER"
        case group = "GROUP"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var workspace: DomainEntityRef?
    /** The workspace member type. */
    public var memberType: MemberType?
    public var member: DomainEntityRef?
    public var user: User?
    public var group: Group?
    public var securityProfile: SecurityProfile?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, workspace: DomainEntityRef?, memberType: MemberType?, member: DomainEntityRef?, user: User?, group: Group?, securityProfile: SecurityProfile?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.workspace = workspace
        self.memberType = memberType
        self.member = member
        self.user = user
        self.group = group
        self.securityProfile = securityProfile
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case workspace
        case memberType
        case member
        case user
        case group
        case securityProfile
        case selfUri
    }


}




public class WorkspaceSummary: Codable {





    public var totalDocumentCount: Int64?
    public var totalDocumentByteCount: Int64?

    public init(totalDocumentCount: Int64?, totalDocumentByteCount: Int64?) {
        self.totalDocumentCount = totalDocumentCount
        self.totalDocumentByteCount = totalDocumentByteCount
    }


}




public class WrapupCode: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The wrap-up code name. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: StarrableDivision?
    /** Date when the wrap-up code was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date when the wrap-up code was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that created the wrap-up code. */
    public var createdBy: String?
    /** The ID of the user that modified the wrap-up code. */
    public var modifiedBy: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: StarrableDivision?, dateCreated: Date?, dateModified: Date?, createdBy: String?, modifiedBy: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case dateCreated
        case dateModified
        case createdBy
        case modifiedBy
        case selfUri
    }


}




public class WrapupCodeRequest: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The wrap-up code name. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableStarrableDivision?
    /** Date when the wrap-up code was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date when the wrap-up code was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that created the wrap-up code. */
    public var createdBy: String?
    /** The ID of the user that modified the wrap-up code. */
    public var modifiedBy: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableStarrableDivision?, dateCreated: Date?, dateModified: Date?, createdBy: String?, modifiedBy: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case dateCreated
        case dateModified
        case createdBy
        case modifiedBy
        case selfUri
    }


}




public class WritableDivision: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}




public class WritableEntity: Codable {



    /** The globally unique identifier for the object. */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}

