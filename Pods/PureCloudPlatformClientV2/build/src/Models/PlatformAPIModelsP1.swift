//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation



public class AcceleratorList: Codable {





















    public var entities: [AcceleratorMetadata]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [AcceleratorMetadata]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class AcknowledgeScreenRecordingRequest: Codable {







    public var participantJid: String?
    public var roomId: String?
    public var conversationId: String?

    public init(participantJid: String?, roomId: String?, conversationId: String?) {
        self.participantJid = participantJid
        self.roomId = roomId
        self.conversationId = conversationId
    }


}




public class ActionAggregateQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [ActionAggregateQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [ActionAggregateQueryPredicate]?

    public init(type: ModelType?, clauses: [ActionAggregateQueryClause]?, predicates: [ActionAggregateQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class ActionMap: Codable {









































    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The version of the action map. */
    public var version: Int?
    /** Whether the action map is active. */
    public var isActive: Bool?
    /** Display name of the action map. */
    public var displayName: String?
    /** Trigger action map if any segment in the list is assigned to a given customer. */
    public var triggerWithSegments: [String]?
    /** List of event conditions that must be satisfied to trigger the action map. */
    public var triggerWithEventConditions: [EventCondition]?
    /** Probability conditions for outcomes that must be satisfied to trigger the action map. */
    public var triggerWithOutcomeProbabilityConditions: [OutcomeProbabilityCondition]?
    /** (deprecated - use triggerWithOutcomeQuantileConditions instead) Percentile conditions for outcomes that must be satisfied to trigger the action map. */
    public var triggerWithOutcomePercentileConditions: [OutcomePercentileCondition]?
    /** Quantile conditions for outcomes that must be satisfied to trigger the action map. */
    public var triggerWithOutcomeQuantileConditions: [OutcomeQuantileCondition]?
    /** URL conditions that a page must match for web actions to be displayable. */
    public var pageUrlConditions: [UrlCondition]?
    /** Type of activation. */
    public var activation: Activation?
    /** Weight of the action map with higher number denoting higher weight. */
    public var weight: Int?
    /** The action that will be executed if this action map is triggered. */
    public var action: ActionMapAction?
    /** The action map's associated schedule groups. */
    public var actionMapScheduleGroups: ActionMapScheduleGroups?
    /** Override organization-level frequency cap and always offer web engagements from this action map. */
    public var ignoreFrequencyCap: Bool?
    /** The URI for this object */
    public var selfUri: String?
    /** Timestamp indicating when the action map was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    /** Timestamp indicating when the action map was last updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    /** Timestamp at which the action map is scheduled to start firing. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** Timestamp at which the action map is scheduled to stop firing. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endDate: Date?

    public init(_id: String?, version: Int?, isActive: Bool?, displayName: String?, triggerWithSegments: [String]?, triggerWithEventConditions: [EventCondition]?, triggerWithOutcomeProbabilityConditions: [OutcomeProbabilityCondition]?, triggerWithOutcomePercentileConditions: [OutcomePercentileCondition]?, triggerWithOutcomeQuantileConditions: [OutcomeQuantileCondition]?, pageUrlConditions: [UrlCondition]?, activation: Activation?, weight: Int?, action: ActionMapAction?, actionMapScheduleGroups: ActionMapScheduleGroups?, ignoreFrequencyCap: Bool?, selfUri: String?, createdDate: Date?, modifiedDate: Date?, startDate: Date?, endDate: Date?) {
        self._id = _id
        self.version = version
        self.isActive = isActive
        self.displayName = displayName
        self.triggerWithSegments = triggerWithSegments
        self.triggerWithEventConditions = triggerWithEventConditions
        self.triggerWithOutcomeProbabilityConditions = triggerWithOutcomeProbabilityConditions
        self.triggerWithOutcomePercentileConditions = triggerWithOutcomePercentileConditions
        self.triggerWithOutcomeQuantileConditions = triggerWithOutcomeQuantileConditions
        self.pageUrlConditions = pageUrlConditions
        self.activation = activation
        self.weight = weight
        self.action = action
        self.actionMapScheduleGroups = actionMapScheduleGroups
        self.ignoreFrequencyCap = ignoreFrequencyCap
        self.selfUri = selfUri
        self.createdDate = createdDate
        self.modifiedDate = modifiedDate
        self.startDate = startDate
        self.endDate = endDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
        case isActive
        case displayName
        case triggerWithSegments
        case triggerWithEventConditions
        case triggerWithOutcomeProbabilityConditions
        case triggerWithOutcomePercentileConditions
        case triggerWithOutcomeQuantileConditions
        case pageUrlConditions
        case activation
        case weight
        case action
        case actionMapScheduleGroups
        case ignoreFrequencyCap
        case selfUri
        case createdDate
        case modifiedDate
        case startDate
        case endDate
    }


}




public class ActionMapListing: Codable {





















    public var entities: [ActionMap]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ActionMap]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class Activation: Codable {





    /** Type of activation. */
    public var type: String?
    /** Activation delay time amount. */
    public var delayInSeconds: Int?

    public init(type: String?, delayInSeconds: Int?) {
        self.type = type
        self.delayInSeconds = delayInSeconds
    }


}




public class AcwSettings: Codable {

    public enum WrapupPrompt: String, Codable { 
        case mandatory = "MANDATORY"
        case _optional = "OPTIONAL"
        case mandatoryTimeout = "MANDATORY_TIMEOUT"
        case mandatoryForcedTimeout = "MANDATORY_FORCED_TIMEOUT"
        case agentRequested = "AGENT_REQUESTED"
    }



    /** This field controls how the UI prompts the agent for a wrapup. */
    public var wrapupPrompt: WrapupPrompt?
    /** The amount of time the agent can stay in ACW (Min: 1 sec, Max: 15 min).  Can only be used when ACW is MANDATORY_TIMEOUT or MANDATORY_FORCED_TIMEOUT. */
    public var timeoutMs: Int?

    public init(wrapupPrompt: WrapupPrompt?, timeoutMs: Int?) {
        self.wrapupPrompt = wrapupPrompt
        self.timeoutMs = timeoutMs
    }


}




public class AddConversationResponse: Codable {





    /** The conversation reference */
    public var conversation: ConversationReference?
    /** The appointment reference */
    public var appointment: CoachingAppointmentReference?

    public init(conversation: ConversationReference?, appointment: CoachingAppointmentReference?) {
        self.conversation = conversation
        self.appointment = appointment
    }


}




public class AddWorkPlanRotationAgentRequest: Codable {







    /** The ID of an agent in this work plan rotation */
    public var userId: String?
    /** The date range to which this agent is effective in the work plan rotation */
    public var dateRange: DateRangeWithOptionalEnd?
    /** Start position of the work plan in the pattern for this agent in the work plan rotation. Position value starts from 0 */
    public var position: Int?

    public init(userId: String?, dateRange: DateRangeWithOptionalEnd?, position: Int?) {
        self.userId = userId
        self.dateRange = dateRange
        self.position = position
    }


}




public class AddWorkPlanRotationRequest: Codable {









    /** Name of this work plan rotation */
    public var name: String?
    /** The date range to which this work plan rotation applies */
    public var dateRange: DateRangeWithOptionalEnd?
    /** Agents in this work plan rotation */
    public var agents: [AddWorkPlanRotationAgentRequest]?
    /** Pattern with list of work plan IDs that rotate on a weekly basis */
    public var pattern: WorkPlanPatternRequest?

    public init(name: String?, dateRange: DateRangeWithOptionalEnd?, agents: [AddWorkPlanRotationAgentRequest]?, pattern: WorkPlanPatternRequest?) {
        self.name = name
        self.dateRange = dateRange
        self.agents = agents
        self.pattern = pattern
    }


}




public class AdditionalLanguagesIntent: Codable {





    /** ID of the intent for respective additional language */
    public var _id: String?
    /** Utterances list for additional language */
    public var utterances: [NluUtterance]?

    public init(_id: String?, utterances: [NluUtterance]?) {
        self._id = _id
        self.utterances = utterances
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case utterances
    }


}




public class AdherenceExplanationAsyncResponse: Codable {



    /** A reference to the job that was started by the request */
    public var job: AdherenceExplanationJobReference?

    public init(job: AdherenceExplanationJobReference?) {
        self.job = job
    }


}




public class AdherenceExplanationResponse: Codable {









    public enum ModelType: String, Codable { 
        case late = "Late"
    }

    public enum Status: String, Codable { 
        case pending = "Pending"
        case approved = "Approved"
        case denied = "Denied"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The agent to whom this adherence explanation applies */
    public var agent: UserReference?
    /** The management unit to which the agent belonged at the time the adherence explanation was submitted */
    public var managementUnit: ManagementUnitReference?
    /** The business unit to which the agent belonged at the time the adherence explanation was submitted */
    public var businessUnit: BusinessUnitReference?
    /** The type of the adherence explanation */
    public var type: ModelType?
    /** The status of the adherence explanation */
    public var status: Status?
    /** The start timestamp of the adherence explanation in ISO-8601 format */
    public var startDate: Date?
    /** The length of the adherence explanation in minutes */
    public var lengthMinutes: Int?
    /** Notes about the adherence explanation */
    public var notes: String?
    /** The user who reviewed the adherence explanation, if applicable */
    public var reviewedBy: UserReference?
    /** The timestamp for when the adherence explanation was reviewed, if applicable. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var reviewedDate: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, agent: UserReference?, managementUnit: ManagementUnitReference?, businessUnit: BusinessUnitReference?, type: ModelType?, status: Status?, startDate: Date?, lengthMinutes: Int?, notes: String?, reviewedBy: UserReference?, reviewedDate: Date?, selfUri: String?) {
        self._id = _id
        self.agent = agent
        self.managementUnit = managementUnit
        self.businessUnit = businessUnit
        self.type = type
        self.status = status
        self.startDate = startDate
        self.lengthMinutes = lengthMinutes
        self.notes = notes
        self.reviewedBy = reviewedBy
        self.reviewedDate = reviewedDate
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case agent
        case managementUnit
        case businessUnit
        case type
        case status
        case startDate
        case lengthMinutes
        case notes
        case reviewedBy
        case reviewedDate
        case selfUri
    }


}




public class AdminTimeOffRequestPatch: Codable {

    public enum Status: String, Codable { 
        case pending = "PENDING"
        case approved = "APPROVED"
        case denied = "DENIED"
    }



















    /** The status of this time off request */
    public var status: Status?
    /** The ID of the activity code associated with this time off request. Activity code must be of the TimeOff category */
    public var activityCodeId: String?
    /** Whether this is a paid time off request */
    public var paid: Bool?
    /** Notes about the time off request */
    public var notes: String?
    /** A set of dates in yyyy-MM-dd format. Should be interpreted in the management unit's configured time zone. */
    public var fullDayManagementUnitDates: [String]?
    /** A set of start date-times in ISO-8601 format for partial day requests. */
    public var partialDayStartDateTimes: [Date]?
    /** The daily duration of this time off request in minutes */
    public var dailyDurationMinutes: Int?
    /** Daily durations for each day of this time off request in minutes */
    public var durationMinutes: [Int]?
    /** Payable minutes for each day of this time off request */
    public var payableMinutes: [Int]?
    /** Version metadata for the time off request */
    public var metadata: WfmVersionedEntityMetadata?

    public init(status: Status?, activityCodeId: String?, paid: Bool?, notes: String?, fullDayManagementUnitDates: [String]?, partialDayStartDateTimes: [Date]?, dailyDurationMinutes: Int?, durationMinutes: [Int]?, payableMinutes: [Int]?, metadata: WfmVersionedEntityMetadata?) {
        self.status = status
        self.activityCodeId = activityCodeId
        self.paid = paid
        self.notes = notes
        self.fullDayManagementUnitDates = fullDayManagementUnitDates
        self.partialDayStartDateTimes = partialDayStartDateTimes
        self.dailyDurationMinutes = dailyDurationMinutes
        self.durationMinutes = durationMinutes
        self.payableMinutes = payableMinutes
        self.metadata = metadata
    }


}




public class AfterCallWork: Codable {





    public enum State: String, Codable { 
        case unknown = "unknown"
        case notapplicable = "notApplicable"
        case skipped = "skipped"
        case pending = "pending"
        case complete = "complete"
    }

    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startTime: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?
    public var state: State?

    public init(startTime: Date?, endTime: Date?, state: State?) {
        self.startTime = startTime
        self.endTime = endTime
        self.state = state
    }


}




public class AgentActivityEntityListing: Codable {





















    public var entities: [AgentActivity]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [AgentActivity]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class AgentEvaluatorActivity: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var agent: User?
    public var evaluator: User?
    public var numEvaluations: Int?
    public var averageEvaluationScore: Int?
    public var numEvaluationsWithoutViewPermission: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, agent: User?, evaluator: User?, numEvaluations: Int?, averageEvaluationScore: Int?, numEvaluationsWithoutViewPermission: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.agent = agent
        self.evaluator = evaluator
        self.numEvaluations = numEvaluations
        self.averageEvaluationScore = averageEvaluationScore
        self.numEvaluationsWithoutViewPermission = numEvaluationsWithoutViewPermission
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case agent
        case evaluator
        case numEvaluations
        case averageEvaluationScore
        case numEvaluationsWithoutViewPermission
        case selfUri
    }


}




public class AgentIntegrationAssociationResponse: Codable {







    /** ID of the agent in external system */
    public var agentExternalId: String?
    /** The integration associated with the agent */
    public var integration: WfmIntegrationReference?
    /** Whether agentExternalId should be protected from update by automatic processes */
    public var locked: Bool?

    public init(agentExternalId: String?, integration: WfmIntegrationReference?, locked: Bool?) {
        self.agentExternalId = agentExternalId
        self.integration = integration
        self.locked = locked
    }


}




public class AgentPossibleWorkShiftsRequest: Codable {





    /** Start date of requested effective work plan, day of week will be in line with business unit start day of week. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekStartDate: Date?
    /** Number of weeks for which to return possible work shifts */
    public var weekCount: Int?

    public init(weekStartDate: Date?, weekCount: Int?) {
        self.weekStartDate = weekStartDate
        self.weekCount = weekCount
    }


}




public class AggregateViewData: Codable {





    public var name: String?
    public var stats: StatisticalSummary?

    public init(name: String?, stats: StatisticalSummary?) {
        self.name = name
        self.stats = stats
    }


}




public class AggregationResult: Codable {

    public enum ModelType: String, Codable { 
        case termfrequency = "termFrequency"
        case numericrange = "numericRange"
    }









    public var type: ModelType?
    /** For termFrequency aggregations */
    public var dimension: String?
    /** For numericRange aggregations */
    public var metric: String?
    public var count: Int64?
    public var results: [AggregationResultEntry]?

    public init(type: ModelType?, dimension: String?, metric: String?, count: Int64?, results: [AggregationResultEntry]?) {
        self.type = type
        self.dimension = dimension
        self.metric = metric
        self.count = count
        self.results = results
    }


}




public class AggregationResultEntry: Codable {









    public var count: Int64?
    /** For termFrequency aggregations */
    public var value: String?
    /** For numericRange aggregations */
    public var gte: Double?
    /** For numericRange aggregations */
    public var lt: Double?

    public init(count: Int64?, value: String?, gte: Double?, lt: Double?) {
        self.count = count
        self.value = value
        self.gte = gte
        self.lt = lt
    }


}




public class AllTimePoints: Codable {







    /** Queried user */
    public var user: UserReference?
    /** Queried end workday for all time points to be collected. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEndWorkday: Date?
    /** All time point collected bt the user */
    public var allTimePoints: Int64?

    public init(user: UserReference?, dateEndWorkday: Date?, allTimePoints: Int64?) {
        self.user = user
        self.dateEndWorkday = dateEndWorkday
        self.allTimePoints = allTimePoints
    }


}




public class AnalyticsConversationAsyncQueryResponse: Codable {







    public var conversations: [AnalyticsConversation]?
    /** Optional cursor to indicate where to resume the results */
    public var cursor: String?
    /** Data available up to at least this datetime. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dataAvailabilityDate: Date?

    public init(conversations: [AnalyticsConversation]?, cursor: String?, dataAvailabilityDate: Date?) {
        self.conversations = conversations
        self.cursor = cursor
        self.dataAvailabilityDate = dataAvailabilityDate
    }


}




public class AnalyticsConversationQueryResponse: Codable {







    public var conversations: [AnalyticsConversationWithoutAttributes]?
    public var aggregations: [AggregationResult]?
    public var totalHits: Int?

    public init(conversations: [AnalyticsConversationWithoutAttributes]?, aggregations: [AggregationResult]?, totalHits: Int?) {
        self.conversations = conversations
        self.aggregations = aggregations
        self.totalHits = totalHits
    }


}




public class AnalyticsParticipant: Codable {





    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }





    public enum Purpose: String, Codable { 
        case acd = "acd"
        case agent = "agent"
        case api = "api"
        case botflow = "botflow"
        case campaign = "campaign"
        case customer = "customer"
        case dialer = "dialer"
        case external = "external"
        case fax = "fax"
        case group = "group"
        case inbound = "inbound"
        case ivr = "ivr"
        case manual = "manual"
        case outbound = "outbound"
        case station = "station"
        case user = "user"
        case voicemail = "voicemail"
        case workflow = "workflow"
    }









    /** External contact identifier */
    public var externalContactId: String?
    /** External organization identifier */
    public var externalOrganizationId: String?
    /** Reason for which participant flagged conversation */
    public var flaggedReason: FlaggedReason?
    /** Unique identifier for the participant */
    public var participantId: String?
    /** A human readable name identifying the participant */
    public var participantName: String?
    /** The participant's purpose */
    public var purpose: Purpose?
    /** The team ID the user is a member of */
    public var teamId: String?
    /** Unique identifier for the user */
    public var userId: String?
    /** List of sessions associated to this participant */
    public var sessions: [AnalyticsSession]?
    /** List of attributes associated to this participant */
    public var attributes: [String:String]?

    public init(externalContactId: String?, externalOrganizationId: String?, flaggedReason: FlaggedReason?, participantId: String?, participantName: String?, purpose: Purpose?, teamId: String?, userId: String?, sessions: [AnalyticsSession]?, attributes: [String:String]?) {
        self.externalContactId = externalContactId
        self.externalOrganizationId = externalOrganizationId
        self.flaggedReason = flaggedReason
        self.participantId = participantId
        self.participantName = participantName
        self.purpose = purpose
        self.teamId = teamId
        self.userId = userId
        self.sessions = sessions
        self.attributes = attributes
    }


}




public class AnalyticsResolution: Codable {









    /** Specifies when an event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventTime: Date?
    /** The ID of the last queue on which the conversation was handled. */
    public var queueId: String?
    /** The ID of the last user who handled the conversation. */
    public var userId: String?
    public var nNextContactAvoided: Int64?

    public init(eventTime: Date?, queueId: String?, userId: String?, nNextContactAvoided: Int64?) {
        self.eventTime = eventTime
        self.queueId = queueId
        self.userId = userId
        self.nNextContactAvoided = nNextContactAvoided
    }


}




public class AnalyticsUserDetailsAsyncQueryResponse: Codable {







    public var userDetails: [AnalyticsUserDetail]?
    /** Optional cursor to indicate where to resume the results */
    public var cursor: String?
    /** Data available up to at least this datetime. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dataAvailabilityDate: Date?

    public init(userDetails: [AnalyticsUserDetail]?, cursor: String?, dataAvailabilityDate: Date?) {
        self.userDetails = userDetails
        self.cursor = cursor
        self.dataAvailabilityDate = dataAvailabilityDate
    }


}




public class AnalyticsUserDetailsQueryResponse: Codable {







    public var userDetails: [AnalyticsUserDetail]?
    public var aggregations: [AggregationResult]?
    public var totalHits: Int?

    public init(userDetails: [AnalyticsUserDetail]?, aggregations: [AggregationResult]?, totalHits: Int?) {
        self.userDetails = userDetails
        self.aggregations = aggregations
        self.totalHits = totalHits
    }


}




public class AnswerOption: Codable {









    public var _id: String?
    public var text: String?
    public var value: Int?
    /** List of assistance conditions which are combined together with a logical AND operator. Eg ( assistanceCondtion1 && assistanceCondition2 ) wherein assistanceCondition could be ( EXISTS topic1 || topic2 || ... ) or (NOTEXISTS topic3 || topic4 || ...). */
    public var assistanceConditions: [AssistanceCondition]?

    public init(_id: String?, text: String?, value: Int?, assistanceConditions: [AssistanceCondition]?) {
        self._id = _id
        self.text = text
        self.value = value
        self.assistanceConditions = assistanceConditions
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case text
        case value
        case assistanceConditions
    }


}




public class AppendToDncActionSettings: Codable {





    public enum ListType: String, Codable { 
        case rds = "Rds"
        case rdsCustom = "RdsCustom"
    }

    /** Whether to expire the record appended to the DNC list. */
    public var expire: Bool?
    /** If 'expire' is set to true, how long to keep the record. */
    public var expirationDuration: String?
    /** The Dnc List Type to append entries to */
    public var listType: ListType?

    public init(expire: Bool?, expirationDuration: String?, listType: ListType?) {
        self.expire = expire
        self.expirationDuration = expirationDuration
        self.listType = listType
    }


}



/** The user who initiated the change. */

public class ArchitectDependencyTrackingBuildNotificationUser: Codable {







    /** The ID of the user. */
    public var _id: String?
    /** The name of the user, if available. */
    public var name: String?
    public var homeOrg: ArchitectDependencyTrackingBuildNotificationHomeOrganization?

    public init(_id: String?, name: String?, homeOrg: ArchitectDependencyTrackingBuildNotificationHomeOrganization?) {
        self._id = _id
        self.name = name
        self.homeOrg = homeOrg
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case homeOrg
    }


}



/** A bare-bones flow version object */

public class ArchitectFlowNotificationFlowVersion: Codable {



    /** The version ID */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}



/** The user who initiated the change. */

public class ArchitectFlowNotificationUser: Codable {







    /** The ID of the user. */
    public var _id: String?
    /** The name of the user, if available. */
    public var name: String?
    public var homeOrg: ArchitectFlowNotificationHomeOrganization?

    public init(_id: String?, name: String?, homeOrg: ArchitectFlowNotificationHomeOrganization?) {
        self._id = _id
        self.name = name
        self.homeOrg = homeOrg
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case homeOrg
    }


}



/** The error message params, if the action failed */

public class ArchitectFlowOutcomeNotificationErrorMessageParams: Codable {



    public var additionalProperties: [String:String]?

    public init(additionalProperties: [String:String]?) {
        self.additionalProperties = additionalProperties
    }


}




public class ArchitectJobStateResponse: Codable {





    public enum Status: String, Codable { 
        case registered = "Registered"
        case started = "Started"
        case success = "Success"
        case failure = "Failure"
    }

    public enum Command: String, Codable { 
        case publish = "Publish"
        case create = "Create"
        case update = "Update"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Flow created from the Architect Job */
    public var flow: AddressableEntityRef?
    /** Status of the Architect Job */
    public var status: Status?
    /** The command executed by the Architect Job */
    public var command: Command?
    /** Warnings and Errors messages of the Architect Job */
    public var messages: [ArchitectJobMessage]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, flow: AddressableEntityRef?, status: Status?, command: Command?, messages: [ArchitectJobMessage]?, selfUri: String?) {
        self._id = _id
        self.flow = flow
        self.status = status
        self.command = command
        self.messages = messages
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case flow
        case status
        case command
        case messages
        case selfUri
    }


}




public class ArticleContentBody: Codable {



    /** Presigned URL to retrieve the document content. */
    public var locationUrl: String?

    public init(locationUrl: String?) {
        self.locationUrl = locationUrl
    }


}




public class AssessmentFormQuestion: Codable {



    public enum ModelType: String, Codable { 
        case multiplechoicequestion = "multipleChoiceQuestion"
        case freetextquestion = "freeTextQuestion"
        case npsquestion = "npsQuestion"
        case readonlytextblockquestion = "readOnlyTextBlockQuestion"
    }



















    public var _id: String?
    public var type: ModelType?
    /** The question text */
    public var text: String?
    public var helpText: String?
    public var naEnabled: Bool?
    public var commentsRequired: Bool?
    public var visibilityCondition: VisibilityCondition?
    /** Options from which to choose an answer for this question. Only used by Multiple Choice type questions. */
    public var answerOptions: [AnswerOption]?
    /** How many characters are allowed in the text response to this question. Used by Free Text question types. */
    public var maxResponseCharacters: Int?
    /** Does an incorrect answer to this question mark the form as having a failed kill question. Only used by Multiple Choice type questions. */
    public var isKill: Bool?
    /** Does this question contribute to the critical score. Only used by Multiple Choice type questions. */
    public var isCritical: Bool?

    public init(_id: String?, type: ModelType?, text: String?, helpText: String?, naEnabled: Bool?, commentsRequired: Bool?, visibilityCondition: VisibilityCondition?, answerOptions: [AnswerOption]?, maxResponseCharacters: Int?, isKill: Bool?, isCritical: Bool?) {
        self._id = _id
        self.type = type
        self.text = text
        self.helpText = helpText
        self.naEnabled = naEnabled
        self.commentsRequired = commentsRequired
        self.visibilityCondition = visibilityCondition
        self.answerOptions = answerOptions
        self.maxResponseCharacters = maxResponseCharacters
        self.isKill = isKill
        self.isCritical = isCritical
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
        case text
        case helpText
        case naEnabled
        case commentsRequired
        case visibilityCondition
        case answerOptions
        case maxResponseCharacters
        case isKill
        case isCritical
    }


}




public class AssessmentFormQuestionGroup: Codable {























    /** The ID of the question group, */
    public var _id: String?
    /** The question group name */
    public var name: String?
    /** The question group type */
    public var type: String?
    public var defaultAnswersToHighest: Bool?
    public var defaultAnswersToNA: Bool?
    public var naEnabled: Bool?
    public var weight: Float?
    public var manualWeight: Bool?
    /** The list of questions for this question group */
    public var questions: [AssessmentFormQuestion]?
    public var visibilityCondition: VisibilityCondition?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, type: String?, defaultAnswersToHighest: Bool?, defaultAnswersToNA: Bool?, naEnabled: Bool?, weight: Float?, manualWeight: Bool?, questions: [AssessmentFormQuestion]?, visibilityCondition: VisibilityCondition?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.type = type
        self.defaultAnswersToHighest = defaultAnswersToHighest
        self.defaultAnswersToNA = defaultAnswersToNA
        self.naEnabled = naEnabled
        self.weight = weight
        self.manualWeight = manualWeight
        self.questions = questions
        self.visibilityCondition = visibilityCondition
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case type
        case defaultAnswersToHighest
        case defaultAnswersToNA
        case naEnabled
        case weight
        case manualWeight
        case questions
        case visibilityCondition
        case selfUri
    }


}




public class AssessmentListing: Codable {









    public var entities: [BenefitAssessment]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [BenefitAssessment]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class AssessmentScoringSet: Codable {










    public enum FailureReasons: String, Codable { 
        case score = "Score"
        case criticalScore = "CriticalScore"
        case killQuestion = "KillQuestion"
    }






    /** The total score of the answers */
    public var totalScore: Float?
    /** The total score for the critical questions */
    public var totalCriticalScore: Float?
    /** The total score for the non-critical questions */
    public var totalNonCriticalScore: Float?
    /** The individual scores for each question group */
    public var questionGroupScores: [AssessmentQuestionGroupScore]?
    /** If the assessment was not passed, the reasons for failure. */
    public var failureReasons: [FailureReasons]?
    /** Comments provided for these answers. */
    public var comments: String?
    /** Comments provided by agent. */
    public var agentComments: String?
    /** True if the assessment was passed */
    public var isPassed: Bool?

    public init(totalScore: Float?, totalCriticalScore: Float?, totalNonCriticalScore: Float?, questionGroupScores: [AssessmentQuestionGroupScore]?, failureReasons: [FailureReasons]?, comments: String?, agentComments: String?, isPassed: Bool?) {
        self.totalScore = totalScore
        self.totalCriticalScore = totalCriticalScore
        self.totalNonCriticalScore = totalNonCriticalScore
        self.questionGroupScores = questionGroupScores
        self.failureReasons = failureReasons
        self.comments = comments
        self.agentComments = agentComments
        self.isPassed = isPassed
    }


}




public class AssignedSegment: Codable {





    /** The ID of the segment assigned. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class AssignedWrapupCode: Codable {











    /** The user configured wrap up code id. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The duration in seconds of the wrap-up segment. */
    public var durationSeconds: Int?
    /** The timestamp when the wrap-up segment ended. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}




public class AssociatedValueField: Codable {

    public enum DataType: String, Codable { 
        case number = "Number"
        case integer = "Integer"
    }



    /** The data type of the value field. */
    public var dataType: DataType?
    /** The field name for extracting value from event. */
    public var name: String?

    public init(dataType: DataType?, name: String?) {
        self.dataType = dataType
        self.name = name
    }


}




public class AsyncForecastOperationResult: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }







    /** The status of the operation */
    public var status: Status?
    /** The ID for the operation */
    public var operationId: String?
    /** The result of the operation.  Null unless status == Complete */
    public var result: BuShortTermForecast?
    /** Percent progress for the operation */
    public var progress: Int?

    public init(status: Status?, operationId: String?, result: BuShortTermForecast?, progress: Int?) {
        self.status = status
        self.operationId = operationId
        self.result = result
        self.progress = progress
    }


}




public class AtzmTimeSlotWithTimeZone: Codable {







    /** The earliest time to dial a contact. Valid format is HH:mm */
    public var earliestCallableTime: String?
    /** The latest time to dial a contact. Valid format is HH:mm */
    public var latestCallableTime: String?
    /** The time zone to use for contacts that cannot be mapped. */
    public var timeZoneId: String?

    public init(earliestCallableTime: String?, latestCallableTime: String?, timeZoneId: String?) {
        self.earliestCallableTime = earliestCallableTime
        self.latestCallableTime = latestCallableTime
        self.timeZoneId = timeZoneId
    }


}




public class AuditFilter: Codable {









    /** The name of the field by which to filter. */
    public var name: String?
    /** The type of the filter, DATE or STRING. */
    public var type: String?
    /** The operation that the filter performs. */
    public var _operator: String?
    /** The values to make the filter comparison against. */
    public var values: [String]?

    public init(name: String?, type: String?, _operator: String?, values: [String]?) {
        self.name = name
        self.type = type
        self._operator = _operator
        self.values = values
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case type
        case _operator = "operator"
        case values
    }


}




public class AuditLogMessage: Codable {













    public enum Level: String, Codable { 
        case user = "USER"
        case system = "SYSTEM"
    }











    public enum Status: String, Codable { 
        case success = "SUCCESS"
        case failure = "FAILURE"
        case warning = "WARNING"
    }













    /** Id of the audit message. */
    public var _id: String?
    /** Home Organization Id associated with this audit message. */
    public var userHomeOrgId: String?
    /** User associated with this audit message. */
    public var user: DomainEntityRef?
    /** Client associated with this audit message. */
    public var client: AddressableEntityRef?
    /** List of IP addresses of systems that originated or handled the request. */
    public var remoteIp: [String]?
    /** Name of the service that logged this audit message. */
    public var serviceName: String?
    /** Level of this audit message, USER or SYSTEM. */
    public var level: Level?
    /** Date and time of when the audit message was logged. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDate: Date?
    /** Message describing the event being audited. */
    public var message: MessageInfo?
    /** Action that took place. */
    public var action: String?
    /** Entity that was impacted. */
    public var entity: DomainEntityRef?
    /** Type of the entity that was impacted. */
    public var entityType: String?
    /** Status of the event being audited */
    public var status: Status?
    /** Name of the application used to perform the audit's action */
    public var application: String?
    /** Id and action of the audit initiating the transaction */
    public var initiatingAction: InitiatingAction?
    /** Whether the current audit is the initiator of the transaction */
    public var transactionInitiator: Bool?
    /** List of properties that were changed and changes made to those properties. */
    public var propertyChanges: [PropertyChange]?
    /** Additional context for this message. */
    public var context: [String:String]?
    /** List of entities that were changed and changes made to those entities. */
    public var entityChanges: [EntityChange]?

    public init(_id: String?, userHomeOrgId: String?, user: DomainEntityRef?, client: AddressableEntityRef?, remoteIp: [String]?, serviceName: String?, level: Level?, eventDate: Date?, message: MessageInfo?, action: String?, entity: DomainEntityRef?, entityType: String?, status: Status?, application: String?, initiatingAction: InitiatingAction?, transactionInitiator: Bool?, propertyChanges: [PropertyChange]?, context: [String:String]?, entityChanges: [EntityChange]?) {
        self._id = _id
        self.userHomeOrgId = userHomeOrgId
        self.user = user
        self.client = client
        self.remoteIp = remoteIp
        self.serviceName = serviceName
        self.level = level
        self.eventDate = eventDate
        self.message = message
        self.action = action
        self.entity = entity
        self.entityType = entityType
        self.status = status
        self.application = application
        self.initiatingAction = initiatingAction
        self.transactionInitiator = transactionInitiator
        self.propertyChanges = propertyChanges
        self.context = context
        self.entityChanges = entityChanges
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case userHomeOrgId
        case user
        case client
        case remoteIp
        case serviceName
        case level
        case eventDate
        case message
        case action
        case entity
        case entityType
        case status
        case application
        case initiatingAction
        case transactionInitiator
        case propertyChanges
        case context
        case entityChanges
    }


}




public class AuditMessage: Codable {

































    /** AuditMessage ID. */
    public var _id: String?
    public var user: AuditUser?
    /** Correlation ID. */
    public var correlationId: String?
    /** Transaction ID. */
    public var transactionId: String?
    /** Whether or not this audit can be considered the initiator of the transaction it is a part of. */
    public var transactionInitiator: Bool?
    /** The application through which the action of this AuditMessage was initiated. */
    public var application: String?
    /** The name of the service which sent this AuditMessage. */
    public var serviceName: String?
    /** The level of this audit. USER or SYSTEM. */
    public var level: String?
    /** The time at which the action of this AuditMessage was initiated. */
    public var timestamp: String?
    /** The time at which this AuditMessage was received. */
    public var receivedTimestamp: String?
    /** The status of the action of this AuditMessage */
    public var status: String?
    /** The context of a system-level action */
    public var actionContext: String?
    /** A string representing the action that took place */
    public var action: String?
    /** Details about any changes that occurred in this audit */
    public var changes: [Change]?
    public var entity: AuditEntity?
    /** The service-specific context associated with this AuditMessage. */
    public var serviceContext: ServiceContext?

    public init(_id: String?, user: AuditUser?, correlationId: String?, transactionId: String?, transactionInitiator: Bool?, application: String?, serviceName: String?, level: String?, timestamp: String?, receivedTimestamp: String?, status: String?, actionContext: String?, action: String?, changes: [Change]?, entity: AuditEntity?, serviceContext: ServiceContext?) {
        self._id = _id
        self.user = user
        self.correlationId = correlationId
        self.transactionId = transactionId
        self.transactionInitiator = transactionInitiator
        self.application = application
        self.serviceName = serviceName
        self.level = level
        self.timestamp = timestamp
        self.receivedTimestamp = receivedTimestamp
        self.status = status
        self.actionContext = actionContext
        self.action = action
        self.changes = changes
        self.entity = entity
        self.serviceContext = serviceContext
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case user
        case correlationId
        case transactionId
        case transactionInitiator
        case application
        case serviceName
        case level
        case timestamp
        case receivedTimestamp
        case status
        case actionContext
        case action
        case changes
        case entity
        case serviceContext
    }


}




public class AuditQueryRequest: Codable {









    /** Date and time range of data to query. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ssZ/YYYY-MM-DDThh:mm:ssZ */
    public var interval: String?
    /** Name of the service to query audits for. */
    public var serviceName: String?
    /** Additional filters for the query. */
    public var filters: [AuditQueryFilter]?
    /** Sort parameter for the query. */
    public var sort: [AuditQuerySort]?

    public init(interval: String?, serviceName: String?, filters: [AuditQueryFilter]?, sort: [AuditQuerySort]?) {
        self.interval = interval
        self.serviceName = serviceName
        self.filters = filters
        self.sort = sort
    }


}




public class AuditRealtimeQueryResultsResponse: Codable {











    public var entities: [AuditLogMessage]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var pageCount: Int?

    public init(entities: [AuditLogMessage]?, pageSize: Int?, pageNumber: Int?, total: Int64?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.pageCount = pageCount
    }


}




public class AuthorizationSettings: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Boolean showing if organization is opted in or not to unused role/perm analysis */
    public var analysisEnabled: Bool?
    /** Integer number of days to analyze user usage */
    public var analysisDays: Int?
    /** The date and time of the most recent unused role calculation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateLastCalculated: Date?
    /** The date of the most recent org activity used for analysis. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateLastActive: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, analysisEnabled: Bool?, analysisDays: Int?, dateLastCalculated: Date?, dateLastActive: Date?, selfUri: String?) {
        self._id = _id
        self.analysisEnabled = analysisEnabled
        self.analysisDays = analysisDays
        self.dateLastCalculated = dateLastCalculated
        self.dateLastActive = dateLastActive
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case analysisEnabled
        case analysisDays
        case dateLastCalculated
        case dateLastActive
        case selfUri
    }


}




public class AuthzGrant: Codable {









    public var subjectId: String?
    public var division: AuthzDivision?
    public var role: AuthzGrantRole?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var grantMadeAt: Date?

    public init(subjectId: String?, division: AuthzDivision?, role: AuthzGrantRole?, grantMadeAt: Date?) {
        self.subjectId = subjectId
        self.division = division
        self.role = role
        self.grantMadeAt = grantMadeAt
    }


}




public class AvailableMediaTypeEntityListing: Codable {



    public var entities: [AvailableMediaType]?

    public init(entities: [AvailableMediaType]?) {
        self.entities = entities
    }


}




public class AvailableTimeOffRange: Codable {





    public enum Granularity: String, Codable { 
        case daily = "Daily"
    }







    /** The time off limit */
    public var timeOffLimit: TimeOffLimitReference?
    /** Start date of the requested date range. The end date is determined by the size of interval list. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var startDate: Date?
    /** Granularity choice for time off limit */
    public var granularity: Granularity?
    /** The list of available time off values in minutes per granularity interval */
    public var availableMinutesPerInterval: [Int]?
    /** The current number of waitlisted time off requests for every interval per granularity */
    public var waitlistedRequestsPerInterval: [Int]?
    /** Whether the time off request can be waitlisted */
    public var waitlistEnabled: Bool?

    public init(timeOffLimit: TimeOffLimitReference?, startDate: Date?, granularity: Granularity?, availableMinutesPerInterval: [Int]?, waitlistedRequestsPerInterval: [Int]?, waitlistEnabled: Bool?) {
        self.timeOffLimit = timeOffLimit
        self.startDate = startDate
        self.granularity = granularity
        self.availableMinutesPerInterval = availableMinutesPerInterval
        self.waitlistedRequestsPerInterval = waitlistedRequestsPerInterval
        self.waitlistEnabled = waitlistEnabled
    }


}




public class BaseTopicEntitiy: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}




public class BatchDownloadJobStatusResult: Codable {















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** JobId returned when job was initially submitted */
    public var jobId: String?
    /** Number of results expected when job is completed */
    public var expectedResultCount: Int?
    /** Current number of results available */
    public var resultCount: Int?
    /** Number of error results produced so far */
    public var errorCount: Int?
    /** Current set of results for the job */
    public var results: [BatchDownloadJobResult]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, jobId: String?, expectedResultCount: Int?, resultCount: Int?, errorCount: Int?, results: [BatchDownloadJobResult]?, selfUri: String?) {
        self._id = _id
        self.jobId = jobId
        self.expectedResultCount = expectedResultCount
        self.resultCount = resultCount
        self.errorCount = errorCount
        self.results = results
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case jobId
        case expectedResultCount
        case resultCount
        case errorCount
        case results
        case selfUri
    }


}




public class BatchDownloadJobSubmission: Codable {



    /** List of up to 100 items requested */
    public var batchDownloadRequestList: [BatchDownloadRequest]?

    public init(batchDownloadRequestList: [BatchDownloadRequest]?) {
        self.batchDownloadRequestList = batchDownloadRequestList
    }


}



/** A maximum of 100 events are allowed per request */

public class BatchUserPresenceEventRequest: Codable {



    /** UserPresence events for this batch */
    public var userPresenceEvents: [UserPresenceEvent]?

    public init(userPresenceEvents: [UserPresenceEvent]?) {
        self.userPresenceEvents = userPresenceEvents
    }


}




public class BillingUsageReport: Codable {









    public enum Status: String, Codable { 
        case inProgress = "InProgress"
        case complete = "Complete"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The period start date. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** The period end date. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endDate: Date?
    /** Generation status of report */
    public var status: Status?
    /** The usages for the given period. */
    public var usages: [BillingUsage]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, startDate: Date?, endDate: Date?, status: Status?, usages: [BillingUsage]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.startDate = startDate
        self.endDate = endDate
        self.status = status
        self.usages = usages
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case startDate
        case endDate
        case status
        case usages
        case selfUri
    }


}




public class BotAggregateQueryResponse: Codable {



    public var results: [BotAggregateDataContainer]?

    public init(results: [BotAggregateDataContainer]?) {
        self.results = results
    }


}




public class BotAggregationView: Codable {

    public enum Target: String, Codable { 
        case nbotsessionturns = "nBotSessionTurns"
        case nbotsessions = "nBotSessions"
        case obotintent = "oBotIntent"
        case obotsessionquery = "oBotSessionQuery"
        case obotsessionqueryselfserved = "oBotSessionQuerySelfServed"
        case obotsessionturn = "oBotSessionTurn"
        case obotslot = "oBotSlot"
        case tbotdisconnect = "tBotDisconnect"
        case tbotexit = "tBotExit"
        case tbotrecognitionfailure = "tBotRecognitionFailure"
        case tbotsession = "tBotSession"
    }



    public enum Function: String, Codable { 
        case rangebound = "rangeBound"
    }



    /** Target metric name */
    public var target: Target?
    /** A unique name for this view. Must be distinct from other views and built-in metric names. */
    public var name: String?
    /** Type of view you wish to create */
    public var function: Function?
    /** Range of numbers for slicing up data */
    public var range: AggregationRange?

    public init(target: Target?, name: String?, function: Function?, range: AggregationRange?) {
        self.target = target
        self.name = name
        self.function = function
        self.range = range
    }


}




public class BotConnectorBotSummaryEntityListing: Codable {





















    public var entities: [BotSummary]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [BotSummary]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** A version description for a botConnector bot. */

public class BotConnectorBotVersion: Codable {







    /** The name of the version. This can be up to 100 characters long and must be comprised of displayable characters without leading or trailing whitespace */
    public var version: String?
    /** The supported languages for this bot. EG 'en-us' or 'es', etc; These language codes are W3C language identification tags (ISO 639-1 for the language name and ISO 3166 for the country code) */
    public var supportedLanguages: [String]?
    /** A list of potential intents this bot will return, limit of 50 */
    public var intents: [BotIntent]?

    public init(version: String?, supportedLanguages: [String]?, intents: [BotIntent]?) {
        self.version = version
        self.supportedLanguages = supportedLanguages
        self.intents = intents
    }


}




public class BuAgentScheduleHistoryChange: Codable {









    /** The metadata of the change, including who and when the change was made */
    public var metadata: BuAgentScheduleHistoryChangeMetadata?
    /** The list of changed shifts */
    public var shifts: [BuAgentScheduleShift]?
    /** The list of changed full day time off markers */
    public var fullDayTimeOffMarkers: [BuFullDayTimeOffMarker]?
    /** The deleted shifts, full day time off markers, or the entire agent schedule */
    public var deletes: BuAgentScheduleHistoryDeletedChange?

    public init(metadata: BuAgentScheduleHistoryChangeMetadata?, shifts: [BuAgentScheduleShift]?, fullDayTimeOffMarkers: [BuFullDayTimeOffMarker]?, deletes: BuAgentScheduleHistoryDeletedChange?) {
        self.metadata = metadata
        self.shifts = shifts
        self.fullDayTimeOffMarkers = fullDayTimeOffMarkers
        self.deletes = deletes
    }


}




public class BuAgentScheduleHistoryDeletedChange: Codable {







    /** The IDs of deleted shifts */
    public var shiftIds: [String]?
    /** The dates of any deleted full day time off markers */
    public var fullDayTimeOffMarkerDates: [Date]?
    /** Whether the entire agent schedule was deleted */
    public var agentSchedule: Bool?

    public init(shiftIds: [String]?, fullDayTimeOffMarkerDates: [Date]?, agentSchedule: Bool?) {
        self.shiftIds = shiftIds
        self.fullDayTimeOffMarkerDates = fullDayTimeOffMarkerDates
        self.agentSchedule = agentSchedule
    }


}




public class BuAgentScheduleHistoryResponse: Codable {









    /** The list of previously published schedules */
    public var priorPublishedSchedules: [BuScheduleReference]?
    /** The originally published agent schedules */
    public var basePublishedSchedule: BuAgentScheduleHistoryChange?
    /** The changes dropped from the schedule history. This will happen if the schedule history is too large */
    public var droppedChanges: [BuAgentScheduleHistoryDroppedChange]?
    /** The list of changes for the schedule history */
    public var changes: [BuAgentScheduleHistoryChange]?

    public init(priorPublishedSchedules: [BuScheduleReference]?, basePublishedSchedule: BuAgentScheduleHistoryChange?, droppedChanges: [BuAgentScheduleHistoryDroppedChange]?, changes: [BuAgentScheduleHistoryChange]?) {
        self.priorPublishedSchedules = priorPublishedSchedules
        self.basePublishedSchedule = basePublishedSchedule
        self.droppedChanges = droppedChanges
        self.changes = changes
    }


}




public class BuAgentScheduleQueryResponse: Codable {













    /** The user to whom this agent schedule applies */
    public var user: UserReference?
    /** The shift definitions for this agent schedule */
    public var shifts: [BuAgentScheduleShift]?
    /** Full day time off markers which apply to this agent schedule */
    public var fullDayTimeOffMarkers: [BuFullDayTimeOffMarker]?
    /** The work plan for this user */
    public var workPlan: WorkPlanReference?
    /** The work plans per week for this user from the work plan rotation. Null values in the list denotes that user is not part of any work plan for that week */
    public var workPlansPerWeek: [WorkPlanReference]?
    /** Versioned entity metadata for this agent schedule */
    public var metadata: WfmVersionedEntityMetadata?

    public init(user: UserReference?, shifts: [BuAgentScheduleShift]?, fullDayTimeOffMarkers: [BuFullDayTimeOffMarker]?, workPlan: WorkPlanReference?, workPlansPerWeek: [WorkPlanReference]?, metadata: WfmVersionedEntityMetadata?) {
        self.user = user
        self.shifts = shifts
        self.fullDayTimeOffMarkers = fullDayTimeOffMarkers
        self.workPlan = workPlan
        self.workPlansPerWeek = workPlansPerWeek
        self.metadata = metadata
    }


}




public class BuAgentScheduleUpdate: Codable {

    public enum ModelType: String, Codable { 
        case added = "Added"
        case edited = "Edited"
        case deleted = "Deleted"
    }



    /** The type of update */
    public var type: ModelType?
    /** The start date for the affected shifts */
    public var shiftStartDates: [Date]?

    public init(type: ModelType?, shiftStartDates: [Date]?) {
        self.type = type
        self.shiftStartDates = shiftStartDates
    }


}




public class BuAgentSchedulesQueryResponse: Codable {





    /** The requested agent schedules */
    public var agentSchedules: [BuAgentScheduleQueryResponse]?
    /** The time zone configured for the business unit to which these schedules apply */
    public var businessUnitTimeZone: String?

    public init(agentSchedules: [BuAgentScheduleQueryResponse]?, businessUnitTimeZone: String?) {
        self.agentSchedules = agentSchedules
        self.businessUnitTimeZone = businessUnitTimeZone
    }


}




public class BuAsyncAgentSchedulesQueryResponse: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }









    /** The status of the operation */
    public var status: Status?
    /** The ID for the operation */
    public var operationId: String?
    /** The result of the operation.  Null unless status == Complete */
    public var result: BuAgentSchedulesQueryResponse?
    /** Percent progress for the operation */
    public var progress: Int?
    /** The URL from which to download the result if it is too large to pass directly */
    public var downloadUrl: String?

    public init(status: Status?, operationId: String?, result: BuAgentSchedulesQueryResponse?, progress: Int?, downloadUrl: String?) {
        self.status = status
        self.operationId = operationId
        self.result = result
        self.progress = progress
        self.downloadUrl = downloadUrl
    }


}




public class BuAsyncScheduleRunResponse: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }





    /** The status of the operation */
    public var status: Status?
    /** The ID for the operation */
    public var operationId: String?
    /** The result of the operation.  Null unless status == Complete */
    public var result: BuScheduleRun?

    public init(status: Status?, operationId: String?, result: BuScheduleRun?) {
        self.status = status
        self.operationId = operationId
        self.result = result
    }


}




public class BuCopyScheduleRequest: Codable {





    /** The description for the new schedule */
    public var _description: String?
    /** The start weekDate for the new copy of the schedule. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekDate: Date?

    public init(_description: String?, weekDate: Date?) {
        self._description = _description
        self.weekDate = weekDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _description = "description"
        case weekDate
    }


}




public class BuForecastResultResponse: Codable {





    /** The result of the operation.  Populated whenever the result is small enough to pass through the api directly */
    public var result: BuForecastResult?
    /** The download url to fetch the result.  Only populated if the result is too large to pass through the api directly */
    public var downloadUrl: String?

    public init(result: BuForecastResult?, downloadUrl: String?) {
        self.result = result
        self.downloadUrl = downloadUrl
    }


}




public class BuForecastStaffingRequirementsResult: Codable {









    /** The week number represented by this response */
    public var weekNumber: Int?
    /** The url to get the requirements results for this week */
    public var downloadUrl: String?
    /** The expiration date of the download url, as an ISO-8601 string */
    public var downloadUrlExpirationDate: Date?
    /** Results will always come via downloadUrl, however the schema is included for documentation */
    public var planningGroupStaffingRequirements: [StaffingRequirementsPlanningGroupData]?

    public init(weekNumber: Int?, downloadUrl: String?, downloadUrlExpirationDate: Date?, planningGroupStaffingRequirements: [StaffingRequirementsPlanningGroupData]?) {
        self.weekNumber = weekNumber
        self.downloadUrl = downloadUrl
        self.downloadUrlExpirationDate = downloadUrlExpirationDate
        self.planningGroupStaffingRequirements = planningGroupStaffingRequirements
    }


}




public class BuGenerateScheduleRequest: Codable {









    /** The description for the schedule */
    public var _description: String?
    /** The forecast to use when generating the schedule.  Note that the forecast must fully encompass the schedule's start week + week count */
    public var shortTermForecast: BuShortTermForecastReference?
    /** The number of weeks in the schedule. One extra day is added at the end */
    public var weekCount: Int?
    /** Additional scheduling options */
    public var options: SchedulingOptionsRequest?

    public init(_description: String?, shortTermForecast: BuShortTermForecastReference?, weekCount: Int?, options: SchedulingOptionsRequest?) {
        self._description = _description
        self.shortTermForecast = shortTermForecast
        self.weekCount = weekCount
        self.options = options
    }

    public enum CodingKeys: String, CodingKey { 
        case _description = "description"
        case shortTermForecast
        case weekCount
        case options
    }


}




public class BuImportAgentScheduleUploadSchema: Codable {











    /** The ID of the user to whom this agent schedule applies */
    public var userId: String?
    /** The ID of the work plan for this user.  Mutually exclusive with workPlanIdsPerWeek */
    public var workPlanId: ValueWrapperString?
    /** The IDs of the work plans per week for this user.  Mutually exclusive with workPlanId */
    public var workPlanIdsPerWeek: ListWrapperString?
    /** The shift definitions for this agent schedule */
    public var shifts: [BuAgentScheduleShift]?
    /** Any full day time off markers that apply to this agent schedule */
    public var fullDayTimeOffMarkers: [BuFullDayTimeOffMarker]?

    public init(userId: String?, workPlanId: ValueWrapperString?, workPlanIdsPerWeek: ListWrapperString?, shifts: [BuAgentScheduleShift]?, fullDayTimeOffMarkers: [BuFullDayTimeOffMarker]?) {
        self.userId = userId
        self.workPlanId = workPlanId
        self.workPlanIdsPerWeek = workPlanIdsPerWeek
        self.shifts = shifts
        self.fullDayTimeOffMarkers = fullDayTimeOffMarkers
    }


}




public class BuIntradayForecastData: Codable {





    /** The number of interactions routed into the queues in the selected planning groups for the given media type for an agent to answer */
    public var offered: Double?
    /** The average handle time in seconds an agent spent handling interactions */
    public var averageHandleTimeSeconds: Double?

    public init(offered: Double?, averageHandleTimeSeconds: Double?) {
        self.offered = offered
        self.averageHandleTimeSeconds = averageHandleTimeSeconds
    }


}




public class BuIntradayScheduleData: Codable {



    /** The total on-queue time in seconds for all agents in this group */
    public var onQueueTimeSeconds: Int64?

    public init(onQueueTimeSeconds: Int64?) {
        self.onQueueTimeSeconds = onQueueTimeSeconds
    }


}




public class BuPlanningGroupHeadcountForecast: Codable {







    /** The planning group to which this portion of the headcount forecast applies */
    public var planningGroup: PlanningGroupReference?
    /** Required headcount per interval, referenced against the reference start date */
    public var requiredPerInterval: [Double]?
    /** Required headcount per interval without accounting for shrinkage, referenced against the reference start date */
    public var requiredWithoutShrinkagePerInterval: [Double]?

    public init(planningGroup: PlanningGroupReference?, requiredPerInterval: [Double]?, requiredWithoutShrinkagePerInterval: [Double]?) {
        self.planningGroup = planningGroup
        self.requiredPerInterval = requiredPerInterval
        self.requiredWithoutShrinkagePerInterval = requiredWithoutShrinkagePerInterval
    }


}




public class BuQueryAdherenceExplanationsRequest: Codable {









    /** The start date of the range to query. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** The end date of the range to query. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endDate: Date?
    /** A filter for which management units to query. Leave empty or omit entirely for all management units in the business unit */
    public var managementUnitIds: [String]?
    /** A filter for which agents within the business unit to query. Leave empty or omit entirely for all agents in the business unit (or management units if specified) */
    public var agentIds: [String]?

    public init(startDate: Date?, endDate: Date?, managementUnitIds: [String]?, agentIds: [String]?) {
        self.startDate = startDate
        self.endDate = endDate
        self.managementUnitIds = managementUnitIds
        self.agentIds = agentIds
    }


}




public class BuScheduleListItem: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The start week date for this schedule. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekDate: Date?
    /** The number of weeks spanned by this schedule */
    public var weekCount: Int?
    /** The description of this schedule */
    public var _description: String?
    /** Whether this schedule is published */
    public var published: Bool?
    /** The forecast used for this schedule, if applicable */
    public var shortTermForecast: BuShortTermForecastReference?
    /** Generation result summary for this schedule, if applicable */
    public var generationResults: ScheduleGenerationResultSummary?
    /** Version metadata for this schedule */
    public var metadata: WfmVersionedEntityMetadata?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, weekDate: Date?, weekCount: Int?, _description: String?, published: Bool?, shortTermForecast: BuShortTermForecastReference?, generationResults: ScheduleGenerationResultSummary?, metadata: WfmVersionedEntityMetadata?, selfUri: String?) {
        self._id = _id
        self.weekDate = weekDate
        self.weekCount = weekCount
        self._description = _description
        self.published = published
        self.shortTermForecast = shortTermForecast
        self.generationResults = generationResults
        self.metadata = metadata
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case weekCount
        case _description = "description"
        case published
        case shortTermForecast
        case generationResults
        case metadata
        case selfUri
    }


}




public class BuScheduleMetadata: Codable {





















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The start week date for this schedule. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekDate: Date?
    /** The number of weeks spanned by this schedule */
    public var weekCount: Int?
    /** The description of this schedule */
    public var _description: String?
    /** Whether this schedule is published */
    public var published: Bool?
    /** The forecast used for this schedule, if applicable */
    public var shortTermForecast: BuShortTermForecastReference?
    /** Generation result summary for this schedule, if applicable */
    public var generationResults: ScheduleGenerationResultSummary?
    /** Version metadata for this schedule */
    public var metadata: WfmVersionedEntityMetadata?
    /** High level per-management unit schedule metadata */
    public var managementUnits: [BuManagementUnitScheduleSummary]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, weekDate: Date?, weekCount: Int?, _description: String?, published: Bool?, shortTermForecast: BuShortTermForecastReference?, generationResults: ScheduleGenerationResultSummary?, metadata: WfmVersionedEntityMetadata?, managementUnits: [BuManagementUnitScheduleSummary]?, selfUri: String?) {
        self._id = _id
        self.weekDate = weekDate
        self.weekCount = weekCount
        self._description = _description
        self.published = published
        self.shortTermForecast = shortTermForecast
        self.generationResults = generationResults
        self.metadata = metadata
        self.managementUnits = managementUnits
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case weekCount
        case _description = "description"
        case published
        case shortTermForecast
        case generationResults
        case metadata
        case managementUnits
        case selfUri
    }


}




public class BuScheduleReference: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The start week date for this schedule. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekDate: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, weekDate: Date?, selfUri: String?) {
        self._id = _id
        self.weekDate = weekDate
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case selfUri
    }


}




public class BuSchedulingSettingsRequest: Codable {









    /** Schedule generation message severity configuration */
    public var messageSeverities: [SchedulerMessageTypeSeverity]?
    /** Synchronize set of time off properties from scheduled activities to time off requests when the schedule is published. */
    public var syncTimeOffProperties: SetWrapperSyncTimeOffProperty?
    /** Configures the max percent increase and decrease of service goals for this business unit */
    public var serviceGoalImpact: WfmServiceGoalImpactSettings?
    /** Indicates whether or not per minute granularity for scheduling will be enabled for this business unit. Defaults to false. */
    public var allowWorkPlanPerMinuteGranularity: Bool?

    public init(messageSeverities: [SchedulerMessageTypeSeverity]?, syncTimeOffProperties: SetWrapperSyncTimeOffProperty?, serviceGoalImpact: WfmServiceGoalImpactSettings?, allowWorkPlanPerMinuteGranularity: Bool?) {
        self.messageSeverities = messageSeverities
        self.syncTimeOffProperties = syncTimeOffProperties
        self.serviceGoalImpact = serviceGoalImpact
        self.allowWorkPlanPerMinuteGranularity = allowWorkPlanPerMinuteGranularity
    }


}




public class BuShortTermForecast: Codable {







    public enum CreationMethod: String, Codable { 
        case _import = "Import"
        case importedHistoricalWeightedAverage = "ImportedHistoricalWeightedAverage"
        case historicalWeightedAverage = "HistoricalWeightedAverage"
        case advanced = "Advanced"
    }

























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The start week date of this forecast in yyyy-MM-dd.  Must fall on the start day of week for the associated business unit. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekDate: Date?
    /** The number of weeks this forecast covers */
    public var weekCount: Int?
    /** The method by which this forecast was created */
    public var creationMethod: CreationMethod?
    /** The description of this forecast */
    public var _description: String?
    /** Whether this forecast contains modifications on legacy metrics */
    public var legacy: Bool?
    /** Metadata for this forecast */
    public var metadata: WfmVersionedEntityMetadata?
    /** Whether this forecast can be used for scheduling */
    public var canUseForScheduling: Bool?
    /** The reference start date for interval-based data for this forecast. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var referenceStartDate: Date?
    /** The source day pointers for this forecast */
    public var sourceDays: [ForecastSourceDayPointer]?
    /** Any manual modifications applied to this forecast */
    public var modifications: [BuForecastModificationResponse]?
    /** Generation result metadata */
    public var generationResults: BuForecastGenerationResult?
    /** The time zone for this forecast */
    public var timeZone: String?
    /** The version of the planning groups that was used for this forecast */
    public var planningGroupsVersion: Int?
    /** A snapshot of the planning groups used for this forecast as of the version number indicated */
    public var planningGroups: ForecastPlanningGroupsResponse?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, weekDate: Date?, weekCount: Int?, creationMethod: CreationMethod?, _description: String?, legacy: Bool?, metadata: WfmVersionedEntityMetadata?, canUseForScheduling: Bool?, referenceStartDate: Date?, sourceDays: [ForecastSourceDayPointer]?, modifications: [BuForecastModificationResponse]?, generationResults: BuForecastGenerationResult?, timeZone: String?, planningGroupsVersion: Int?, planningGroups: ForecastPlanningGroupsResponse?, selfUri: String?) {
        self._id = _id
        self.weekDate = weekDate
        self.weekCount = weekCount
        self.creationMethod = creationMethod
        self._description = _description
        self.legacy = legacy
        self.metadata = metadata
        self.canUseForScheduling = canUseForScheduling
        self.referenceStartDate = referenceStartDate
        self.sourceDays = sourceDays
        self.modifications = modifications
        self.generationResults = generationResults
        self.timeZone = timeZone
        self.planningGroupsVersion = planningGroupsVersion
        self.planningGroups = planningGroups
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case weekCount
        case creationMethod
        case _description = "description"
        case legacy
        case metadata
        case canUseForScheduling
        case referenceStartDate
        case sourceDays
        case modifications
        case generationResults
        case timeZone
        case planningGroupsVersion
        case planningGroups
        case selfUri
    }


}




public class BuShortTermForecastListing: Codable {



    public var entities: [BuShortTermForecastListItem]?

    public init(entities: [BuShortTermForecastListItem]?) {
        self.entities = entities
    }


}




public class BuUpdateAgentScheduleShift: Codable {















    /** The ID of the shift */
    public var _id: String?
    /** The start date of this shift. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** The length of this shift in minutes */
    public var lengthMinutes: Int?
    /** The activities associated with this shift */
    public var activities: [BuAgentScheduleActivity]?
    /** Whether this shift was manually edited. This is only set by clients and is used for rescheduling */
    public var manuallyEdited: Bool?
    /** The schedule to which this shift belongs */
    public var schedule: BuScheduleReference?
    /** Set to true to delete the shift from the agent's schedule */
    public var delete: Bool?

    public init(_id: String?, startDate: Date?, lengthMinutes: Int?, activities: [BuAgentScheduleActivity]?, manuallyEdited: Bool?, schedule: BuScheduleReference?, delete: Bool?) {
        self._id = _id
        self.startDate = startDate
        self.lengthMinutes = lengthMinutes
        self.activities = activities
        self.manuallyEdited = manuallyEdited
        self.schedule = schedule
        self.delete = delete
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case startDate
        case lengthMinutes
        case activities
        case manuallyEdited
        case schedule
        case delete
    }


}




public class BulkCallbackPatchResponse: Codable {







    /** A list of the results from the bulk operation. */
    public var results: [BulkResult]?
    /** The number of errors from the bulk operation. */
    public var errorCount: Int?
    /** An index of where the errors are in the listing. */
    public var errorIndexes: [Int]?

    public init(results: [BulkResult]?, errorCount: Int?, errorIndexes: [Int]?) {
        self.results = results
        self.errorCount = errorCount
        self.errorIndexes = errorIndexes
    }


}




public class BulkErrorEntity: Codable {













    public var code: String?
    public var message: String?
    public var status: Int?
    public var retryable: Bool?
    public var entity: Entity?
    public var details: [BulkErrorDetail]?

    public init(code: String?, message: String?, status: Int?, retryable: Bool?, entity: Entity?, details: [BulkErrorDetail]?) {
        self.code = code
        self.message = message
        self.status = status
        self.retryable = retryable
        self.entity = entity
        self.details = details
    }


}




public class BulkOrganizationsRequest: Codable {



    public var entities: [ExternalOrganization]?

    public init(entities: [ExternalOrganization]?) {
        self.entities = entities
    }


}




public class BulkResponseResultExternalContactEntity: Codable {









    public var _id: String?
    public var success: Bool?
    public var entity: ExternalContact?
    public var error: BulkErrorEntity?

    public init(_id: String?, success: Bool?, entity: ExternalContact?, error: BulkErrorEntity?) {
        self._id = _id
        self.success = success
        self.entity = entity
        self.error = error
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case success
        case entity
        case error
    }


}




public class BulkResponseResultExternalOrganizationExternalOrganization: Codable {









    public var _id: String?
    public var success: Bool?
    public var entity: ExternalOrganization?
    public var error: BulkErrorExternalOrganization?

    public init(_id: String?, success: Bool?, entity: ExternalOrganization?, error: BulkErrorExternalOrganization?) {
        self._id = _id
        self.success = success
        self.entity = entity
        self.error = error
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case success
        case entity
        case error
    }


}




public class BulkResponseResultNoteEntity: Codable {









    public var _id: String?
    public var success: Bool?
    public var entity: Note?
    public var error: BulkErrorEntity?

    public init(_id: String?, success: Bool?, entity: Note?, error: BulkErrorEntity?) {
        self._id = _id
        self.success = success
        self.entity = entity
        self.error = error
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case success
        case entity
        case error
    }


}




public class BulkResponseResultRelationshipEntity: Codable {









    public var _id: String?
    public var success: Bool?
    public var entity: Relationship?
    public var error: BulkErrorEntity?

    public init(_id: String?, success: Bool?, entity: Relationship?, error: BulkErrorEntity?) {
        self._id = _id
        self.success = success
        self.entity = entity
        self.error = error
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case success
        case entity
        case error
    }


}




public class BulkResult: Codable {





    /** Error details if the operation failed. */
    public var error: BulkError?
    /** The result of the operation if it succeeded. */
    public var entity: JSON?

    public init(error: BulkError?, entity: JSON?) {
        self.error = error
        self.entity = entity
    }


}




public class BulkUpdateShiftTradeStateRequestItem: Codable {



    public enum State: String, Codable { 
        case unmatched = "Unmatched"
        case matched = "Matched"
        case approved = "Approved"
        case denied = "Denied"
        case expired = "Expired"
        case canceled = "Canceled"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The new state to set on the shift trade */
    public var state: State?
    /** Version metadata for the shift trade */
    public var metadata: WfmVersionedEntityMetadata?

    public init(_id: String?, state: State?, metadata: WfmVersionedEntityMetadata?) {
        self._id = _id
        self.state = state
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case metadata
    }


}




public class BulkUpdateShiftTradeStateResult: Codable {



    public var entities: [BulkUpdateShiftTradeStateResultItem]?

    public init(entities: [BulkUpdateShiftTradeStateResultItem]?) {
        self.entities = entities
    }


}




public class Bullseye: Codable {



    /** The bullseye rings configured for this queue. */
    public var rings: [Ring]?

    public init(rings: [Ring]?) {
        self.rings = rings
    }


}




public class BusinessUnitResponse: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Settings for this business unit */
    public var settings: BusinessUnitSettingsResponse?
    /** The division to which this entity belongs. */
    public var division: DivisionReference?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, settings: BusinessUnitSettingsResponse?, division: DivisionReference?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.settings = settings
        self.division = division
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case settings
        case division
        case selfUri
    }


}



/** Defines an external media that has been ingested and cached by Genesys Cloud for conversation messaging */

public class CachedMediaItem: Codable {

















    /** The unique identifier for the cached media. */
    public var _id: String?
    /** The URL that represents the external media that has been cached */
    public var url: String?
    /** A URL to fetch the cached media */
    public var downloadUrl: String?
    /** The media type for the URL */
    public var mediaType: String?
    /** The content length of the media represented by the URL, in bytes. */
    public var contentLengthBytes: Int?
    /** The date the cached item was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date the cached item expires and will be removed from the cache. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateExpires: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, url: String?, downloadUrl: String?, mediaType: String?, contentLengthBytes: Int?, dateCreated: Date?, dateExpires: Date?, selfUri: String?) {
        self._id = _id
        self.url = url
        self.downloadUrl = downloadUrl
        self.mediaType = mediaType
        self.contentLengthBytes = contentLengthBytes
        self.dateCreated = dateCreated
        self.dateExpires = dateExpires
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case url
        case downloadUrl
        case mediaType
        case contentLengthBytes
        case dateCreated
        case dateExpires
        case selfUri
    }


}




public class CalibrationAssignment: Codable {









    public var calibrator: User?
    public var evaluators: [User]?
    public var evaluationForm: EvaluationForm?
    public var expertEvaluator: User?

    public init(calibrator: User?, evaluators: [User]?, evaluationForm: EvaluationForm?, expertEvaluator: User?) {
        self.calibrator = calibrator
        self.evaluators = evaluators
        self.evaluationForm = evaluationForm
        self.expertEvaluator = expertEvaluator
    }


}




public class CallBasic: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case _none = "none"
    }



    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }



    public enum RecordingState: String, Codable { 
        case _none = "none"
        case active = "active"
        case paused = "paused"
    }















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDonotdisturb = "endpoint.donotdisturb"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferDonotdisturb = "transfer.donotdisturb"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }







































    /** The connection state of this communication. */
    public var state: State?
    /** The initial connection state of this communication. */
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The direction of the call */
    public var direction: Direction?
    /** True if this call is being recorded. */
    public var recording: Bool?
    /** State of recording on this call. */
    public var recordingState: RecordingState?
    /** True if this call is muted so that remote participants can't hear any audio from this end. */
    public var muted: Bool?
    /** True if this call is held and the person on this side hears hold music. */
    public var confined: Bool?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** True when the recording of this call is in secure pause status. */
    public var securePause: Bool?
    /** A globally unique identifier for the recording associated with this call. */
    public var recordingId: String?
    /** The time line of the participant's call, divided into activity segments. */
    public var segments: [Segment]?
    public var errorInfo: ErrorInfo?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the call was placed on hold in the cloud clock if the call is currently on hold. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startHoldTime: Date?
    /** If call is an outbound fax of a document from content management, then this is the id in content management. */
    public var documentId: String?
    /** The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAlertingTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var disconnectedTime: Date?
    /** List of reasons that this call was disconnected. This will be set once the call disconnects. */
    public var disconnectReasons: [DisconnectReason]?
    /** Extra information on fax transmission. */
    public var faxStatus: FaxStatus?
    /** The source provider for the call. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** User to User Information (UUI) data managed by SIP session application. */
    public var uuiData: String?
    /** Address and name data for a call endpoint. */
    public var _self: Address?
    /** Address and name data for a call endpoint. */
    public var other: Address?
    /** Call wrap up or disposition data. */
    public var wrapup: Wrapup?
    /** After-call work for the communication. */
    public var afterCallWork: AfterCallWork?
    /** Indicates if after-call work is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** UUID of virtual agent assistant that provide suggestions to the agent participant during the conversation. */
    public var agentAssistantId: String?
    /** Represents the queue settings for this media type. */
    public var queueMediaSettings: ConversationQueueMediaSettings?
    /** Call resolution data for Dialer bulk make calls commands. */
    public var disposition: Disposition?

    public init(state: State?, initialState: InitialState?, _id: String?, direction: Direction?, recording: Bool?, recordingState: RecordingState?, muted: Bool?, confined: Bool?, held: Bool?, securePause: Bool?, recordingId: String?, segments: [Segment]?, errorInfo: ErrorInfo?, disconnectType: DisconnectType?, startHoldTime: Date?, documentId: String?, startAlertingTime: Date?, connectedTime: Date?, disconnectedTime: Date?, disconnectReasons: [DisconnectReason]?, faxStatus: FaxStatus?, provider: String?, scriptId: String?, peerId: String?, uuiData: String?, _self: Address?, other: Address?, wrapup: Wrapup?, afterCallWork: AfterCallWork?, afterCallWorkRequired: Bool?, agentAssistantId: String?, queueMediaSettings: ConversationQueueMediaSettings?, disposition: Disposition?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.direction = direction
        self.recording = recording
        self.recordingState = recordingState
        self.muted = muted
        self.confined = confined
        self.held = held
        self.securePause = securePause
        self.recordingId = recordingId
        self.segments = segments
        self.errorInfo = errorInfo
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.documentId = documentId
        self.startAlertingTime = startAlertingTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.disconnectReasons = disconnectReasons
        self.faxStatus = faxStatus
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.uuiData = uuiData
        self._self = _self
        self.other = other
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.agentAssistantId = agentAssistantId
        self.queueMediaSettings = queueMediaSettings
        self.disposition = disposition
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case direction
        case recording
        case recordingState
        case muted
        case confined
        case held
        case securePause
        case recordingId
        case segments
        case errorInfo
        case disconnectType
        case startHoldTime
        case documentId
        case startAlertingTime
        case connectedTime
        case disconnectedTime
        case disconnectReasons
        case faxStatus
        case provider
        case scriptId
        case peerId
        case uuiData
        case _self = "self"
        case other
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case agentAssistantId
        case queueMediaSettings
        case disposition
    }


}




public class CallConversationEntityListing: Codable {





















    public var entities: [CallConversation]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CallConversation]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CallForwardingEventCall: Codable {



    public var targets: [CallForwardingEventTarget]?

    public init(targets: [CallForwardingEventTarget]?) {
        self.targets = targets
    }


}




public class CallForwardingEventTarget: Codable {





    public var type: String?
    public var value: String?

    public init(type: String?, value: String?) {
        self.type = type
        self.value = value
    }


}




public class CallForwardingEventUser: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class CallRecord: Codable {





    /** Timestamp of the last attempt to reach this number. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var lastAttempt: Date?
    /** Result of the last attempt to reach this number */
    public var lastResult: String?

    public init(lastAttempt: Date?, lastResult: String?) {
        self.lastAttempt = lastAttempt
        self.lastResult = lastResult
    }


}




public class CallRoute: Codable {



    /** A list of CallTargets to be called when the CallRoute is executed */
    public var targets: [CallTarget]?

    public init(targets: [CallTarget]?) {
        self.targets = targets
    }


}




public class CallbackDisconnectIdentifier: Codable {





    /** The Conversation Id. */
    public var conversationId: String?
    /** The callback id. */
    public var callbackId: String?

    public init(conversationId: String?, callbackId: String?) {
        self.conversationId = conversationId
        self.callbackId = callbackId
    }


}




public class CallbackMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case parked = "parked"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDonotdisturb = "endpoint.donotdisturb"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferDonotdisturb = "transfer.donotdisturb"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
    }





































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }



























    /** The unique participant ID. */
    public var _id: String?
    /** The display friendly name of the participant. */
    public var name: String?
    /** The participant address. */
    public var address: String?
    /** The time when this participant first joined the conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startTime: Date?
    /** The time when this participant went connected for this media (eg: video connected time). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** The time when this participant went disconnected for this media (eg: video disconnected time). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?
    /** The time when this participant's hold started. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startHoldTime: Date?
    /** The participant's purpose.  Values can be: 'agent', 'user', 'customer', 'external', 'acd', 'ivr */
    public var purpose: String?
    /** The participant's state.  Values can be: 'alerting', 'connected', 'disconnected', 'dialing', 'contacting */
    public var state: State?
    /** The participant's direction.  Values can be: 'inbound' or 'outbound' */
    public var direction: Direction?
    /** The reason the participant was disconnected from the conversation. */
    public var disconnectType: DisconnectType?
    /** Value is true when the participant is on hold. */
    public var held: Bool?
    /** Value is true when the participant requires wrap-up. */
    public var wrapupRequired: Bool?
    /** The wrap-up prompt indicating the type of wrap-up to be performed. */
    public var wrapupPrompt: String?
    /** List of roles this participant's media has had on the conversation, ie monitor, coach, etc */
    public var mediaRoles: [String]?
    /** The PureCloud user for this participant. */
    public var user: DomainEntityRef?
    /** The PureCloud queue for this participant. */
    public var queue: DomainEntityRef?
    /** The PureCloud team for this participant. */
    public var team: DomainEntityRef?
    /** A list of ad-hoc attributes for the participant. */
    public var attributes: [String:String]?
    /** If the conversation ends in error, contains additional error details. */
    public var errorInfo: ErrorInfo?
    /** The Engage script that should be used by this participant. */
    public var script: DomainEntityRef?
    /** The amount of time the participant has to complete wrap-up. */
    public var wrapupTimeoutMs: Int?
    /** Value is true when the participant has skipped wrap-up. */
    public var wrapupSkipped: Bool?
    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutMs: Int?
    /** The source provider for the communication. */
    public var provider: String?
    /** If this participant represents an external contact, then this will be the reference for the external contact. */
    public var externalContact: DomainEntityRef?
    /** If this participant represents an external org, then this will be the reference for the external org. */
    public var externalOrganization: DomainEntityRef?
    /** Wrapup for this participant, if it has been applied. */
    public var wrapup: Wrapup?
    /** The peer communication corresponding to a matching leg for this communication. */
    public var peer: String?
    /** The reason specifying why participant flagged the conversation. */
    public var flaggedReason: FlaggedReason?
    /** Journey System data/context that is applicable to this communication.  When used for historical purposes, the context should be immutable.  When null, there is no applicable Journey System context. */
    public var journeyContext: JourneyContext?
    /** Information on how a communication should be routed to an agent. */
    public var conversationRoutingData: ConversationRoutingData?
    /** The timestamp when this participant started after-call work. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAcwTime: Date?
    /** The timestamp when this participant ended after-call work. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endAcwTime: Date?
    /** The outbound preview associated with this callback. */
    public var outboundPreview: DialerPreview?
    /** The voicemail associated with this callback. */
    public var voicemail: Voicemail?
    /** The list of phone number to use for this callback. */
    public var callbackNumbers: [String]?
    /** The name of the callback target. */
    public var callbackUserName: String?
    /** True if the call for the callback uses external dialing. */
    public var externalCampaign: Bool?
    /** If true, the callback can be skipped. */
    public var skipEnabled: Bool?
    /** Duration in seconds before the callback will be auto-dialed. */
    public var timeoutSeconds: Int?
    /** The id of the config for automatically placing the callback (and handling the disposition). If absent, the callback will not be placed automatically but routed to an agent as per normal. */
    public var automatedCallbackConfigId: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var callbackScheduledTime: Date?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, mediaRoles: [String]?, user: DomainEntityRef?, queue: DomainEntityRef?, team: DomainEntityRef?, attributes: [String:String]?, errorInfo: ErrorInfo?, script: DomainEntityRef?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, alertingTimeoutMs: Int?, provider: String?, externalContact: DomainEntityRef?, externalOrganization: DomainEntityRef?, wrapup: Wrapup?, peer: String?, flaggedReason: FlaggedReason?, journeyContext: JourneyContext?, conversationRoutingData: ConversationRoutingData?, startAcwTime: Date?, endAcwTime: Date?, outboundPreview: DialerPreview?, voicemail: Voicemail?, callbackNumbers: [String]?, callbackUserName: String?, externalCampaign: Bool?, skipEnabled: Bool?, timeoutSeconds: Int?, automatedCallbackConfigId: String?, callbackScheduledTime: Date?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.mediaRoles = mediaRoles
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.peer = peer
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.conversationRoutingData = conversationRoutingData
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.outboundPreview = outboundPreview
        self.voicemail = voicemail
        self.callbackNumbers = callbackNumbers
        self.callbackUserName = callbackUserName
        self.externalCampaign = externalCampaign
        self.skipEnabled = skipEnabled
        self.timeoutSeconds = timeoutSeconds
        self.automatedCallbackConfigId = automatedCallbackConfigId
        self.callbackScheduledTime = callbackScheduledTime
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case mediaRoles
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalOrganization
        case wrapup
        case peer
        case flaggedReason
        case journeyContext
        case conversationRoutingData
        case startAcwTime
        case endAcwTime
        case outboundPreview
        case voicemail
        case callbackNumbers
        case callbackUserName
        case externalCampaign
        case skipEnabled
        case timeoutSeconds
        case automatedCallbackConfigId
        case callbackScheduledTime
    }


}




public class Callheader: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** parsed SIP headers */
    public var headers: [String:[String]]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, headers: [String:[String]]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.headers = headers
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case headers
        case selfUri
    }


}




public class CampaignEntityListing: Codable {





















    public var entities: [Campaign]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Campaign]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CampaignInteraction: Codable {



























    public enum Disposition: String, Codable { 
        case disconnect = "DISCONNECT"
        case liveVoice = "LIVE_VOICE"
        case busy = "BUSY"
        case machine = "MACHINE"
        case noAnswer = "NO_ANSWER"
        case sitCallable = "SIT_CALLABLE"
        case sitUncallable = "SIT_UNCALLABLE"
        case fax = "FAX"
    }















    public var _id: String?
    public var campaign: DomainEntityRef?
    public var agent: DomainEntityRef?
    public var contact: DomainEntityRef?
    public var destinationAddress: String?
    /** Boolean value if there is an active preview call on the interaction */
    public var activePreviewCall: Bool?
    /** The time when the last preview of the interaction was wrapped up. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var lastActivePreviewWrapupTime: Date?
    /** The time when dialer created the interaction. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var creationTime: Date?
    /** The time when the agent or system places the call. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var callPlacedTime: Date?
    /** The time when the agent was connected to the call. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var callRoutedTime: Date?
    /** The time when the customer and routing participant are connected. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var previewConnectedTime: Date?
    public var queue: DomainEntityRef?
    public var script: DomainEntityRef?
    /** Describes what happened with call analysis for instance: disposition.classification.callable.person, disposition.classification.callable.noanswer */
    public var disposition: Disposition?
    public var callerName: String?
    public var callerAddress: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var previewPopDeliveredTime: Date?
    public var conversation: ConversationBasic?
    /** conversation participant id that is the dialer system participant to monitor the call from dialer perspective */
    public var dialerSystemParticipantId: String?
    public var dialingMode: String?
    /** Any skills that are attached to the call for routing */
    public var skills: [DomainEntityRef]?

    public init(_id: String?, campaign: DomainEntityRef?, agent: DomainEntityRef?, contact: DomainEntityRef?, destinationAddress: String?, activePreviewCall: Bool?, lastActivePreviewWrapupTime: Date?, creationTime: Date?, callPlacedTime: Date?, callRoutedTime: Date?, previewConnectedTime: Date?, queue: DomainEntityRef?, script: DomainEntityRef?, disposition: Disposition?, callerName: String?, callerAddress: String?, previewPopDeliveredTime: Date?, conversation: ConversationBasic?, dialerSystemParticipantId: String?, dialingMode: String?, skills: [DomainEntityRef]?) {
        self._id = _id
        self.campaign = campaign
        self.agent = agent
        self.contact = contact
        self.destinationAddress = destinationAddress
        self.activePreviewCall = activePreviewCall
        self.lastActivePreviewWrapupTime = lastActivePreviewWrapupTime
        self.creationTime = creationTime
        self.callPlacedTime = callPlacedTime
        self.callRoutedTime = callRoutedTime
        self.previewConnectedTime = previewConnectedTime
        self.queue = queue
        self.script = script
        self.disposition = disposition
        self.callerName = callerName
        self.callerAddress = callerAddress
        self.previewPopDeliveredTime = previewPopDeliveredTime
        self.conversation = conversation
        self.dialerSystemParticipantId = dialerSystemParticipantId
        self.dialingMode = dialingMode
        self.skills = skills
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case campaign
        case agent
        case contact
        case destinationAddress
        case activePreviewCall
        case lastActivePreviewWrapupTime
        case creationTime
        case callPlacedTime
        case callRoutedTime
        case previewConnectedTime
        case queue
        case script
        case disposition
        case callerName
        case callerAddress
        case previewPopDeliveredTime
        case conversation
        case dialerSystemParticipantId
        case dialingMode
        case skills
    }


}




public class CampaignInteractions: Codable {













    public var campaign: DomainEntityRef?
    public var pendingInteractions: [CampaignInteraction]?
    public var proceedingInteractions: [CampaignInteraction]?
    public var previewingInteractions: [CampaignInteraction]?
    public var interactingInteractions: [CampaignInteraction]?
    public var scheduledInteractions: [CampaignInteraction]?

    public init(campaign: DomainEntityRef?, pendingInteractions: [CampaignInteraction]?, proceedingInteractions: [CampaignInteraction]?, previewingInteractions: [CampaignInteraction]?, interactingInteractions: [CampaignInteraction]?, scheduledInteractions: [CampaignInteraction]?) {
        self.campaign = campaign
        self.pendingInteractions = pendingInteractions
        self.proceedingInteractions = proceedingInteractions
        self.previewingInteractions = previewingInteractions
        self.interactingInteractions = interactingInteractions
        self.scheduledInteractions = scheduledInteractions
    }


}




public class CampaignRuleParameters: Codable {

    public enum Operator: String, Codable { 
        case equals = "equals"
        case greaterthan = "greaterThan"
        case greaterthanequalto = "greaterThanEqualTo"
        case lessthan = "lessThan"
        case lessthanequalto = "lessThanEqualTo"
    }



    public enum Priority: String, Codable { 
        case _1 = "1"
        case _2 = "2"
        case _3 = "3"
        case _4 = "4"
        case _5 = "5"
    }

    public enum DialingMode: String, Codable { 
        case agentless = "agentless"
        case preview = "preview"
        case power = "power"
        case predictive = "predictive"
        case progressive = "progressive"
        case external = "external"
    }

    /** The operator for comparison. Required for a CampaignRuleCondition. */
    public var _operator: Operator?
    /** The value for comparison. Required for a CampaignRuleCondition. */
    public var value: String?
    /** The priority to set a campaign to. Required for the 'setCampaignPriority' action. */
    public var priority: Priority?
    /** The dialing mode to set a campaign to. Required for the 'setCampaignDialingMode' action. */
    public var dialingMode: DialingMode?

    public init(_operator: Operator?, value: String?, priority: Priority?, dialingMode: DialingMode?) {
        self._operator = _operator
        self.value = value
        self.priority = priority
        self.dialingMode = dialingMode
    }

    public enum CodingKeys: String, CodingKey { 
        case _operator = "operator"
        case value
        case priority
        case dialingMode
    }


}




public class CampaignSequenceEntityListing: Codable {





















    public var entities: [CampaignSequence]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CampaignSequence]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CampaignStats: Codable {















    /** Information regarding the campaign's connect rate */
    public var contactRate: ConnectRate?
    /** Number of available agents not currently being utilized */
    public var idleAgents: Int?
    /** Number of effective available agents not currently being utilized */
    public var effectiveIdleAgents: Double?
    /** Calls per agent adjusted by pace */
    public var adjustedCallsPerAgent: Double?
    /** Number of campaign calls currently ongoing */
    public var outstandingCalls: Int?
    /** Number of campaign calls currently scheduled */
    public var scheduledCalls: Int?
    /** Number of campaign calls currently timezone rescheduled */
    public var timeZoneRescheduledCalls: Int?

    public init(contactRate: ConnectRate?, idleAgents: Int?, effectiveIdleAgents: Double?, adjustedCallsPerAgent: Double?, outstandingCalls: Int?, scheduledCalls: Int?, timeZoneRescheduledCalls: Int?) {
        self.contactRate = contactRate
        self.idleAgents = idleAgents
        self.effectiveIdleAgents = effectiveIdleAgents
        self.adjustedCallsPerAgent = adjustedCallsPerAgent
        self.outstandingCalls = outstandingCalls
        self.scheduledCalls = scheduledCalls
        self.timeZoneRescheduledCalls = timeZoneRescheduledCalls
    }


}




public class CampaignTimeSlot: Codable {







    /** The start time of the interval as an ISO-8601 string, i.e. HH:mm:ss */
    public var startTime: String?
    /** The end time of the interval as an ISO-8601 string, i.e. HH:mm:ss */
    public var stopTime: String?
    /** The day of the interval. Valid values: [1-7], representing Monday through Sunday */
    public var day: Int?

    public init(startTime: String?, stopTime: String?, day: Int?) {
        self.startTime = startTime
        self.stopTime = stopTime
        self.day = day
    }


}




public class CannedResponseLibraries: Codable {



    public enum Mode: String, Codable { 
        case all = "All"
        case selectedOnly = "SelectedOnly"
        case _none = "None"
    }

    /** Set of canned response library IDs associated with the queue only when mode is SelectedOnly. */
    public var libraryIds: [String]?
    /** The association mode of canned response libraries to queue */
    public var mode: Mode?

    public init(libraryIds: [String]?, mode: Mode?) {
        self.libraryIds = libraryIds
        self.mode = mode
    }


}




public class CategoryEntityListing: Codable {











    public var entities: [Category]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var pageCount: Int?

    public init(entities: [Category]?, pageSize: Int?, pageNumber: Int?, total: Int64?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.pageCount = pageCount
    }


}




public class CategoryResponse: Codable {





















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the category. */
    public var name: String?
    public var _description: String?
    public var externalId: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The reference to category to which this category belongs to. */
    public var parentCategory: CategoryReference?
    /** Number of documents assigned to this category. */
    public var documentCount: Int?
    /** The reference to knowledge base to which the category belongs to. */
    public var knowledgeBase: KnowledgeBaseReference?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, externalId: String?, dateCreated: Date?, dateModified: Date?, parentCategory: CategoryReference?, documentCount: Int?, knowledgeBase: KnowledgeBaseReference?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.externalId = externalId
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.parentCategory = parentCategory
        self.documentCount = documentCount
        self.knowledgeBase = knowledgeBase
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case externalId
        case dateCreated
        case dateModified
        case parentCategory
        case documentCount
        case knowledgeBase
        case selfUri
    }


}




public class CategoryResponseListing: Codable {









    public var entities: [CategoryResponse]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [CategoryResponse]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class Change: Codable {









    public var entity: AuditEntity?
    /** The property that was changed */
    public var property: String?
    /** The old values which were modified and/or removed by this action. */
    public var oldValues: [String]?
    /** The new values which were modified and/or added by this action. */
    public var newValues: [String]?

    public init(entity: AuditEntity?, property: String?, oldValues: [String]?, newValues: [String]?) {
        self.entity = entity
        self.property = property
        self.oldValues = oldValues
        self.newValues = newValues
    }


}




public class Channel: Codable {







    public var connectUri: String?
    public var _id: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var expires: Date?

    public init(connectUri: String?, _id: String?, expires: Date?) {
        self.connectUri = connectUri
        self._id = _id
        self.expires = expires
    }

    public enum CodingKeys: String, CodingKey { 
        case connectUri
        case _id = "id"
        case expires
    }


}



/** Represents a cloned user in a trustor organization. */

public class ClonedUser: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The ID of the trustor organization this clone exists in. */
    public var trustor: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, trustor: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.trustor = trustor
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case trustor
        case selfUri
    }


}




public class CoachingAnnotation: Codable {















    public enum AccessType: String, Codable { 
        case _public = "Public"
        case _private = "Private"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The user who created the annotation. */
    public var createdBy: UserReference?
    /** The date/time the annotation was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The last user to modify the annotation. */
    public var modifiedBy: UserReference?
    /** The date/time the annotation was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The text of the annotation. */
    public var text: String?
    /** Flag indicating whether the annotation is deleted. */
    public var isDeleted: Bool?
    /** Determines the permissions required to view this item. */
    public var accessType: AccessType?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, createdBy: UserReference?, dateCreated: Date?, modifiedBy: UserReference?, dateModified: Date?, text: String?, isDeleted: Bool?, accessType: AccessType?, selfUri: String?) {
        self._id = _id
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
        self.text = text
        self.isDeleted = isDeleted
        self.accessType = accessType
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case createdBy
        case dateCreated
        case modifiedBy
        case dateModified
        case text
        case isDeleted
        case accessType
        case selfUri
    }


}




public class CoachingAppointmentResponseList: Codable {





















    public var entities: [CoachingAppointmentResponse]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CoachingAppointmentResponse]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CoachingAppointmentStatusRequest: Codable {

    public enum Status: String, Codable { 
        case scheduled = "Scheduled"
        case inProgress = "InProgress"
        case completed = "Completed"
    }

    /** The status of the coaching appointment */
    public var status: Status?

    public init(status: Status?) {
        self.status = status
    }


}




public class CobrowseMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case parked = "parked"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDonotdisturb = "endpoint.donotdisturb"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferDonotdisturb = "transfer.donotdisturb"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
    }





































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }



















    /** The unique participant ID. */
    public var _id: String?
    /** The display friendly name of the participant. */
    public var name: String?
    /** The participant address. */
    public var address: String?
    /** The time when this participant first joined the conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startTime: Date?
    /** The time when this participant went connected for this media (eg: video connected time). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** The time when this participant went disconnected for this media (eg: video disconnected time). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?
    /** The time when this participant's hold started. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startHoldTime: Date?
    /** The participant's purpose.  Values can be: 'agent', 'user', 'customer', 'external', 'acd', 'ivr */
    public var purpose: String?
    /** The participant's state.  Values can be: 'alerting', 'connected', 'disconnected', 'dialing', 'contacting */
    public var state: State?
    /** The participant's direction.  Values can be: 'inbound' or 'outbound' */
    public var direction: Direction?
    /** The reason the participant was disconnected from the conversation. */
    public var disconnectType: DisconnectType?
    /** Value is true when the participant is on hold. */
    public var held: Bool?
    /** Value is true when the participant requires wrap-up. */
    public var wrapupRequired: Bool?
    /** The wrap-up prompt indicating the type of wrap-up to be performed. */
    public var wrapupPrompt: String?
    /** List of roles this participant's media has had on the conversation, ie monitor, coach, etc */
    public var mediaRoles: [String]?
    /** The PureCloud user for this participant. */
    public var user: DomainEntityRef?
    /** The PureCloud queue for this participant. */
    public var queue: DomainEntityRef?
    /** The PureCloud team for this participant. */
    public var team: DomainEntityRef?
    /** A list of ad-hoc attributes for the participant. */
    public var attributes: [String:String]?
    /** If the conversation ends in error, contains additional error details. */
    public var errorInfo: ErrorInfo?
    /** The Engage script that should be used by this participant. */
    public var script: DomainEntityRef?
    /** The amount of time the participant has to complete wrap-up. */
    public var wrapupTimeoutMs: Int?
    /** Value is true when the participant has skipped wrap-up. */
    public var wrapupSkipped: Bool?
    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutMs: Int?
    /** The source provider for the communication. */
    public var provider: String?
    /** If this participant represents an external contact, then this will be the reference for the external contact. */
    public var externalContact: DomainEntityRef?
    /** If this participant represents an external org, then this will be the reference for the external org. */
    public var externalOrganization: DomainEntityRef?
    /** Wrapup for this participant, if it has been applied. */
    public var wrapup: Wrapup?
    /** The peer communication corresponding to a matching leg for this communication. */
    public var peer: String?
    /** The reason specifying why participant flagged the conversation. */
    public var flaggedReason: FlaggedReason?
    /** Journey System data/context that is applicable to this communication.  When used for historical purposes, the context should be immutable.  When null, there is no applicable Journey System context. */
    public var journeyContext: JourneyContext?
    /** Information on how a communication should be routed to an agent. */
    public var conversationRoutingData: ConversationRoutingData?
    /** The timestamp when this participant started after-call work. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAcwTime: Date?
    /** The timestamp when this participant ended after-call work. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endAcwTime: Date?
    /** The co-browse session ID. */
    public var cobrowseSessionId: String?
    /** This value identifies the role of the co-browse client within the co-browse session (a client is a sharer or a viewer). */
    public var cobrowseRole: String?
    /** ID of co-browse participants for which this client has been granted control (list is empty if this client cannot control any shared pages). */
    public var controlling: [String]?
    /** The URL that can be used to open co-browse session in web browser. */
    public var viewerUrl: String?
    /** The time when the provider event which triggered this conversation update happened in the corrected provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var providerEventTime: Date?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, mediaRoles: [String]?, user: DomainEntityRef?, queue: DomainEntityRef?, team: DomainEntityRef?, attributes: [String:String]?, errorInfo: ErrorInfo?, script: DomainEntityRef?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, alertingTimeoutMs: Int?, provider: String?, externalContact: DomainEntityRef?, externalOrganization: DomainEntityRef?, wrapup: Wrapup?, peer: String?, flaggedReason: FlaggedReason?, journeyContext: JourneyContext?, conversationRoutingData: ConversationRoutingData?, startAcwTime: Date?, endAcwTime: Date?, cobrowseSessionId: String?, cobrowseRole: String?, controlling: [String]?, viewerUrl: String?, providerEventTime: Date?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.mediaRoles = mediaRoles
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.peer = peer
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.conversationRoutingData = conversationRoutingData
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.cobrowseSessionId = cobrowseSessionId
        self.cobrowseRole = cobrowseRole
        self.controlling = controlling
        self.viewerUrl = viewerUrl
        self.providerEventTime = providerEventTime
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case mediaRoles
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalOrganization
        case wrapup
        case peer
        case flaggedReason
        case journeyContext
        case conversationRoutingData
        case startAcwTime
        case endAcwTime
        case cobrowseSessionId
        case cobrowseRole
        case controlling
        case viewerUrl
        case providerEventTime
    }


}




public class Column: Codable {









    /** Column name. Mandatory for Fixed position/length file format. */
    public var columnName: String?
    /** 0 based column number in delimited file format */
    public var columnNumber: Int?
    /** Zero-based position of the first column's character. Mandatory for Fixed position/length file format. */
    public var startPosition: Int?
    /** Column width. Mandatory for Fixed position/length file format. */
    public var length: Int?

    public init(columnName: String?, columnNumber: Int?, startPosition: Int?, length: Int?) {
        self.columnName = columnName
        self.columnNumber = columnNumber
        self.startPosition = startPosition
        self.length = length
    }


}




public class CommandStatus: Codable {









    public enum StatusCode: String, Codable { 
        case inprogress = "INPROGRESS"
        case complete = "COMPLETE"
        case error = "ERROR"
        case canceling = "CANCELING"
        case canceled = "CANCELED"
    }

    public enum CommandType: String, Codable { 
        case upload = "UPLOAD"
        case copydocument = "COPYDOCUMENT"
        case movedocument = "MOVEDOCUMENT"
        case deleteworkspace = "DELETEWORKSPACE"
        case deletedocument = "DELETEDOCUMENT"
        case deletetag = "DELETETAG"
        case updatetag = "UPDATETAG"
        case reindex = "REINDEX"
        case cleanup = "CLEANUP"
        case replacedocument = "REPLACEDOCUMENT"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var expiration: Date?
    public var userId: String?
    public var statusCode: StatusCode?
    public var commandType: CommandType?
    public var document: Document?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, expiration: Date?, userId: String?, statusCode: StatusCode?, commandType: CommandType?, document: Document?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.expiration = expiration
        self.userId = userId
        self.statusCode = statusCode
        self.commandType = commandType
        self.document = document
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case expiration
        case userId
        case statusCode
        case commandType
        case document
        case selfUri
    }


}




public class CommonCampaign: Codable {







    public enum MediaType: String, Codable { 
        case email = "email"
        case sms = "sms"
        case voice = "voice"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the Campaign. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The media type used for this campaign. */
    public var mediaType: MediaType?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, mediaType: MediaType?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.mediaType = mediaType
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case mediaType
        case selfUri
    }


}




public class CommonCampaignDivisionViewEntityListing: Codable {





















    public var entities: [CommonCampaignDivisionView]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CommonCampaignDivisionView]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ComparisonPeriod: Codable {















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Key Performance Indicator optimised during the comparison period. */
    public var kpi: String?
    /** Start date of the comparison period. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStarted: Date?
    /** End date of the comparison period. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateEnded: Date?
    /** The percentage benefit on this queue for the duration of the comparison period */
    public var percentageBenefit: Double?
    /** KPI results for each metric */
    public var kpiResults: [KpiResult]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, kpi: String?, dateStarted: Date?, dateEnded: Date?, percentageBenefit: Double?, kpiResults: [KpiResult]?, selfUri: String?) {
        self._id = _id
        self.kpi = kpi
        self.dateStarted = dateStarted
        self.dateEnded = dateEnded
        self.percentageBenefit = percentageBenefit
        self.kpiResults = kpiResults
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case kpi
        case dateStarted
        case dateEnded
        case percentageBenefit
        case kpiResults
        case selfUri
    }


}




public class ComparisonPeriodListing: Codable {







    public var total: Int64?
    public var entities: [ComparisonPeriod]?
    public var selfUri: String?

    public init(total: Int64?, entities: [ComparisonPeriod]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class ConditionalGroupRoutingRule: Codable {



    public enum Metric: String, Codable { 
        case estimatedWaitTime = "EstimatedWaitTime"
        case serviceLevel = "ServiceLevel"
    }

    public enum Operator: String, Codable { 
        case greaterThan = "GreaterThan"
        case greaterThanOrEqualTo = "GreaterThanOrEqualTo"
        case lessThan = "LessThan"
        case lessThanOrEqualTo = "LessThanOrEqualTo"
    }







    /** The queue being evaluated for this rule.  For rule 1, this is always the current queue, so should not be specified. */
    public var queue: DomainEntityRef?
    /** The queue metric being evaluated */
    public var metric: Metric?
    /** The operator that compares the actual value against the condition value */
    public var _operator: Operator?
    /** The limit value, beyond which a rule evaluates as true */
    public var conditionValue: Double?
    /** The group(s) to activate if the rule evaluates as true */
    public var groups: [MemberGroup]?
    /** The number of seconds to wait in this rule, if it evaluates as true, before evaluating the next rule.  For the final rule, this is ignored, so need not be specified. */
    public var waitSeconds: Int?

    public init(queue: DomainEntityRef?, metric: Metric?, _operator: Operator?, conditionValue: Double?, groups: [MemberGroup]?, waitSeconds: Int?) {
        self.queue = queue
        self.metric = metric
        self._operator = _operator
        self.conditionValue = conditionValue
        self.groups = groups
        self.waitSeconds = waitSeconds
    }

    public enum CodingKeys: String, CodingKey { 
        case queue
        case metric
        case _operator = "operator"
        case conditionValue
        case groups
        case waitSeconds
    }


}




public class ConfusionUtterance: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Utterance Text. */
    public var text: String?
    /** Utterance's similarity score, 0 being dissimilar and 1 being very similar. */
    public var similarity: Float?

    public init(_id: String?, text: String?, similarity: Float?) {
        self._id = _id
        self.text = text
        self.similarity = similarity
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case text
        case similarity
    }


}




public class ConnectedQueue: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class ConsultTransferUpdate: Codable {

    public enum SpeakTo: String, Codable { 
        case destination = "DESTINATION"
        case object = "OBJECT"
        case both = "BOTH"
        case conference = "CONFERENCE"
    }



    /** Determines to whom the initiating participant is speaking. */
    public var speakTo: SpeakTo?
    /** The user ID of the person who wants to talk before completing the transfer. Could be the same of the context user ID */
    public var consultingUserId: String?

    public init(speakTo: SpeakTo?, consultingUserId: String?) {
        self.speakTo = speakTo
        self.consultingUserId = consultingUserId
    }


}




public class ConsumedResourcesEntityListing: Codable {





















    public var entities: [Dependency]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Dependency]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ContactAddressableEntityRef: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class ContactCallbackRequest: Codable {











    /** Campaign identifier */
    public var campaignId: String?
    /** Contact list identifier */
    public var contactListId: String?
    /** Contact identifier */
    public var contactId: String?
    /** Name of the phone column containing the number to be called */
    public var phoneColumn: String?
    /** The scheduled time for the callback as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss.SSSZ\", example = \"2016-01-02T16:59:59\" */
    public var schedule: String?

    public init(campaignId: String?, contactListId: String?, contactId: String?, phoneColumn: String?, schedule: String?) {
        self.campaignId = campaignId
        self.contactListId = contactListId
        self.contactId = contactId
        self.phoneColumn = phoneColumn
        self.schedule = schedule
    }


}




public class ContactColumnConditionSettings: Codable {



    public enum Operator: String, Codable { 
        case equals = "Equals"
        case lessThan = "LessThan"
        case lessThanEquals = "LessThanEquals"
        case greaterThan = "GreaterThan"
        case greaterThanEquals = "GreaterThanEquals"
        case contains = "Contains"
        case beginsWith = "BeginsWith"
        case endsWith = "EndsWith"
        case before = "Before"
        case after = "After"
    }



    public enum ValueType: String, Codable { 
        case dateTime = "DateTime"
        case numeric = "Numeric"
        case period = "Period"
        case string = "String"
    }

    /** The name of the contact list column to evaluate. */
    public var columnName: String?
    /** The operator to use when comparing values. */
    public var _operator: Operator?
    /** The value to compare against the contact's data. */
    public var value: String?
    /** The data type the value should be treated as. */
    public var valueType: ValueType?

    public init(columnName: String?, _operator: Operator?, value: String?, valueType: ValueType?) {
        self.columnName = columnName
        self._operator = _operator
        self.value = value
        self.valueType = valueType
    }

    public enum CodingKeys: String, CodingKey { 
        case columnName
        case _operator = "operator"
        case value
        case valueType
    }


}




public class ContactColumnToDataActionFieldMapping: Codable {





    /** The name of a contact column whose data will be passed to the data action */
    public var contactColumnName: String?
    /** The name of an input field from the data action that the contact column data will be passed to */
    public var dataActionField: String?

    public init(contactColumnName: String?, dataActionField: String?) {
        self.contactColumnName = contactColumnName
        self.dataActionField = dataActionField
    }


}




public class ContactDetailEventTopicContactUpdateEvent: Codable {









    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
    }







    public enum Direction: String, Codable { 
        case unknown = "UNKNOWN"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }

















    public enum MessageType: String, Codable { 
        case unknown = "UNKNOWN"
        case sms = "SMS"
        case twitter = "TWITTER"
        case facebook = "FACEBOOK"
        case line = "LINE"
        case whatsapp = "WHATSAPP"
        case webmessaging = "WEBMESSAGING"
        case _open = "OPEN"
        case instagram = "INSTAGRAM"
    }





    public var eventTime: Int?
    public var conversationId: String?
    public var participantId: String?
    public var sessionId: String?
    public var mediaType: MediaType?
    public var externalOrganizationId: String?
    public var externalContactId: String?
    public var provider: String?
    public var direction: Direction?
    public var ani: String?
    public var dnis: String?
    public var addressTo: String?
    public var addressFrom: String?
    public var callbackUserName: String?
    public var callbackNumbers: [String]?
    public var callbackScheduledTime: Int?
    public var subject: String?
    public var messageType: MessageType?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?

    public init(eventTime: Int?, conversationId: String?, participantId: String?, sessionId: String?, mediaType: MediaType?, externalOrganizationId: String?, externalContactId: String?, provider: String?, direction: Direction?, ani: String?, dnis: String?, addressTo: String?, addressFrom: String?, callbackUserName: String?, callbackNumbers: [String]?, callbackScheduledTime: Int?, subject: String?, messageType: MessageType?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.sessionId = sessionId
        self.mediaType = mediaType
        self.externalOrganizationId = externalOrganizationId
        self.externalContactId = externalContactId
        self.provider = provider
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.addressTo = addressTo
        self.addressFrom = addressFrom
        self.callbackUserName = callbackUserName
        self.callbackNumbers = callbackNumbers
        self.callbackScheduledTime = callbackScheduledTime
        self.subject = subject
        self.messageType = messageType
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
    }


}




public class ContactListFilter: Codable {















    public enum SourceType: String, Codable { 
        case contactList = "ContactList"
        case contactListTemplate = "ContactListTemplate"
    }



    public enum FilterType: String, Codable { 
        case and = "AND"
        case or = "OR"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the list. */
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** The contact list the filter is based on. Required if sourceType is ContactList */
    public var contactList: DomainEntityRef?
    /** The contact list template the filter is based on. Required if sourceType is ContactListTemplate */
    public var contactListTemplate: DomainEntityRef?
    /** The source type the filter is based on. */
    public var sourceType: SourceType?
    /** Groups of conditions to filter the contacts by. */
    public var clauses: [ContactListFilterClause]?
    /** How to join clauses together. */
    public var filterType: FilterType?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, contactList: DomainEntityRef?, contactListTemplate: DomainEntityRef?, sourceType: SourceType?, clauses: [ContactListFilterClause]?, filterType: FilterType?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.contactList = contactList
        self.contactListTemplate = contactListTemplate
        self.sourceType = sourceType
        self.clauses = clauses
        self.filterType = filterType
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case contactList
        case contactListTemplate
        case sourceType
        case clauses
        case filterType
        case selfUri
    }


}




public class ContactListFilterClause: Codable {

    public enum FilterType: String, Codable { 
        case and = "AND"
        case or = "OR"
    }



    /** How to join predicates together. */
    public var filterType: FilterType?
    /** Conditions to filter the contacts by. */
    public var predicates: [ContactListFilterPredicate]?

    public init(filterType: FilterType?, predicates: [ContactListFilterPredicate]?) {
        self.filterType = filterType
        self.predicates = predicates
    }


}



/** User actions available on the content. All actions are optional and all actions are executed simultaneously. */

public class ContentActions: Codable {







    /** A URL of a web page to direct the user to. */
    public var url: String?
    /** The target window in which to open the URL. If empty will open a blank page or tab. */
    public var urlTarget: String?
    /** Text to be returned as the payload from a ButtonResponse when a button is clicked. The textback and title are a combination which will have to be unique across each card and carousel in order to determine which button was clicked in that card or carousel. */
    public var textback: String?

    public init(url: String?, urlTarget: String?, textback: String?) {
        self.url = url
        self.urlTarget = urlTarget
        self.textback = textback
    }


}



/** Deprecated, should use Card. */

public class ContentGeneric: Codable {













    /** Text to show in the title. */
    public var title: String?
    /** Text to show in the description. */
    public var _description: String?
    /** URL of an image. */
    public var image: String?
    /** URL of a video. */
    public var video: String?
    /** Actions to be taken (Deprecated). */
    public var actions: ContentActions?
    /** An array of component objects. */
    public var components: [ButtonComponent]?

    public init(title: String?, _description: String?, image: String?, video: String?, actions: ContentActions?, components: [ButtonComponent]?) {
        self.title = title
        self._description = _description
        self.image = image
        self.video = video
        self.actions = actions
        self.components = components
    }

    public enum CodingKeys: String, CodingKey { 
        case title
        case _description = "description"
        case image
        case video
        case actions
        case components
    }


}




public class ContentManagementSingleDocumentTopicUserData: Codable {





    public var _id: String?
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class ContentManagementWorkspaceDocumentsTopicDocumentDataV2: Codable {





























    public var _id: String?
    public var name: String?
    public var dateCreated: Date?
    public var dateModified: Date?
    public var workspace: ContentManagementWorkspaceDocumentsTopicWorkspaceData?
    public var createdBy: ContentManagementWorkspaceDocumentsTopicUserData?
    public var contentType: String?
    public var contentLength: Int?
    public var filename: String?
    public var changeNumber: Int?
    public var dateUploaded: Date?
    public var uploadedBy: ContentManagementWorkspaceDocumentsTopicUserData?
    public var lockInfo: ContentManagementWorkspaceDocumentsTopicLockData?
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, workspace: ContentManagementWorkspaceDocumentsTopicWorkspaceData?, createdBy: ContentManagementWorkspaceDocumentsTopicUserData?, contentType: String?, contentLength: Int?, filename: String?, changeNumber: Int?, dateUploaded: Date?, uploadedBy: ContentManagementWorkspaceDocumentsTopicUserData?, lockInfo: ContentManagementWorkspaceDocumentsTopicLockData?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.workspace = workspace
        self.createdBy = createdBy
        self.contentType = contentType
        self.contentLength = contentLength
        self.filename = filename
        self.changeNumber = changeNumber
        self.dateUploaded = dateUploaded
        self.uploadedBy = uploadedBy
        self.lockInfo = lockInfo
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case workspace
        case createdBy
        case contentType
        case contentLength
        case filename
        case changeNumber
        case dateUploaded
        case uploadedBy
        case lockInfo
        case selfUri
    }


}




public class ContentOfferStyleProperties: Codable {







    /** Padding of the offer. (eg. 10px) */
    public var padding: String?
    /** Text color of the offer. (eg. #FF0000) */
    public var color: String?
    /** Background color of the offer. (eg. #000000) */
    public var backgroundColor: String?

    public init(padding: String?, color: String?, backgroundColor: String?) {
        self.padding = padding
        self.color = color
        self.backgroundColor = backgroundColor
    }


}



/** User reaction to public message. */

public class ContentReaction: Codable {

    public enum ReactionType: String, Codable { 
        case like = "Like"
        case love = "Love"
        case wow = "Wow"
        case haha = "Haha"
        case sad = "Sad"
        case angry = "Angry"
        case thankful = "Thankful"
        case pride = "Pride"
        case care = "Care"
    }



    /** Type of reaction. */
    public var reactionType: ReactionType?
    /** Number of users that reacted this way to the message. */
    public var count: Int?

    public init(reactionType: ReactionType?, count: Int?) {
        self.reactionType = reactionType
        self.count = count
    }


}



/** Message content element containing text only. */

public class ContentText: Codable {

    public enum ModelType: String, Codable { 
        case text = "Text"
    }



    /** Type of text content. */
    public var type: ModelType?
    /** Text to be shown for this content element. */
    public var body: String?

    public init(type: ModelType?, body: String?) {
        self.type = type
        self.body = body
    }


}




public class ContextIntent: Codable {



    /** The name of the intent. */
    public var name: String?

    public init(name: String?) {
        self.name = name
    }


}




public class ConversationAggregateDataContainer: Codable {





    /** A mapping from dimension to value */
    public var group: [String:String]?
    public var data: [StatisticalResponse]?

    public init(group: [String:String]?, data: [StatisticalResponse]?) {
        self.group = group
        self.data = data
    }


}




public class ConversationAggregateQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [ConversationAggregateQueryPredicate]?

    public init(type: ModelType?, predicates: [ConversationAggregateQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class ConversationAggregationQuery: Codable {







    public enum GroupBy: String, Codable { 
        case activerouting = "activeRouting"
        case activeskillid = "activeSkillId"
        case addressfrom = "addressFrom"
        case addressto = "addressTo"
        case agentassistantid = "agentAssistantId"
        case agentbullseyering = "agentBullseyeRing"
        case agentowned = "agentOwned"
        case agentrank = "agentRank"
        case agentscore = "agentScore"
        case ani = "ani"
        case assignerid = "assignerId"
        case authenticated = "authenticated"
        case conversationid = "conversationId"
        case conversationinitiator = "conversationInitiator"
        case convertedfrom = "convertedFrom"
        case convertedto = "convertedTo"
        case customerparticipation = "customerParticipation"
        case deliverystatus = "deliveryStatus"
        case destinationaddress = "destinationAddress"
        case direction = "direction"
        case disconnecttype = "disconnectType"
        case divisionid = "divisionId"
        case dnis = "dnis"
        case edgeid = "edgeId"
        case eligibleagentcount = "eligibleAgentCount"
        case errorcode = "errorCode"
        case extendeddeliverystatus = "extendedDeliveryStatus"
        case externalcontactid = "externalContactId"
        case externalmediacount = "externalMediaCount"
        case externalorganizationid = "externalOrganizationId"
        case externaltag = "externalTag"
        case firstqueue = "firstQueue"
        case flaggedreason = "flaggedReason"
        case flowintype = "flowInType"
        case flowouttype = "flowOutType"
        case groupid = "groupId"
        case interactiontype = "interactionType"
        case journeyactionid = "journeyActionId"
        case journeyactionmapid = "journeyActionMapId"
        case journeyactionmapversion = "journeyActionMapVersion"
        case journeycustomerid = "journeyCustomerId"
        case journeycustomeridtype = "journeyCustomerIdType"
        case journeycustomersessionid = "journeyCustomerSessionId"
        case journeycustomersessionidtype = "journeyCustomerSessionIdType"
        case knowledgebaseid = "knowledgeBaseId"
        case mediacount = "mediaCount"
        case mediatype = "mediaType"
        case messagetype = "messageType"
        case originatingdirection = "originatingDirection"
        case outboundcampaignid = "outboundCampaignId"
        case outboundcontactid = "outboundContactId"
        case outboundcontactlistid = "outboundContactListId"
        case participantname = "participantName"
        case peerid = "peerId"
        case proposedagentid = "proposedAgentId"
        case provider = "provider"
        case purpose = "purpose"
        case queueid = "queueId"
        case remote = "remote"
        case removedskillid = "removedSkillId"
        case requestedlanguageid = "requestedLanguageId"
        case requestedrouting = "requestedRouting"
        case requestedroutingskillid = "requestedRoutingSkillId"
        case roomid = "roomId"
        case routingpriority = "routingPriority"
        case routingring = "routingRing"
        case routingrule = "routingRule"
        case routingruletype = "routingRuleType"
        case scoredagentid = "scoredAgentId"
        case selectedagentid = "selectedAgentId"
        case selectedagentrank = "selectedAgentRank"
        case selfserved = "selfServed"
        case sessiondnis = "sessionDnis"
        case sessionid = "sessionId"
        case stationid = "stationId"
        case teamid = "teamId"
        case usedrouting = "usedRouting"
        case userid = "userId"
        case waitinginteractioncount = "waitingInteractionCount"
        case wrapupcode = "wrapUpCode"
    }



    public enum Metrics: String, Codable { 
        case nblindtransferred = "nBlindTransferred"
        case nbotinteractions = "nBotInteractions"
        case ncobrowsesessions = "nCobrowseSessions"
        case nconnected = "nConnected"
        case nconsult = "nConsult"
        case nconsulttransferred = "nConsultTransferred"
        case nerror = "nError"
        case noffered = "nOffered"
        case noutbound = "nOutbound"
        case noutboundabandoned = "nOutboundAbandoned"
        case noutboundattempted = "nOutboundAttempted"
        case noutboundconnected = "nOutboundConnected"
        case noversla = "nOverSla"
        case nstatetransitionerror = "nStateTransitionError"
        case ntransferred = "nTransferred"
        case oexternalmediacount = "oExternalMediaCount"
        case omediacount = "oMediaCount"
        case omessageturn = "oMessageTurn"
        case oservicelevel = "oServiceLevel"
        case oservicetarget = "oServiceTarget"
        case tabandon = "tAbandon"
        case tacd = "tAcd"
        case tactivecallback = "tActiveCallback"
        case tactivecallbackcomplete = "tActiveCallbackComplete"
        case tacw = "tAcw"
        case tagentresponsetime = "tAgentResponseTime"
        case talert = "tAlert"
        case tanswered = "tAnswered"
        case tbarging = "tBarging"
        case tcoaching = "tCoaching"
        case tcoachingcomplete = "tCoachingComplete"
        case tconnected = "tConnected"
        case tcontacting = "tContacting"
        case tdialing = "tDialing"
        case tfirstconnect = "tFirstConnect"
        case tfirstdial = "tFirstDial"
        case tflowout = "tFlowOut"
        case thandle = "tHandle"
        case theld = "tHeld"
        case theldcomplete = "tHeldComplete"
        case tivr = "tIvr"
        case tmonitoring = "tMonitoring"
        case tmonitoringcomplete = "tMonitoringComplete"
        case tnotresponding = "tNotResponding"
        case tpark = "tPark"
        case tparkcomplete = "tParkComplete"
        case tshortabandon = "tShortAbandon"
        case ttalk = "tTalk"
        case ttalkcomplete = "tTalkComplete"
        case tuserresponsetime = "tUserResponseTime"
        case tvoicemail = "tVoicemail"
        case twait = "tWait"
    }





    public enum AlternateTimeDimension: String, Codable { 
        case eventtime = "eventTime"
    }

    /** Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H */
    public var granularity: String?
    /** Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var timeZone: String?
    /** Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group. */
    public var groupBy: [GroupBy]?
    /** Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters */
    public var filter: ConversationAggregateQueryFilter?
    /** Behaves like a SQL SELECT clause. Only named metrics will be retrieved. */
    public var metrics: [Metrics]?
    /** Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c') */
    public var flattenMultivaluedDimensions: Bool?
    /** Custom derived metric views */
    public var views: [ConversationAggregationView]?
    /** Dimension to use as the alternative timestamp for data in the aggregate.  Choosing \"eventTime\" uses the actual time of the data event. */
    public var alternateTimeDimension: AlternateTimeDimension?

    public init(interval: String?, granularity: String?, timeZone: String?, groupBy: [GroupBy]?, filter: ConversationAggregateQueryFilter?, metrics: [Metrics]?, flattenMultivaluedDimensions: Bool?, views: [ConversationAggregationView]?, alternateTimeDimension: AlternateTimeDimension?) {
        self.interval = interval
        self.granularity = granularity
        self.timeZone = timeZone
        self.groupBy = groupBy
        self.filter = filter
        self.metrics = metrics
        self.flattenMultivaluedDimensions = flattenMultivaluedDimensions
        self.views = views
        self.alternateTimeDimension = alternateTimeDimension
    }


}




public class ConversationBasic: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The external tag associated with the conversation. */
    public var externalTag: String?
    /** The time when the conversation started. This will be the time when the first participant joined the conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startTime: Date?
    /** The time when the conversation ended. This will be the time when the last participant left the conversation, or null when the conversation is still active. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?
    /** Identifiers of divisions associated with this conversation */
    public var divisions: [ConversationDivisionMembership]?
    /** True when the recording of this conversation is in secure pause status. */
    public var securePause: Bool?
    /** The URI for this object */
    public var selfUri: String?
    public var participants: [ParticipantBasic]?

    public init(_id: String?, name: String?, externalTag: String?, startTime: Date?, endTime: Date?, divisions: [ConversationDivisionMembership]?, securePause: Bool?, selfUri: String?, participants: [ParticipantBasic]?) {
        self._id = _id
        self.name = name
        self.externalTag = externalTag
        self.startTime = startTime
        self.endTime = endTime
        self.divisions = divisions
        self.securePause = securePause
        self.selfUri = selfUri
        self.participants = participants
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case externalTag
        case startTime
        case endTime
        case divisions
        case securePause
        case selfUri
        case participants
    }


}




public class ConversationCallEventTopicConversationRoutingData: Codable {











    /** A UriReference for a resource */
    public var queue: ConversationCallEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: ConversationCallEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int?
    /** The skills to use for routing decisions */
    public var skills: [ConversationCallEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [ConversationCallEventTopicScoredAgent]?

    public init(queue: ConversationCallEventTopicUriReference?, language: ConversationCallEventTopicUriReference?, priority: Int?, skills: [ConversationCallEventTopicUriReference]?, scoredAgents: [ConversationCallEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}




public class ConversationCallbackEventTopicCallbackConversation: Codable {









    public var _id: String?
    public var name: String?
    public var participants: [ConversationCallbackEventTopicCallbackMediaParticipant]?
    public var otherMediaUris: [String]?

    public init(_id: String?, name: String?, participants: [ConversationCallbackEventTopicCallbackMediaParticipant]?, otherMediaUris: [String]?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
    }


}




public class ConversationCallbackEventTopicDialerPreview: Codable {











    public var _id: String?
    /** The contact associated with this preview data pop */
    public var contactId: String?
    /** The contactList associated with this preview data pop. */
    public var contactListId: String?
    /** The campaignId associated with this preview data pop. */
    public var campaignId: String?
    /** The phone number columns associated with this campaign */
    public var phoneNumberColumns: [ConversationCallbackEventTopicPhoneNumberColumn]?

    public init(_id: String?, contactId: String?, contactListId: String?, campaignId: String?, phoneNumberColumns: [ConversationCallbackEventTopicPhoneNumberColumn]?) {
        self._id = _id
        self.contactId = contactId
        self.contactListId = contactListId
        self.campaignId = campaignId
        self.phoneNumberColumns = phoneNumberColumns
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case contactId
        case contactListId
        case campaignId
        case phoneNumberColumns
    }


}




public class ConversationCallbackEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}




public class ConversationCallbackEventTopicVoicemail: Codable {



    public enum UploadStatus: String, Codable { 
        case pending = "pending"
        case complete = "complete"
        case failed = "failed"
        case timeout = "timeout"
        case _none = "none"
    }

    /** The voicemail id */
    public var _id: String?
    /** current state of the voicemail upload */
    public var uploadStatus: UploadStatus?

    public init(_id: String?, uploadStatus: UploadStatus?) {
        self._id = _id
        self.uploadStatus = uploadStatus
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case uploadStatus
    }


}




public class ConversationChannel: Codable {

    public enum ModelType: String, Codable { 
        case unknown = "Unknown"
        case call = "Call"
        case callback = "Callback"
        case email = "Email"
        case genericObject = "GenericObject"
        case messaging = "Messaging"
        case social = "Social"
        case webchat = "Webchat"
        case voice = "Voice"
        case chat = "Chat"
        case cobrowse = "Cobrowse"
        case video = "Video"
        case screenshare = "Screenshare"
        case message = "Message"
    }

    public enum MessageType: String, Codable { 
        case unknown = "Unknown"
        case sms = "Sms"
        case twitter = "Twitter"
        case facebook = "Facebook"
        case line = "Line"
        case whatsApp = "WhatsApp"
        case webMessaging = "WebMessaging"
        case _open = "Open"
        case instagram = "Instagram"
    }



    /** The type or category of this channel. */
    public var type: ModelType?
    /** Message type for messaging conversations. */
    public var messageType: MessageType?
    /** The source provider for the conversation (e.g. Edge, PureCloud Messaging, PureCloud Email). */
    public var platform: String?

    public init(type: ModelType?, messageType: MessageType?, platform: String?) {
        self.type = type
        self.messageType = messageType
        self.platform = platform
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationChatEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationChatEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}




public class ConversationChatEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: ConversationChatEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int?

    public init(agent: ConversationChatEventTopicUriReference?, score: Int?) {
        self.agent = agent
        self.score = score
    }


}




public class ConversationCobrowseEventTopicCobrowseConversation: Codable {









    public var _id: String?
    public var name: String?
    public var participants: [ConversationCobrowseEventTopicCobrowseMediaParticipant]?
    public var otherMediaUris: [String]?

    public init(_id: String?, name: String?, participants: [ConversationCobrowseEventTopicCobrowseMediaParticipant]?, otherMediaUris: [String]?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
    }


}




public class ConversationCobrowseEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}



/** Message content element containing text only. */

public class ConversationContentText: Codable {

    public enum ModelType: String, Codable { 
        case text = "Text"
    }



    /** Type of text content (Deprecated). */
    public var type: ModelType?
    /** Text to be shown for this content element. */
    public var body: String?

    public init(type: ModelType?, body: String?) {
        self.type = type
        self.body = body
    }


}




public class ConversationDeletionProtectionQuery: Codable {



    /** This is a list of ConversationIds. The list cannot exceed 100 conversationids. */
    public var conversationIds: [String]?

    public init(conversationIds: [String]?) {
        self.conversationIds = conversationIds
    }


}




public class ConversationDetailQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case conversationend = "conversationEnd"
        case conversationid = "conversationId"
        case conversationinitiator = "conversationInitiator"
        case conversationstart = "conversationStart"
        case customerparticipation = "customerParticipation"
        case divisionid = "divisionId"
        case externaltag = "externalTag"
        case mediastatsminconversationmos = "mediaStatsMinConversationMos"
        case originatingdirection = "originatingDirection"
    }

    public enum Metric: String, Codable { 
        case nblindtransferred = "nBlindTransferred"
        case nbotinteractions = "nBotInteractions"
        case ncobrowsesessions = "nCobrowseSessions"
        case nconnected = "nConnected"
        case nconsult = "nConsult"
        case nconsulttransferred = "nConsultTransferred"
        case nerror = "nError"
        case nflow = "nFlow"
        case nflowmilestone = "nFlowMilestone"
        case nflowoutcome = "nFlowOutcome"
        case nflowoutcomefailed = "nFlowOutcomeFailed"
        case noffered = "nOffered"
        case noutbound = "nOutbound"
        case noutboundabandoned = "nOutboundAbandoned"
        case noutboundattempted = "nOutboundAttempted"
        case noutboundconnected = "nOutboundConnected"
        case noversla = "nOverSla"
        case nstatetransitionerror = "nStateTransitionError"
        case ntransferred = "nTransferred"
        case oexternalmediacount = "oExternalMediaCount"
        case oflowmilestone = "oFlowMilestone"
        case omediacount = "oMediaCount"
        case omessageturn = "oMessageTurn"
        case tabandon = "tAbandon"
        case tacd = "tAcd"
        case tactivecallback = "tActiveCallback"
        case tactivecallbackcomplete = "tActiveCallbackComplete"
        case tacw = "tAcw"
        case tagentresponsetime = "tAgentResponseTime"
        case talert = "tAlert"
        case tanswered = "tAnswered"
        case tbarging = "tBarging"
        case tcoaching = "tCoaching"
        case tcoachingcomplete = "tCoachingComplete"
        case tconnected = "tConnected"
        case tcontacting = "tContacting"
        case tconversationduration = "tConversationDuration"
        case tdialing = "tDialing"
        case tfirstconnect = "tFirstConnect"
        case tfirstdial = "tFirstDial"
        case tflow = "tFlow"
        case tflowdisconnect = "tFlowDisconnect"
        case tflowexit = "tFlowExit"
        case tflowout = "tFlowOut"
        case tflowoutcome = "tFlowOutcome"
        case thandle = "tHandle"
        case theld = "tHeld"
        case theldcomplete = "tHeldComplete"
        case tivr = "tIvr"
        case tmonitoring = "tMonitoring"
        case tmonitoringcomplete = "tMonitoringComplete"
        case tnotresponding = "tNotResponding"
        case tpark = "tPark"
        case tparkcomplete = "tParkComplete"
        case tshortabandon = "tShortAbandon"
        case ttalk = "tTalk"
        case ttalkcomplete = "tTalkComplete"
        case tuserresponsetime = "tUserResponseTime"
        case tvoicemail = "tVoicemail"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Left hand side for metric predicates */
    public var metric: Metric?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension or metric predicates */
    public var value: String?
    /** Right hand side for dimension or metric predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, metric: Metric?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self.metric = metric
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case metric
        case _operator = "operator"
        case value
        case range
    }


}




public class ConversationEmailEventTopicEmailMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case timeout = "timeout"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }







































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }























    public var _id: String?
    public var name: String?
    public var address: String?
    public var startTime: Date?
    public var connectedTime: Date?
    public var endTime: Date?
    public var startHoldTime: Date?
    public var purpose: String?
    public var state: State?
    public var initialState: InitialState?
    public var direction: Direction?
    public var disconnectType: DisconnectType?
    public var held: Bool?
    public var wrapupRequired: Bool?
    public var wrapupPrompt: String?
    public var user: ConversationEmailEventTopicUriReference?
    public var queue: ConversationEmailEventTopicUriReference?
    public var team: ConversationEmailEventTopicUriReference?
    public var attributes: [String:String]?
    public var errorInfo: ConversationEmailEventTopicErrorBody?
    public var script: ConversationEmailEventTopicUriReference?
    public var wrapupTimeoutMs: Int?
    public var wrapupSkipped: Bool?
    public var alertingTimeoutMs: Int?
    public var provider: String?
    public var externalContact: ConversationEmailEventTopicUriReference?
    public var externalOrganization: ConversationEmailEventTopicUriReference?
    public var wrapup: ConversationEmailEventTopicWrapup?
    public var conversationRoutingData: ConversationEmailEventTopicConversationRoutingData?
    public var peer: String?
    public var screenRecordingState: String?
    public var flaggedReason: FlaggedReason?
    public var journeyContext: ConversationEmailEventTopicJourneyContext?
    public var startAcwTime: Date?
    public var endAcwTime: Date?
    public var mediaRoles: [String]?
    public var queueMediaSettings: ConversationEmailEventTopicQueueMediaSettings?
    public var subject: String?
    public var messagesSent: Int?
    public var autoGenerated: Bool?
    public var messageId: String?
    public var draftAttachments: [ConversationEmailEventTopicAttachment]?
    public var spam: Bool?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, initialState: InitialState?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, user: ConversationEmailEventTopicUriReference?, queue: ConversationEmailEventTopicUriReference?, team: ConversationEmailEventTopicUriReference?, attributes: [String:String]?, errorInfo: ConversationEmailEventTopicErrorBody?, script: ConversationEmailEventTopicUriReference?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, alertingTimeoutMs: Int?, provider: String?, externalContact: ConversationEmailEventTopicUriReference?, externalOrganization: ConversationEmailEventTopicUriReference?, wrapup: ConversationEmailEventTopicWrapup?, conversationRoutingData: ConversationEmailEventTopicConversationRoutingData?, peer: String?, screenRecordingState: String?, flaggedReason: FlaggedReason?, journeyContext: ConversationEmailEventTopicJourneyContext?, startAcwTime: Date?, endAcwTime: Date?, mediaRoles: [String]?, queueMediaSettings: ConversationEmailEventTopicQueueMediaSettings?, subject: String?, messagesSent: Int?, autoGenerated: Bool?, messageId: String?, draftAttachments: [ConversationEmailEventTopicAttachment]?, spam: Bool?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.conversationRoutingData = conversationRoutingData
        self.peer = peer
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.mediaRoles = mediaRoles
        self.queueMediaSettings = queueMediaSettings
        self.subject = subject
        self.messagesSent = messagesSent
        self.autoGenerated = autoGenerated
        self.messageId = messageId
        self.draftAttachments = draftAttachments
        self.spam = spam
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case initialState
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalOrganization
        case wrapup
        case conversationRoutingData
        case peer
        case screenRecordingState
        case flaggedReason
        case journeyContext
        case startAcwTime
        case endAcwTime
        case mediaRoles
        case queueMediaSettings
        case subject
        case messagesSent
        case autoGenerated
        case messageId
        case draftAttachments
        case spam
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class ConversationEmailEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: ConversationEmailEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: ConversationEmailEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}




public class ConversationEmailEventTopicJourneyContext: Codable {







    public var customer: ConversationEmailEventTopicJourneyCustomer?
    public var customerSession: ConversationEmailEventTopicJourneyCustomerSession?
    public var triggeringAction: ConversationEmailEventTopicJourneyAction?

    public init(customer: ConversationEmailEventTopicJourneyCustomer?, customerSession: ConversationEmailEventTopicJourneyCustomerSession?, triggeringAction: ConversationEmailEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class ConversationEmailEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}




public class ConversationEntityListing: Codable {





















    public var entities: [Conversation]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Conversation]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** A communication's after-call work data. */

public class ConversationEventTopicAfterCallWork: Codable {

    public enum State: String, Codable { 
        case unknown = "unknown"
        case skipped = "skipped"
        case pending = "pending"
        case complete = "complete"
        case notapplicable = "notApplicable"
    }





    /** The communication's after-call work state. */
    public var state: State?
    /** The timestamp when this communication started after-call work in the cloud clock. */
    public var startTime: Date?
    /** The timestamp when this communication ended after-call work in the cloud clock. */
    public var endTime: Date?

    public init(state: State?, startTime: Date?, endTime: Date?) {
        self.state = state
        self.startTime = startTime
        self.endTime = endTime
    }


}



/** Information on how a communication should be routed to an agent. */

public class ConversationEventTopicConversationRoutingData: Codable {











    public var queue: ConversationEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: ConversationEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int?
    /** The skills to use for routing decisions */
    public var skills: [ConversationEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [ConversationEventTopicScoredAgent]?

    public init(queue: ConversationEventTopicUriReference?, language: ConversationEventTopicUriReference?, priority: Int?, skills: [ConversationEventTopicUriReference]?, scoredAgents: [ConversationEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}



/** Detailed information about an error response. */

public class ConversationEventTopicErrorDetails: Codable {















    /** The HTTP status code for this message (400, 401, 403, 404, 500, etc. */
    public var status: Int?
    /** A code unique to this error. */
    public var code: String?
    /** Friendly description of this error. */
    public var message: String?
    /** This is the same as message except it uses template fields for variable replacement. For instance: 'User {username} was not found' */
    public var messageWithParams: String?
    /** Used in conjunction with messageWithParams. These are the template parameters. For instance: UserParam.key = 'username', UserParam.value = 'john.doe' */
    public var messageParams: [String:String]?
    /** The correlation Id or context Id for this message. If left blank the Public API will look at the HTTP response header 'ININ-Correlation-Id' instead. */
    public var contextId: String?
    public var uri: String?

    public init(status: Int?, code: String?, message: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, uri: String?) {
        self.status = status
        self.code = code
        self.message = message
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.uri = uri
    }


}



/** Fields identifying the initiator of a given conversation command. */

public class ConversationEventTopicInitiator: Codable {



    /** The id of the user who initiated the command if it was initiated by a user. */
    public var userId: String?

    public init(userId: String?) {
        self.userId = userId
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationMessageEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationMessageEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}




public class ConversationMetrics: Codable {







    public enum SentimentTrendClass: String, Codable { 
        case notCalculated = "NotCalculated"
        case declining = "Declining"
        case slightlyDeclining = "SlightlyDeclining"
        case noChange = "NoChange"
        case slightlyImproving = "SlightlyImproving"
        case improving = "Improving"
    }





    /** The Conversation Reference */
    public var conversation: AddressableEntityRef?
    /** The Sentiment Score */
    public var sentimentScore: Double?
    /** The Sentiment Trend */
    public var sentimentTrend: Double?
    /** The Sentiment Trend Class */
    public var sentimentTrendClass: SentimentTrendClass?
    /** The Empathy Scores */
    public var empathyScores: [EmpathyScore]?
    /** The Participant Metrics */
    public var participantMetrics: ParticipantMetrics?

    public init(conversation: AddressableEntityRef?, sentimentScore: Double?, sentimentTrend: Double?, sentimentTrendClass: SentimentTrendClass?, empathyScores: [EmpathyScore]?, participantMetrics: ParticipantMetrics?) {
        self.conversation = conversation
        self.sentimentScore = sentimentScore
        self.sentimentTrend = sentimentTrend
        self.sentimentTrendClass = sentimentTrendClass
        self.empathyScores = empathyScores
        self.participantMetrics = participantMetrics
    }


}




public class ConversationMessageEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: ConversationMessageEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int?

    public init(agent: ConversationMessageEventTopicUriReference?, score: Int?) {
        self.agent = agent
        self.score = score
    }


}



/** Information about the recipient the message is sent to. */

public class ConversationMessagingToRecipient: Codable {





    public enum IdType: String, Codable { 
        case email = "Email"
        case phone = "Phone"
        case opaque = "Opaque"
    }











    /** Nickname or display name of the recipient. */
    public var nickname: String?
    /** The recipient ID specific to the provider. */
    public var _id: String?
    /** The recipient ID type. This is used to indicate the format used for the ID. */
    public var idType: IdType?
    /** URL of an image that represents the recipient. */
    public var image: String?
    /** First name of the recipient. */
    public var firstName: String?
    /** Last name of the recipient. */
    public var lastName: String?
    /** E-mail address of the recipient. */
    public var email: String?
    /** List of recipient additional identifiers */
    public var additionalIds: [ConversationRecipientAdditionalIdentifier]?

    public init(nickname: String?, _id: String?, idType: IdType?, image: String?, firstName: String?, lastName: String?, email: String?, additionalIds: [ConversationRecipientAdditionalIdentifier]?) {
        self.nickname = nickname
        self._id = _id
        self.idType = idType
        self.image = image
        self.firstName = firstName
        self.lastName = lastName
        self.email = email
        self.additionalIds = additionalIds
    }

    public enum CodingKeys: String, CodingKey { 
        case nickname
        case _id = "id"
        case idType
        case image
        case firstName
        case lastName
        case email
        case additionalIds
    }


}




public class ConversationMetricsTopicConversationMetricRecord: Codable {

    public enum Metric: String, Codable { 
        case nblindtransferred = "nBlindTransferred"
        case ncobrowsesessions = "nCobrowseSessions"
        case nconnected = "nConnected"
        case nconsult = "nConsult"
        case nconsulttransferred = "nConsultTransferred"
        case nerror = "nError"
        case noffered = "nOffered"
        case noutbound = "nOutbound"
        case noutboundabandoned = "nOutboundAbandoned"
        case noutboundattempted = "nOutboundAttempted"
        case noutboundconnected = "nOutboundConnected"
        case noversla = "nOverSla"
        case ntransferred = "nTransferred"
        case oexternalmediacount = "oExternalMediaCount"
        case omediacount = "oMediaCount"
        case omessageturn = "oMessageTurn"
        case tabandon = "tAbandon"
        case tacd = "tAcd"
        case tactivecallback = "tActiveCallback"
        case tactivecallbackcomplete = "tActiveCallbackComplete"
        case tacw = "tAcw"
        case tagentresponsetime = "tAgentResponseTime"
        case talert = "tAlert"
        case tanswered = "tAnswered"
        case tbarging = "tBarging"
        case tcoaching = "tCoaching"
        case tcoachingcomplete = "tCoachingComplete"
        case tconnected = "tConnected"
        case tcontacting = "tContacting"
        case tdialing = "tDialing"
        case tfirstconnect = "tFirstConnect"
        case tfirstdial = "tFirstDial"
        case tflowout = "tFlowOut"
        case thandle = "tHandle"
        case theld = "tHeld"
        case theldcomplete = "tHeldComplete"
        case tivr = "tIvr"
        case tmonitoring = "tMonitoring"
        case tmonitoringcomplete = "tMonitoringComplete"
        case tnotresponding = "tNotResponding"
        case tpark = "tPark"
        case tparkcomplete = "tParkComplete"
        case ttalk = "tTalk"
        case ttalkcomplete = "tTalkComplete"
        case tuserresponsetime = "tUserResponseTime"
        case tvoicemail = "tVoicemail"
    }







    public enum ActiveRouting: String, Codable { 
        case bullseye = "Bullseye"
        case conditional = "Conditional"
        case direct = "Direct"
        case last = "Last"
        case manual = "Manual"
        case predictive = "Predictive"
        case preferred = "Preferred"
        case standard = "Standard"
        case vip = "Vip"
    }





















    public enum ConversationInitiator: String, Codable { 
        case acd = "acd"
        case agent = "agent"
        case api = "api"
        case botflow = "botflow"
        case campaign = "campaign"
        case customer = "customer"
        case dialer = "dialer"
        case external = "external"
        case fax = "fax"
        case group = "group"
        case inbound = "inbound"
        case ivr = "ivr"
        case manual = "manual"
        case outbound = "outbound"
        case station = "station"
        case user = "user"
        case voicemail = "voicemail"
        case workflow = "workflow"
    }







    public enum DeliveryStatus: String, Codable { 
        case deliveryFailed = "DeliveryFailed"
        case deliverySuccess = "DeliverySuccess"
        case failed = "Failed"
        case queued = "Queued"
        case read = "Read"
        case received = "Received"
        case sent = "Sent"
    }



    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case client = "client"
        case conferencetransfer = "conferenceTransfer"
        case consulttransfer = "consultTransfer"
        case endpoint = "endpoint"
        case endpointdnd = "endpointDnd"
        case error = "error"
        case forwardtransfer = "forwardTransfer"
        case noanswertransfer = "noAnswerTransfer"
        case notavailabletransfer = "notAvailableTransfer"
        case other = "other"
        case peer = "peer"
        case spam = "spam"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferdnd = "transferDnd"
        case transportfailure = "transportFailure"
        case uncallable = "uncallable"
    }























    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }



























    public enum MediaType: String, Codable { 
        case callback = "callback"
        case chat = "chat"
        case cobrowse = "cobrowse"
        case email = "email"
        case message = "message"
        case screenshare = "screenshare"
        case unknown = "unknown"
        case video = "video"
        case voice = "voice"
    }



    public enum OriginatingDirection: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }













    public enum Purpose: String, Codable { 
        case acd = "acd"
        case agent = "agent"
        case api = "api"
        case botflow = "botflow"
        case campaign = "campaign"
        case customer = "customer"
        case dialer = "dialer"
        case external = "external"
        case fax = "fax"
        case group = "group"
        case inbound = "inbound"
        case ivr = "ivr"
        case manual = "manual"
        case outbound = "outbound"
        case station = "station"
        case user = "user"
        case voicemail = "voicemail"
        case workflow = "workflow"
    }











    public enum RequestedRoutings: String, Codable { 
        case bullseye = "Bullseye"
        case conditional = "Conditional"
        case direct = "Direct"
        case last = "Last"
        case manual = "Manual"
        case predictive = "Predictive"
        case preferred = "Preferred"
        case standard = "Standard"
        case vip = "Vip"
    }









    public enum RoutingRuleType: String, Codable { 
        case bullseye = "Bullseye"
        case conditional = "Conditional"
        case predictive = "Predictive"
        case preferred = "Preferred"
    }















    public enum UsedRouting: String, Codable { 
        case bullseye = "Bullseye"
        case conditional = "Conditional"
        case direct = "Direct"
        case last = "Last"
        case manual = "Manual"
        case predictive = "Predictive"
        case preferred = "Preferred"
        case standard = "Standard"
        case vip = "Vip"
    }











    /** Metric name */
    public var metric: Metric?
    /** The date and time of metric creation */
    public var metricDate: Date?
    /** Metric value */
    public var value: Int?
    /** Record identifier */
    public var recordId: String?
    /** Active routing method */
    public var activeRouting: ActiveRouting?
    /** ID(s) of Skill(s) that are active on the conversation */
    public var activeSkillIds: [String]?
    /** The address that initiated an action */
    public var addressFrom: String?
    /** The address receiving an action */
    public var addressTo: String?
    /** Unique identifier of the active virtual agent assistant */
    public var agentAssistantId: String?
    /** Bullseye ring of the targeted agent */
    public var agentBullseyeRing: Int?
    /** Flag indicating an agent-owned callback */
    public var agentOwned: Bool?
    /** Automatic Number Identification (caller's number) */
    public var ani: String?
    /** ID of the user that manually assigned a conversation */
    public var assignerId: String?
    /** Flag that indicates that the identity of the customer has been asserted as verified by the provider. */
    public var authenticated: Bool?
    /** Unique identifier for the conversation */
    public var conversationId: String?
    /** Indicates the participant purpose of the participant initiating a message conversation */
    public var conversationInitiator: ConversationInitiator?
    /** Session media type that was converted from in case of a media type conversion */
    public var convertedFrom: String?
    /** Session media type that was converted to in case of a media type conversion */
    public var convertedTo: String?
    /** Indicates a messaging conversation in which the customer participated by sending at least one message */
    public var customerParticipation: Bool?
    /** The email or SMS delivery status */
    public var deliveryStatus: DeliveryStatus?
    /** Destination address(es) of transfers or consults */
    public var destinationAddresses: [String]?
    /** The direction of the communication */
    public var direction: Direction?
    /** The session disconnect type */
    public var disconnectType: DisconnectType?
    /** Identifier(s) of division(s) associated with a conversation */
    public var divisionIds: [String]?
    /** Dialed number identification service (number dialed by the calling party) */
    public var dnis: String?
    /** Unique identifier of the edge device */
    public var edgeId: String?
    /** Number of eligible agents for each predictive routing attempt */
    public var eligibleAgentCounts: [Int]?
    /** A code corresponding to the error that occurred */
    public var errorCode: String?
    /** Extended delivery status */
    public var extendedDeliveryStatus: String?
    /** External contact identifier */
    public var externalContactId: String?
    /** Count of any media (images, files, etc) included on the external session */
    public var externalMediaCount: Int?
    /** External organization identifier */
    public var externalOrganizationId: String?
    /** External tag for the conversation */
    public var externalTag: String?
    /** Marker that is set if the current queue is the first queue in a conversation */
    public var firstQueue: Bool?
    /** Reason for which participant flagged conversation */
    public var flaggedReason: FlaggedReason?
    /** Type of flow in that occurred when entering ACD. */
    public var flowInType: String?
    /** Type of flow out that occurred when emitting tFlowOut. */
    public var flowOutType: String?
    /** Unique identifier for a PureCloud group */
    public var groupId: String?
    /** The interaction type (enterprise or contactCenter) */
    public var interactionType: String?
    /** Identifier of the journey action. */
    public var journeyActionId: String?
    /** Identifier of the journey action map that triggered the action. */
    public var journeyActionMapId: String?
    /** Version of the journey action map that triggered the action. */
    public var journeyActionMapVersion: Int?
    /** Primary identifier of the journey customer in the source where the activities originate from. */
    public var journeyCustomerId: String?
    /** Type of primary identifier of the journey customer (e.g. cookie). */
    public var journeyCustomerIdType: String?
    /** Unique identifier of the journey session. */
    public var journeyCustomerSessionId: String?
    /** Type or category of journey sessions (e.g. web, ticket, delivery, atm). */
    public var journeyCustomerSessionIdType: String?
    /** The unique identifier(s) of the knowledge base(s) used */
    public var knowledgeBaseIds: [String]?
    /** Count of any media (images, files, etc) included in this session */
    public var mediaCount: Int?
    /** The session media type */
    public var mediaType: MediaType?
    /** Message type for messaging services. E.g.: sms, facebook, twitter, line */
    public var messageType: String?
    /** The original direction of the conversation */
    public var originatingDirection: OriginatingDirection?
    /** (Dialer) Unique identifier of the outbound campaign */
    public var outboundCampaignId: String?
    /** (Dialer) Unique identifier of the contact */
    public var outboundContactId: String?
    /** (Dialer) Unique identifier of the contact list that this contact belongs to */
    public var outboundContactListId: String?
    /** A human readable name identifying the participant */
    public var participantName: String?
    /** This identifies pairs of related sessions on a conversation. E.g. an external sessions peerId will be the session that the call originally connected to, e.g. if an IVR was dialed, the IVR session, which will also have the external sessions ID as its peer. After that point, any transfers of that session to other internal components (acd, agent, etc.) will all spawn new sessions whose peerIds point back to that original external session. */
    public var peerId: String?
    /** The source provider for the communication. */
    public var provider: String?
    /** The participant's purpose */
    public var purpose: Purpose?
    /** Queue identifier */
    public var queueId: String?
    /** Name, phone number, or email address of the remote party. */
    public var remote: String?
    /** ID(s) of Skill(s) that have been removed by bullseye routing */
    public var removedSkillIds: [String]?
    /** Unique identifier for the language requested for an interaction */
    public var requestedLanguageId: String?
    /** Unique identifier(s) for skill(s) requested for an interaction */
    public var requestedRoutingSkillIds: [String]?
    /** Routing type(s) for requested/attempted routing methods. */
    public var requestedRoutings: [RequestedRoutings]?
    /** Unique identifier for the room */
    public var roomId: String?
    /** Routing priority for the current interaction */
    public var routingPriority: Int?
    /** Routing ring for bullseye or preferred agent routing */
    public var routingRing: Int?
    /** Routing rule for preferred, conditional and predictive routing type */
    public var routingRule: String?
    /** Routing rule type */
    public var routingRuleType: RoutingRuleType?
    /** Selected agent ID */
    public var selectedAgentId: String?
    /** Selected agent GPR rank */
    public var selectedAgentRank: Int?
    /** Indicates whether all flow sessions were self serviced */
    public var selfServed: Bool?
    /** Dialed number for the current session; this can be different from dnis, e.g. if the call was transferred */
    public var sessionDnis: String?
    /** The unique identifier of this session */
    public var sessionId: String?
    /** Unique identifier for a phone */
    public var stationId: String?
    /** The team ID the user is a member of */
    public var teamId: String?
    /** Complete routing method */
    public var usedRouting: UsedRouting?
    /** Unique identifier for the user */
    public var userId: String?
    /** Number of waiting interactions for each predictive routing attempt */
    public var waitingInteractionCounts: [Int]?
    /** Wrap up code */
    public var wrapUpCode: String?
    /** Proposed agents */
    public var proposedAgents: [ConversationMetricsTopicConversationProposedAgent]?
    /** Scored agents */
    public var scoredAgents: [ConversationMetricsTopicConversationScoredAgent]?

    public init(metric: Metric?, metricDate: Date?, value: Int?, recordId: String?, activeRouting: ActiveRouting?, activeSkillIds: [String]?, addressFrom: String?, addressTo: String?, agentAssistantId: String?, agentBullseyeRing: Int?, agentOwned: Bool?, ani: String?, assignerId: String?, authenticated: Bool?, conversationId: String?, conversationInitiator: ConversationInitiator?, convertedFrom: String?, convertedTo: String?, customerParticipation: Bool?, deliveryStatus: DeliveryStatus?, destinationAddresses: [String]?, direction: Direction?, disconnectType: DisconnectType?, divisionIds: [String]?, dnis: String?, edgeId: String?, eligibleAgentCounts: [Int]?, errorCode: String?, extendedDeliveryStatus: String?, externalContactId: String?, externalMediaCount: Int?, externalOrganizationId: String?, externalTag: String?, firstQueue: Bool?, flaggedReason: FlaggedReason?, flowInType: String?, flowOutType: String?, groupId: String?, interactionType: String?, journeyActionId: String?, journeyActionMapId: String?, journeyActionMapVersion: Int?, journeyCustomerId: String?, journeyCustomerIdType: String?, journeyCustomerSessionId: String?, journeyCustomerSessionIdType: String?, knowledgeBaseIds: [String]?, mediaCount: Int?, mediaType: MediaType?, messageType: String?, originatingDirection: OriginatingDirection?, outboundCampaignId: String?, outboundContactId: String?, outboundContactListId: String?, participantName: String?, peerId: String?, provider: String?, purpose: Purpose?, queueId: String?, remote: String?, removedSkillIds: [String]?, requestedLanguageId: String?, requestedRoutingSkillIds: [String]?, requestedRoutings: [RequestedRoutings]?, roomId: String?, routingPriority: Int?, routingRing: Int?, routingRule: String?, routingRuleType: RoutingRuleType?, selectedAgentId: String?, selectedAgentRank: Int?, selfServed: Bool?, sessionDnis: String?, sessionId: String?, stationId: String?, teamId: String?, usedRouting: UsedRouting?, userId: String?, waitingInteractionCounts: [Int]?, wrapUpCode: String?, proposedAgents: [ConversationMetricsTopicConversationProposedAgent]?, scoredAgents: [ConversationMetricsTopicConversationScoredAgent]?) {
        self.metric = metric
        self.metricDate = metricDate
        self.value = value
        self.recordId = recordId
        self.activeRouting = activeRouting
        self.activeSkillIds = activeSkillIds
        self.addressFrom = addressFrom
        self.addressTo = addressTo
        self.agentAssistantId = agentAssistantId
        self.agentBullseyeRing = agentBullseyeRing
        self.agentOwned = agentOwned
        self.ani = ani
        self.assignerId = assignerId
        self.authenticated = authenticated
        self.conversationId = conversationId
        self.conversationInitiator = conversationInitiator
        self.convertedFrom = convertedFrom
        self.convertedTo = convertedTo
        self.customerParticipation = customerParticipation
        self.deliveryStatus = deliveryStatus
        self.destinationAddresses = destinationAddresses
        self.direction = direction
        self.disconnectType = disconnectType
        self.divisionIds = divisionIds
        self.dnis = dnis
        self.edgeId = edgeId
        self.eligibleAgentCounts = eligibleAgentCounts
        self.errorCode = errorCode
        self.extendedDeliveryStatus = extendedDeliveryStatus
        self.externalContactId = externalContactId
        self.externalMediaCount = externalMediaCount
        self.externalOrganizationId = externalOrganizationId
        self.externalTag = externalTag
        self.firstQueue = firstQueue
        self.flaggedReason = flaggedReason
        self.flowInType = flowInType
        self.flowOutType = flowOutType
        self.groupId = groupId
        self.interactionType = interactionType
        self.journeyActionId = journeyActionId
        self.journeyActionMapId = journeyActionMapId
        self.journeyActionMapVersion = journeyActionMapVersion
        self.journeyCustomerId = journeyCustomerId
        self.journeyCustomerIdType = journeyCustomerIdType
        self.journeyCustomerSessionId = journeyCustomerSessionId
        self.journeyCustomerSessionIdType = journeyCustomerSessionIdType
        self.knowledgeBaseIds = knowledgeBaseIds
        self.mediaCount = mediaCount
        self.mediaType = mediaType
        self.messageType = messageType
        self.originatingDirection = originatingDirection
        self.outboundCampaignId = outboundCampaignId
        self.outboundContactId = outboundContactId
        self.outboundContactListId = outboundContactListId
        self.participantName = participantName
        self.peerId = peerId
        self.provider = provider
        self.purpose = purpose
        self.queueId = queueId
        self.remote = remote
        self.removedSkillIds = removedSkillIds
        self.requestedLanguageId = requestedLanguageId
        self.requestedRoutingSkillIds = requestedRoutingSkillIds
        self.requestedRoutings = requestedRoutings
        self.roomId = roomId
        self.routingPriority = routingPriority
        self.routingRing = routingRing
        self.routingRule = routingRule
        self.routingRuleType = routingRuleType
        self.selectedAgentId = selectedAgentId
        self.selectedAgentRank = selectedAgentRank
        self.selfServed = selfServed
        self.sessionDnis = sessionDnis
        self.sessionId = sessionId
        self.stationId = stationId
        self.teamId = teamId
        self.usedRouting = usedRouting
        self.userId = userId
        self.waitingInteractionCounts = waitingInteractionCounts
        self.wrapUpCode = wrapUpCode
        self.proposedAgents = proposedAgents
        self.scoredAgents = scoredAgents
    }


}




public class ConversationMetricsTopicConversationProposedAgent: Codable {





    /** Proposed agent rank for this conversation from predictive routing (lower is better) */
    public var agentRank: Int?
    /** Unique identifier for the agent that was proposed by predictive routing */
    public var proposedAgentId: String?

    public init(agentRank: Int?, proposedAgentId: String?) {
        self.agentRank = agentRank
        self.proposedAgentId = proposedAgentId
    }


}



/** Template parameters for placeholders in template. */

public class ConversationNotificationTemplateParameter: Codable {





    /** Parameter name. */
    public var name: String?
    /** Parameter text value. */
    public var text: String?

    public init(name: String?, text: String?) {
        self.name = name
        self.text = text
    }


}




public class ConversationRoutingData: Codable {













    /** The queue to use for routing decisions */
    public var queue: AddressableEntityRef?
    /** The language to use for routing decisions */
    public var language: AddressableEntityRef?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int?
    /** The skills to use for routing decisions */
    public var skills: [AddressableEntityRef]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [ScoredAgent]?
    /** An optional label that categorizes the conversation.  Max-utilization settings can be configured at a per-label level */
    public var label: String?

    public init(queue: AddressableEntityRef?, language: AddressableEntityRef?, priority: Int?, skills: [AddressableEntityRef]?, scoredAgents: [ScoredAgent]?, label: String?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
        self.label = label
    }


}




public class ConversationScreenShareEventTopicDetail: Codable {









    public var errorCode: String?
    public var fieldName: String?
    public var entityId: String?
    public var entityName: String?

    public init(errorCode: String?, fieldName: String?, entityId: String?, entityName: String?) {
        self.errorCode = errorCode
        self.fieldName = fieldName
        self.entityId = entityId
        self.entityName = entityName
    }


}




public class ConversationScreenShareEventTopicErrorBody: Codable {





















    public var message: String?
    public var code: String?
    public var status: Int?
    public var entityId: String?
    public var entityName: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var contextId: String?
    public var details: [ConversationScreenShareEventTopicDetail]?
    public var errors: [ConversationScreenShareEventTopicErrorBody]?

    public init(message: String?, code: String?, status: Int?, entityId: String?, entityName: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, details: [ConversationScreenShareEventTopicDetail]?, errors: [ConversationScreenShareEventTopicErrorBody]?) {
        self.message = message
        self.code = code
        self.status = status
        self.entityId = entityId
        self.entityName = entityName
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.details = details
        self.errors = errors
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class ConversationScreenShareEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int?

    public init(_id: String?, version: Int?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}




public class ConversationScreenShareEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class ConversationSocialExpressionEventTopicConversationRoutingData: Codable {











    /** A UriReference for a resource */
    public var queue: ConversationSocialExpressionEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: ConversationSocialExpressionEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int?
    /** The skills to use for routing decisions */
    public var skills: [ConversationSocialExpressionEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [ConversationSocialExpressionEventTopicScoredAgent]?

    public init(queue: ConversationSocialExpressionEventTopicUriReference?, language: ConversationSocialExpressionEventTopicUriReference?, priority: Int?, skills: [ConversationSocialExpressionEventTopicUriReference]?, scoredAgents: [ConversationSocialExpressionEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class ConversationVideoEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: ConversationVideoEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: ConversationVideoEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}




public class ConversationVideoEventTopicJourneyContext: Codable {







    public var customer: ConversationVideoEventTopicJourneyCustomer?
    public var customerSession: ConversationVideoEventTopicJourneyCustomerSession?
    public var triggeringAction: ConversationVideoEventTopicJourneyAction?

    public init(customer: ConversationVideoEventTopicJourneyCustomer?, customerSession: ConversationVideoEventTopicJourneyCustomerSession?, triggeringAction: ConversationVideoEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class ConversationVideoEventTopicVideoMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case timeout = "timeout"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }







































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }























    public var _id: String?
    public var name: String?
    public var address: String?
    public var startTime: Date?
    public var connectedTime: Date?
    public var endTime: Date?
    public var startHoldTime: Date?
    public var purpose: String?
    public var state: State?
    public var initialState: InitialState?
    public var direction: Direction?
    public var disconnectType: DisconnectType?
    public var held: Bool?
    public var wrapupRequired: Bool?
    public var wrapupPrompt: String?
    public var user: ConversationVideoEventTopicUriReference?
    public var queue: ConversationVideoEventTopicUriReference?
    public var team: ConversationVideoEventTopicUriReference?
    public var attributes: [String:String]?
    public var errorInfo: ConversationVideoEventTopicErrorBody?
    public var script: ConversationVideoEventTopicUriReference?
    public var wrapupTimeoutMs: Int?
    public var wrapupSkipped: Bool?
    public var alertingTimeoutMs: Int?
    public var provider: String?
    public var externalContact: ConversationVideoEventTopicUriReference?
    public var externalOrganization: ConversationVideoEventTopicUriReference?
    public var wrapup: ConversationVideoEventTopicWrapup?
    public var conversationRoutingData: ConversationVideoEventTopicConversationRoutingData?
    public var peer: String?
    public var screenRecordingState: String?
    public var flaggedReason: FlaggedReason?
    public var journeyContext: ConversationVideoEventTopicJourneyContext?
    public var startAcwTime: Date?
    public var endAcwTime: Date?
    public var mediaRoles: [String]?
    public var queueMediaSettings: ConversationVideoEventTopicQueueMediaSettings?
    public var audioMuted: Bool?
    public var videoMuted: Bool?
    public var sharingScreen: Bool?
    public var peerCount: Int?
    public var context: String?
    public var msids: [String]?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, initialState: InitialState?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, user: ConversationVideoEventTopicUriReference?, queue: ConversationVideoEventTopicUriReference?, team: ConversationVideoEventTopicUriReference?, attributes: [String:String]?, errorInfo: ConversationVideoEventTopicErrorBody?, script: ConversationVideoEventTopicUriReference?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, alertingTimeoutMs: Int?, provider: String?, externalContact: ConversationVideoEventTopicUriReference?, externalOrganization: ConversationVideoEventTopicUriReference?, wrapup: ConversationVideoEventTopicWrapup?, conversationRoutingData: ConversationVideoEventTopicConversationRoutingData?, peer: String?, screenRecordingState: String?, flaggedReason: FlaggedReason?, journeyContext: ConversationVideoEventTopicJourneyContext?, startAcwTime: Date?, endAcwTime: Date?, mediaRoles: [String]?, queueMediaSettings: ConversationVideoEventTopicQueueMediaSettings?, audioMuted: Bool?, videoMuted: Bool?, sharingScreen: Bool?, peerCount: Int?, context: String?, msids: [String]?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.conversationRoutingData = conversationRoutingData
        self.peer = peer
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.mediaRoles = mediaRoles
        self.queueMediaSettings = queueMediaSettings
        self.audioMuted = audioMuted
        self.videoMuted = videoMuted
        self.sharingScreen = sharingScreen
        self.peerCount = peerCount
        self.context = context
        self.msids = msids
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case initialState
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalOrganization
        case wrapup
        case conversationRoutingData
        case peer
        case screenRecordingState
        case flaggedReason
        case journeyContext
        case startAcwTime
        case endAcwTime
        case mediaRoles
        case queueMediaSettings
        case audioMuted
        case videoMuted
        case sharingScreen
        case peerCount
        case context
        case msids
    }


}




public class ConversationVideoEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}




public class CopyBuForecastRequest: Codable {





    /** The description for the forecast */
    public var _description: String?
    /** The start date of the new forecast to create from the existing forecast. Must correspond to the start day of week for the business unit. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekDate: Date?

    public init(_description: String?, weekDate: Date?) {
        self._description = _description
        self.weekDate = weekDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _description = "description"
        case weekDate
    }


}




public class CreateAdminTimeOffRequest: Codable {

    public enum Status: String, Codable { 
        case pending = "PENDING"
        case approved = "APPROVED"
    }



















    /** The status of this time off request */
    public var status: Status?
    /** A set of IDs for users to associate with this time off request */
    public var users: [UserReference]?
    /** The ID of the activity code associated with this time off request. Activity code must be of the TimeOff category */
    public var activityCodeId: String?
    /** Notes about the time off request */
    public var notes: String?
    /** A set of dates in yyyy-MM-dd format.  Should be interpreted in the management unit's configured time zone. */
    public var fullDayManagementUnitDates: [String]?
    /** A set of start date-times in ISO-8601 format for partial day requests. */
    public var partialDayStartDateTimes: [Date]?
    /** The daily duration of this time off request in minutes */
    public var dailyDurationMinutes: Int?
    /** Daily durations for each day of this time off request in minutes */
    public var durationMinutes: [Int]?
    /** Payable minutes for each day of this time off request */
    public var payableMinutes: [Int]?
    /** Whether this is a paid time off request */
    public var paid: Bool?

    public init(status: Status?, users: [UserReference]?, activityCodeId: String?, notes: String?, fullDayManagementUnitDates: [String]?, partialDayStartDateTimes: [Date]?, dailyDurationMinutes: Int?, durationMinutes: [Int]?, payableMinutes: [Int]?, paid: Bool?) {
        self.status = status
        self.users = users
        self.activityCodeId = activityCodeId
        self.notes = notes
        self.fullDayManagementUnitDates = fullDayManagementUnitDates
        self.partialDayStartDateTimes = partialDayStartDateTimes
        self.dailyDurationMinutes = dailyDurationMinutes
        self.durationMinutes = durationMinutes
        self.payableMinutes = payableMinutes
        self.paid = paid
    }


}




public class CreateBenefitAssessmentJobRequest: Codable {



    /** The list of division ids for routing queues that are to be assessed for Predictive Routing benefit. */
    public var divisionIds: [String]?

    public init(divisionIds: [String]?) {
        self.divisionIds = divisionIds
    }


}



/** Details for an Integration */

public class CreateIntegrationRequest: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the integration, used to distinguish this integration from others of the same type. */
    public var name: String?
    /** Type of the integration to create. */
    public var integrationType: IntegrationType?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, integrationType: IntegrationType?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.integrationType = integrationType
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case integrationType
        case selfUri
    }


}




public class CreateManagementUnitSettingsRequest: Codable {











    /** Adherence settings for this management unit */
    public var adherence: AdherenceSettings?
    /** Short term forecasting settings for this management unit.  Moving to Business Unit */
    public var shortTermForecasting: ShortTermForecastingSettings?
    /** Time off request settings for this management unit */
    public var timeOff: TimeOffRequestSettings?
    /** Scheduling settings for this management unit */
    public var scheduling: SchedulingSettingsRequest?
    /** Shift trade settings for this management unit */
    public var shiftTrading: ShiftTradeSettings?

    public init(adherence: AdherenceSettings?, shortTermForecasting: ShortTermForecastingSettings?, timeOff: TimeOffRequestSettings?, scheduling: SchedulingSettingsRequest?, shiftTrading: ShiftTradeSettings?) {
        self.adherence = adherence
        self.shortTermForecasting = shortTermForecasting
        self.timeOff = timeOff
        self.scheduling = scheduling
        self.shiftTrading = shiftTrading
    }


}




public class CreateResponseAssetResponse: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Pre-signed URL to PUT the file to */
    public var url: String?
    /** Required headers when uploading a file through PUT request to the URL */
    public var headers: [String:String]?

    public init(_id: String?, url: String?, headers: [String:String]?) {
        self._id = _id
        self.url = url
        self.headers = headers
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case url
        case headers
    }


}




public class CreateServiceGoalTemplate: Codable {











    /** The name of the service goal template. */
    public var name: String?
    /** Service level targets for this service goal template */
    public var serviceLevel: BuServiceLevel?
    /** Average speed of answer targets for this service goal template */
    public var averageSpeedOfAnswer: BuAverageSpeedOfAnswer?
    /** Abandon rate targets for this service goal template */
    public var abandonRate: BuAbandonRate?
    /** Settings controlling max percent increase and decrease of service goals for this service goal template */
    public var impactOverride: ServiceGoalTemplateImpactOverride?

    public init(name: String?, serviceLevel: BuServiceLevel?, averageSpeedOfAnswer: BuAverageSpeedOfAnswer?, abandonRate: BuAbandonRate?, impactOverride: ServiceGoalTemplateImpactOverride?) {
        self.name = name
        self.serviceLevel = serviceLevel
        self.averageSpeedOfAnswer = averageSpeedOfAnswer
        self.abandonRate = abandonRate
        self.impactOverride = impactOverride
    }


}




public class CreateShareResponse: Codable {





    public enum SharedEntityType: String, Codable { 
        case document = "DOCUMENT"
    }



    public enum MemberType: String, Codable { 
        case user = "USER"
        case group = "GROUP"
        case _public = "PUBLIC"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var sharedEntityType: SharedEntityType?
    public var sharedEntity: DomainEntityRef?
    public var memberType: MemberType?
    public var member: DomainEntityRef?
    public var sharedBy: DomainEntityRef?
    public var workspace: DomainEntityRef?
    public var succeeded: [Share]?
    public var failed: [Share]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, sharedEntityType: SharedEntityType?, sharedEntity: DomainEntityRef?, memberType: MemberType?, member: DomainEntityRef?, sharedBy: DomainEntityRef?, workspace: DomainEntityRef?, succeeded: [Share]?, failed: [Share]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.sharedEntityType = sharedEntityType
        self.sharedEntity = sharedEntity
        self.memberType = memberType
        self.member = member
        self.sharedBy = sharedBy
        self.workspace = workspace
        self.succeeded = succeeded
        self.failed = failed
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case sharedEntityType
        case sharedEntity
        case memberType
        case member
        case sharedBy
        case workspace
        case succeeded
        case failed
        case selfUri
    }


}




public class CredentialType: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Properties describing credentials of this type. */
    public var properties: JSON?
    /** Order in which properties should be displayed in the UI. */
    public var displayOrder: [String]?
    /** Properties that are required fields. */
    public var _required: [String]?

    public init(_id: String?, name: String?, properties: JSON?, displayOrder: [String]?, _required: [String]?) {
        self._id = _id
        self.name = name
        self.properties = properties
        self.displayOrder = displayOrder
        self._required = _required
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case properties
        case displayOrder
        case _required = "required"
    }


}




public class CredentialTypeListing: Codable {





















    public var entities: [CredentialType]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CredentialType]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CrossPlatformChatMediaPolicy: Codable {





    /** Actions applied when specified conditions are met */
    public var actions: CrossPlatformPolicyActions?
    /** Conditions for when actions should be applied */
    public var conditions: ChatMediaPolicyConditions?

    public init(actions: CrossPlatformPolicyActions?, conditions: ChatMediaPolicyConditions?) {
        self.actions = actions
        self.conditions = conditions
    }


}




public class CrossPlatformMessageMediaPolicy: Codable {





    /** Actions applied when specified conditions are met */
    public var actions: CrossPlatformPolicyActions?
    /** Conditions for when actions should be applied */
    public var conditions: MessageMediaPolicyConditions?

    public init(actions: CrossPlatformPolicyActions?, conditions: MessageMediaPolicyConditions?) {
        self.actions = actions
        self.conditions = conditions
    }


}




public class CursorOrganizationListing: Codable {











    public var entities: [ExternalOrganization]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?
    /** The cursor that points to the next set of entities being returned. */
    public var cursors: Cursors?

    public init(entities: [ExternalOrganization]?, nextUri: String?, selfUri: String?, previousUri: String?, cursors: Cursors?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
        self.cursors = cursors
    }


}




public class CustomEventAttribute: Codable {





    /** The data type of the custom attribute. */
    public var dataType: String?
    /** The value of the custom attribute. */
    public var value: String?

    public init(dataType: String?, value: String?) {
        self.dataType = dataType
        self.value = value
    }


}




public class CustomerEndDetailEventTopicCustomerEndEvent: Codable {









    public enum DisconnectType: String, Codable { 
        case unknown = "UNKNOWN"
        case endpoint = "ENDPOINT"
        case client = "CLIENT"
        case system = "SYSTEM"
        case transfer = "TRANSFER"
        case error = "ERROR"
        case peer = "PEER"
        case other = "OTHER"
        case spam = "SPAM"
        case timeout = "TIMEOUT"
        case transportFailure = "TRANSPORT_FAILURE"
        case conferenceTransfer = "CONFERENCE_TRANSFER"
        case consultTransfer = "CONSULT_TRANSFER"
        case forwardTransfer = "FORWARD_TRANSFER"
        case noAnswerTransfer = "NO_ANSWER_TRANSFER"
        case notAvailableTransfer = "NOT_AVAILABLE_TRANSFER"
        case uncallable = "UNCALLABLE"
        case dndEndpoint = "DND_ENDPOINT"
        case dndTransfer = "DND_TRANSFER"
    }

    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
    }







    public enum Direction: String, Codable { 
        case unknown = "UNKNOWN"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }

















    public enum MessageType: String, Codable { 
        case unknown = "UNKNOWN"
        case sms = "SMS"
        case twitter = "TWITTER"
        case facebook = "FACEBOOK"
        case line = "LINE"
        case whatsapp = "WHATSAPP"
        case webmessaging = "WEBMESSAGING"
        case _open = "OPEN"
        case instagram = "INSTAGRAM"
    }







    public var eventTime: Int?
    public var conversationId: String?
    public var participantId: String?
    public var sessionId: String?
    public var disconnectType: DisconnectType?
    public var mediaType: MediaType?
    public var externalOrganizationId: String?
    public var externalContactId: String?
    public var provider: String?
    public var direction: Direction?
    public var ani: String?
    public var dnis: String?
    public var addressTo: String?
    public var addressFrom: String?
    public var callbackUserName: String?
    public var callbackNumbers: [String]?
    public var callbackScheduledTime: Int?
    public var subject: String?
    public var messageType: MessageType?
    public var interactingDurationMs: Int?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?

    public init(eventTime: Int?, conversationId: String?, participantId: String?, sessionId: String?, disconnectType: DisconnectType?, mediaType: MediaType?, externalOrganizationId: String?, externalContactId: String?, provider: String?, direction: Direction?, ani: String?, dnis: String?, addressTo: String?, addressFrom: String?, callbackUserName: String?, callbackNumbers: [String]?, callbackScheduledTime: Int?, subject: String?, messageType: MessageType?, interactingDurationMs: Int?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.sessionId = sessionId
        self.disconnectType = disconnectType
        self.mediaType = mediaType
        self.externalOrganizationId = externalOrganizationId
        self.externalContactId = externalContactId
        self.provider = provider
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.addressTo = addressTo
        self.addressFrom = addressFrom
        self.callbackUserName = callbackUserName
        self.callbackNumbers = callbackNumbers
        self.callbackScheduledTime = callbackScheduledTime
        self.subject = subject
        self.messageType = messageType
        self.interactingDurationMs = interactingDurationMs
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
    }


}




public class DailyPossibleShift: Codable {

    public enum DayOfWeek: String, Codable { 
        case sunday = "Sunday"
        case monday = "Monday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
        case thursday = "Thursday"
        case friday = "Friday"
        case saturday = "Saturday"
    }











    /** Day of the shift */
    public var dayOfWeek: DayOfWeek?
    /** Minutes of the earliest shift start from midnight. Note that midnight is 12:00 am in the time zone specified in the timeZone field (in the top level of the response) */
    public var earliestShiftStartMinutesFromMidnight: Int?
    /** Whether this is a required shift */
    public var _required: Bool?
    /** Minimum paid time in minutes of this daily shift */
    public var minimumPaidTimeMinutes: Int?
    /** Maximum paid time in minutes of this daily shift */
    public var maximumPaidTimeMinutes: Int?
    /** The percentage of being scheduled in each interval between the earliest shift start and latest shift end. Range of the values: [0, 100]. */
    public var intervalScheduleProbabilities: [Int]?

    public init(dayOfWeek: DayOfWeek?, earliestShiftStartMinutesFromMidnight: Int?, _required: Bool?, minimumPaidTimeMinutes: Int?, maximumPaidTimeMinutes: Int?, intervalScheduleProbabilities: [Int]?) {
        self.dayOfWeek = dayOfWeek
        self.earliestShiftStartMinutesFromMidnight = earliestShiftStartMinutesFromMidnight
        self._required = _required
        self.minimumPaidTimeMinutes = minimumPaidTimeMinutes
        self.maximumPaidTimeMinutes = maximumPaidTimeMinutes
        self.intervalScheduleProbabilities = intervalScheduleProbabilities
    }

    public enum CodingKeys: String, CodingKey { 
        case dayOfWeek
        case earliestShiftStartMinutesFromMidnight
        case _required = "required"
        case minimumPaidTimeMinutes
        case maximumPaidTimeMinutes
        case intervalScheduleProbabilities
    }


}




public class DataActionConditionPredicate: Codable {



    public enum OutputOperator: String, Codable { 
        case equals = "EQUALS"
        case lessThan = "LESS_THAN"
        case lessThanEquals = "LESS_THAN_EQUALS"
        case greaterThan = "GREATER_THAN"
        case greaterThanEquals = "GREATER_THAN_EQUALS"
        case contains = "CONTAINS"
        case beginsWith = "BEGINS_WITH"
        case endsWith = "ENDS_WITH"
        case before = "BEFORE"
        case after = "AFTER"
    }







    /** The name of an output field from the data action's output to use for this condition */
    public var outputField: String?
    /** The operation with which to evaluate this condition */
    public var outputOperator: OutputOperator?
    /** The value to compare against for this condition */
    public var comparisonValue: String?
    /** If true, inverts the result of evaluating this Predicate. Default is false. */
    public var inverted: Bool?
    /** The result of this predicate if the requested output field is missing from the data action's result */
    public var outputFieldMissingResolution: Bool?

    public init(outputField: String?, outputOperator: OutputOperator?, comparisonValue: String?, inverted: Bool?, outputFieldMissingResolution: Bool?) {
        self.outputField = outputField
        self.outputOperator = outputOperator
        self.comparisonValue = comparisonValue
        self.inverted = inverted
        self.outputFieldMissingResolution = outputFieldMissingResolution
    }


}




public class DataActionContactColumnFieldMapping: Codable {





    /** The name of a contact column whose data will be passed to the data action */
    public var contactColumnName: String?
    /** The name of an input field from the data action that the contact column data will be passed to */
    public var dataActionField: String?

    public init(contactColumnName: String?, dataActionField: String?) {
        self.contactColumnName = contactColumnName
        self.dataActionField = dataActionField
    }


}




public class DefaultGreetingList: Codable {







    public enum OwnerType: String, Codable { 
        case user = "USER"
        case organization = "ORGANIZATION"
        case group = "GROUP"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var owner: GreetingOwner?
    public var ownerType: OwnerType?
    public var greetings: [String:Greeting]?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    public var createdBy: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    public var modifiedBy: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, owner: GreetingOwner?, ownerType: OwnerType?, greetings: [String:Greeting]?, createdDate: Date?, createdBy: String?, modifiedDate: Date?, modifiedBy: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.owner = owner
        self.ownerType = ownerType
        self.greetings = greetings
        self.createdDate = createdDate
        self.createdBy = createdBy
        self.modifiedDate = modifiedDate
        self.modifiedBy = modifiedBy
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case owner
        case ownerType
        case greetings
        case createdDate
        case createdBy
        case modifiedDate
        case modifiedBy
        case selfUri
    }


}




public class DefaultObjective: Codable {









    public enum MediaTypes: String, Codable { 
        case callback = "callback"
        case chat = "chat"
        case cobrowse = "cobrowse"
        case email = "email"
        case message = "message"
        case screenshare = "screenshare"
        case unknown = "unknown"
        case video = "video"
        case voice = "voice"
    }





    public enum TopicIdsFilterType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The id of this objective's base template */
    public var templateId: String?
    /** Objective zone specifies min,max points and values for the associated metric */
    public var zones: [ObjectiveZone]?
    /** A flag for whether this objective is enabled for the related metric */
    public var enabled: Bool?
    /** A list of media types for the metric */
    public var mediaTypes: [MediaTypes]?
    /** A list of queues for the metric */
    public var queues: [AddressableEntityRef]?
    /** A list of topic ids for detected topic metrics */
    public var topics: [AddressableEntityRef]?
    /** A filter type for topic Ids. It's only used for objectives with topicIds. Default filter behavior is \"or\". */
    public var topicIdsFilterType: TopicIdsFilterType?
    /** The ids of associated evaluation form context, for Quality Evaluation Score metrics */
    public var evaluationFormContextIds: [String]?

    public init(_id: String?, templateId: String?, zones: [ObjectiveZone]?, enabled: Bool?, mediaTypes: [MediaTypes]?, queues: [AddressableEntityRef]?, topics: [AddressableEntityRef]?, topicIdsFilterType: TopicIdsFilterType?, evaluationFormContextIds: [String]?) {
        self._id = _id
        self.templateId = templateId
        self.zones = zones
        self.enabled = enabled
        self.mediaTypes = mediaTypes
        self.queues = queues
        self.topics = topics
        self.topicIdsFilterType = topicIdsFilterType
        self.evaluationFormContextIds = evaluationFormContextIds
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case templateId
        case zones
        case enabled
        case mediaTypes
        case queues
        case topics
        case topicIdsFilterType
        case evaluationFormContextIds
    }


}




public class DeleteRetention: Codable {



    public var days: Int?

    public init(days: Int?) {
        self.days = days
    }


}




public class DependencyObject: Codable {







    public enum ModelType: String, Codable { 
        case acdlanguage = "ACDLANGUAGE"
        case acdskill = "ACDSKILL"
        case acdwrapupcode = "ACDWRAPUPCODE"
        case audioconnectorbot = "AUDIOCONNECTORBOT"
        case botconnectorbot = "BOTCONNECTORBOT"
        case botconnectorintegration = "BOTCONNECTORINTEGRATION"
        case botflow = "BOTFLOW"
        case bridgeaction = "BRIDGEACTION"
        case commonmoduleflow = "COMMONMODULEFLOW"
        case composerscript = "COMPOSERSCRIPT"
        case contactlist = "CONTACTLIST"
        case dataaction = "DATAACTION"
        case datatable = "DATATABLE"
        case dialogenginebot = "DIALOGENGINEBOT"
        case dialogenginebotversion = "DIALOGENGINEBOTVERSION"
        case dialogflowagent = "DIALOGFLOWAGENT"
        case dialogflowcxagent = "DIALOGFLOWCXAGENT"
        case digitalbotflow = "DIGITALBOTFLOW"
        case emailroute = "EMAILROUTE"
        case emergencygroup = "EMERGENCYGROUP"
        case flowaction = "FLOWACTION"
        case flowdatatype = "FLOWDATATYPE"
        case flowmilestone = "FLOWMILESTONE"
        case flowoutcome = "FLOWOUTCOME"
        case grammar = "GRAMMAR"
        case group = "GROUP"
        case image = "IMAGE"
        case inboundcallflow = "INBOUNDCALLFLOW"
        case inboundchatflow = "INBOUNDCHATFLOW"
        case inboundemailflow = "INBOUNDEMAILFLOW"
        case inboundshortmessageflow = "INBOUNDSHORTMESSAGEFLOW"
        case inqueuecallflow = "INQUEUECALLFLOW"
        case inqueueemailflow = "INQUEUEEMAILFLOW"
        case inqueueshortmessageflow = "INQUEUESHORTMESSAGEFLOW"
        case ivrconfiguration = "IVRCONFIGURATION"
        case knowledgebase = "KNOWLEDGEBASE"
        case knowledgebasedocument = "KNOWLEDGEBASEDOCUMENT"
        case language = "LANGUAGE"
        case lexbot = "LEXBOT"
        case lexbotalias = "LEXBOTALIAS"
        case lexv2bot = "LEXV2BOT"
        case lexv2botalias = "LEXV2BOTALIAS"
        case nludomain = "NLUDOMAIN"
        case nuancemixbot = "NUANCEMIXBOT"
        case nuancemixintegration = "NUANCEMIXINTEGRATION"
        case oauthclient = "OAUTHCLIENT"
        case outboundcallflow = "OUTBOUNDCALLFLOW"
        case queue = "QUEUE"
        case recordingpolicy = "RECORDINGPOLICY"
        case response = "RESPONSE"
        case schedule = "SCHEDULE"
        case schedulegroup = "SCHEDULEGROUP"
        case secureaction = "SECUREACTION"
        case securecallflow = "SECURECALLFLOW"
        case sttengine = "STTENGINE"
        case surveyform = "SURVEYFORM"
        case surveyinviteflow = "SURVEYINVITEFLOW"
        case systemprompt = "SYSTEMPROMPT"
        case ttsengine = "TTSENGINE"
        case ttsvoice = "TTSVOICE"
        case user = "USER"
        case userprompt = "USERPROMPT"
        case utilizationlabel = "UTILIZATIONLABEL"
        case voiceflow = "VOICEFLOW"
        case voicemailflow = "VOICEMAILFLOW"
        case voicesurveyflow = "VOICESURVEYFLOW"
        case widget = "WIDGET"
        case workflow = "WORKFLOW"
        case workitemflow = "WORKITEMFLOW"
    }













    /** The dependency identifier */
    public var _id: String?
    public var name: String?
    public var version: String?
    public var type: ModelType?
    public var deleted: Bool?
    public var updated: Bool?
    public var stateUnknown: Bool?
    public var consumedResources: [Dependency]?
    public var consumingResources: [Dependency]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, version: String?, type: ModelType?, deleted: Bool?, updated: Bool?, stateUnknown: Bool?, consumedResources: [Dependency]?, consumingResources: [Dependency]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.version = version
        self.type = type
        self.deleted = deleted
        self.updated = updated
        self.stateUnknown = stateUnknown
        self.consumedResources = consumedResources
        self.consumingResources = consumingResources
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case version
        case type
        case deleted
        case updated
        case stateUnknown
        case consumedResources
        case consumingResources
        case selfUri
    }


}




public class DependencyStatus: Codable {















    public enum Status: String, Codable { 
        case buildinitializing = "BUILDINITIALIZING"
        case buildinprogress = "BUILDINPROGRESS"
        case notbuilt = "NOTBUILT"
        case operational = "OPERATIONAL"
        case operationalneedsrebuild = "OPERATIONALNEEDSREBUILD"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** User that initiated the build. */
    public var user: User?
    /** OAuth client that initiated the build. */
    public var client: DomainEntityRef?
    public var buildId: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStarted: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCompleted: Date?
    public var status: Status?
    public var failedObjects: [FailedObject]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, user: User?, client: DomainEntityRef?, buildId: String?, dateStarted: Date?, dateCompleted: Date?, status: Status?, failedObjects: [FailedObject]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.user = user
        self.client = client
        self.buildId = buildId
        self.dateStarted = dateStarted
        self.dateCompleted = dateCompleted
        self.status = status
        self.failedObjects = failedObjects
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case user
        case client
        case buildId
        case dateStarted
        case dateCompleted
        case status
        case failedObjects
        case selfUri
    }


}




public class DevelopmentActivityAggregateQueryRequestClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "And"
        case or = "Or"
    }



    /** The logic used to combine the predicates */
    public var type: ModelType?
    /** The list of predicates used to filter the data */
    public var predicates: [DevelopmentActivityAggregateQueryRequestPredicate]?

    public init(type: ModelType?, predicates: [DevelopmentActivityAggregateQueryRequestPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class DevelopmentActivityAggregateQueryResponseData: Codable {





    /** Specifies the range of due dates to be used for filtering. A maximum of 1 year can be specified in the range. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** The list of aggregated metrics */
    public var metrics: [DevelopmentActivityAggregateQueryResponseMetric]?

    public init(interval: String?, metrics: [DevelopmentActivityAggregateQueryResponseMetric]?) {
        self.interval = interval
        self.metrics = metrics
    }


}




public class Device: Codable {

    public enum Category: String, Codable { 
        case desktop = "desktop"
        case mobile = "mobile"
        case tablet = "tablet"
        case other = "other"
    }



















    /** Device category. */
    public var category: Category?
    /** Device type (e.g. iPad, iPhone, Other). */
    public var type: String?
    /** Flag that is true for mobile devices. */
    public var isMobile: Bool?
    /** Device's screen height. */
    public var screenHeight: Int?
    /** Device's screen width. */
    public var screenWidth: Int?
    /** Device's screen density, measured as a scale factor where a value of 1 represents a baseline 1:1 ratio of pixels to logical (device-independent) pixels. */
    public var screenDensity: Int?
    /** Fingerprint generated by looking at the individual device features. */
    public var fingerprint: String?
    /** Operating system family. */
    public var osFamily: String?
    /** Operating system version. */
    public var osVersion: String?
    /** Manufacturer of the device. */
    public var manufacturer: String?

    public init(category: Category?, type: String?, isMobile: Bool?, screenHeight: Int?, screenWidth: Int?, screenDensity: Int?, fingerprint: String?, osFamily: String?, osVersion: String?, manufacturer: String?) {
        self.category = category
        self.type = type
        self.isMobile = isMobile
        self.screenHeight = screenHeight
        self.screenWidth = screenWidth
        self.screenDensity = screenDensity
        self.fingerprint = fingerprint
        self.osFamily = osFamily
        self.osVersion = osVersion
        self.manufacturer = manufacturer
    }


}




public class DialerCallabletimesetConfigChangeTimeSlot: Codable {









    /** The start time of this time slot */
    public var startTime: String?
    /** The stop time of this time slot */
    public var stopTime: String?
    /** The day this time slot applies */
    public var day: Int?
    public var additionalProperties: [String:JSON]?

    public init(startTime: String?, stopTime: String?, day: Int?, additionalProperties: [String:JSON]?) {
        self.startTime = startTime
        self.stopTime = stopTime
        self.day = day
        self.additionalProperties = additionalProperties
    }


}




public class Digits: Codable {



    /** A string representing the digits pressed on phone. */
    public var digits: String?

    public init(digits: String?) {
        self.digits = digits
    }


}



/** the campaign/sequence entities that this action acts on */

public class DialerCampaignRuleConfigChangeCampaignRuleActionEntities: Codable {









    /** Whether this action should act on the entity that triggered it */
    public var useTriggeringEntity: Bool?
    public var additionalProperties: [String:JSON]?
    /** A list of campaignIds to act on */
    public var campaigns: [DialerCampaignRuleConfigChangeUriReference]?
    /** A list of sequenceIds to act on */
    public var sequences: [DialerCampaignRuleConfigChangeUriReference]?

    public init(useTriggeringEntity: Bool?, additionalProperties: [String:JSON]?, campaigns: [DialerCampaignRuleConfigChangeUriReference]?, sequences: [DialerCampaignRuleConfigChangeUriReference]?) {
        self.useTriggeringEntity = useTriggeringEntity
        self.additionalProperties = additionalProperties
        self.campaigns = campaigns
        self.sequences = sequences
    }


}




public class DialerContactId: Codable {





    public var _id: String?
    public var contactListId: String?

    public init(_id: String?, contactListId: String?) {
        self._id = _id
        self.contactListId = contactListId
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case contactListId
    }


}




public class DialerContactlistConfigChangeImportStatus: Codable {

    public enum ImportState: String, Codable { 
        case inProgress = "IN_PROGRESS"
        case failed = "FAILED"
    }















    /** current status of the import */
    public var importState: ImportState?
    /** total number of records to be imported */
    public var totalRecords: Int?
    /** number of records finished importing */
    public var completedRecords: Int?
    /** percentage of records finished importing */
    public var percentageComplete: Int?
    /** if the import has failed, the reason for the failure */
    public var failureReason: String?
    /** The ids for target contact lists */
    public var targetContactListIds: [String]?
    /** The prefix used for target contact list names */
    public var listNamePrefix: String?
    public var additionalProperties: [String:JSON]?

    public init(importState: ImportState?, totalRecords: Int?, completedRecords: Int?, percentageComplete: Int?, failureReason: String?, targetContactListIds: [String]?, listNamePrefix: String?, additionalProperties: [String:JSON]?) {
        self.importState = importState
        self.totalRecords = totalRecords
        self.completedRecords = completedRecords
        self.percentageComplete = percentageComplete
        self.failureReason = failureReason
        self.targetContactListIds = targetContactListIds
        self.listNamePrefix = listNamePrefix
        self.additionalProperties = additionalProperties
    }


}



/** FilterRange is one of the attributes of a FilterPredicate */

public class DialerContactlistfilterConfigChangeRange: Codable {













    /** Minimum end of the range */
    public var min: String?
    /** Maximum end of the range */
    public var max: String?
    /** Whether or not to include the minimum in the range */
    public var minInclusive: Bool?
    /** Whether or not to include the maximum in the range */
    public var maxInclusive: Bool?
    /** Elements that apply to the IN operator */
    public var inSet: [String]?
    public var additionalProperties: [String:JSON]?

    public init(min: String?, max: String?, minInclusive: Bool?, maxInclusive: Bool?, inSet: [String]?, additionalProperties: [String:JSON]?) {
        self.min = min
        self.max = max
        self.minInclusive = minInclusive
        self.maxInclusive = maxInclusive
        self.inSet = inSet
        self.additionalProperties = additionalProperties
    }


}



/** The time interval to place outbound calls */

public class DialerOutboundSettingsConfigChangeAtzmTimeSlotWithTimeZone: Codable {







    /** The time zone to use for contacts that cannot be mapped */
    public var timeZoneId: String?
    /** The earliest time to dial a contact */
    public var earliestCallableTime: String?
    /** The latest time to dial a contact */
    public var latestCallableTime: String?

    public init(timeZoneId: String?, earliestCallableTime: String?, latestCallableTime: String?) {
        self.timeZoneId = timeZoneId
        self.earliestCallableTime = earliestCallableTime
        self.latestCallableTime = latestCallableTime
    }


}




public class DialerOutboundSettingsConfigChangeOutboundSettings: Codable {







    public enum ComplianceAbandonRateDenominator: String, Codable { 
        case allCalls = "ALL_CALLS"
        case callsThatReachedQueue = "CALLS_THAT_REACHED_QUEUE"
    }













    /** The maximum number of calls that can be placed per agent on any campaign */
    public var maxCallsPerAgent: Int?
    /** The maximum percentage of lines that should be used for Outbound, expressed as a decimal in the range [0.0, 1.0] */
    public var maxLineUtilization: Double?
    /** The number of seconds used to determine if a call is abandoned */
    public var abandonSeconds: Double?
    /** The denominator to be used in determining the compliance abandon rate */
    public var complianceAbandonRateDenominator: ComplianceAbandonRateDenominator?
    public var automaticTimeZoneMapping: DialerOutboundSettingsConfigChangeAutomaticTimeZoneMappingSettings?
    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The UI-visible name of the object */
    public var name: String?
    /** Creation time of the entity */
    public var dateCreated: Date?
    /** Last modified time of the entity */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?

    public init(maxCallsPerAgent: Int?, maxLineUtilization: Double?, abandonSeconds: Double?, complianceAbandonRateDenominator: ComplianceAbandonRateDenominator?, automaticTimeZoneMapping: DialerOutboundSettingsConfigChangeAutomaticTimeZoneMappingSettings?, _id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?) {
        self.maxCallsPerAgent = maxCallsPerAgent
        self.maxLineUtilization = maxLineUtilization
        self.abandonSeconds = abandonSeconds
        self.complianceAbandonRateDenominator = complianceAbandonRateDenominator
        self.automaticTimeZoneMapping = automaticTimeZoneMapping
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case maxCallsPerAgent
        case maxLineUtilization
        case abandonSeconds
        case complianceAbandonRateDenominator
        case automaticTimeZoneMapping
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
    }


}




public class DialogflowAgent: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The project this Dialogflow agent belongs to */
    public var project: DialogflowProject?
    /** The supported languages of the Dialogflow agent */
    public var languages: [String]?
    /** An array of Intents associated with this agent */
    public var intents: [DialogflowIntent]?
    /** Available environments for this agent */
    public var environments: [String]?
    /** The Integration this Dialogflow agent was referenced from. */
    public var integration: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, project: DialogflowProject?, languages: [String]?, intents: [DialogflowIntent]?, environments: [String]?, integration: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.project = project
        self.languages = languages
        self.intents = intents
        self.environments = environments
        self.integration = integration
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case project
        case languages
        case intents
        case environments
        case integration
        case selfUri
    }


}




public class DialogflowAgentSummary: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The project this Dialogflow agent belongs to. */
    public var project: DialogflowProject?
    /** A description of the Dialogflow agent. */
    public var _description: String?
    /** The Integration this Dialogflow agent was referenced from. */
    public var integration: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, project: DialogflowProject?, _description: String?, integration: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.project = project
        self._description = _description
        self.integration = integration
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case project
        case _description = "description"
        case integration
        case selfUri
    }


}




public class Draft: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Draft name */
    public var name: String?
    /** Miner to which the draft belongs. */
    public var miner: Miner?
    /** Draft intent object. */
    public var intents: [DraftIntents]?
    /** Draft topic object. */
    public var topics: [DraftTopics]?
    /** Date when the draft was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date when the draft was updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, miner: Miner?, intents: [DraftIntents]?, topics: [DraftTopics]?, dateCreated: Date?, dateModified: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.miner = miner
        self.intents = intents
        self.topics = topics
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case miner
        case intents
        case topics
        case dateCreated
        case dateModified
        case selfUri
    }


}




public class DialogflowCXAgent: Codable {















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The project this Dialogflow CX agent belongs to. */
    public var project: DialogflowCXProject?
    /** The supported languages of the Dialogflow CX agent.  Each value will be a language code in the country-locale format. e.g. en-us, es-us, fr-ca, etc. */
    public var languages: [String]?
    /** Available environments for this CX agent. */
    public var environments: [DialogflowCXEnvironment]?
    /** The Integration this Dialogflow CX agent was referenced from. */
    public var integration: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, project: DialogflowCXProject?, languages: [String]?, environments: [DialogflowCXEnvironment]?, integration: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.project = project
        self.languages = languages
        self.environments = environments
        self.integration = integration
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case project
        case languages
        case environments
        case integration
        case selfUri
    }


}




public class DialogflowCXAgentSummary: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The project this Dialogflow CX agent belongs to. */
    public var project: DialogflowCXProject?
    /** A description of the Dialogflow CX agent. */
    public var _description: String?
    /** The Integration this Dialogflow CX agent was referenced from. */
    public var integration: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, project: DialogflowCXProject?, _description: String?, integration: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.project = project
        self._description = _description
        self.integration = integration
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case project
        case _description = "description"
        case integration
        case selfUri
    }


}




public class DigitLength: Codable {





    public var start: String?
    public var end: String?

    public init(start: String?, end: String?) {
        self.start = start
        self.end = end
    }


}




public class DigitalCondition: Codable {



















    /** If true, inverts the result of evaluating this condition. Default is false. */
    public var inverted: Bool?
    /** The settings for a 'contact list column' condition. */
    public var contactColumnConditionSettings: ContactColumnConditionSettings?
    /** The settings for a 'contact address' condition. */
    public var contactAddressConditionSettings: ContactAddressConditionSettings?
    /** The settings for a 'contact address type' condition. */
    public var contactAddressTypeConditionSettings: ContactAddressTypeConditionSettings?
    /** The settings for a 'last attempt by column' condition. */
    public var lastAttemptByColumnConditionSettings: LastAttemptByColumnConditionSettings?
    /** The settings for a 'last attempt overall' condition. */
    public var lastAttemptOverallConditionSettings: LastAttemptOverallConditionSettings?
    /** The settings for a 'last result by column' condition. */
    public var lastResultByColumnConditionSettings: LastResultByColumnConditionSettings?
    /** The settings for a 'last result overall' condition. */
    public var lastResultOverallConditionSettings: LastResultOverallConditionSettings?
    /** The settings for a 'data action' condition. */
    public var dataActionConditionSettings: DataActionConditionSettings?

    public init(inverted: Bool?, contactColumnConditionSettings: ContactColumnConditionSettings?, contactAddressConditionSettings: ContactAddressConditionSettings?, contactAddressTypeConditionSettings: ContactAddressTypeConditionSettings?, lastAttemptByColumnConditionSettings: LastAttemptByColumnConditionSettings?, lastAttemptOverallConditionSettings: LastAttemptOverallConditionSettings?, lastResultByColumnConditionSettings: LastResultByColumnConditionSettings?, lastResultOverallConditionSettings: LastResultOverallConditionSettings?, dataActionConditionSettings: DataActionConditionSettings?) {
        self.inverted = inverted
        self.contactColumnConditionSettings = contactColumnConditionSettings
        self.contactAddressConditionSettings = contactAddressConditionSettings
        self.contactAddressTypeConditionSettings = contactAddressTypeConditionSettings
        self.lastAttemptByColumnConditionSettings = lastAttemptByColumnConditionSettings
        self.lastAttemptOverallConditionSettings = lastAttemptOverallConditionSettings
        self.lastResultByColumnConditionSettings = lastResultByColumnConditionSettings
        self.lastResultOverallConditionSettings = lastResultOverallConditionSettings
        self.dataActionConditionSettings = dataActionConditionSettings
    }


}




public class DigitalRuleSetEntityListing: Codable {





















    public var entities: [DigitalRuleSet]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DigitalRuleSet]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DirectRouting: Codable {













    /** Direct Routing Settings specific to Call media. */
    public var callMediaSettings: DirectRoutingMediaSettings?
    /** Direct Routing Settings specific to Email media. */
    public var emailMediaSettings: DirectRoutingMediaSettings?
    /** Direct Routing Settings specific to Message media. */
    public var messageMediaSettings: DirectRoutingMediaSettings?
    /** ID of another queue to be used as the default backup if an agent does not have their Backup Settings configured. If not set, the current queue will be used as backup, but with Direct Routing criteria removed from the conversation. */
    public var backupQueueId: String?
    /** Flag indicating if Direct Routing interactions should wait for Direct Routing agent or go immediately to selected backup. */
    public var waitForAgent: Bool?
    /** Time (in seconds) that a Direct Routing interaction will wait for Direct Routing agent before going to selected backup. Valid range [60, 864000]. */
    public var agentWaitSeconds: Int?

    public init(callMediaSettings: DirectRoutingMediaSettings?, emailMediaSettings: DirectRoutingMediaSettings?, messageMediaSettings: DirectRoutingMediaSettings?, backupQueueId: String?, waitForAgent: Bool?, agentWaitSeconds: Int?) {
        self.callMediaSettings = callMediaSettings
        self.emailMediaSettings = emailMediaSettings
        self.messageMediaSettings = messageMediaSettings
        self.backupQueueId = backupQueueId
        self.waitForAgent = waitForAgent
        self.agentWaitSeconds = agentWaitSeconds
    }


}




public class DisableSiteConnectionsRequest: Codable {



    public var enabled: Bool?

    public init(enabled: Bool?) {
        self.enabled = enabled
    }


}




public class DispositionParameters: Codable {



    /** ALSD evaluation inputs and output (isPersonalLikely) of the ALSD detector the last time it ran on the call (could be multiple times) */
    public var adjustableLiveSpeakerDetection: AdjustableLiveSpeakerDetection?

    public init(adjustableLiveSpeakerDetection: AdjustableLiveSpeakerDetection?) {
        self.adjustableLiveSpeakerDetection = adjustableLiveSpeakerDetection
    }


}




public class Division: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}




public class DncListDivisionView: Codable {











    public enum DncSourceType: String, Codable { 
        case rds = "rds"
        case rdsCustom = "rds_custom"
        case dncCom = "dnc.com"
        case gryphon = "gryphon"
    }

    public enum ContactMethod: String, Codable { 
        case email = "Email"
        case phone = "Phone"
        case any = "Any"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The status of the import process. */
    public var importStatus: ImportStatus?
    /** The number of contacts in the DncList. */
    public var size: Int64?
    /** The type of the DncList. */
    public var dncSourceType: DncSourceType?
    /** The contact method. Required if dncSourceType is rds. */
    public var contactMethod: ContactMethod?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, importStatus: ImportStatus?, size: Int64?, dncSourceType: DncSourceType?, contactMethod: ContactMethod?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.importStatus = importStatus
        self.size = size
        self.dncSourceType = dncSourceType
        self.contactMethod = contactMethod
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case importStatus
        case size
        case dncSourceType
        case contactMethod
        case selfUri
    }


}




public class DncListDivisionViewListing: Codable {





















    public var entities: [DncListDivisionView]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DncListDivisionView]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DnclistDownloadReadyExportUri: Codable {







    public var uri: String?
    public var exportTimestamp: String?
    public var additionalProperties: [String:JSON]?

    public init(uri: String?, exportTimestamp: String?, additionalProperties: [String:JSON]?) {
        self.uri = uri
        self.exportTimestamp = exportTimestamp
        self.additionalProperties = additionalProperties
    }


}




public class DocumentBodyImage: Codable {







    /** The URL for the image. */
    public var url: String?
    /** The URL of the page OR an email OR the reference to the knowledge article that the hyperlink goes to. Possible URL value types are https://<url link> | mailto:<email> | grn:knowledge:::documentVariation/<knowledgeBaseId>/<documentId>/<variationId> | grn:knowledge:::document/<knowledgeBaseId>/<documentId> | grn:knowledge:::category/<knowledgeBaseId>/<categoryId> | grn:knowledge:::label/<knowledgeBaseId>/<labelId> */
    public var hyperlink: String?
    /** The properties for the image. */
    public var properties: DocumentBodyImageProperties?

    public init(url: String?, hyperlink: String?, properties: DocumentBodyImageProperties?) {
        self.url = url
        self.hyperlink = hyperlink
        self.properties = properties
    }


}




public class DocumentBodyListBlock: Codable {

    public enum ModelType: String, Codable { 
        case listItem = "ListItem"
    }





    /** The type of the list block. */
    public var type: ModelType?
    /** The list of items for an OrderedList or an UnorderedList. */
    public var blocks: [DocumentListContentBlock]?
    /** The properties for the list block. */
    public var properties: DocumentBodyListItemProperties?

    public init(type: ModelType?, blocks: [DocumentListContentBlock]?, properties: DocumentBodyListItemProperties?) {
        self.type = type
        self.blocks = blocks
        self.properties = properties
    }


}




public class DocumentBodyParagraph: Codable {





    /** The list of blocks for the paragraph. */
    public var blocks: [DocumentContentBlock]?
    /** The properties for the paragraph. */
    public var properties: DocumentBodyParagraphProperties?

    public init(blocks: [DocumentContentBlock]?, properties: DocumentBodyParagraphProperties?) {
        self.blocks = blocks
        self.properties = properties
    }


}




public class DocumentBodyTable: Codable {





    /** The list of rows for the table. */
    public var rows: [DocumentBodyTableRowBlock]?
    /** The properties for the table. */
    public var properties: DocumentBodyTableProperties?

    public init(rows: [DocumentBodyTableRowBlock]?, properties: DocumentBodyTableProperties?) {
        self.rows = rows
        self.properties = properties
    }


}




public class DocumentBodyTableCellBlock: Codable {





    /** The list of content blocks for the table. */
    public var blocks: [DocumentTableContentBlock]?
    /** The properties for the table cell. */
    public var properties: DocumentBodyTableCellBlockProperties?

    public init(blocks: [DocumentTableContentBlock]?, properties: DocumentBodyTableCellBlockProperties?) {
        self.blocks = blocks
        self.properties = properties
    }


}




public class DocumentBodyVideo: Codable {





    /** The URL for the video. */
    public var url: String?
    /** The properties for the video. */
    public var properties: DocumentBodyVideoProperties?

    public init(url: String?, properties: DocumentBodyVideoProperties?) {
        self.url = url
        self.properties = properties
    }


}




public class DocumentQueryInterval: Codable {

    public enum Field: String, Codable { 
        case datecreated = "dateCreated"
        case datemodified = "dateModified"
        case datepublished = "datePublished"
    }



    /** Specifies the date field to be used for date and time range. */
    public var field: Field?
    /** Specifies the date and time range for filtering the documents. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var value: String?

    public init(field: Field?, value: String?) {
        self.field = field
        self.value = value
    }


}




public class DocumentReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class DocumentText: Codable {




    public enum Marks: String, Codable { 
        case bold = "Bold"
        case italic = "Italic"
        case underline = "Underline"
        case strikethrough = "Strikethrough"
        case _subscript = "Subscript"
        case superscript = "Superscript"
    }




    /** Text. */
    public var text: String?
    /** The unique list of marks (whether it is bold and/or underlined etc.) for the text. */
    public var marks: [Marks]?
    /** The URL of the page OR an email OR the reference to the knowledge article that the hyperlink goes to. Possible URL value types are https://<url link> | mailto:<email> | grn:knowledge:::documentVariation/<knowledgeBaseId>/<documentId>/<variationId> | grn:knowledge:::document/<knowledgeBaseId>/<documentId> | grn:knowledge:::category/<knowledgeBaseId>/<categoryId> | grn:knowledge:::label/<knowledgeBaseId>/<labelId> */
    public var hyperlink: String?
    /** The properties for the text. */
    public var properties: DocumentTextProperties?

    public init(text: String?, marks: [Marks]?, hyperlink: String?, properties: DocumentTextProperties?) {
        self.text = text
        self.marks = marks
        self.hyperlink = hyperlink
        self.properties = properties
    }


}




public class DocumentUpdate: Codable {



















    public var changeNumber: Int?
    /** The name of the document */
    public var name: String?
    public var read: Bool?
    public var addTags: [String]?
    public var removeTags: [String]?
    public var addTagIds: [String]?
    public var removeTagIds: [String]?
    public var updateAttributes: [DocumentAttribute]?
    public var removeAttributes: [String]?

    public init(changeNumber: Int?, name: String?, read: Bool?, addTags: [String]?, removeTags: [String]?, addTagIds: [String]?, removeTagIds: [String]?, updateAttributes: [DocumentAttribute]?, removeAttributes: [String]?) {
        self.changeNumber = changeNumber
        self.name = name
        self.read = read
        self.addTags = addTags
        self.removeTags = removeTags
        self.addTagIds = addTagIds
        self.removeTagIds = removeTagIds
        self.updateAttributes = updateAttributes
        self.removeAttributes = removeAttributes
    }


}




public class DocumentVariation: Codable {

















    /** The globally unique identifier for the variation. */
    public var _id: String?
    /** The content for the variation. */
    public var body: DocumentBody?
    /** The creation date-time for the document variation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The last modification date-time for the document variation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The version of the document. */
    public var documentVersion: AddressableEntityRef?
    /** The context values associated with the variation. */
    public var contexts: [DocumentVariationContext]?
    /** The reference to document to which the variation is associated. */
    public var document: KnowledgeDocumentReference?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, body: DocumentBody?, dateCreated: Date?, dateModified: Date?, documentVersion: AddressableEntityRef?, contexts: [DocumentVariationContext]?, document: KnowledgeDocumentReference?, selfUri: String?) {
        self._id = _id
        self.body = body
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.documentVersion = documentVersion
        self.contexts = contexts
        self.document = document
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case body
        case dateCreated
        case dateModified
        case documentVersion
        case contexts
        case document
        case selfUri
    }


}




public class DocumentVariationListing: Codable {









    public var entities: [DocumentVariation]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [DocumentVariation]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class DocumentationSearchCriteria: Codable {









    public enum Operator: String, Codable { 
        case and = "AND"
        case or = "OR"
        case not = "NOT"
    }





    public enum ModelType: String, Codable { 
        case exact = "EXACT"
        case startsWith = "STARTS_WITH"
        case contains = "CONTAINS"
        case term = "TERM"
        case terms = "TERMS"
        case matchAll = "MATCH_ALL"
        case simple = "SIMPLE"
        case queryString = "QUERY_STRING"
        case multiMatch = "MULTI_MATCH"
    }



    /** The end value of the range. This field is used for range search types. */
    public var endValue: String?
    /** A list of values for the search to match against */
    public var values: [String]?
    /** The start value of the range. This field is used for range search types. */
    public var startValue: String?
    /** A value for the search to match against */
    public var value: String?
    /** How to apply this search criteria against other criteria */
    public var _operator: Operator?
    /** Groups multiple conditions */
    public var group: [DocumentationSearchCriteria]?
    /** Set date format for criteria values when using date range search type.  Supports Java date format syntax, example yyyy-MM-dd'T'HH:mm:ss.SSSX. */
    public var dateFormat: String?
    /** Search Type */
    public var type: ModelType?
    /** Field names to search against */
    public var fields: [String]?

    public init(endValue: String?, values: [String]?, startValue: String?, value: String?, _operator: Operator?, group: [DocumentationSearchCriteria]?, dateFormat: String?, type: ModelType?, fields: [String]?) {
        self.endValue = endValue
        self.values = values
        self.startValue = startValue
        self.value = value
        self._operator = _operator
        self.group = group
        self.dateFormat = dateFormat
        self.type = type
        self.fields = fields
    }

    public enum CodingKeys: String, CodingKey { 
        case endValue
        case values
        case startValue
        case value
        case _operator = "operator"
        case group
        case dateFormat
        case type
        case fields
    }


}



/** A certificate authority represents an organization that has issued a digital certificate for making secure connections with an edge device. */

public class DomainCertificateAuthority: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }







    public enum ModelType: String, Codable { 
        case managed = "MANAGED"
        case remote = "REMOTE"
    }

    public enum Services: String, Codable { 
        case sip = "SIP"
        case provision = "PROVISION"
        case provisionPhone = "PROVISION_PHONE"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** The authorities signed X509 PEM encoded certificate. */
    public var certificate: String?
    /** The certificate authorities type.  Managed certificate authorities are generated and maintained by Interactive Intelligence.  These are read-only and not modifiable by clients.  Remote authorities are customer managed. */
    public var type: ModelType?
    /** The service(s) that the authority can be used to authenticate. */
    public var services: [Services]?
    /** The details of the parsed certificate(s). */
    public var certificateDetails: [CertificateDetails]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, certificate: String?, type: ModelType?, services: [Services]?, certificateDetails: [CertificateDetails]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.certificate = certificate
        self.type = type
        self.services = services
        self.certificateDetails = certificateDetails
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case certificate
        case type
        case services
        case certificateDetails
        case selfUri
    }


}




public class DomainEdgeSoftwareUpdateDto: Codable {













    public enum Status: String, Codable { 
        case _none = "NONE"
        case _init = "INIT"
        case inProgress = "IN_PROGRESS"
        case expired = "EXPIRED"
        case exception = "EXCEPTION"
        case aborted = "ABORTED"
        case failed = "FAILED"
        case succeeded = "SUCCEEDED"
        case delete = "DELETE"
    }







    /** Version */
    public var version: DomainEdgeSoftwareVersionDto?
    public var maxDownloadRate: Int?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var downloadStartTime: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var executeStartTime: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var executeStopTime: Date?
    public var executeOnIdle: Bool?
    public var status: Status?
    public var edgeUri: String?
    public var callDrainingWaitTimeSeconds: Int64?
    public var current: Bool?

    public init(version: DomainEdgeSoftwareVersionDto?, maxDownloadRate: Int?, downloadStartTime: Date?, executeStartTime: Date?, executeStopTime: Date?, executeOnIdle: Bool?, status: Status?, edgeUri: String?, callDrainingWaitTimeSeconds: Int64?, current: Bool?) {
        self.version = version
        self.maxDownloadRate = maxDownloadRate
        self.downloadStartTime = downloadStartTime
        self.executeStartTime = executeStartTime
        self.executeStopTime = executeStopTime
        self.executeOnIdle = executeOnIdle
        self.status = status
        self.edgeUri = edgeUri
        self.callDrainingWaitTimeSeconds = callDrainingWaitTimeSeconds
        self.current = current
    }


}




public class DomainEntity: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}




public class DomainEntityListing: Codable {





















    public var entities: [DomainEntity]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DomainEntity]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DomainEntityRef: Codable {







    public var _id: String?
    public var name: String?
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}




public class DomainLogicalInterface: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }



















    public enum InterfaceType: String, Codable { 
        case diagnostic = "DIAGNOSTIC"
        case system = "SYSTEM"
    }













    public enum CurrentState: String, Codable { 
        case _init = "INIT"
        case creating = "CREATING"
        case updating = "UPDATING"
        case ok = "OK"
        case exception = "EXCEPTION"
        case deleting = "DELETING"
    }































    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    public var edgeUri: String?
    public var edgeAssignedId: String?
    /** Friendly Name */
    public var friendlyName: String?
    public var vlanTagId: Int?
    /** Hardware Address */
    public var hardwareAddress: String?
    /** Physical Adapter Id */
    public var physicalAdapterId: String?
    public var ifStatus: String?
    /** The type of this network interface. */
    public var interfaceType: InterfaceType?
    /** IPv4 NENT IP Address */
    public var publicNatAddressIpV4: String?
    /** IPv6 NENT IP Address */
    public var publicNatAddressIpV6: String?
    /** The list of routes assigned to this interface. */
    public var routes: [DomainNetworkRoute]?
    /** The list of IP addresses on this interface.  Priority of dns addresses are based on order in the list. */
    public var addresses: [DomainNetworkAddress]?
    /** IPv4 interface settings. */
    public var ipv4Capabilities: DomainCapabilities?
    /** IPv6 interface settings. */
    public var ipv6Capabilities: DomainCapabilities?
    public var currentState: CurrentState?
    public var lastModifiedUserId: String?
    public var lastModifiedCorrelationId: String?
    public var commandResponses: [DomainNetworkCommandResponse]?
    /** The IPv4 phone trunk base assignment will be inherited from the Edge Group. */
    public var inheritPhoneTrunkBasesIPv4: Bool?
    /** The IPv6 phone trunk base assignment will be inherited from the Edge Group. */
    public var inheritPhoneTrunkBasesIPv6: Bool?
    /** This interface will be used for all internal edge-to-edge communication using settings from the edgeTrunkBaseAssignment on the Edge Group. */
    public var useForInternalEdgeCommunication: Bool?
    /** Site Interconnects using the \"Indirect\" method will communicate using the Public IP Address specified on the interface. Use this option when a NAT enabled firewall is between the Edge and the far end. */
    public var useForIndirectEdgeCommunication: Bool?
    /** Site Interconnects using the \"Cloud Proxy\" method will broker the connection between them with a Cloud Proxy. This method is required for connections between one or more Sites using Cloud Media, but can optionally be used between two premises Sites if Direct or Indirect are not an option. */
    public var useForCloudProxyEdgeCommunication: Bool?
    /** This interface will be used for all communication with the internet. */
    public var useForWanInterface: Bool?
    /** External trunk base settings to use for external communication from this interface. */
    public var externalTrunkBaseAssignments: [TrunkBaseAssignment]?
    /** Phone trunk base settings to use for phone communication from this interface.  These settings will be ignored when \"inheritPhoneTrunkBases\" is true. */
    public var phoneTrunkBaseAssignments: [TrunkBaseAssignment]?
    public var traceEnabled: Bool?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endDate: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, edgeUri: String?, edgeAssignedId: String?, friendlyName: String?, vlanTagId: Int?, hardwareAddress: String?, physicalAdapterId: String?, ifStatus: String?, interfaceType: InterfaceType?, publicNatAddressIpV4: String?, publicNatAddressIpV6: String?, routes: [DomainNetworkRoute]?, addresses: [DomainNetworkAddress]?, ipv4Capabilities: DomainCapabilities?, ipv6Capabilities: DomainCapabilities?, currentState: CurrentState?, lastModifiedUserId: String?, lastModifiedCorrelationId: String?, commandResponses: [DomainNetworkCommandResponse]?, inheritPhoneTrunkBasesIPv4: Bool?, inheritPhoneTrunkBasesIPv6: Bool?, useForInternalEdgeCommunication: Bool?, useForIndirectEdgeCommunication: Bool?, useForCloudProxyEdgeCommunication: Bool?, useForWanInterface: Bool?, externalTrunkBaseAssignments: [TrunkBaseAssignment]?, phoneTrunkBaseAssignments: [TrunkBaseAssignment]?, traceEnabled: Bool?, startDate: Date?, endDate: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.edgeUri = edgeUri
        self.edgeAssignedId = edgeAssignedId
        self.friendlyName = friendlyName
        self.vlanTagId = vlanTagId
        self.hardwareAddress = hardwareAddress
        self.physicalAdapterId = physicalAdapterId
        self.ifStatus = ifStatus
        self.interfaceType = interfaceType
        self.publicNatAddressIpV4 = publicNatAddressIpV4
        self.publicNatAddressIpV6 = publicNatAddressIpV6
        self.routes = routes
        self.addresses = addresses
        self.ipv4Capabilities = ipv4Capabilities
        self.ipv6Capabilities = ipv6Capabilities
        self.currentState = currentState
        self.lastModifiedUserId = lastModifiedUserId
        self.lastModifiedCorrelationId = lastModifiedCorrelationId
        self.commandResponses = commandResponses
        self.inheritPhoneTrunkBasesIPv4 = inheritPhoneTrunkBasesIPv4
        self.inheritPhoneTrunkBasesIPv6 = inheritPhoneTrunkBasesIPv6
        self.useForInternalEdgeCommunication = useForInternalEdgeCommunication
        self.useForIndirectEdgeCommunication = useForIndirectEdgeCommunication
        self.useForCloudProxyEdgeCommunication = useForCloudProxyEdgeCommunication
        self.useForWanInterface = useForWanInterface
        self.externalTrunkBaseAssignments = externalTrunkBaseAssignments
        self.phoneTrunkBaseAssignments = phoneTrunkBaseAssignments
        self.traceEnabled = traceEnabled
        self.startDate = startDate
        self.endDate = endDate
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case edgeUri
        case edgeAssignedId
        case friendlyName
        case vlanTagId
        case hardwareAddress
        case physicalAdapterId
        case ifStatus
        case interfaceType
        case publicNatAddressIpV4
        case publicNatAddressIpV6
        case routes
        case addresses
        case ipv4Capabilities
        case ipv6Capabilities
        case currentState
        case lastModifiedUserId
        case lastModifiedCorrelationId
        case commandResponses
        case inheritPhoneTrunkBasesIPv4
        case inheritPhoneTrunkBasesIPv6
        case useForInternalEdgeCommunication
        case useForIndirectEdgeCommunication
        case useForCloudProxyEdgeCommunication
        case useForWanInterface
        case externalTrunkBaseAssignments
        case phoneTrunkBaseAssignments
        case traceEnabled
        case startDate
        case endDate
        case selfUri
    }


}




public class DomainOrganizationRoleCreate: Codable {

























    /** role id */
    public var _id: String?
    /** The role name */
    public var name: String?
    public var _description: String?
    public var defaultRoleId: String?
    public var permissions: [String]?
    /** A collection of the permissions the role is not using */
    public var unusedPermissions: [String]?
    public var permissionPolicies: [DomainPermissionPolicy]?
    public var userCount: Int?
    /** Optional unless patch operation. */
    public var roleNeedsUpdate: Bool?
    public var base: Bool?
    public var _default: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, defaultRoleId: String?, permissions: [String]?, unusedPermissions: [String]?, permissionPolicies: [DomainPermissionPolicy]?, userCount: Int?, roleNeedsUpdate: Bool?, base: Bool?, _default: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.defaultRoleId = defaultRoleId
        self.permissions = permissions
        self.unusedPermissions = unusedPermissions
        self.permissionPolicies = permissionPolicies
        self.userCount = userCount
        self.roleNeedsUpdate = roleNeedsUpdate
        self.base = base
        self._default = _default
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case defaultRoleId
        case permissions
        case unusedPermissions
        case permissionPolicies
        case userCount
        case roleNeedsUpdate
        case base
        case _default = "default"
        case selfUri
    }


}




public class DomainOrganizationRoleUpdate: Codable {

























    /** role id */
    public var _id: String?
    /** The name of the role */
    public var name: String?
    public var _description: String?
    public var defaultRoleId: String?
    public var permissions: [String]?
    /** A collection of the permissions the role is not using */
    public var unusedPermissions: [String]?
    public var permissionPolicies: [DomainPermissionPolicy]?
    public var userCount: Int?
    /** Optional unless patch operation. */
    public var roleNeedsUpdate: Bool?
    public var base: Bool?
    public var _default: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, defaultRoleId: String?, permissions: [String]?, unusedPermissions: [String]?, permissionPolicies: [DomainPermissionPolicy]?, userCount: Int?, roleNeedsUpdate: Bool?, base: Bool?, _default: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.defaultRoleId = defaultRoleId
        self.permissions = permissions
        self.unusedPermissions = unusedPermissions
        self.permissionPolicies = permissionPolicies
        self.userCount = userCount
        self.roleNeedsUpdate = roleNeedsUpdate
        self.base = base
        self._default = _default
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case defaultRoleId
        case permissions
        case unusedPermissions
        case permissionPolicies
        case userCount
        case roleNeedsUpdate
        case base
        case _default = "default"
        case selfUri
    }


}




public class DomainPhysicalInterface: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    public var edgeUri: String?
    public var friendlyName: String?
    public var hardwareAddress: String?
    public var portLabel: String?
    public var physicalCapabilities: DomainPhysicalCapabilities?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, edgeUri: String?, friendlyName: String?, hardwareAddress: String?, portLabel: String?, physicalCapabilities: DomainPhysicalCapabilities?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.edgeUri = edgeUri
        self.friendlyName = friendlyName
        self.hardwareAddress = hardwareAddress
        self.portLabel = portLabel
        self.physicalCapabilities = physicalCapabilities
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case edgeUri
        case friendlyName
        case hardwareAddress
        case portLabel
        case physicalCapabilities
        case selfUri
    }


}




public class DomainRole: Codable {





    /** The ID of the role */
    public var _id: String?
    /** The name of the role */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class DraftListing: Codable {









    public var entities: [Draft]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [Draft]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class DraftManipulationRequest: Codable {



    public enum DraftType: String, Codable { 
        case reply = "Reply"
        case replyAll = "ReplyAll"
        case forward = "Forward"
    }

    /** A set of definitions to translate email attributes and correctly display date and time, for a given language */
    public var translate: HistoryHeadersTranslation?
    /** The kind of draft that as to be treated. Used to prefix response subject or auto-include information */
    public var draftType: DraftType?

    public init(translate: HistoryHeadersTranslation?, draftType: DraftType?) {
        self.translate = translate
        self.draftType = draftType
    }


}




public class DraftRequest: Codable {





    /** Draft intent object. */
    public var intents: [DraftIntents]?
    /** Draft topic object. */
    public var topics: [DraftTopicRequest]?

    public init(intents: [DraftIntents]?, topics: [DraftTopicRequest]?) {
        self.intents = intents
        self.topics = topics
    }


}




public class EdgeLogicalInterfacesChangeTopicDomainLogicalInterfaceChange: Codable {





    public var _id: String?
    public var errorInfo: EdgeLogicalInterfacesChangeTopicErrorInfo?

    public init(_id: String?, errorInfo: EdgeLogicalInterfacesChangeTopicErrorInfo?) {
        self._id = _id
        self.errorInfo = errorInfo
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case errorInfo
    }


}




public class EdgeMetricsTopicEdgeMetricNetworks: Codable {











    public var ifname: String?
    public var sentBytesPerSec: Int?
    public var receivedBytesPerSec: Int?
    public var bandwidthBitsPerSec: Int?
    public var utilizationPct: Double?

    public init(ifname: String?, sentBytesPerSec: Int?, receivedBytesPerSec: Int?, bandwidthBitsPerSec: Int?, utilizationPct: Double?) {
        self.ifname = ifname
        self.sentBytesPerSec = sentBytesPerSec
        self.receivedBytesPerSec = receivedBytesPerSec
        self.bandwidthBitsPerSec = bandwidthBitsPerSec
        self.utilizationPct = utilizationPct
    }


}




public class EdgeServiceStateRequest: Codable {





    /** A boolean that sets the Edge in-service or out-of-service. */
    public var inService: Bool?
    /** The number of seconds to wait for call draining to complete before initiating the reboot. A value of 0 will prevent call draining and all calls will disconnect immediately. */
    public var callDrainingWaitTimeSeconds: Int?

    public init(inService: Bool?, callDrainingWaitTimeSeconds: Int?) {
        self.inService = inService
        self.callDrainingWaitTimeSeconds = callDrainingWaitTimeSeconds
    }


}




public class EmailCommunicationRepliedEvent: Codable {









    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication. */
    public var communicationId: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
    }


}




public class EmailMediaPolicy: Codable {





    /** Actions applied when specified conditions are met */
    public var actions: PolicyActions?
    /** Conditions for when actions should be applied */
    public var conditions: EmailMediaPolicyConditions?

    public init(actions: PolicyActions?, conditions: EmailMediaPolicyConditions?) {
        self.actions = actions
        self.conditions = conditions
    }


}




public class EmailMediaPolicyConditions: Codable {















    public enum CustomerParticipation: String, Codable { 
        case yes = "YES"
        case no = "NO"
    }

    public var forUsers: [User]?
    public var dateRanges: [String]?
    public var forQueues: [Queue]?
    public var wrapupCodes: [WrapupCode]?
    public var languages: [Language]?
    public var timeAllowed: TimeAllowed?
    /** Teams to match conversations against */
    public var teams: [Team]?
    public var customerParticipation: CustomerParticipation?

    public init(forUsers: [User]?, dateRanges: [String]?, forQueues: [Queue]?, wrapupCodes: [WrapupCode]?, languages: [Language]?, timeAllowed: TimeAllowed?, teams: [Team]?, customerParticipation: CustomerParticipation?) {
        self.forUsers = forUsers
        self.dateRanges = dateRanges
        self.forQueues = forQueues
        self.wrapupCodes = wrapupCodes
        self.languages = languages
        self.timeAllowed = timeAllowed
        self.teams = teams
        self.customerParticipation = customerParticipation
    }


}




public class EmailMessage: Codable {



























    public enum State: String, Codable { 
        case created = "Created"
        case ready = "Ready"
        case edited = "Edited"
    }

    public enum DraftType: String, Codable { 
        case reply = "Reply"
        case replyAll = "ReplyAll"
        case forward = "Forward"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The recipients of the email message. */
    public var to: [EmailAddress]?
    /** The recipients that were copied on the email message. */
    public var cc: [EmailAddress]?
    /** The recipients that were blind copied on the email message. */
    public var bcc: [EmailAddress]?
    /** The sender of the email message. */
    public var from: EmailAddress?
    /** The receiver of the reply email message. */
    public var replyTo: EmailAddress?
    /** The subject of the email message. */
    public var subject: String?
    /** The attachments of the email message. */
    public var attachments: [Attachment]?
    /** The text body of the email message. */
    public var textBody: String?
    /** The html body of the email message. */
    public var htmlBody: String?
    /** The time when the message was received or sent. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var time: Date?
    /** Indicates whether the history of previous emails of the conversation is included within the email bodies of this message. */
    public var historyIncluded: Bool?
    /** The state of the current draft. */
    public var state: State?
    /** The type of draft that need to be treated. */
    public var draftType: DraftType?
    /** Indicates an estimation of the size of the current email as a whole, in its final, ready to be sent form. */
    public var emailSizeBytes: Int?
    /** Indicates the maximum allowed size for an email to be send via SMTP server, based on the email domain configuration */
    public var maxEmailSizeBytes: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, to: [EmailAddress]?, cc: [EmailAddress]?, bcc: [EmailAddress]?, from: EmailAddress?, replyTo: EmailAddress?, subject: String?, attachments: [Attachment]?, textBody: String?, htmlBody: String?, time: Date?, historyIncluded: Bool?, state: State?, draftType: DraftType?, emailSizeBytes: Int?, maxEmailSizeBytes: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.to = to
        self.cc = cc
        self.bcc = bcc
        self.from = from
        self.replyTo = replyTo
        self.subject = subject
        self.attachments = attachments
        self.textBody = textBody
        self.htmlBody = htmlBody
        self.time = time
        self.historyIncluded = historyIncluded
        self.state = state
        self.draftType = draftType
        self.emailSizeBytes = emailSizeBytes
        self.maxEmailSizeBytes = maxEmailSizeBytes
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case to
        case cc
        case bcc
        case from
        case replyTo
        case subject
        case attachments
        case textBody
        case htmlBody
        case time
        case historyIncluded
        case state
        case draftType
        case emailSizeBytes
        case maxEmailSizeBytes
        case selfUri
    }


}




public class EmailProgressTransferEvent: Codable {













    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** The id (V4 UUID) used to identify the transfer already started by the external platform. */
    public var commandId: String?
    /** The id (V4 UUID) of the communication that is being transferred. */
    public var objectCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred to. */
    public var destinationCommunicationId: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, commandId: String?, objectCommunicationId: String?, destinationCommunicationId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.commandId = commandId
        self.objectCommunicationId = objectCommunicationId
        self.destinationCommunicationId = destinationCommunicationId
    }


}




public class EmailSettings: Codable {



    /** This setting allows a single inbound email that contains multiple routes configured in Genesys Cloud to create a conversation per route. When this setting is disabled only a single conversation will be created */
    public var multipleRouteDestinationsOnInboundEmailEnabled: Bool?

    public init(multipleRouteDestinationsOnInboundEmailEnabled: Bool?) {
        self.multipleRouteDestinationsOnInboundEmailEnabled = multipleRouteDestinationsOnInboundEmailEnabled
    }


}




public class EmailSetup: Codable {



    /** The root PureCloud domain that all sub-domains are created from. */
    public var rootDomain: String?

    public init(rootDomain: String?) {
        self.rootDomain = rootDomain
    }


}




public class EmailsSettings: Codable {



    public var sendingSizeLimit: Int?

    public init(sendingSizeLimit: Int?) {
        self.sendingSizeLimit = sendingSizeLimit
    }


}



/** A group of emergency call flows to use in an emergency. */

public class EmergencyGroup: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** True if an emergency is occurring and the associated emergency call flow(s) should be used.  False otherwise. */
    public var enabled: Bool?
    /** The emergency call flow(s) to use during an emergency. */
    public var emergencyCallFlows: [EmergencyCallFlow]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, enabled: Bool?, emergencyCallFlows: [EmergencyCallFlow]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.enabled = enabled
        self.emergencyCallFlows = emergencyCallFlows
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case enabled
        case emergencyCallFlows
        case selfUri
    }


}




public class EmergencyGroupDivisionViewEntityListing: Codable {





















    public var entities: [EmergencyGroupDivisionView]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [EmergencyGroupDivisionView]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class EmergencyGroupListing: Codable {





















    public var entities: [EmergencyGroup]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [EmergencyGroup]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class EmergencyLocation: Codable {









    public enum Source: String, Codable { 
        case admin = "Admin"
        case user = "User"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Emergency address */
    public var address: LocationAddress?
    /** Phone number in E164 format */
    public var did: String?
    /** source */
    public var source: Source?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, address: LocationAddress?, did: String?, source: Source?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.address = address
        self.did = did
        self.source = source
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case did
        case source
        case selfUri
    }


}




public class Entity: Codable {



    /** The globally unique identifier for the object. */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class EntityListing: Codable {



    public var entities: [JSON]?

    public init(entities: [JSON]?) {
        self.entities = entities
    }


}




public class ErrorDetails: Codable {

















    public var status: Int?
    public var message: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var code: String?
    public var contextId: String?
    public var nested: ErrorDetails?
    public var details: String?

    public init(status: Int?, message: String?, messageWithParams: String?, messageParams: [String:String]?, code: String?, contextId: String?, nested: ErrorDetails?, details: String?) {
        self.status = status
        self.message = message
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.code = code
        self.contextId = contextId
        self.nested = nested
        self.details = details
    }


}




public class EstimateAvailablePartialDayTimeOffResponse: Codable {









    /** Start date-time in ISO-8601 format for partial day request */
    public var date: Date?
    /** An estimation of time off request length in minutes */
    public var durationMinutes: Int?
    /** An estimation of payable part of time off request in minutes */
    public var payableMinutes: Int?
    /** Whether there is flexibility for a user to choose different hours than the system estimated */
    public var flexible: Bool?

    public init(date: Date?, durationMinutes: Int?, payableMinutes: Int?, flexible: Bool?) {
        self.date = date
        self.durationMinutes = durationMinutes
        self.payableMinutes = payableMinutes
        self.flexible = flexible
    }


}




public class EstimateAvailableTimeOffRequest: Codable {









    /** Full day dates. partialDayDates must be empty if this field is populated */
    public var fullDayDates: [EstimateAvailableFullDayTimeOffRequest]?
    /** Partial day dates. fullDayDates must be empty if this field is populated */
    public var partialDayDates: [EstimateAvailablePartialDayTimeOffRequest]?
    /** The ID of the activity code associated with the time off request. Activity code must be of the TimeOff category */
    public var activityCodeId: String?
    /** Whether this estimate is for a paid time off request */
    public var paid: Bool?

    public init(fullDayDates: [EstimateAvailableFullDayTimeOffRequest]?, partialDayDates: [EstimateAvailablePartialDayTimeOffRequest]?, activityCodeId: String?, paid: Bool?) {
        self.fullDayDates = fullDayDates
        self.partialDayDates = partialDayDates
        self.activityCodeId = activityCodeId
        self.paid = paid
    }


}




public class EvaluationAggregateQueryResponse: Codable {



    public var results: [EvaluationAggregateDataContainer]?

    public init(results: [EvaluationAggregateDataContainer]?) {
        self.results = results
    }


}




public class EvaluationAggregationView: Codable {

    public enum Target: String, Codable { 
        case nevaluations = "nEvaluations"
        case nevaluationsdeleted = "nEvaluationsDeleted"
        case nevaluationsrescored = "nEvaluationsRescored"
        case ototalcriticalscore = "oTotalCriticalScore"
        case ototalscore = "oTotalScore"
    }



    public enum Function: String, Codable { 
        case rangebound = "rangeBound"
    }



    /** Target metric name */
    public var target: Target?
    /** A unique name for this view. Must be distinct from other views and built-in metric names. */
    public var name: String?
    /** Type of view you wish to create */
    public var function: Function?
    /** Range of numbers for slicing up data */
    public var range: AggregationRange?

    public init(target: Target?, name: String?, function: Function?, range: AggregationRange?) {
        self.target = target
        self.name = name
        self.function = function
        self.range = range
    }


}




public class EvaluationAssignment: Codable {





    public var evaluationForm: EvaluationForm?
    public var user: User?

    public init(evaluationForm: EvaluationForm?, user: User?) {
        self.evaluationForm = evaluationForm
        self.user = user
    }


}




public class EvaluationCreateBody: Codable {



















    public enum ResourceType: String, Codable { 
        case email = "EMAIL"
    }









    public enum Status: String, Codable { 
        case pending = "PENDING"
        case inprogress = "INPROGRESS"
        case finished = "FINISHED"
        case inreview = "INREVIEW"
        case retracted = "RETRACTED"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Evaluation form used for evaluation (must be included for a successful request) */
    public var evaluationForm: EvaluationCreateEvalForm?
    /** User ID of the evaluator (must be included for a successful request) */
    public var evaluator: EvaluationCreateUser?
    /** User ID of the agent (must be included for a successful request) */
    public var agent: EvaluationCreateUser?
    public var agentHasRead: Bool?
    public var answers: EvaluationScoringSet?
    public var calibration: EvaluationCreateCalibration?
    public var evaluationContextId: String?
    public var conversation: EvaluationCreateConversation?
    public var resourceType: ResourceType?
    public var evaluationSource: EvaluationSource?
    public var rescore: Bool?
    public var queue: EvaluationCreateQueue?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var releaseDate: Date?
    public var status: Status?
    public var neverRelease: Bool?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateAssigneeChanged: Date?
    public var assignee: EvaluationCreateUser?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, evaluationForm: EvaluationCreateEvalForm?, evaluator: EvaluationCreateUser?, agent: EvaluationCreateUser?, agentHasRead: Bool?, answers: EvaluationScoringSet?, calibration: EvaluationCreateCalibration?, evaluationContextId: String?, conversation: EvaluationCreateConversation?, resourceType: ResourceType?, evaluationSource: EvaluationSource?, rescore: Bool?, queue: EvaluationCreateQueue?, releaseDate: Date?, status: Status?, neverRelease: Bool?, dateAssigneeChanged: Date?, assignee: EvaluationCreateUser?, selfUri: String?) {
        self._id = _id
        self.evaluationForm = evaluationForm
        self.evaluator = evaluator
        self.agent = agent
        self.agentHasRead = agentHasRead
        self.answers = answers
        self.calibration = calibration
        self.evaluationContextId = evaluationContextId
        self.conversation = conversation
        self.resourceType = resourceType
        self.evaluationSource = evaluationSource
        self.rescore = rescore
        self.queue = queue
        self.releaseDate = releaseDate
        self.status = status
        self.neverRelease = neverRelease
        self.dateAssigneeChanged = dateAssigneeChanged
        self.assignee = assignee
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case evaluationForm
        case evaluator
        case agent
        case agentHasRead
        case answers
        case calibration
        case evaluationContextId
        case conversation
        case resourceType
        case evaluationSource
        case rescore
        case queue
        case releaseDate
        case status
        case neverRelease
        case dateAssigneeChanged
        case assignee
        case selfUri
    }


}




public class EvaluationCreateCalibration: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class EvaluationDetailQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [EvaluationDetailQueryPredicate]?

    public init(type: ModelType?, predicates: [EvaluationDetailQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class EvaluationForm: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The evaluation form name */
    public var name: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    public var published: Bool?
    public var contextId: String?
    /** A list of question groups */
    public var questionGroups: [EvaluationQuestionGroup]?
    /** A list of the published versions of this form. Not populated by default, its availability depends on the endpoint. Use the 'expand=publishHistory' query parameter to retrieve this data where applicable (refer to the endpoint description to see if it is applicable). */
    public var publishedVersions: DomainEntityListingEvaluationForm?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, modifiedDate: Date?, published: Bool?, contextId: String?, questionGroups: [EvaluationQuestionGroup]?, publishedVersions: DomainEntityListingEvaluationForm?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.modifiedDate = modifiedDate
        self.published = published
        self.contextId = contextId
        self.questionGroups = questionGroups
        self.publishedVersions = publishedVersions
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case modifiedDate
        case published
        case contextId
        case questionGroups
        case publishedVersions
        case selfUri
    }


}




public class EvaluationFormAndScoringSet: Codable {





    public var evaluationForm: EvaluationForm?
    public var answers: EvaluationScoringSet?

    public init(evaluationForm: EvaluationForm?, answers: EvaluationScoringSet?) {
        self.evaluationForm = evaluationForm
        self.answers = answers
    }


}




public class EvaluationQuestionGroupScore: Codable {

































    public var questionGroupId: String?
    /** Score of all questions in the group */
    public var totalScore: Float?
    /** Maximum possible score of all questions in the group */
    public var maxTotalScore: Float?
    /** True when the evaluation is submitted with a question group that does not have any answers. Only allowed when naEnabled is true or if set by the system */
    public var markedNA: Bool?
    /** If markedNA is true, systemMarkedNA indicates whether it was marked by a user or by the system due to visibility conditions. Always false if markedNA is false. */
    public var systemMarkedNA: Bool?
    /** Score of only the critical questions in the group */
    public var totalCriticalScore: Float?
    /** Maximum possible score of only the critical questions in the group */
    public var maxTotalCriticalScore: Float?
    /** Score of only the non critical questions in the group */
    public var totalNonCriticalScore: Float?
    /** Maximum possible score of only the non critical questions in the group */
    public var maxTotalNonCriticalScore: Float?
    /** Unweighted score of all questions in the group */
    public var totalScoreUnweighted: Float?
    /** Maximum possible unweighted score of all questions in the group */
    public var maxTotalScoreUnweighted: Float?
    /** Unweighted score of only the critical questions in the group */
    public var totalCriticalScoreUnweighted: Float?
    /** Maximum possible unweighted score of only the critical questions in the group */
    public var maxTotalCriticalScoreUnweighted: Float?
    /** Unweighted score of only the non critical questions in the group */
    public var totalNonCriticalScoreUnweighted: Float?
    /** Maximum possible unweighted score of only the non critical questions in the group */
    public var maxTotalNonCriticalScoreUnweighted: Float?
    public var questionScores: [EvaluationQuestionScore]?

    public init(questionGroupId: String?, totalScore: Float?, maxTotalScore: Float?, markedNA: Bool?, systemMarkedNA: Bool?, totalCriticalScore: Float?, maxTotalCriticalScore: Float?, totalNonCriticalScore: Float?, maxTotalNonCriticalScore: Float?, totalScoreUnweighted: Float?, maxTotalScoreUnweighted: Float?, totalCriticalScoreUnweighted: Float?, maxTotalCriticalScoreUnweighted: Float?, totalNonCriticalScoreUnweighted: Float?, maxTotalNonCriticalScoreUnweighted: Float?, questionScores: [EvaluationQuestionScore]?) {
        self.questionGroupId = questionGroupId
        self.totalScore = totalScore
        self.maxTotalScore = maxTotalScore
        self.markedNA = markedNA
        self.systemMarkedNA = systemMarkedNA
        self.totalCriticalScore = totalCriticalScore
        self.maxTotalCriticalScore = maxTotalCriticalScore
        self.totalNonCriticalScore = totalNonCriticalScore
        self.maxTotalNonCriticalScore = maxTotalNonCriticalScore
        self.totalScoreUnweighted = totalScoreUnweighted
        self.maxTotalScoreUnweighted = maxTotalScoreUnweighted
        self.totalCriticalScoreUnweighted = totalCriticalScoreUnweighted
        self.maxTotalCriticalScoreUnweighted = maxTotalCriticalScoreUnweighted
        self.totalNonCriticalScoreUnweighted = totalNonCriticalScoreUnweighted
        self.maxTotalNonCriticalScoreUnweighted = maxTotalNonCriticalScoreUnweighted
        self.questionScores = questionScores
    }


}




public class EvaluationQuestionScore: Codable {

















    public var questionId: String?
    public var answerId: String?
    /** Unweighted score of the question */
    public var score: Int?
    /** True when the evaluation is submitted with a question that does not have an answer. Only allowed when naEnabled is true or if set by the system */
    public var markedNA: Bool?
    /** If markedNA is true, systemMarkedNA indicates whether it was marked by a user or by the system due to visibility conditions. Always false if markedNA is false. */
    public var systemMarkedNA: Bool?
    /** AnswerId found with evaluation assistance conditions */
    public var assistedAnswerId: String?
    /** Applicable only on fatal questions. Indicates that the answer selected was not the highest score available for the question */
    public var failedKillQuestion: Bool?
    /** Comments from the evaluator specific to this question */
    public var comments: String?

    public init(questionId: String?, answerId: String?, score: Int?, markedNA: Bool?, systemMarkedNA: Bool?, assistedAnswerId: String?, failedKillQuestion: Bool?, comments: String?) {
        self.questionId = questionId
        self.answerId = answerId
        self.score = score
        self.markedNA = markedNA
        self.systemMarkedNA = systemMarkedNA
        self.assistedAnswerId = assistedAnswerId
        self.failedKillQuestion = failedKillQuestion
        self.comments = comments
    }


}




public class EvaluatorActivity: Codable {























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var evaluator: User?
    public var numEvaluationsAssigned: Int?
    public var numEvaluationsStarted: Int?
    public var numEvaluationsCompleted: Int?
    public var numCalibrationsAssigned: Int?
    public var numCalibrationsStarted: Int?
    public var numCalibrationsCompleted: Int?
    public var numEvaluationsWithoutViewPermission: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, evaluator: User?, numEvaluationsAssigned: Int?, numEvaluationsStarted: Int?, numEvaluationsCompleted: Int?, numCalibrationsAssigned: Int?, numCalibrationsStarted: Int?, numCalibrationsCompleted: Int?, numEvaluationsWithoutViewPermission: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.evaluator = evaluator
        self.numEvaluationsAssigned = numEvaluationsAssigned
        self.numEvaluationsStarted = numEvaluationsStarted
        self.numEvaluationsCompleted = numEvaluationsCompleted
        self.numCalibrationsAssigned = numCalibrationsAssigned
        self.numCalibrationsStarted = numCalibrationsStarted
        self.numCalibrationsCompleted = numCalibrationsCompleted
        self.numEvaluationsWithoutViewPermission = numEvaluationsWithoutViewPermission
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case evaluator
        case numEvaluationsAssigned
        case numEvaluationsStarted
        case numEvaluationsCompleted
        case numCalibrationsAssigned
        case numCalibrationsStarted
        case numCalibrationsCompleted
        case numEvaluationsWithoutViewPermission
        case selfUri
    }


}




public class EventDefinition: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the object. */
    public var name: String?
    /** description */
    public var _description: String?

    public init(_id: String?, name: String?, _description: String?) {
        self._id = _id
        self.name = name
        self._description = _description
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
    }


}




public class EventDefinitionListing: Codable {



    public var entities: [EventDefinition]?

    public init(entities: [EventDefinition]?) {
        self.entities = entities
    }


}




public class ExpandableWebDeploymentEntityListing: Codable {







    public var total: Int64?
    public var entities: [ExpandableWebDeployment]?
    public var selfUri: String?

    public init(total: Int64?, entities: [ExpandableWebDeployment]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class ExpansionCriterium: Codable {

    public enum ModelType: String, Codable { 
        case timeoutSeconds = "TIMEOUT_SECONDS"
    }



    public var type: ModelType?
    public var threshold: Double?

    public init(type: ModelType?, threshold: Double?) {
        self.type = type
        self.threshold = threshold
    }


}




public class Extension: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }











    public enum OwnerType: String, Codable { 
        case user = "USER"
        case phone = "PHONE"
        case ivrConfig = "IVR_CONFIG"
        case group = "GROUP"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    public var number: String?
    /** A Uri reference to the owner of this extension, which is either a User or an IVR */
    public var owner: DomainEntityRef?
    public var extensionPool: DomainEntityRef?
    public var ownerType: OwnerType?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, number: String?, owner: DomainEntityRef?, extensionPool: DomainEntityRef?, ownerType: OwnerType?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.number = number
        self.owner = owner
        self.extensionPool = extensionPool
        self.ownerType = ownerType
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case number
        case owner
        case extensionPool
        case ownerType
        case selfUri
    }


}




public class ExtensionPool: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** The starting phone number for the range of this Extension pool. The number must be between 3 and 9 digits in length and the same length as the endNumber. */
    public var startNumber: String?
    /** The ending phone number for the range of this Extension pool. The number must be between 3 and 9 digits in length and the same length as the startNumber. */
    public var endNumber: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, startNumber: String?, endNumber: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.startNumber = startNumber
        self.endNumber = endNumber
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case startNumber
        case endNumber
        case selfUri
    }


}




public class ExtensionPoolDivisionViewEntityListing: Codable {





















    public var entities: [ExtensionPoolDivisionView]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ExtensionPoolDivisionView]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ExternalContactsContactChangedTopicDivision: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class ExternalContactsContactChangedTopicFacebookId: Codable {





    public var ids: [ExternalContactsContactChangedTopicFacebookScopedId]?
    public var displayName: String?

    public init(ids: [ExternalContactsContactChangedTopicFacebookScopedId]?, displayName: String?) {
        self.ids = ids
        self.displayName = displayName
    }


}




public class ExternalContactsContactChangedTopicInstagramId: Codable {





    public var ids: [ExternalContactsContactChangedTopicInstagramScopedId]?
    public var displayName: String?

    public init(ids: [ExternalContactsContactChangedTopicInstagramScopedId]?, displayName: String?) {
        self.ids = ids
        self.displayName = displayName
    }


}




public class ExternalContactsUnresolvedContactChangedTopicExternalOrganization: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class ExternalEstablishedEvent: Codable {





















    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication */
    public var communicationId: String?
    /** The automatic number identification if it is available for this conversation. */
    public var ani: String?
    /** The automatic number identification name if it is available for this conversation. */
    public var aniName: String?
    /** The dialed number identification if it is available for this conversation. */
    public var dnis: String?
    /** The dialed number identification name if it is available for this conversation. */
    public var dnisName: String?
    /** Metadata about this communication. */
    public var initialConfiguration: InitialConfiguration?
    /** Metadata about the source of this communication's interaction. */
    public var sourceConfiguration: SourceConfiguration?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, ani: String?, aniName: String?, dnis: String?, dnisName: String?, initialConfiguration: InitialConfiguration?, sourceConfiguration: SourceConfiguration?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.ani = ani
        self.aniName = aniName
        self.dnis = dnis
        self.dnisName = dnisName
        self.initialConfiguration = initialConfiguration
        self.sourceConfiguration = sourceConfiguration
    }


}




public class ExternalMetricDataUnprocessedItem: Codable {













    public enum ModelType: String, Codable { 
        case total = "Total"
        case cumulative = "Cumulative"
    }





    /** The user ID. Must provide either userId or userEmail, but not both. */
    public var userId: String?
    /** The user main email used in user's GenesysCloud account. Must provide either userId or userEmail, but not both. */
    public var userEmail: String?
    /** The ID of the external metric definition */
    public var metricId: String?
    /** The date of the metric data. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateOccurred: Date?
    /** The value of the metric data. When value is null, the metric data will be deleted. */
    public var value: Double?
    /** The number of data points. The default value is 0 when type is Cumulative and the metric data already exists, otherwise 1. When total count reaches 0, the metric data will be deleted. */
    public var count: Int?
    /** The type of the metric data. The default value is Total. */
    public var type: ModelType?
    /** The error message */
    public var message: String?
    /** The error code */
    public var code: String?

    public init(userId: String?, userEmail: String?, metricId: String?, dateOccurred: Date?, value: Double?, count: Int?, type: ModelType?, message: String?, code: String?) {
        self.userId = userId
        self.userEmail = userEmail
        self.metricId = metricId
        self.dateOccurred = dateOccurred
        self.value = value
        self.count = count
        self.type = type
        self.message = message
        self.code = code
    }


}



/** User information for a Facebook user interacting with a page or app */

public class FacebookId: Codable {





    /** The set of scopedIds that this person has. Each scopedId is specific to a page or app that the user interacts with. */
    public var ids: [FacebookScopedId]?
    /** The displayName of this person's Facebook account. Roughly translates to user.first_name + ' ' + user.last_name in the Facebook API. */
    public var displayName: String?

    public init(ids: [FacebookScopedId]?, displayName: String?) {
        self.ids = ids
        self.displayName = displayName
    }


}




public class FacebookAppCredentials: Codable {



    /** Genesys Cloud Facebook App Id */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class FacebookIntegrationEntityListing: Codable {





















    public var entities: [FacebookIntegration]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [FacebookIntegration]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class FaxSummary: Codable {







    public var readCount: Int?
    public var unreadCount: Int?
    public var totalCount: Int?

    public init(readCount: Int?, unreadCount: Int?, totalCount: Int?) {
        self.readCount = readCount
        self.unreadCount = unreadCount
        self.totalCount = totalCount
    }


}




public class FieldConfig: Codable {





    public enum EntityType: String, Codable { 
        case person = "person"
        case group = "group"
        case org = "org"
        case externalcontact = "externalContact"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var entityType: EntityType?
    public var state: String?
    public var sections: [Section]?
    public var version: String?
    public var schemaVersion: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, entityType: EntityType?, state: String?, sections: [Section]?, version: String?, schemaVersion: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.entityType = entityType
        self.state = state
        self.sections = sections
        self.version = version
        self.schemaVersion = schemaVersion
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case entityType
        case state
        case sections
        case version
        case schemaVersion
        case selfUri
    }


}




public class FieldConfigs: Codable {









    public var org: FieldConfig?
    public var person: FieldConfig?
    public var group: FieldConfig?
    public var externalContact: FieldConfig?

    public init(org: FieldConfig?, person: FieldConfig?, group: FieldConfig?, externalContact: FieldConfig?) {
        self.org = org
        self.person = person
        self.group = group
        self.externalContact = externalContact
    }


}




public class FileSpecificationTemplate: Codable {













    public enum Format: String, Codable { 
        case fixedLength = "FixedLength"
        case delimited = "Delimited"
    }







    public enum Delimiter: String, Codable { 
        case comma = "Comma"
        case pipe = "Pipe"
        case colon = "Colon"
        case tab = "Tab"
        case semicolon = "Semicolon"
        case custom = "Custom"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the File Specification template. */
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** Description of the file specification template */
    public var _description: String?
    /** File format */
    public var format: Format?
    /** Number of heading lines to be skipped */
    public var numberOfHeadingLinesSkipped: Int?
    /** Number of trailing lines to be skipped */
    public var numberOfTrailingLinesSkipped: Int?
    /** If true indicates that delimited file has a header row, which can provide column names */
    public var header: Bool?
    /** Kind of delimiter */
    public var delimiter: Delimiter?
    /** Delimiter character, used only when delimiter=\"Custom\" */
    public var delimiterValue: String?
    /** Columns specification */
    public var columnInformation: [Column]?
    /** Preprocessing rules */
    public var preprocessingRules: [PreprocessingRule]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, _description: String?, format: Format?, numberOfHeadingLinesSkipped: Int?, numberOfTrailingLinesSkipped: Int?, header: Bool?, delimiter: Delimiter?, delimiterValue: String?, columnInformation: [Column]?, preprocessingRules: [PreprocessingRule]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self._description = _description
        self.format = format
        self.numberOfHeadingLinesSkipped = numberOfHeadingLinesSkipped
        self.numberOfTrailingLinesSkipped = numberOfTrailingLinesSkipped
        self.header = header
        self.delimiter = delimiter
        self.delimiterValue = delimiterValue
        self.columnInformation = columnInformation
        self.preprocessingRules = preprocessingRules
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case _description = "description"
        case format
        case numberOfHeadingLinesSkipped
        case numberOfTrailingLinesSkipped
        case header
        case delimiter
        case delimiterValue
        case columnInformation
        case preprocessingRules
        case selfUri
    }


}




public class FlowAggregateQueryResponse: Codable {



    public var results: [FlowAggregateDataContainer]?

    public init(results: [FlowAggregateDataContainer]?) {
        self.results = results
    }


}




public class FlowAggregationView: Codable {

    public enum Target: String, Codable { 
        case nflow = "nFlow"
        case nflowmilestone = "nFlowMilestone"
        case nflowoutcome = "nFlowOutcome"
        case nflowoutcomefailed = "nFlowOutcomeFailed"
        case oflowmilestone = "oFlowMilestone"
        case tflow = "tFlow"
        case tflowdisconnect = "tFlowDisconnect"
        case tflowexit = "tFlowExit"
        case tflowoutcome = "tFlowOutcome"
    }



    public enum Function: String, Codable { 
        case rangebound = "rangeBound"
    }



    /** Target metric name */
    public var target: Target?
    /** A unique name for this view. Must be distinct from other views and built-in metric names. */
    public var name: String?
    /** Type of view you wish to create */
    public var function: Function?
    /** Range of numbers for slicing up data */
    public var range: AggregationRange?

    public init(target: Target?, name: String?, function: Function?, range: AggregationRange?) {
        self.target = target
        self.name = name
        self.function = function
        self.range = range
    }


}




public class FlowExecutionAggregateQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [FlowExecutionAggregateQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [FlowExecutionAggregateQueryPredicate]?

    public init(type: ModelType?, clauses: [FlowExecutionAggregateQueryClause]?, predicates: [FlowExecutionAggregateQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}



/** This is the metadata of an executionData entry for a flow. */

public class FlowExecutionDataQueryResult: Codable {















    public enum FlowType: String, Codable { 
        case bot = "bot"
        case commonmodule = "commonmodule"
        case digitalbot = "digitalbot"
        case inboundcall = "inboundcall"
        case inboundchat = "inboundchat"
        case inboundemail = "inboundemail"
        case inboundshortmessage = "inboundshortmessage"
        case inqueuecall = "inqueuecall"
        case inqueueshortmessage = "inqueueshortmessage"
        case inqueueemail = "inqueueemail"
        case outboundcall = "outboundcall"
        case securecall = "securecall"
        case surveyinvite = "surveyinvite"
        case voice = "voice"
        case voicemail = "voicemail"
        case voicesurvey = "voicesurvey"
        case workflow = "workflow"
        case workitem = "workitem"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The start time for the execution of this flow. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDateTime: Date?
    /** The end time for the execution of this flow. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endDateTime: Date?
    /** The id of the flow that was executed. */
    public var flowId: String?
    /** The version of the flow that was executed. */
    public var flowVersion: String?
    /** The id of the conversation that executed this flow. */
    public var conversationId: String?
    /** The type of flow. */
    public var flowType: FlowType?
    /** If the flow errored out this is the reason. */
    public var flowErrorReason: String?
    /** The name of the flow. */
    public var flowName: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, startDateTime: Date?, endDateTime: Date?, flowId: String?, flowVersion: String?, conversationId: String?, flowType: FlowType?, flowErrorReason: String?, flowName: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.startDateTime = startDateTime
        self.endDateTime = endDateTime
        self.flowId = flowId
        self.flowVersion = flowVersion
        self.conversationId = conversationId
        self.flowType = flowType
        self.flowErrorReason = flowErrorReason
        self.flowName = flowName
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case startDateTime
        case endDateTime
        case flowId
        case flowVersion
        case conversationId
        case flowType
        case flowErrorReason
        case flowName
        case selfUri
    }


}




public class FlowHealthIntent: Codable {







    public enum Language: String, Codable { 
        case enUs = "en-us"
        case enGb = "en-gb"
        case enAu = "en-au"
        case enZa = "en-za"
        case enNz = "en-nz"
        case enIe = "en-ie"
        case frCa = "fr-ca"
        case frFr = "fr-fr"
        case esUs = "es-us"
        case esEs = "es-es"
        case esMx = "es-mx"
        case deDe = "de-de"
        case itIt = "it-it"
        case ptBr = "pt-br"
        case ptPt = "pt-pt"
        case nlNl = "nl-nl"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Info about given flow version. */
    public var flowVersionInfo: FlowHealthIntentVersionInfo?
    /** Language provided for this intent's health. */
    public var language: Language?
    /** Health computation details for given language. */
    public var health: HealthInfo?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, flowVersionInfo: FlowHealthIntentVersionInfo?, language: Language?, health: HealthInfo?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.flowVersionInfo = flowVersionInfo
        self.language = language
        self.health = health
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case flowVersionInfo
        case language
        case health
        case selfUri
    }


}




public class FlowMetricsTopicFlowScoredAgent: Codable {





    /** Assigned agent score for this conversation (0 - 100, higher being better) */
    public var agentScore: Int?
    /** Unique identifier for the agent that was scored for this conversation */
    public var scoredAgentId: String?

    public init(agentScore: Int?, scoredAgentId: String?) {
        self.agentScore = agentScore
        self.scoredAgentId = scoredAgentId
    }


}




public class FlowMilestone: Codable {











    /** The flow milestone identifier */
    public var _id: String?
    /** The flow milestone name. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    /** The flow milestone description. */
    public var _description: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, _description: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case selfUri
    }


}




public class FlowMilestoneDivisionViewEntityListing: Codable {





















    public var entities: [FlowMilestoneDivisionView]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [FlowMilestoneDivisionView]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class FlowMilestoneListing: Codable {





















    public var entities: [FlowMilestone]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [FlowMilestone]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class FlowOutcomeDetailEventTopicFlowMilestone: Codable {





    public var milestoneId: String?
    public var milestoneTime: Int?

    public init(milestoneId: String?, milestoneTime: Int?) {
        self.milestoneId = milestoneId
        self.milestoneTime = milestoneTime
    }


}




public class FlowStartDetailEventTopicFlowStartEvent: Codable {









    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
    }



    public enum Direction: String, Codable { 
        case unknown = "UNKNOWN"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }











    public enum MessageType: String, Codable { 
        case unknown = "UNKNOWN"
        case sms = "SMS"
        case twitter = "TWITTER"
        case facebook = "FACEBOOK"
        case line = "LINE"
        case whatsapp = "WHATSAPP"
        case webmessaging = "WEBMESSAGING"
        case _open = "OPEN"
        case instagram = "INSTAGRAM"
    }

    public enum FlowType: String, Codable { 
        case unknown = "UNKNOWN"
        case inboundcall = "INBOUNDCALL"
        case outboundcall = "OUTBOUNDCALL"
        case inqueuecall = "INQUEUECALL"
        case securecall = "SECURECALL"
        case inboundemail = "INBOUNDEMAIL"
        case surveyinvite = "SURVEYINVITE"
        case inboundshortmessage = "INBOUNDSHORTMESSAGE"
        case inboundchat = "INBOUNDCHAT"
        case workflow = "WORKFLOW"
        case bot = "BOT"
        case digitalbot = "DIGITALBOT"
        case commonmodule = "COMMONMODULE"
        case inqueueemail = "INQUEUEEMAIL"
        case inqueueshortmessage = "INQUEUESHORTMESSAGE"
        case voice = "VOICE"
        case voicemail = "VOICEMAIL"
        case workitem = "WORKITEM"
    }











    public var eventTime: Int?
    public var conversationId: String?
    public var participantId: String?
    public var sessionId: String?
    public var mediaType: MediaType?
    public var provider: String?
    public var direction: Direction?
    public var ani: String?
    public var dnis: String?
    public var addressTo: String?
    public var addressFrom: String?
    public var subject: String?
    public var messageType: MessageType?
    public var flowType: FlowType?
    public var flowId: String?
    public var divisionId: String?
    public var flowVersion: String?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?

    public init(eventTime: Int?, conversationId: String?, participantId: String?, sessionId: String?, mediaType: MediaType?, provider: String?, direction: Direction?, ani: String?, dnis: String?, addressTo: String?, addressFrom: String?, subject: String?, messageType: MessageType?, flowType: FlowType?, flowId: String?, divisionId: String?, flowVersion: String?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.sessionId = sessionId
        self.mediaType = mediaType
        self.provider = provider
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.addressTo = addressTo
        self.addressFrom = addressFrom
        self.subject = subject
        self.messageType = messageType
        self.flowType = flowType
        self.flowId = flowId
        self.divisionId = divisionId
        self.flowVersion = flowVersion
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
    }


}




public class FlowVersionEntityListing: Codable {





















    public var entities: [FlowVersion]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [FlowVersion]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ForecastAbandonRateResponse: Codable {



    /** The target percent abandon rate goal */
    public var percent: Int?

    public init(percent: Int?) {
        self.percent = percent
    }


}




public class Format: Codable {


    public enum Flags: String, Codable { 
        case boolPlayYesNo = "BoolPlayYesNo"
        case currencyAsMinorUnits = "CurrencyAsMinorUnits"
        case currencyMajorUnitsOnly = "CurrencyMajorUnitsOnly"
        case currencyMinorUnitsOnly = "CurrencyMinorUnitsOnly"
        case currencyPlayDigits = "CurrencyPlayDigits"
        case dateLongYear = "DateLongYear"
        case dateShortYear = "DateShortYear"
        case dateShortMonthAndDay = "DateShortMonthAndDay"
        case dateDayOfWeekOnly = "DateDayOfWeekOnly"
        case dateDayOnly = "DateDayOnly"
        case dateMonthOnly = "DateMonthOnly"
        case dateShortYearOnly = "DateShortYearOnly"
        case dateLongYearOnly = "DateLongYearOnly"
        case timeTwentyFourHours = "TimeTwentyFourHours"
        case timeTwelveHours = "TimeTwelveHours"
        case timePartDays = "TimePartDays"
        case timePartHours = "TimePartHours"
        case timePartMinutes = "TimePartMinutes"
        case timePartSeconds = "TimePartSeconds"
        case stringPlayChars = "StringPlayChars"
        case numberPlayDigits = "NumberPlayDigits"
        case numberOrdinal = "NumberOrdinal"
        case languageCaseArticle = "LanguageCaseArticle"
        case languageCaseAccusative = "LanguageCaseAccusative"
        case languageCaseDative = "LanguageCaseDative"
        case languageCaseGenitive = "LanguageCaseGenitive"
        case languageCaseNominative = "LanguageCaseNominative"
        case languageQuantityPlural = "LanguageQuantityPlural"
        case languageQuantitySingular = "LanguageQuantitySingular"
        case languageGenderCommon = "LanguageGenderCommon"
        case languageGenderFeminine = "LanguageGenderFeminine"
        case languageGenderMasculine = "LanguageGenderMasculine"
        case languageGenderNeuter = "LanguageGenderNeuter"
        case caseArticle = "CaseArticle"
        case caseAccusative = "CaseAccusative"
        case caseDative = "CaseDative"
        case caseGenitive = "CaseGenitive"
        case caseNominative = "CaseNominative"
        case quantityPlural = "QuantityPlural"
        case quantitySingular = "QuantitySingular"
        case genderCommon = "GenderCommon"
        case genderFeminine = "GenderFeminine"
        case genderMasculine = "GenderMasculine"
        case genderNeuter = "GenderNeuter"
    }
    /** The Set of prompt segment format flags i.e. each entry is a part of describing the overall format. E.g. \"format\": { \"flags\": [StringPlayChars] } */
    public var flags: [Flags]?

    public init(flags: [Flags]?) {
        self.flags = flags
    }


}




public class FromEmailAddress: Codable {







    /** The OutboundDomain used for the email address. */
    public var domain: DomainEntityRef?
    /** The friendly name of the email address. */
    public var friendlyName: String?
    /** The local part of the email address. */
    public var localPart: String?

    public init(domain: DomainEntityRef?, friendlyName: String?, localPart: String?) {
        self.domain = domain
        self.friendlyName = friendlyName
        self.localPart = localPart
    }


}




public class GKNDocumentationSearchRequest: Codable {

    public enum SortOrder: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
        case score = "SCORE"
    }











    /** The sort order for results */
    public var sortOrder: SortOrder?
    /** The field in the resource that you want to sort the results by */
    public var sortBy: String?
    /** The number of results per page */
    public var pageSize: Int?
    /** The page of resources you want to retrieve */
    public var pageNumber: Int?
    /** Multi-value sort order, list of multiple sort values */
    public var sort: [SearchSort]?
    public var query: [GKNDocumentationSearchCriteria]?

    public init(sortOrder: SortOrder?, sortBy: String?, pageSize: Int?, pageNumber: Int?, sort: [SearchSort]?, query: [GKNDocumentationSearchCriteria]?) {
        self.sortOrder = sortOrder
        self.sortBy = sortBy
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.sort = sort
        self.query = query
    }


}




public class GenerateBuForecastRequest: Codable {







    /** The description for the forecast */
    public var _description: String?
    /** The number of weeks this forecast covers */
    public var weekCount: Int?
    /** Whether this forecast can be used for scheduling */
    public var canUseForScheduling: Bool?

    public init(_description: String?, weekCount: Int?, canUseForScheduling: Bool?) {
        self._description = _description
        self.weekCount = weekCount
        self.canUseForScheduling = canUseForScheduling
    }

    public enum CodingKeys: String, CodingKey { 
        case _description = "description"
        case weekCount
        case canUseForScheduling
    }


}




public class GenericSAML: Codable {

























    public enum NameIdentifierFormat: String, Codable { 
        case urnOasisNamesTcSaml11NameidFormatUnspecified = "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified"
        case urnOasisNamesTcSaml11NameidFormatEmailaddress = "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
        case urnOasisNamesTcSaml11NameidFormatX509subjectname = "urn:oasis:names:tc:SAML:1.1:nameid-format:X509SubjectName"
        case urnOasisNamesTcSaml11NameidFormatWindowsdomainqualifiedname = "urn:oasis:names:tc:SAML:1.1:nameid-format:WindowsDomainQualifiedName"
        case urnOasisNamesTcSaml20NameidFormatKerberos = "urn:oasis:names:tc:SAML:2.0:nameid-format:kerberos"
        case urnOasisNamesTcSaml20NameidFormatEntity = "urn:oasis:names:tc:SAML:2.0:nameid-format:entity"
        case urnOasisNamesTcSaml20NameidFormatPersistent = "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent"
        case urnOasisNamesTcSaml20NameidFormatTransient = "urn:oasis:names:tc:SAML:2.0:nameid-format:transient"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var disabled: Bool?
    public var issuerURI: String?
    public var ssoTargetURI: String?
    public var sloURI: String?
    public var sloBinding: String?
    public var relyingPartyIdentifier: String?
    public var certificate: String?
    public var certificates: [String]?
    public var logoImageData: String?
    public var endpointCompression: Bool?
    public var nameIdentifierFormat: NameIdentifierFormat?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, disabled: Bool?, issuerURI: String?, ssoTargetURI: String?, sloURI: String?, sloBinding: String?, relyingPartyIdentifier: String?, certificate: String?, certificates: [String]?, logoImageData: String?, endpointCompression: Bool?, nameIdentifierFormat: NameIdentifierFormat?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.disabled = disabled
        self.issuerURI = issuerURI
        self.ssoTargetURI = ssoTargetURI
        self.sloURI = sloURI
        self.sloBinding = sloBinding
        self.relyingPartyIdentifier = relyingPartyIdentifier
        self.certificate = certificate
        self.certificates = certificates
        self.logoImageData = logoImageData
        self.endpointCompression = endpointCompression
        self.nameIdentifierFormat = nameIdentifierFormat
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case disabled
        case issuerURI
        case ssoTargetURI
        case sloURI
        case sloBinding
        case relyingPartyIdentifier
        case certificate
        case certificates
        case logoImageData
        case endpointCompression
        case nameIdentifierFormat
        case selfUri
    }


}




public class GetMetricResponse: Codable {







    public var total: Int64?
    public var entities: [Metric]?
    public var selfUri: String?

    public init(total: Int64?, entities: [Metric]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class GetMetricsResponse: Codable {







    public var total: Int64?
    public var entities: [Metrics]?
    public var selfUri: String?

    public init(total: Int64?, entities: [Metrics]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class GreetingMediaInfo: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var mediaFileUri: String?
    public var mediaImageUri: String?

    public init(_id: String?, mediaFileUri: String?, mediaImageUri: String?) {
        self._id = _id
        self.mediaFileUri = mediaFileUri
        self.mediaImageUri = mediaImageUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case mediaFileUri
        case mediaImageUri
    }


}




public class GroupEntityListing: Codable {





















    public var entities: [Group]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Group]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class GroupSearchCriteria: Codable {









    public enum Operator: String, Codable { 
        case and = "AND"
        case or = "OR"
        case not = "NOT"
    }





    public enum ModelType: String, Codable { 
        case exact = "EXACT"
        case startsWith = "STARTS_WITH"
        case contains = "CONTAINS"
        case regex = "REGEX"
        case term = "TERM"
        case terms = "TERMS"
        case requiredFields = "REQUIRED_FIELDS"
        case matchAll = "MATCH_ALL"
    }



    /** The end value of the range. This field is used for range search types. */
    public var endValue: String?
    /** A list of values for the search to match against */
    public var values: [String]?
    /** The start value of the range. This field is used for range search types. */
    public var startValue: String?
    /** A value for the search to match against */
    public var value: String?
    /** How to apply this search criteria against other criteria */
    public var _operator: Operator?
    /** Groups multiple conditions */
    public var group: [GroupSearchCriteria]?
    /** Set date format for criteria values when using date range search type.  Supports Java date format syntax, example yyyy-MM-dd'T'HH:mm:ss.SSSX. */
    public var dateFormat: String?
    /** Search Type */
    public var type: ModelType?
    /** Field names to search against */
    public var fields: [String]?

    public init(endValue: String?, values: [String]?, startValue: String?, value: String?, _operator: Operator?, group: [GroupSearchCriteria]?, dateFormat: String?, type: ModelType?, fields: [String]?) {
        self.endValue = endValue
        self.values = values
        self.startValue = startValue
        self.value = value
        self._operator = _operator
        self.group = group
        self.dateFormat = dateFormat
        self.type = type
        self.fields = fields
    }

    public enum CodingKeys: String, CodingKey { 
        case endValue
        case values
        case startValue
        case value
        case _operator = "operator"
        case group
        case dateFormat
        case type
        case fields
    }


}




public class GuestCategoryResponseListing: Codable {











    public var entities: [GuestResponseCategory]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?
    public var sessionId: String?

    public init(entities: [GuestResponseCategory]?, nextUri: String?, selfUri: String?, previousUri: String?, sessionId: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
        self.sessionId = sessionId
    }


}




public class GuestResponseCategory: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var _description: String?
    public var externalId: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The reference to category to which this category belongs. */
    public var parentCategory: GuestCategoryReference?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, externalId: String?, dateCreated: Date?, dateModified: Date?, parentCategory: GuestCategoryReference?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.externalId = externalId
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.parentCategory = parentCategory
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case externalId
        case dateCreated
        case dateModified
        case parentCategory
        case selfUri
    }


}




public class HelpSettings: Codable {





    /** List of keywords for compliance */
    public var keyword: [String]?
    /** The response configuration for the keywords */
    public var response: ComplianceResponse?

    public init(keyword: [String]?, response: ComplianceResponse?) {
        self.keyword = keyword
        self.response = response
    }


}




public class HistoricalImportDeleteJobResponse: Codable {





    public enum Status: String, Codable { 
        case inProgress = "InProgress"
        case success = "Success"
        case failed = "Failed"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Property denoting the status of the delete. */
    public var status: Status?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, status: Status?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.status = status
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case status
        case selfUri
    }


}




public class HistoricalShrinkageActivityCodeResponse: Codable {





    /** The ID of the activity code for which shrinkage data is provided */
    public var activityCodeId: String?
    /** Aggregated shrinkage data for the activity code */
    public var shrinkageForActivityCode: HistoricalShrinkageAggregateResponse?

    public init(activityCodeId: String?, shrinkageForActivityCode: HistoricalShrinkageAggregateResponse?) {
        self.activityCodeId = activityCodeId
        self.shrinkageForActivityCode = shrinkageForActivityCode
    }


}




public class IdentityProviderEntityListing: Codable {





















    public var entities: [IdentityProvider]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [IdentityProvider]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class IgnoredActivityCategories: Codable {

    public enum Values: String, Codable { 
        case onQueueWork = "OnQueueWork"
        case _break = "Break"
        case meal = "Meal"
        case meeting = "Meeting"
        case offQueueWork = "OffQueueWork"
        case timeOff = "TimeOff"
        case training = "Training"
        case unavailable = "Unavailable"
        case unscheduled = "Unscheduled"
    }

    /** Activity categories list */
    public var values: [Values]?

    public init(values: [Values]?) {
        self.values = values
    }


}




public class ImportError: Codable {





    public var message: String?
    public var line: Int?

    public init(message: String?, line: Int?) {
        self.message = message
        self.line = line
    }


}




public class InitialConfiguration: Codable {













    /** Indicates the initial audio state for the communication. */
    public var audioState: AudioState?
    /** Indicates that this communication's initial state is alerting. If false, the communication started in a connected state. */
    public var alerting: Bool?
    /** Indicates the direction of this communication with respect to the contact center. `true` means the communication is INBOUND. `false` means the communication is OUTBOUND. */
    public var inbound: Bool?
    /** The id of the communication (the \"peer\") that \"invited\" this communication, if this occurred. */
    public var invitedBy: String?
    /** Indicates whether recording is active for this communication at creation. */
    public var recordingActive: Bool?
    /** Additional metadata about this session which should be recorded by the platform but which will not be indexed or searchable. Primarily for diagnostic value. Any information that needs to be accessible through other components like Analytics should be moved to dedicated fields. */
    public var additionalInfo: [String:String]?

    public init(audioState: AudioState?, alerting: Bool?, inbound: Bool?, invitedBy: String?, recordingActive: Bool?, additionalInfo: [String:String]?) {
        self.audioState = audioState
        self.alerting = alerting
        self.inbound = inbound
        self.invitedBy = invitedBy
        self.recordingActive = recordingActive
        self.additionalInfo = additionalInfo
    }


}




public class InsightsDetailsMetricItem: Codable {











    /** The gamification metric for the data */
    public var metric: AddressableEntityRef?
    /** Insights data in the comparative period */
    public var comparativePeriod: InsightsDetailsMetricPeriodPoints?
    /** Insights data in the primary period */
    public var primaryPeriod: InsightsDetailsMetricPeriodPoints?
    /** Percent of goal change */
    public var percentOfGoalChange: Double?
    /** Value change */
    public var valueChange: Double?

    public init(metric: AddressableEntityRef?, comparativePeriod: InsightsDetailsMetricPeriodPoints?, primaryPeriod: InsightsDetailsMetricPeriodPoints?, percentOfGoalChange: Double?, valueChange: Double?) {
        self.metric = metric
        self.comparativePeriod = comparativePeriod
        self.primaryPeriod = primaryPeriod
        self.percentOfGoalChange = percentOfGoalChange
        self.valueChange = valueChange
    }


}




public class InsightsSummaryMetricItem: Codable {











    /** The gamification metric for the data */
    public var metric: AddressableEntityRef?
    /** Insights data in the comparative period */
    public var comparativePeriod: InsightsSummaryMetricPeriodPoints?
    /** Insights data in the primary period */
    public var primaryPeriod: InsightsSummaryMetricPeriodPoints?
    /** Percent of goal change */
    public var percentOfGoalChange: Double?
    /** Value change */
    public var valueChange: Double?

    public init(metric: AddressableEntityRef?, comparativePeriod: InsightsSummaryMetricPeriodPoints?, primaryPeriod: InsightsSummaryMetricPeriodPoints?, percentOfGoalChange: Double?, valueChange: Double?) {
        self.metric = metric
        self.comparativePeriod = comparativePeriod
        self.primaryPeriod = primaryPeriod
        self.percentOfGoalChange = percentOfGoalChange
        self.valueChange = valueChange
    }


}



/** User information for an Instagram account */

public class InstagramId: Codable {





    /** The set of scopedIds that this person has. Each scopedId is specific to an Instagram page or app that the user interacts with. */
    public var ids: [InstagramScopedId]?
    /** The displayName of the person who owns this Instagram account */
    public var displayName: String?

    public init(ids: [InstagramScopedId]?, displayName: String?) {
        self.ids = ids
        self.displayName = displayName
    }


}




public class InstagramIntegrationEntityListing: Codable {





















    public var entities: [InstagramIntegration]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [InstagramIntegration]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class IntegrationAction: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class InteractionStatsRule: Codable {





    public enum Dimension: String, Codable { 
        case queueid = "queueId"
        case userid = "userId"
    }



    public enum Metric: String, Codable { 
        case tabandon = "tAbandon"
        case tanswered = "tAnswered"
        case ttalk = "tTalk"
        case noffered = "nOffered"
        case thandle = "tHandle"
        case ntransferred = "nTransferred"
        case oservicelevel = "oServiceLevel"
        case twait = "tWait"
        case theld = "tHeld"
        case tacw = "tAcw"
    }

    public enum MediaType: String, Codable { 
        case voice = "voice"
        case chat = "chat"
        case email = "email"
        case callback = "callback"
        case message = "message"
    }

    public enum NumericRange: String, Codable { 
        case gt = "gt"
        case gte = "gte"
        case lt = "lt"
        case lte = "lte"
        case eq = "eq"
        case ne = "ne"
    }

    public enum Statistic: String, Codable { 
        case count = "count"
        case min = "min"
        case ratio = "ratio"
        case max = "max"
    }










    public enum AlertTypes: String, Codable { 
        case sms = "SMS"
        case device = "DEVICE"
        case email = "EMAIL"
    }


    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Name of the rule */
    public var name: String?
    /** The dimension of concern. */
    public var dimension: Dimension?
    /** The value of the dimension. */
    public var dimensionValue: String?
    /** The metric to be assessed. */
    public var metric: Metric?
    /** The media type. */
    public var mediaType: MediaType?
    /** The comparison descriptor used against the metric's value. */
    public var numericRange: NumericRange?
    /** The statistic of concern for the metric. */
    public var statistic: Statistic?
    /** The threshold value. */
    public var value: Double?
    /** Indicates if the rule is enabled. */
    public var enabled: Bool?
    /** Indicates if the rule is in alarm state. */
    public var inAlarm: Bool?
    /** The ids of users who will be notified of alarm state change. */
    public var notificationUsers: [User]?
    /** A collection of notification methods. */
    public var alertTypes: [AlertTypes]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dimension: Dimension?, dimensionValue: String?, metric: Metric?, mediaType: MediaType?, numericRange: NumericRange?, statistic: Statistic?, value: Double?, enabled: Bool?, inAlarm: Bool?, notificationUsers: [User]?, alertTypes: [AlertTypes]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dimension = dimension
        self.dimensionValue = dimensionValue
        self.metric = metric
        self.mediaType = mediaType
        self.numericRange = numericRange
        self.statistic = statistic
        self.value = value
        self.enabled = enabled
        self.inAlarm = inAlarm
        self.notificationUsers = notificationUsers
        self.alertTypes = alertTypes
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dimension
        case dimensionValue
        case metric
        case mediaType
        case numericRange
        case statistic
        case value
        case enabled
        case inAlarm
        case notificationUsers
        case alertTypes
        case selfUri
    }


}




public class IpAddressAuthentication: Codable {



    public var networkWhitelist: [String]?

    public init(networkWhitelist: [String]?) {
        self.networkWhitelist = networkWhitelist
    }


}




public class IvrEstablishedEvent: Codable {





















    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication */
    public var communicationId: String?
    /** The phone number for this IVR, if any is known */
    public var ivrPhoneNumber: String?
    /** A displayable name for this IVR, if any is known. */
    public var ivrName: String?
    /** The automatic number identification if it is available for this conversation. */
    public var ani: String?
    /** The dialed number identification if it is available for this conversation. */
    public var dnis: String?
    /** Metadata about this communication. */
    public var initialConfiguration: InitialConfiguration?
    /** Metadata about the source of this communication's interaction. */
    public var sourceConfiguration: SourceConfiguration?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, ivrPhoneNumber: String?, ivrName: String?, ani: String?, dnis: String?, initialConfiguration: InitialConfiguration?, sourceConfiguration: SourceConfiguration?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.ivrPhoneNumber = ivrPhoneNumber
        self.ivrName = ivrName
        self.ani = ani
        self.dnis = dnis
        self.initialConfiguration = initialConfiguration
        self.sourceConfiguration = sourceConfiguration
    }


}




public class JourneyAggregateQueryResponse: Codable {



    public var results: [JourneyAggregateDataContainer]?

    public init(results: [JourneyAggregateDataContainer]?) {
        self.results = results
    }


}




public class JourneyAggregationView: Codable {

    public enum Target: String, Codable { 
        case ndistinctjourneyactions = "nDistinctJourneyActions"
        case ndistinctjourneysessions = "nDistinctJourneySessions"
        case njourneyactionsblocked = "nJourneyActionsBlocked"
        case njourneyoutcomesachieved = "nJourneyOutcomesAchieved"
        case njourneyoutcomesattributed = "nJourneyOutcomesAttributed"
        case njourneysegmentsassigned = "nJourneySegmentsAssigned"
        case njourneysessions = "nJourneySessions"
        case nwebactionsabandoned = "nWebActionsAbandoned"
        case nwebactionsaccepted = "nWebActionsAccepted"
        case nwebactionsengaged = "nWebActionsEngaged"
        case nwebactionserrored = "nWebActionsErrored"
        case nwebactionsfrequencycapreached = "nWebActionsFrequencyCapReached"
        case nwebactionsignored = "nWebActionsIgnored"
        case nwebactionsoffered = "nWebActionsOffered"
        case nwebactionsofferedoutsideschedule = "nWebActionsOfferedOutsideSchedule"
        case nwebactionsqualified = "nWebActionsQualified"
        case nwebactionsqualifiedoutsideschedule = "nWebActionsQualifiedOutsideSchedule"
        case nwebactionsrejected = "nWebActionsRejected"
        case nwebactionsstarted = "nWebActionsStarted"
        case nwebactionstimedout = "nWebActionsTimedout"
        case ojourneyoutcometouchpointvalue = "oJourneyOutcomeTouchpointValue"
        case ojourneyoutcomevalue = "oJourneyOutcomeValue"
    }



    public enum Function: String, Codable { 
        case rangebound = "rangeBound"
    }



    /** Target metric name */
    public var target: Target?
    /** A unique name for this view. Must be distinct from other views and built-in metric names. */
    public var name: String?
    /** Type of view you wish to create */
    public var function: Function?
    /** Range of numbers for slicing up data */
    public var range: AggregationRange?

    public init(target: Target?, name: String?, function: Function?, range: AggregationRange?) {
        self.target = target
        self.name = name
        self.function = function
        self.range = range
    }


}




public class JourneyApp: Codable {









    /** Name of the application (e.g. mybankingapp). */
    public var name: String?
    /** Namespace of the application (e.g. com.genesys.bancodinero). */
    public var namespace: String?
    /** Version of the application (e.g. 5.9.27). */
    public var version: String?
    /** Build number of the application (e.g. 701). */
    public var buildNumber: String?

    public init(name: String?, namespace: String?, version: String?, buildNumber: String?) {
        self.name = name
        self.namespace = namespace
        self.version = version
        self.buildNumber = buildNumber
    }


}




public class JourneyAppEventsNotificationExternalContact: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneyAppEventsNotificationSegmentAssignmentMessage: Codable {



    public var segment: JourneyAppEventsNotificationSegment?

    public init(segment: JourneyAppEventsNotificationSegment?) {
        self.segment = segment
    }


}




public class JourneyOutcomeEventsNotificationAssociatedValue: Codable {

    public enum DataType: String, Codable { 
        case number = "Number"
        case integer = "Integer"
    }



    public var dataType: DataType?
    public var value: Double?

    public init(dataType: DataType?, value: Double?) {
        self.dataType = dataType
        self.value = value
    }


}




public class JourneyOutcomeEventsNotificationGeoLocation: Codable {





















    public var country: String?
    public var countryName: String?
    public var latitude: Double?
    public var longitude: Double?
    public var locality: String?
    public var postalCode: String?
    public var region: String?
    public var regionName: String?
    public var timezone: String?
    public var source: String?

    public init(country: String?, countryName: String?, latitude: Double?, longitude: Double?, locality: String?, postalCode: String?, region: String?, regionName: String?, timezone: String?, source: String?) {
        self.country = country
        self.countryName = countryName
        self.latitude = latitude
        self.longitude = longitude
        self.locality = locality
        self.postalCode = postalCode
        self.region = region
        self.regionName = regionName
        self.timezone = timezone
        self.source = source
    }


}




public class JourneyOutcomeEventsNotificationOutcomeTouchpointChannel: Codable {

    public enum ModelType: String, Codable { 
        case unknown = "Unknown"
        case contentOffer = "ContentOffer"
        case webchat = "Webchat"
    }

    public var type: ModelType?

    public init(type: ModelType?) {
        self.type = type
    }


}




public class JourneyOutcomeEventsNotificationSegment: Codable {







    public var _id: String?
    public var selfUri: String?
    public var assignedDate: Date?

    public init(_id: String?, selfUri: String?, assignedDate: Date?) {
        self._id = _id
        self.selfUri = selfUri
        self.assignedDate = assignedDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case assignedDate
    }


}




public class JourneyPattern: Codable {





    public enum StreamType: String, Codable { 
        case web = "Web"
        case custom = "Custom"
        case conversation = "Conversation"
        case app = "App"
    }





    /** A list of one or more criteria to satisfy. */
    public var criteria: [Criteria]?
    /** The number of times the pattern must match. */
    public var count: Int?
    /** The stream type for which this pattern can be matched on. */
    public var streamType: StreamType?
    /** The session type for which this pattern can be matched on. */
    public var sessionType: String?
    /** The name of the event for which this pattern can be matched on. */
    public var eventName: String?

    public init(criteria: [Criteria]?, count: Int?, streamType: StreamType?, sessionType: String?, eventName: String?) {
        self.criteria = criteria
        self.count = count
        self.streamType = streamType
        self.sessionType = sessionType
        self.eventName = eventName
    }


}




public class JourneySessionEventsNotificationBrowser: Codable {





















    public var family: String?
    public var version: String?
    public var lang: String?
    public var fingerprint: String?
    public var viewHeight: Int?
    public var viewWidth: Int?
    public var featuresFlash: Bool?
    public var featuresJava: Bool?
    public var featuresPdf: Bool?
    public var featuresWebrtc: Bool?

    public init(family: String?, version: String?, lang: String?, fingerprint: String?, viewHeight: Int?, viewWidth: Int?, featuresFlash: Bool?, featuresJava: Bool?, featuresPdf: Bool?, featuresWebrtc: Bool?) {
        self.family = family
        self.version = version
        self.lang = lang
        self.fingerprint = fingerprint
        self.viewHeight = viewHeight
        self.viewWidth = viewWidth
        self.featuresFlash = featuresFlash
        self.featuresJava = featuresJava
        self.featuresPdf = featuresPdf
        self.featuresWebrtc = featuresWebrtc
    }


}




public class JourneySessionEventsNotificationConversation: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneySessionEventsNotificationMktCampaign: Codable {















    public var content: String?
    public var medium: String?
    public var name: String?
    public var source: String?
    public var term: String?
    public var clickId: String?
    public var network: String?

    public init(content: String?, medium: String?, name: String?, source: String?, term: String?, clickId: String?, network: String?) {
        self.content = content
        self.medium = medium
        self.name = name
        self.source = source
        self.term = term
        self.clickId = clickId
        self.network = network
    }


}




public class JourneySessionEventsNotificationNetworkConnectivity: Codable {









    public var carrier: String?
    public var bluetoothEnabled: Bool?
    public var cellularEnabled: Bool?
    public var wifiEnabled: Bool?

    public init(carrier: String?, bluetoothEnabled: Bool?, cellularEnabled: Bool?, wifiEnabled: Bool?) {
        self.carrier = carrier
        self.bluetoothEnabled = bluetoothEnabled
        self.cellularEnabled = cellularEnabled
        self.wifiEnabled = wifiEnabled
    }


}




public class JourneySessionEventsNotificationSdkLibrary: Codable {





    public var name: String?
    public var version: String?

    public init(name: String?, version: String?) {
        self.name = name
        self.version = version
    }


}




public class JourneySessionEventsNotificationUser: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneyWebActionEventsNotificationGeoLocation: Codable {





















    public var country: String?
    public var countryName: String?
    public var latitude: Double?
    public var longitude: Double?
    public var locality: String?
    public var postalCode: String?
    public var region: String?
    public var regionName: String?
    public var timezone: String?
    public var source: String?

    public init(country: String?, countryName: String?, latitude: Double?, longitude: Double?, locality: String?, postalCode: String?, region: String?, regionName: String?, timezone: String?, source: String?) {
        self.country = country
        self.countryName = countryName
        self.latitude = latitude
        self.longitude = longitude
        self.locality = locality
        self.postalCode = postalCode
        self.region = region
        self.regionName = regionName
        self.timezone = timezone
        self.source = source
    }


}




public class JourneyWebActionEventsNotificationScheduleGroup: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneyWebEventsNotificationOutcomeAchievedMessage: Codable {























    public var outcome: JourneyWebEventsNotificationOutcome?
    public var browser: JourneyWebEventsNotificationBrowser?
    public var visitCreatedDate: Date?
    public var ipAddress: String?
    public var ipOrganization: String?
    public var userAgentString: String?
    public var device: JourneyWebEventsNotificationDevice?
    public var geolocation: JourneyWebEventsNotificationGeoLocation?
    public var mktCampaign: JourneyWebEventsNotificationMktCampaign?
    public var visitReferrer: JourneyWebEventsNotificationReferrer?
    public var associatedValue: JourneyWebEventsNotificationAssociatedValue?

    public init(outcome: JourneyWebEventsNotificationOutcome?, browser: JourneyWebEventsNotificationBrowser?, visitCreatedDate: Date?, ipAddress: String?, ipOrganization: String?, userAgentString: String?, device: JourneyWebEventsNotificationDevice?, geolocation: JourneyWebEventsNotificationGeoLocation?, mktCampaign: JourneyWebEventsNotificationMktCampaign?, visitReferrer: JourneyWebEventsNotificationReferrer?, associatedValue: JourneyWebEventsNotificationAssociatedValue?) {
        self.outcome = outcome
        self.browser = browser
        self.visitCreatedDate = visitCreatedDate
        self.ipAddress = ipAddress
        self.ipOrganization = ipOrganization
        self.userAgentString = userAgentString
        self.device = device
        self.geolocation = geolocation
        self.mktCampaign = mktCampaign
        self.visitReferrer = visitReferrer
        self.associatedValue = associatedValue
    }


}




public class JourneyWebEventsNotificationReferrer: Codable {

















    public enum Medium: String, Codable { 
        case _internal = "internal"
        case search = "search"
        case social = "social"
        case email = "email"
        case unknown = "unknown"
        case paid = "paid"
    }

    public var url: String?
    public var domain: String?
    public var hostname: String?
    public var keywords: String?
    public var pathname: String?
    public var queryString: String?
    public var fragment: String?
    public var name: String?
    public var medium: Medium?

    public init(url: String?, domain: String?, hostname: String?, keywords: String?, pathname: String?, queryString: String?, fragment: String?, name: String?, medium: Medium?) {
        self.url = url
        self.domain = domain
        self.hostname = hostname
        self.keywords = keywords
        self.pathname = pathname
        self.queryString = queryString
        self.fragment = fragment
        self.name = name
        self.medium = medium
    }


}




public class KeyPerformanceIndicatorAssessment: Codable {



    public enum AssessmentResult: String, Codable { 
        case unknown = "Unknown"
        case notSupported = "NotSupported"
        case high = "High"
        case low = "Low"
        case error = "Error"
    }



    /** Name of the key performance indicator assessed. */
    public var kpi: String?
    /** The overall result of the assessment for a key performance indicator. */
    public var assessmentResult: AssessmentResult?
    /** Set of checks executed as part of an assessment. */
    public var checks: [Check]?

    public init(kpi: String?, assessmentResult: AssessmentResult?, checks: [Check]?) {
        self.kpi = kpi
        self.assessmentResult = assessmentResult
        self.checks = checks
    }


}




public class KnowledgeAggregateQueryResponse: Codable {



    public var results: [KnowledgeAggregateDataContainer]?

    public init(results: [KnowledgeAggregateDataContainer]?) {
        self.results = results
    }


}




public class KnowledgeAggregationView: Codable {

    public enum Target: String, Codable { 
        case ndistinctknowledgesessions = "nDistinctKnowledgeSessions"
        case nknowledgedocumentcopied = "nKnowledgeDocumentCopied"
        case nknowledgedocumentfeedback = "nKnowledgeDocumentFeedback"
        case nknowledgedocumentpresented = "nKnowledgeDocumentPresented"
        case nknowledgedocumentsurfaced = "nKnowledgeDocumentSurfaced"
        case nknowledgedocumentviewed = "nKnowledgeDocumentViewed"
        case nknowledgesearch = "nKnowledgeSearch"
        case nknowledgesearchanswered = "nKnowledgeSearchAnswered"
        case nknowledgesearchfeedback = "nKnowledgeSearchFeedback"
        case nknowledgesearchunanswered = "nKnowledgeSearchUnanswered"
        case nknowledgesessions = "nKnowledgeSessions"
        case oknowledgedocumentquery = "oKnowledgeDocumentQuery"
        case oknowledgedocumentqueryselfserved = "oKnowledgeDocumentQuerySelfServed"
        case oknowledgesearch = "oKnowledgeSearch"
    }



    public enum Function: String, Codable { 
        case rangebound = "rangeBound"
    }



    /** Target metric name */
    public var target: Target?
    /** A unique name for this view. Must be distinct from other views and built-in metric names. */
    public var name: String?
    /** Type of view you wish to create */
    public var function: Function?
    /** Range of numbers for slicing up data */
    public var range: AggregationRange?

    public init(target: Target?, name: String?, function: Function?, range: AggregationRange?) {
        self.target = target
        self.name = name
        self.function = function
        self.range = range
    }


}




public class KnowledgeBase: Codable {







    public enum CoreLanguage: String, Codable { 
        case enUs = "en-US"
        case enUk = "en-UK"
        case enAu = "en-AU"
        case enCa = "en-CA"
        case enHk = "en-HK"
        case enIn = "en-IN"
        case enIe = "en-IE"
        case enNz = "en-NZ"
        case enPh = "en-PH"
        case enSg = "en-SG"
        case enZa = "en-ZA"
        case deDe = "de-DE"
        case deAt = "de-AT"
        case deCh = "de-CH"
        case esAr = "es-AR"
        case esCo = "es-CO"
        case esMx = "es-MX"
        case esUs = "es-US"
        case esEs = "es-ES"
        case frFr = "fr-FR"
        case frBe = "fr-BE"
        case frCa = "fr-CA"
        case frCh = "fr-CH"
        case ptBr = "pt-BR"
        case ptPt = "pt-PT"
        case nlNl = "nl-NL"
        case nlBe = "nl-BE"
        case itIt = "it-IT"
        case caEs = "ca-ES"
        case trTr = "tr-TR"
        case svSe = "sv-SE"
        case fiFi = "fi-FI"
        case nbNo = "nb-NO"
        case daDk = "da-DK"
        case jaJp = "ja-JP"
        case arAe = "ar-AE"
    }















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Knowledge base description */
    public var _description: String?
    /** Core language for knowledge base in which initial content must be created, language codes [en-US, en-UK, en-AU, de-DE] are supported currently. However, the new DX knowledge will support all these language codes, along with 'early preview' language codes [ca-ES, tr-TR, sv-SE, fi-FI, nb-NO, da-DK, ja-JP, ar-AE] which might have a lower accuracy. */
    public var coreLanguage: CoreLanguage?
    /** Knowledge base creation date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Knowledge base last modification date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The count representing the number of documents of type FAQ in the KnowledgeBase */
    public var faqCount: Int?
    /** The date representing when the last document is modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateDocumentLastModified: Date?
    /** The count representing the number of documents of type Article in the KnowledgeBase */
    public var articleCount: Int?
    /** Flag that indicates the knowledge base is published */
    public var published: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, coreLanguage: CoreLanguage?, dateCreated: Date?, dateModified: Date?, faqCount: Int?, dateDocumentLastModified: Date?, articleCount: Int?, published: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.coreLanguage = coreLanguage
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.faqCount = faqCount
        self.dateDocumentLastModified = dateDocumentLastModified
        self.articleCount = articleCount
        self.published = published
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case coreLanguage
        case dateCreated
        case dateModified
        case faqCount
        case dateDocumentLastModified
        case articleCount
        case published
        case selfUri
    }


}




public class KnowledgeBaseListing: Codable {









    public var entities: [KnowledgeBase]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [KnowledgeBase]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class KnowledgeDocumentBulkRequest: Codable {

    public enum ModelType: String, Codable { 
        case faq = "Faq"
        case article = "Article"
    }











    /** Document type according to assigned template */
    public var type: ModelType?
    /** External Url to the document */
    public var externalUrl: String?
    /** Faq document details */
    public var faq: DocumentFaq?
    /** Document categories */
    public var categories: [DocumentCategoryInput]?
    /** Article details */
    public var article: DocumentArticle?
    /** Identifier of document for update. Omit for create new Document. */
    public var _id: String?

    public init(type: ModelType?, externalUrl: String?, faq: DocumentFaq?, categories: [DocumentCategoryInput]?, article: DocumentArticle?, _id: String?) {
        self.type = type
        self.externalUrl = externalUrl
        self.faq = faq
        self.categories = categories
        self.article = article
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case externalUrl
        case faq
        case categories
        case article
        case _id = "id"
    }


}




public class KnowledgeDocumentFeedback: Codable {





    public enum Rating: String, Codable { 
        case negative = "Negative"
        case positive = "Positive"
    }

    public enum Reason: String, Codable { 
        case documentContent = "DocumentContent"
        case searchResults = "SearchResults"
    }









    public enum QueryType: String, Codable { 
        case unknown = "Unknown"
        case article = "Article"
        case autoSearch = "AutoSearch"
        case category = "Category"
        case manualSearch = "ManualSearch"
        case recommendation = "Recommendation"
        case suggestion = "Suggestion"
    }

    public enum State: String, Codable { 
        case draft = "Draft"
        case _final = "Final"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The variation of the document on which feedback was given. */
    public var documentVariation: EntityReference?
    /** Feedback rating. */
    public var rating: Rating?
    /** Feedback reason. */
    public var reason: Reason?
    /** Free-text comment of the feedback. Maximum length: 2000 characters. */
    public var comment: String?
    /** The search that surfaced the document on which feedback was given. */
    public var search: EntityReference?
    /** Knowledge guest session ID. */
    public var sessionId: String?
    /** The date and time of the feedback. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The type of the query that surfaced the document on which the feedback was given. */
    public var queryType: QueryType?
    /** The state of the feedback. */
    public var state: State?
    /** The document on which feedback was given. */
    public var document: KnowledgeDocumentVersionReference?
    /** The client application from which feedback was given. */
    public var application: KnowledgeSearchClientApplication?
    /** Conversation context information if the feedback is given in the context of a conversation. */
    public var conversationContext: KnowledgeConversationContext?
    /** The ID of the user who created the feedback. */
    public var userId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, documentVariation: EntityReference?, rating: Rating?, reason: Reason?, comment: String?, search: EntityReference?, sessionId: String?, dateCreated: Date?, queryType: QueryType?, state: State?, document: KnowledgeDocumentVersionReference?, application: KnowledgeSearchClientApplication?, conversationContext: KnowledgeConversationContext?, userId: String?, selfUri: String?) {
        self._id = _id
        self.documentVariation = documentVariation
        self.rating = rating
        self.reason = reason
        self.comment = comment
        self.search = search
        self.sessionId = sessionId
        self.dateCreated = dateCreated
        self.queryType = queryType
        self.state = state
        self.document = document
        self.application = application
        self.conversationContext = conversationContext
        self.userId = userId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case documentVariation
        case rating
        case reason
        case comment
        case search
        case sessionId
        case dateCreated
        case queryType
        case state
        case document
        case application
        case conversationContext
        case userId
        case selfUri
    }


}




public class KnowledgeDocumentGuestSearch: Codable {













    public enum QueryType: String, Codable { 
        case autoSearch = "AutoSearch"
        case manualSearch = "ManualSearch"
        case suggestion = "Suggestion"
    }





    /** Query to search content in the knowledge base. Maximum of 30 records per query can be fetched. */
    public var query: String?
    /** Page size of the returned results. */
    public var pageSize: Int?
    /** Page number of the returned results. */
    public var pageNumber: Int?
    /** The globally unique identifier for the search. */
    public var searchId: String?
    /** The total number of documents matching the query. */
    public var total: Int?
    /** Number of pages returned in the result calculated according to the pageSize and the total */
    public var pageCount: Int?
    /** The type of the query that initiates the search. */
    public var queryType: QueryType?
    /** Session ID of the search. */
    public var sessionId: String?
    /** Documents that matched the search query. */
    public var results: [KnowledgeDocumentGuestSearchResult]?

    public init(query: String?, pageSize: Int?, pageNumber: Int?, searchId: String?, total: Int?, pageCount: Int?, queryType: QueryType?, sessionId: String?, results: [KnowledgeDocumentGuestSearchResult]?) {
        self.query = query
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.searchId = searchId
        self.total = total
        self.pageCount = pageCount
        self.queryType = queryType
        self.sessionId = sessionId
        self.results = results
    }


}




public class KnowledgeDocumentGuestSearchRequest: Codable {













    public enum QueryType: String, Codable { 
        case autoSearch = "AutoSearch"
        case manualSearch = "ManualSearch"
        case suggestion = "Suggestion"
    }





    /** Query to search content in the knowledge base. Maximum of 30 records per query can be fetched. */
    public var query: String?
    /** Page size of the returned results. */
    public var pageSize: Int?
    /** Page number of the returned results. */
    public var pageNumber: Int?
    /** The globally unique identifier for the search. */
    public var searchId: String?
    /** The total number of documents matching the query. */
    public var total: Int?
    /** Number of pages returned in the result calculated according to the pageSize and the total */
    public var pageCount: Int?
    /** The type of the query that initiates the search. */
    public var queryType: QueryType?
    /** Session ID of the search. */
    public var sessionId: String?
    /** Indicates whether the search results would also include draft documents. */
    public var includeDraftDocuments: Bool?

    public init(query: String?, pageSize: Int?, pageNumber: Int?, searchId: String?, total: Int?, pageCount: Int?, queryType: QueryType?, sessionId: String?, includeDraftDocuments: Bool?) {
        self.query = query
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.searchId = searchId
        self.total = total
        self.pageCount = pageCount
        self.queryType = queryType
        self.sessionId = sessionId
        self.includeDraftDocuments = includeDraftDocuments
    }


}




public class KnowledgeDocumentSearch: Codable {













    public enum QueryType: String, Codable { 
        case autoSearch = "AutoSearch"
        case manualSearch = "ManualSearch"
        case suggestion = "Suggestion"
    }









    /** Query to search content in the knowledge base. Maximum of 30 records per query can be fetched. */
    public var query: String?
    /** Page size of the returned results. */
    public var pageSize: Int?
    /** Page number of the returned results. */
    public var pageNumber: Int?
    /** The globally unique identifier for the search. */
    public var searchId: String?
    /** The total number of documents matching the query. */
    public var total: Int?
    /** Number of pages returned in the result calculated according to the pageSize and the total */
    public var pageCount: Int?
    /** The type of the query that initiates the search. */
    public var queryType: QueryType?
    /** Documents matching the search query. */
    public var results: [KnowledgeDocumentSearchResult]?
    /** The client application details from which search happened. */
    public var application: KnowledgeSearchClientApplication?
    /** Conversation context information if the search is initiated in the context of a conversation. */
    public var conversationContext: KnowledgeConversationContextResponse?
    /** The confidence threshold for the search results. If applied, the returned results will have an equal or higher confidence than the threshold. */
    public var confidenceThreshold: Float?

    public init(query: String?, pageSize: Int?, pageNumber: Int?, searchId: String?, total: Int?, pageCount: Int?, queryType: QueryType?, results: [KnowledgeDocumentSearchResult]?, application: KnowledgeSearchClientApplication?, conversationContext: KnowledgeConversationContextResponse?, confidenceThreshold: Float?) {
        self.query = query
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.searchId = searchId
        self.total = total
        self.pageCount = pageCount
        self.queryType = queryType
        self.results = results
        self.application = application
        self.conversationContext = conversationContext
        self.confidenceThreshold = confidenceThreshold
    }


}




public class KnowledgeDocumentSearchRequest: Codable {













    public enum QueryType: String, Codable { 
        case autoSearch = "AutoSearch"
        case manualSearch = "ManualSearch"
        case suggestion = "Suggestion"
    }







    public enum SortOrder: String, Codable { 
        case asc = "Asc"
        case desc = "Desc"
    }

    public enum SortBy: String, Codable { 
        case confidenceScore = "ConfidenceScore"
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case categoryName = "CategoryName"
        case labelName = "LabelName"
    }







    /** Query to search content in the knowledge base. Maximum of 30 records per query can be fetched. */
    public var query: String?
    /** Page size of the returned results. */
    public var pageSize: Int?
    /** Page number of the returned results. */
    public var pageNumber: Int?
    /** The globally unique identifier for the search. */
    public var searchId: String?
    /** The total number of documents matching the query. */
    public var total: Int?
    /** Number of pages returned in the result calculated according to the pageSize and the total */
    public var pageCount: Int?
    /** The type of the query that initiates the search. */
    public var queryType: QueryType?
    /** Indicates whether the search results would also include draft documents. */
    public var includeDraftDocuments: Bool?
    /** Retrieves the documents created/modified/published in specified date and time range. */
    public var interval: DocumentQueryInterval?
    /** Filter for the document search. */
    public var filter: DocumentQuery?
    /** The sort order for search results. */
    public var sortOrder: SortOrder?
    /** The field in the documents that you want to sort the search results by. */
    public var sortBy: SortBy?
    /** The client application details from which search request was sent. */
    public var application: KnowledgeSearchClientApplication?
    /** Conversation context information if the search is initiated in the context of a conversation. */
    public var conversationContext: KnowledgeConversationContext?
    /** The confidence threshold for the search results. If applied, the returned results will have an equal or higher confidence than the threshold. The value should be between 0 to 1. */
    public var confidenceThreshold: Float?

    public init(query: String?, pageSize: Int?, pageNumber: Int?, searchId: String?, total: Int?, pageCount: Int?, queryType: QueryType?, includeDraftDocuments: Bool?, interval: DocumentQueryInterval?, filter: DocumentQuery?, sortOrder: SortOrder?, sortBy: SortBy?, application: KnowledgeSearchClientApplication?, conversationContext: KnowledgeConversationContext?, confidenceThreshold: Float?) {
        self.query = query
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.searchId = searchId
        self.total = total
        self.pageCount = pageCount
        self.queryType = queryType
        self.includeDraftDocuments = includeDraftDocuments
        self.interval = interval
        self.filter = filter
        self.sortOrder = sortOrder
        self.sortBy = sortBy
        self.application = application
        self.conversationContext = conversationContext
        self.confidenceThreshold = confidenceThreshold
    }


}




public class KnowledgeDocumentSuggestionResult: Codable {





    /** Matched phrase to the autocomplete suggestions query. */
    public var matchedPhrase: String?
    public var document: KnowledgeDocumentSuggestionResultDocument?

    public init(matchedPhrase: String?, document: KnowledgeDocumentSuggestionResultDocument?) {
        self.matchedPhrase = matchedPhrase
        self.document = document
    }


}




public class KnowledgeDocumentVersionReference: Codable {









    /** The globally unique identifier for the document. */
    public var _id: String?
    /** The knowledge base that the document belongs to. */
    public var knowledgeBase: KnowledgeBaseReference?
    /** The globally unique identifier for the version of the document. */
    public var versionId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, knowledgeBase: KnowledgeBaseReference?, versionId: String?, selfUri: String?) {
        self._id = _id
        self.knowledgeBase = knowledgeBase
        self.versionId = versionId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case knowledgeBase
        case versionId
        case selfUri
    }


}




public class KnowledgeDocumentVersionVariation: Codable {















    /** The globally unique identifier for the variation. */
    public var _id: String?
    /** The content for the variation. */
    public var body: DocumentBody?
    /** The creation date-time for the document variation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The last modification date-time for the document variation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The context values associated with the variation. */
    public var contexts: [DocumentVariationContext]?
    /** The URI for this object */
    public var selfUri: String?
    /** Reference to the document version to which the variation is associated with. */
    public var documentVersion: AddressableEntityRef?

    public init(_id: String?, body: DocumentBody?, dateCreated: Date?, dateModified: Date?, contexts: [DocumentVariationContext]?, selfUri: String?, documentVersion: AddressableEntityRef?) {
        self._id = _id
        self.body = body
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.contexts = contexts
        self.selfUri = selfUri
        self.documentVersion = documentVersion
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case body
        case dateCreated
        case dateModified
        case contexts
        case selfUri
        case documentVersion
    }


}




public class KnowledgeDocumentVersionVariationListing: Codable {









    public var entities: [KnowledgeDocumentVersionVariation]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [KnowledgeDocumentVersionVariation]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class KnowledgeExportJobFilter: Codable {



    public enum VersionFilter: String, Codable { 
        case all = "All"
        case latest = "Latest"
    }

    /** Filters for narrowing down which documents to export. */
    public var documentsFilter: KnowledgeExportJobDocumentsFilter?
    /** Specifies what version should be exported. */
    public var versionFilter: VersionFilter?

    public init(documentsFilter: KnowledgeExportJobDocumentsFilter?, versionFilter: VersionFilter?) {
        self.documentsFilter = documentsFilter
        self.versionFilter = versionFilter
    }


}




public class KnowledgeGuestDocumentFeedback: Codable {





    public enum Rating: String, Codable { 
        case negative = "Negative"
        case positive = "Positive"
    }

    public enum Reason: String, Codable { 
        case documentContent = "DocumentContent"
        case searchResults = "SearchResults"
    }









    public enum QueryType: String, Codable { 
        case unknown = "Unknown"
        case article = "Article"
        case autoSearch = "AutoSearch"
        case category = "Category"
        case manualSearch = "ManualSearch"
        case recommendation = "Recommendation"
        case suggestion = "Suggestion"
    }

    public enum State: String, Codable { 
        case draft = "Draft"
        case _final = "Final"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The variation of the document on which feedback was given. */
    public var documentVariation: EntityReference?
    /** Feedback rating. */
    public var rating: Rating?
    /** Feedback reason. */
    public var reason: Reason?
    /** Free-text comment of the feedback. Maximum length: 2000 characters. */
    public var comment: String?
    /** The search that surfaced the document on which feedback was given. */
    public var search: EntityReference?
    /** Knowledge guest session ID. */
    public var sessionId: String?
    /** The date and time of the feedback. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The type of the query that surfaced the document on which the feedback was given. */
    public var queryType: QueryType?
    /** The state of the feedback. */
    public var state: State?
    /** The document on which feedback was given. */
    public var document: KnowledgeGuestDocumentVersionReference?
    /** The client application from which feedback was given. */
    public var application: KnowledgeGuestSearchClientApplication?

    public init(_id: String?, documentVariation: EntityReference?, rating: Rating?, reason: Reason?, comment: String?, search: EntityReference?, sessionId: String?, dateCreated: Date?, queryType: QueryType?, state: State?, document: KnowledgeGuestDocumentVersionReference?, application: KnowledgeGuestSearchClientApplication?) {
        self._id = _id
        self.documentVariation = documentVariation
        self.rating = rating
        self.reason = reason
        self.comment = comment
        self.search = search
        self.sessionId = sessionId
        self.dateCreated = dateCreated
        self.queryType = queryType
        self.state = state
        self.document = document
        self.application = application
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case documentVariation
        case rating
        case reason
        case comment
        case search
        case sessionId
        case dateCreated
        case queryType
        case state
        case document
        case application
    }


}




public class KnowledgeGuestDocumentSuggestionResult: Codable {



    /** Matched phrase to the autocomplete suggestions query. */
    public var matchedPhrase: String?

    public init(matchedPhrase: String?) {
        self.matchedPhrase = matchedPhrase
    }


}




public class KnowledgeGuestDocumentVersionReference: Codable {





    /** The globally unique identifier for the document. */
    public var _id: String?
    /** The globally unique identifier for the version of the document. */
    public var versionId: String?

    public init(_id: String?, versionId: String?) {
        self._id = _id
        self.versionId = versionId
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case versionId
    }


}




public class KnowledgeGuestSessionApp: Codable {



    public enum ModelType: String, Codable { 
        case messengerKnowledgeApp = "MessengerKnowledgeApp"
        case supportCenter = "SupportCenter"
    }

    /** App deployment ID. */
    public var deploymentId: String?
    /** App type. */
    public var type: ModelType?

    public init(deploymentId: String?, type: ModelType?) {
        self.deploymentId = deploymentId
        self.type = type
    }


}




public class KnowledgeImportJobReport: Codable {





    /** List of errors occurred during processing import. */
    public var errors: [KnowledgeImportJobError]?
    /** Statistics related to the import job. */
    public var statistics: KnowledgeImportJobStatistics?

    public init(errors: [KnowledgeImportJobError]?, statistics: KnowledgeImportJobStatistics?) {
        self.errors = errors
        self.statistics = statistics
    }


}




public class KnowledgeSearchDocument: Codable {





    public enum LanguageCode: String, Codable { 
        case enUs = "en-US"
        case enUk = "en-UK"
        case enAu = "en-AU"
        case enCa = "en-CA"
        case enHk = "en-HK"
        case enIn = "en-IN"
        case enIe = "en-IE"
        case enNz = "en-NZ"
        case enPh = "en-PH"
        case enSg = "en-SG"
        case enZa = "en-ZA"
        case deDe = "de-DE"
        case deAt = "de-AT"
        case deCh = "de-CH"
        case esAr = "es-AR"
        case esCo = "es-CO"
        case esMx = "es-MX"
        case esUs = "es-US"
        case esEs = "es-ES"
        case frFr = "fr-FR"
        case frBe = "fr-BE"
        case frCa = "fr-CA"
        case frCh = "fr-CH"
        case ptBr = "pt-BR"
        case ptPt = "pt-PT"
        case nlNl = "nl-NL"
        case nlBe = "nl-BE"
        case itIt = "it-IT"
        case caEs = "ca-ES"
        case trTr = "tr-TR"
        case svSe = "sv-SE"
        case fiFi = "fi-FI"
        case nbNo = "nb-NO"
        case daDk = "da-DK"
        case jaJp = "ja-JP"
        case arAe = "ar-AE"
    }

    public enum ModelType: String, Codable { 
        case faq = "Faq"
        case article = "Article"
    }



















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Language of the document */
    public var languageCode: LanguageCode?
    /** Document type */
    public var type: ModelType?
    /** FAQ document details */
    public var faq: DocumentFaq?
    /** Document creation date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Document last modification date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Document categories */
    public var categories: [KnowledgeCategory]?
    /** Knowledge base which document does belong to */
    public var knowledgeBase: KnowledgeBase?
    /** External URL to the document */
    public var externalUrl: String?
    /** Article */
    public var article: DocumentArticle?
    /** The confidence associated with a document with respect to a search query */
    public var confidence: Double?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, languageCode: LanguageCode?, type: ModelType?, faq: DocumentFaq?, dateCreated: Date?, dateModified: Date?, categories: [KnowledgeCategory]?, knowledgeBase: KnowledgeBase?, externalUrl: String?, article: DocumentArticle?, confidence: Double?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.languageCode = languageCode
        self.type = type
        self.faq = faq
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.categories = categories
        self.knowledgeBase = knowledgeBase
        self.externalUrl = externalUrl
        self.article = article
        self.confidence = confidence
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case languageCode
        case type
        case faq
        case dateCreated
        case dateModified
        case categories
        case knowledgeBase
        case externalUrl
        case article
        case confidence
        case selfUri
    }


}




public class LabelResponse: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the label. */
    public var name: String?
    /** The color of the label. */
    public var color: String?
    /** The creation date and time of the label. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The last modification date and time of the label. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Number of documents assigned to this label. */
    public var documentCount: Int?
    /** The external id associated with the label. */
    public var externalId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, color: String?, dateCreated: Date?, dateModified: Date?, documentCount: Int?, externalId: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.color = color
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.documentCount = documentCount
        self.externalId = externalId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case color
        case dateCreated
        case dateModified
        case documentCount
        case externalId
        case selfUri
    }


}




public class LabelUtilizationResponse: Codable {







    /** Defines the maximum number of interactions with this label that an agent can handle at one time. */
    public var maximumCapacity: Int?
    /** Defines other labels that can interrupt an interaction with this label. */
    public var interruptingLabelIds: [String]?
    /** Name of the label this utilization relates to. */
    public var labelName: String?

    public init(maximumCapacity: Int?, interruptingLabelIds: [String]?, labelName: String?) {
        self.maximumCapacity = maximumCapacity
        self.interruptingLabelIds = interruptingLabelIds
        self.labelName = labelName
    }


}




public class LastAttemptByColumnConditionSettings: Codable {





    public enum Operator: String, Codable { 
        case before = "Before"
        case after = "After"
    }



    /** The name of the contact column to evaluate for Email. */
    public var emailColumnName: String?
    /** The name of the contact column to evaluate for SMS. */
    public var smsColumnName: String?
    /** The operator to use when comparing values. */
    public var _operator: Operator?
    /** The period value to compare against the contact's data. */
    public var value: String?

    public init(emailColumnName: String?, smsColumnName: String?, _operator: Operator?, value: String?) {
        self.emailColumnName = emailColumnName
        self.smsColumnName = smsColumnName
        self._operator = _operator
        self.value = value
    }

    public enum CodingKeys: String, CodingKey { 
        case emailColumnName
        case smsColumnName
        case _operator = "operator"
        case value
    }


}




public class LastResultOverallConditionSettings: Codable {





    /** A list of wrapup code identifiers to match for Email. */
    public var emailWrapupCodes: [String]?
    /** A list of wrapup code identifiers to match for SMS. */
    public var smsWrapupCodes: [String]?

    public init(emailWrapupCodes: [String]?, smsWrapupCodes: [String]?) {
        self.emailWrapupCodes = emailWrapupCodes
        self.smsWrapupCodes = smsWrapupCodes
    }


}




public class LearningAssignmentAggregateQueryRequestClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "And"
        case or = "Or"
    }



    /** The logic used to combine the predicates */
    public var type: ModelType?
    /** The list of predicates used to filter the data */
    public var predicates: [LearningAssignmentAggregateQueryRequestPredicate]?

    public init(type: ModelType?, predicates: [LearningAssignmentAggregateQueryRequestPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class LearningAssignmentAggregateQueryResponseData: Codable {





    /** Specifies the range of due dates to be used for filtering. A maximum of 1 year can be specified in the range. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** The list of aggregated metrics */
    public var metrics: [LearningAssignmentAggregateQueryResponseMetric]?

    public init(interval: String?, metrics: [LearningAssignmentAggregateQueryResponseMetric]?) {
        self.interval = interval
        self.metrics = metrics
    }


}




public class LearningAssignmentBulkRemoveResponse: Codable {





    /** The learning assignments that were removed successfully */
    public var entities: [LearningAssignmentEntity]?
    /** The learning assignments that were not removed due to missing permissions */
    public var disallowedEntities: [DisallowedEntityLearningAssignmentReference]?

    public init(entities: [LearningAssignmentEntity]?, disallowedEntities: [DisallowedEntityLearningAssignmentReference]?) {
        self.entities = entities
        self.disallowedEntities = disallowedEntities
    }


}




public class LearningAssignmentEntity: Codable {



    public var assignmentId: String?

    public init(assignmentId: String?) {
        self.assignmentId = assignmentId
    }


}



/** Learning assignment step */

public class LearningAssignmentStep: Codable {







    public enum SuccessStatus: String, Codable { 
        case passed = "Passed"
        case failed = "Failed"
        case unknown = "Unknown"
    }

    public enum CompletionStatus: String, Codable { 
        case completed = "Completed"
        case incomplete = "Incomplete"
        case notAttempted = "NotAttempted"
        case unknown = "Unknown"
    }











    /** The ID of the learning assignment step */
    public var _id: String?
    /** The module step data for this step */
    public var moduleStep: LearningModuleInformStep?
    /** The structure for any SCO associated with this step */
    public var structure: [LearningAssignmentStepScoStructure]?
    /** The success status of this step */
    public var successStatus: SuccessStatus?
    /** The completion status of the assignment step */
    public var completionStatus: CompletionStatus?
    /** The completion percentage for this step */
    public var completionPercentage: Float?
    /** The percentage score for this step */
    public var percentageScore: Float?
    /** The SCO (Shareable Content Object) data */
    public var shareableContentObject: LearningShareableContentObject?
    /** The signed cookie information needed to access the content of this step (if required) */
    public var signedCookie: LearningAssignmentStepSignedCookie?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, moduleStep: LearningModuleInformStep?, structure: [LearningAssignmentStepScoStructure]?, successStatus: SuccessStatus?, completionStatus: CompletionStatus?, completionPercentage: Float?, percentageScore: Float?, shareableContentObject: LearningShareableContentObject?, signedCookie: LearningAssignmentStepSignedCookie?, selfUri: String?) {
        self._id = _id
        self.moduleStep = moduleStep
        self.structure = structure
        self.successStatus = successStatus
        self.completionStatus = completionStatus
        self.completionPercentage = completionPercentage
        self.percentageScore = percentageScore
        self.shareableContentObject = shareableContentObject
        self.signedCookie = signedCookie
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case moduleStep
        case structure
        case successStatus
        case completionStatus
        case completionPercentage
        case percentageScore
        case shareableContentObject
        case signedCookie
        case selfUri
    }


}




public class LearningAssignmentStepScoStructure: Codable {





    public enum SuccessStatus: String, Codable { 
        case passed = "Passed"
        case failed = "Failed"
        case unknown = "Unknown"
    }

    public enum CompletionStatus: String, Codable { 
        case completed = "Completed"
        case incomplete = "Incomplete"
        case notAttempted = "NotAttempted"
        case unknown = "Unknown"
    }



    /** The id of this SCO in the course manifest */
    public var _id: String?
    /** The name of this SCO in the course manifest */
    public var name: String?
    /** The success status of this SCO */
    public var successStatus: SuccessStatus?
    /** The completion status of this SCO */
    public var completionStatus: CompletionStatus?
    /** Child items belonging to this SCO in the course manifest */
    public var children: [LearningAssignmentStepScoStructure]?

    public init(_id: String?, name: String?, successStatus: SuccessStatus?, completionStatus: CompletionStatus?, children: [LearningAssignmentStepScoStructure]?) {
        self._id = _id
        self.name = name
        self.successStatus = successStatus
        self.completionStatus = completionStatus
        self.children = children
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case successStatus
        case completionStatus
        case children
    }


}




public class LearningAssignmentTopicLearningModuleReference: Codable {





    public var _id: String?
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class LearningAssignmentTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class LearningAssignmentsDomainEntity: Codable {





















    public var entities: [LearningAssignment]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [LearningAssignment]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class LearningCoverArtUploadUrlRequest: Codable {







    public enum ContentType: String, Codable { 
        case imageBmp = "image/bmp"
        case imageGif = "image/gif"
        case imageJpeg = "image/jpeg"
        case imageJpg = "image/jpg"
        case imagePng = "image/png"
    }

    public enum ServerSideEncryption: String, Codable { 
        case aes256 = "AES256"
    }

    /** Name of the file to upload. It must not start with a dot and not end with a forward slash. Whitespace and the following characters are not allowed: \\{^}%`]\">[~<#| */
    public var fileName: String?
    /** Content MD5 of the file to upload */
    public var contentMd5: String?
    /** The number of seconds the presigned URL is valid for (from 1 to 604800 seconds). If none provided, defaults to 600 seconds */
    public var signedUrlTimeoutSeconds: Int?
    /** The content type of the file to upload. */
    public var contentType: ContentType?
    public var serverSideEncryption: ServerSideEncryption?

    public init(fileName: String?, contentMd5: String?, signedUrlTimeoutSeconds: Int?, contentType: ContentType?, serverSideEncryption: ServerSideEncryption?) {
        self.fileName = fileName
        self.contentMd5 = contentMd5
        self.signedUrlTimeoutSeconds = signedUrlTimeoutSeconds
        self.contentType = contentType
        self.serverSideEncryption = serverSideEncryption
    }


}



/** Learning module publish request */

public class LearningModulePublishRequest: Codable {



    /** Whether the terms and conditions were accepted */
    public var termsAndConditionsAccepted: Bool?

    public init(termsAndConditionsAccepted: Bool?) {
        self.termsAndConditionsAccepted = termsAndConditionsAccepted
    }


}




public class LearningModulesDomainEntityListing: Codable {





















    public var entities: [LearningModule]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [LearningModule]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class LearningSlotScheduleActivity: Codable {















    public enum ExternalActivityType: String, Codable { 
        case activityPlan = "ActivityPlan"
        case coaching = "Coaching"
        case learning = "Learning"
    }

    /** The start date/time of this activity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?
    /** The length of this activity in minutes */
    public var lengthMinutes: Int?
    /** The description of this activity */
    public var _description: String?
    /** The ID of the activity code associated with this activity */
    public var activityCodeId: String?
    /** Whether this activity is paid */
    public var paid: Bool?
    /** The ID of the time off request associated with this activity, if applicable */
    public var timeOffRequestId: String?
    /** The ID of the external activity associated with this activity, if applicable */
    public var externalActivityId: String?
    /** The type of the external activity associated with this activity, if applicable */
    public var externalActivityType: ExternalActivityType?

    public init(dateStart: Date?, lengthMinutes: Int?, _description: String?, activityCodeId: String?, paid: Bool?, timeOffRequestId: String?, externalActivityId: String?, externalActivityType: ExternalActivityType?) {
        self.dateStart = dateStart
        self.lengthMinutes = lengthMinutes
        self._description = _description
        self.activityCodeId = activityCodeId
        self.paid = paid
        self.timeOffRequestId = timeOffRequestId
        self.externalActivityId = externalActivityId
        self.externalActivityType = externalActivityType
    }

    public enum CodingKeys: String, CodingKey { 
        case dateStart
        case lengthMinutes
        case _description = "description"
        case activityCodeId
        case paid
        case timeOffRequestId
        case externalActivityId
        case externalActivityType
    }


}




public class LexBotAliasEntityListing: Codable {





















    public var entities: [LexBotAlias]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [LexBotAlias]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class LexBotEntityListing: Codable {





















    public var entities: [LexBot]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [LexBot]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class LibraryEntityListing: Codable {





















    public var entities: [Library]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Library]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class LicenseUpdateStatus: Codable {







    public var userId: String?
    public var licenseId: String?
    public var result: String?

    public init(userId: String?, licenseId: String?, result: String?) {
        self.userId = userId
        self.licenseId = licenseId
        self.result = result
    }


}




public class LicenseUser: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var licenses: [LicenseDefinition]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, licenses: [LicenseDefinition]?, selfUri: String?) {
        self._id = _id
        self.licenses = licenses
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case licenses
        case selfUri
    }


}




public class Line: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }

























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    public var properties: [String:JSON]?
    /** The edge group associated with the line. (Deprecated) */
    public var edgeGroup: DomainEntityRef?
    public var template: DomainEntityRef?
    public var site: DomainEntityRef?
    public var lineBaseSettings: DomainEntityRef?
    /** The primary edge associated to the line. (Deprecated) */
    public var primaryEdge: Edge?
    /** The secondary edge associated to the line. (Deprecated) */
    public var secondaryEdge: Edge?
    public var loggedInUser: DomainEntityRef?
    public var defaultForUser: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, properties: [String:JSON]?, edgeGroup: DomainEntityRef?, template: DomainEntityRef?, site: DomainEntityRef?, lineBaseSettings: DomainEntityRef?, primaryEdge: Edge?, secondaryEdge: Edge?, loggedInUser: DomainEntityRef?, defaultForUser: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.properties = properties
        self.edgeGroup = edgeGroup
        self.template = template
        self.site = site
        self.lineBaseSettings = lineBaseSettings
        self.primaryEdge = primaryEdge
        self.secondaryEdge = secondaryEdge
        self.loggedInUser = loggedInUser
        self.defaultForUser = defaultForUser
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case properties
        case edgeGroup
        case template
        case site
        case lineBaseSettings
        case primaryEdge
        case secondaryEdge
        case loggedInUser
        case defaultForUser
        case selfUri
    }


}




public class ListedDictionaryFeedback: Codable {









    public enum Source: String, Codable { 
        case manual = "Manual"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The dictionary term which needs to be added to dictionary feedback system */
    public var term: String?
    /** The dialect for the given term, dialect format is {language}-{country} where language follows ISO 639-1 standard and country follows ISO 3166-1 alpha 2 standard */
    public var dialect: String?
    /** A weighted value assigned to a phrase. The higher the value, the higher the likelihood that the system will choose the word or phrase from the possible alternatives. Boost range is from 1.0 to 10.0. Default is 2.0 */
    public var boostValue: Float?
    /** The source of the given dictionary feedback */
    public var source: Source?
    /** The Timestamp when dictionary feedback created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The Id of the user who created the dictionary feedback */
    public var createdBy: UserReference?
    /** The Timestamp when dictionary feedback modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The Id of the user who modified the dictionary feedback */
    public var modifiedBy: UserReference?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, term: String?, dialect: String?, boostValue: Float?, source: Source?, dateCreated: Date?, createdBy: UserReference?, dateModified: Date?, modifiedBy: UserReference?, selfUri: String?) {
        self._id = _id
        self.term = term
        self.dialect = dialect
        self.boostValue = boostValue
        self.source = source
        self.dateCreated = dateCreated
        self.createdBy = createdBy
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case term
        case dialect
        case boostValue
        case source
        case dateCreated
        case createdBy
        case dateModified
        case modifiedBy
        case selfUri
    }


}




public class LocationEntityListing: Codable {





















    public var entities: [LocationDefinition]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [LocationDefinition]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class LocationSearchCriteria: Codable {









    public enum Operator: String, Codable { 
        case and = "AND"
        case or = "OR"
        case not = "NOT"
    }





    public enum ModelType: String, Codable { 
        case exact = "EXACT"
        case startsWith = "STARTS_WITH"
        case contains = "CONTAINS"
        case regex = "REGEX"
        case term = "TERM"
        case terms = "TERMS"
        case requiredFields = "REQUIRED_FIELDS"
        case matchAll = "MATCH_ALL"
    }



    /** The end value of the range. This field is used for range search types. */
    public var endValue: String?
    /** A list of values for the search to match against */
    public var values: [String]?
    /** The start value of the range. This field is used for range search types. */
    public var startValue: String?
    /** A value for the search to match against */
    public var value: String?
    /** How to apply this search criteria against other criteria */
    public var _operator: Operator?
    /** Groups multiple conditions */
    public var group: [LocationSearchCriteria]?
    /** Set date format for criteria values when using date range search type.  Supports Java date format syntax, example yyyy-MM-dd'T'HH:mm:ss.SSSX. */
    public var dateFormat: String?
    /** Search Type */
    public var type: ModelType?
    /** Field names to search against */
    public var fields: [String]?

    public init(endValue: String?, values: [String]?, startValue: String?, value: String?, _operator: Operator?, group: [LocationSearchCriteria]?, dateFormat: String?, type: ModelType?, fields: [String]?) {
        self.endValue = endValue
        self.values = values
        self.startValue = startValue
        self.value = value
        self._operator = _operator
        self.group = group
        self.dateFormat = dateFormat
        self.type = type
        self.fields = fields
    }

    public enum CodingKeys: String, CodingKey { 
        case endValue
        case values
        case startValue
        case value
        case _operator = "operator"
        case group
        case dateFormat
        case type
        case fields
    }


}




public class LogCaptureUserConfiguration: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Indicates when log capture will be turned off for the user. (Must be within 24 hours). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateExpired: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, dateExpired: Date?, selfUri: String?) {
        self._id = _id
        self.dateExpired = dateExpired
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case dateExpired
        case selfUri
    }


}




public class LongTermForecastPlanningGroupData: Codable {







    /** The ID of the planning group to which this data applies. Note this is a snapshot of the planning group at the time of forecast creation and may not correspond to the current configuration */
    public var planningGroupId: String?
    /** Forecast offered counts per day for this planning group */
    public var offeredPerDay: [Double]?
    /** Forecast average handle time per day in seconds */
    public var averageHandleTimeSecondsPerDay: [Double]?

    public init(planningGroupId: String?, offeredPerDay: [Double]?, averageHandleTimeSecondsPerDay: [Double]?) {
        self.planningGroupId = planningGroupId
        self.offeredPerDay = offeredPerDay
        self.averageHandleTimeSecondsPerDay = averageHandleTimeSecondsPerDay
    }


}




public class LongTermForecastResultResponse: Codable {





    /** The result of the operation.  Populated whenever the result is small enough to pass through the api directly */
    public var result: LongTermForecastResult?
    /** The download url to fetch the result.  Only populated if the result is too large to pass through the api directly */
    public var downloadUrl: String?

    public init(result: LongTermForecastResult?, downloadUrl: String?) {
        self.result = result
        self.downloadUrl = downloadUrl
    }


}




public class ManagementUnit: Codable {







    public enum StartDayOfWeek: String, Codable { 
        case sunday = "Sunday"
        case monday = "Monday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
        case thursday = "Thursday"
        case friday = "Friday"
        case saturday = "Saturday"
    }

















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The business unit to which this management unit belongs */
    public var businessUnit: BusinessUnitReference?
    /** Start day of week for scheduling and forecasting purposes. Moving to Business Unit */
    public var startDayOfWeek: StartDayOfWeek?
    /** The time zone for the management unit in standard Olson format.  Moving to Business Unit */
    public var timeZone: String?
    /** The configuration settings for this management unit */
    public var settings: ManagementUnitSettingsResponse?
    /** Version info metadata for this management unit. Deprecated, use settings.metadata */
    public var metadata: WfmVersionedEntityMetadata?
    /** The division to which this entity belongs. */
    public var division: DivisionReference?
    /** The user who last modified this entity.  Deprecated, use field from settings.metadata instead */
    public var modifiedBy: UserReference?
    /** The version of the underlying entity.  Deprecated, use field from settings.metadata instead */
    public var version: Int?
    /** The date and time at which this entity was last modified.  Deprecated, use field from settings.metadata instead. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, businessUnit: BusinessUnitReference?, startDayOfWeek: StartDayOfWeek?, timeZone: String?, settings: ManagementUnitSettingsResponse?, metadata: WfmVersionedEntityMetadata?, division: DivisionReference?, modifiedBy: UserReference?, version: Int?, dateModified: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.businessUnit = businessUnit
        self.startDayOfWeek = startDayOfWeek
        self.timeZone = timeZone
        self.settings = settings
        self.metadata = metadata
        self.division = division
        self.modifiedBy = modifiedBy
        self.version = version
        self.dateModified = dateModified
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case businessUnit
        case startDayOfWeek
        case timeZone
        case settings
        case metadata
        case division
        case modifiedBy
        case version
        case dateModified
        case selfUri
    }


}




public class ManagementUnitListing: Codable {





















    public var entities: [ManagementUnit]?
    /** Deprecated, paging is not supported */
    public var pageSize: Int?
    /** Deprecated, paging is not supported */
    public var pageNumber: Int?
    /** Deprecated, paging is not supported */
    public var total: Int64?
    /** Deprecated, paging is not supported */
    public var firstUri: String?
    /** Deprecated, paging is not supported */
    public var nextUri: String?
    /** Deprecated, paging is not supported */
    public var pageCount: Int?
    /** Deprecated, paging is not supported */
    public var previousUri: String?
    /** Deprecated, paging is not supported */
    public var lastUri: String?
    public var selfUri: String?

    public init(entities: [ManagementUnit]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, pageCount: Int?, previousUri: String?, lastUri: String?, selfUri: String?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.pageCount = pageCount
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
    }


}



/** Defines a simple matching condition */

public class MatchCriteria: Codable {



    public enum Operator: String, Codable { 
        case greaterThanOrEqual = "GreaterThanOrEqual"
        case lessThanOrEqual = "LessThanOrEqual"
        case equal = "Equal"
        case notEqual = "NotEqual"
        case lessThan = "LessThan"
        case greaterThan = "GreaterThan"
        case notIn = "NotIn"
        case _in = "In"
        case contains = "Contains"
        case all = "All"
        case exists = "Exists"
        case size = "Size"
    }





    /** The Goessner json path of the field to match */
    public var jsonPath: String?
    /** The type of operation to perform for matching check */
    public var _operator: Operator?
    /** The value to match on. Only one of value and values can be included */
    public var value: JSON?
    /** The list of values to match on. Only one of value and values can be included */
    public var values: [JSON]?

    public init(jsonPath: String?, _operator: Operator?, value: JSON?, values: [JSON]?) {
        self.jsonPath = jsonPath
        self._operator = _operator
        self.value = value
        self.values = values
    }

    public enum CodingKeys: String, CodingKey { 
        case jsonPath
        case _operator = "operator"
        case value
        case values
    }


}



/** Results of a matching expression */

public class MatchCriteriaTestResult: Codable {



    public enum Operator: String, Codable { 
        case greaterThanOrEqual = "GreaterThanOrEqual"
        case lessThanOrEqual = "LessThanOrEqual"
        case equal = "Equal"
        case notEqual = "NotEqual"
        case lessThan = "LessThan"
        case greaterThan = "GreaterThan"
        case notIn = "NotIn"
        case _in = "In"
        case contains = "Contains"
        case all = "All"
        case exists = "Exists"
        case size = "Size"
    }











    /** The Goessner json path of the field to match */
    public var jsonPath: String?
    /** The type of operation to perform for matching check */
    public var _operator: Operator?
    /** The value to match on. Only one of value and values can be included */
    public var value: JSON?
    /** The list of values to match on. Only one of value and values can be included */
    public var values: [JSON]?
    /** The generated json path condition */
    public var generatedJsonPathCondition: String?
    /** Did the generated json path condition match */
    public var match: Bool?
    /** The json paths and their values that were compared */
    public var jsonPathExtraction: [MatchTestResult]?

    public init(jsonPath: String?, _operator: Operator?, value: JSON?, values: [JSON]?, generatedJsonPathCondition: String?, match: Bool?, jsonPathExtraction: [MatchTestResult]?) {
        self.jsonPath = jsonPath
        self._operator = _operator
        self.value = value
        self.values = values
        self.generatedJsonPathCondition = generatedJsonPathCondition
        self.match = match
        self.jsonPathExtraction = jsonPathExtraction
    }

    public enum CodingKeys: String, CodingKey { 
        case jsonPath
        case _operator = "operator"
        case value
        case values
        case generatedJsonPathCondition
        case match
        case jsonPathExtraction
    }


}




public class MediaRegions: Codable {







    /** The AWS region your organization is in. */
    public var awsHomeRegion: String?
    /** The list of AWS regions to which Genesys Cloud is deployed with full functionality including media streaming. */
    public var awsCoreRegions: [String]?
    /** The list of AWS regions that Genesys Cloud uses only for media streaming. */
    public var awsSatelliteRegions: [String]?

    public init(awsHomeRegion: String?, awsCoreRegions: [String]?, awsSatelliteRegions: [String]?) {
        self.awsHomeRegion = awsHomeRegion
        self.awsCoreRegions = awsCoreRegions
        self.awsSatelliteRegions = awsSatelliteRegions
    }


}




public class MediaTranscription: Codable {



    public enum TranscriptionProvider: String, Codable { 
        case voci = "VOCI"
        case calljourney = "CALLJOURNEY"
    }



    public var displayName: String?
    public var transcriptionProvider: TranscriptionProvider?
    public var integrationId: String?

    public init(displayName: String?, transcriptionProvider: TranscriptionProvider?, integrationId: String?) {
        self.displayName = displayName
        self.transcriptionProvider = transcriptionProvider
        self.integrationId = integrationId
    }


}



/** Media type access definitions */

public class MediaTypeAccess: Codable {





    /** List of media types allowed for inbound messages from customers. If inbound messages from a customer contain media that is not in this list, the media will be dropped from the outbound message. */
    public var inbound: [MediaType]?
    /** List of media types allowed for outbound messages to customers. If an outbound message is sent that contains media that is not in this list, the message will not be sent. */
    public var outbound: [MediaType]?

    public init(inbound: [MediaType]?, outbound: [MediaType]?) {
        self.inbound = inbound
        self.outbound = outbound
    }


}




public class MemberEntity: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class MessageData: Codable {













    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum MessengerType: String, Codable { 
        case sms = "sms"
        case facebook = "facebook"
        case twitter = "twitter"
        case line = "line"
        case whatsapp = "whatsapp"
        case webmessaging = "webmessaging"
        case instagram = "instagram"
        case _open = "open"
    }



    public enum Status: String, Codable { 
        case queued = "queued"
        case sent = "sent"
        case failed = "failed"
        case received = "received"
        case deliverySuccess = "delivery-success"
        case deliveryFailed = "delivery-failed"
        case read = "read"
        case removed = "removed"
    }















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The unique identifier of the message from provider */
    public var providerMessageId: String?
    /** The time when the message was received or sent. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var timestamp: Date?
    /** The sender of the text message. */
    public var fromAddress: String?
    /** The recipient of the text message. */
    public var toAddress: String?
    /** The direction of the message. */
    public var direction: Direction?
    /** Type of text messenger. */
    public var messengerType: MessengerType?
    /** The body of the text message. (Deprecated - Instead use normalizedMessage.text) */
    public var textBody: String?
    /** The status of the message. */
    public var status: Status?
    /** The media details associated to a message. (Deprecated - Instead use normalizedMessage.content[index].attachment) */
    public var media: [MessageMedia]?
    /** The sticker details associated to a message. (Deprecated - Instead use normalizedMessage.content[index].attachment */
    public var stickers: [MessageSticker]?
    /** The message into normalized format */
    public var normalizedMessage: ConversationNormalizedMessage?
    /** The delivery event associated with this message in normalized format, if the message direction was outbound */
    public var normalizedReceipts: [ConversationNormalizedMessage]?
    /** User who sent this message. */
    public var createdBy: User?
    /** The id of the conversation of this message. */
    public var conversationId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, providerMessageId: String?, timestamp: Date?, fromAddress: String?, toAddress: String?, direction: Direction?, messengerType: MessengerType?, textBody: String?, status: Status?, media: [MessageMedia]?, stickers: [MessageSticker]?, normalizedMessage: ConversationNormalizedMessage?, normalizedReceipts: [ConversationNormalizedMessage]?, createdBy: User?, conversationId: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.providerMessageId = providerMessageId
        self.timestamp = timestamp
        self.fromAddress = fromAddress
        self.toAddress = toAddress
        self.direction = direction
        self.messengerType = messengerType
        self.textBody = textBody
        self.status = status
        self.media = media
        self.stickers = stickers
        self.normalizedMessage = normalizedMessage
        self.normalizedReceipts = normalizedReceipts
        self.createdBy = createdBy
        self.conversationId = conversationId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case providerMessageId
        case timestamp
        case fromAddress
        case toAddress
        case direction
        case messengerType
        case textBody
        case status
        case media
        case stickers
        case normalizedMessage
        case normalizedReceipts
        case createdBy
        case conversationId
        case selfUri
    }


}




public class MessageEvaluation: Codable {





    public enum MessageType: String, Codable { 
        case sms = "Sms"
        case email = "Email"
    }





    /** The name of the contact column that was wrapped up */
    public var contactColumn: String?
    /** The address (phone or email) that was wrapped up */
    public var contactAddress: String?
    /** The type of message sent */
    public var messageType: MessageType?
    /** The id of the wrap-up code */
    public var wrapupCodeId: String?
    /** The time that the wrap-up was applied. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var timestamp: Date?

    public init(contactColumn: String?, contactAddress: String?, messageType: MessageType?, wrapupCodeId: String?, timestamp: Date?) {
        self.contactColumn = contactColumn
        self.contactAddress = contactAddress
        self.messageType = messageType
        self.wrapupCodeId = wrapupCodeId
        self.timestamp = timestamp
    }


}




public class MessageMediaAttachment: Codable {



    public enum MediaType: String, Codable { 
        case imagePng = "image/png"
        case imageJpeg = "image/jpeg"
        case imageGif = "image/gif"
    }







    /** The location of the media, useful for retrieving it */
    public var url: String?
    /** The optional internet media type of the the media object.If null then the media type should be dictated by the url. */
    public var mediaType: MediaType?
    /** The optional content length of the the media object, in bytes. */
    public var contentLength: Int64?
    /** The name of the media object. */
    public var name: String?
    /** A globally unique identifier for the media object. */
    public var _id: String?

    public init(url: String?, mediaType: MediaType?, contentLength: Int64?, name: String?, _id: String?) {
        self.url = url
        self.mediaType = mediaType
        self.contentLength = contentLength
        self.name = name
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case url
        case mediaType
        case contentLength
        case name
        case _id = "id"
    }


}




public class MessageMediaData: Codable {













    public enum Status: String, Codable { 
        case uploading = "uploading"
        case valid = "valid"
        case invalid = "invalid"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The location of the media, useful for retrieving it */
    public var url: String?
    /** The detected internet media type of the the media object.  If null then the media type should be dictated by the url. */
    public var mediaType: String?
    /** The optional content length of the the media object, in bytes. */
    public var contentLengthBytes: Int?
    /** The URL returned to upload an attachment */
    public var uploadUrl: String?
    /** The status of the media, indicates if the media is in the process of uploading. If the upload fails, the media becomes invalid */
    public var status: Status?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, url: String?, mediaType: String?, contentLengthBytes: Int?, uploadUrl: String?, status: Status?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.url = url
        self.mediaType = mediaType
        self.contentLengthBytes = contentLengthBytes
        self.uploadUrl = uploadUrl
        self.status = status
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case url
        case mediaType
        case contentLengthBytes
        case uploadUrl
        case status
        case selfUri
    }


}




public class MessageStickerAttachment: Codable {





    /** The location of the media, useful for retrieving it */
    public var url: String?
    /** A globally unique identifier for the media object. */
    public var _id: String?

    public init(url: String?, _id: String?) {
        self.url = url
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case url
        case _id = "id"
    }


}




public class MessagingCommunicationDispositionAppliedEvent: Codable {















    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication */
    public var communicationId: String?
    /** The wrapup-code (V4 UUID) used to disposition this interaction. If this value is not provided the disposition is considered skipped. */
    public var code: String?
    /** Text entered by the agent to describe the interaction or disposition. Ignored if the disposition is considered skipped. */
    public var notes: String?
    /** The list of tags selected by the agent to describe the interaction or disposition. Ignored if the disposition is considered skipped. */
    public var tags: [String]?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, code: String?, notes: String?, tags: [String]?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.code = code
        self.notes = notes
        self.tags = tags
    }


}




public class MessagingHoldUpdatedEvent: Codable {











    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication */
    public var communicationId: String?
    /** Indicates whether this communication is held. */
    public var held: Bool?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, held: Bool?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.held = held
    }


}




public class MessagingIntegration: Codable {









    public enum Status: String, Codable { 
        case active = "Active"
        case inactive = "Inactive"
        case error = "Error"
        case starting = "Starting"
        case incomplete = "Incomplete"
        case deleting = "Deleting"
        case deletionFailed = "DeletionFailed"
    }

    public enum MessengerType: String, Codable { 
        case sms = "sms"
        case facebook = "facebook"
        case twitter = "twitter"
        case line = "line"
        case whatsapp = "whatsapp"
        case webmessaging = "webmessaging"
        case instagram = "instagram"
        case _open = "open"
    }















    /** A unique Integration Id */
    public var _id: String?
    /** The name of the Integration */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    public var messagingSetting: MessagingSettingReference?
    /** The status of the Integration */
    public var status: Status?
    /** The type of Messaging Integration */
    public var messengerType: MessengerType?
    /** The recipient associated to the Integration. This recipient is used to associate a flow to an integration */
    public var recipient: DomainEntityRef?
    /** Date this Integration was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date this Integration was modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** User reference that created this Integration */
    public var createdBy: DomainEntityRef?
    /** User reference that last modified this Integration */
    public var modifiedBy: DomainEntityRef?
    /** Version number required for updates. */
    public var version: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingReference?, status: Status?, messengerType: MessengerType?, recipient: DomainEntityRef?, dateCreated: Date?, dateModified: Date?, createdBy: DomainEntityRef?, modifiedBy: DomainEntityRef?, version: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.status = status
        self.messengerType = messengerType
        self.recipient = recipient
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.version = version
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case status
        case messengerType
        case recipient
        case dateCreated
        case dateModified
        case createdBy
        case modifiedBy
        case version
        case selfUri
    }


}



/** Information about the recipient the message is sent to or received from. */

public class MessagingRecipient: Codable {





    public enum IdType: String, Codable { 
        case email = "Email"
        case phone = "Phone"
        case opaque = "Opaque"
    }











    /** Nickname or display name of the recipient. */
    public var nickname: String?
    /** The recipient ID specific to the provider. */
    public var _id: String?
    /** The recipient ID type. This is used to indicate the format used for the ID. */
    public var idType: IdType?
    /** URL of an image that represents the recipient. */
    public var image: String?
    /** First name of the recipient. */
    public var firstName: String?
    /** Last name of the recipient. */
    public var lastName: String?
    /** E-mail address of the recipient. */
    public var email: String?
    /** List of recipient additional identifiers */
    public var additionalIds: [RecipientAdditionalIdentifier]?

    public init(nickname: String?, _id: String?, idType: IdType?, image: String?, firstName: String?, lastName: String?, email: String?, additionalIds: [RecipientAdditionalIdentifier]?) {
        self.nickname = nickname
        self._id = _id
        self.idType = idType
        self.image = image
        self.firstName = firstName
        self.lastName = lastName
        self.email = email
        self.additionalIds = additionalIds
    }

    public enum CodingKeys: String, CodingKey { 
        case nickname
        case _id = "id"
        case idType
        case image
        case firstName
        case lastName
        case email
        case additionalIds
    }


}




public class MessagingRoutingEstablishedEvent: Codable {





















    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication. */
    public var communicationId: String?
    /** The id of the queue that is routing this conversation. */
    public var queueId: String?
    /** The unique identifiers for the skills that should be used to determine the destination for the conversation. */
    public var skillIds: [String]?
    /** The unique identifier for the language that should be used to determine the destination for the conversation. */
    public var languageId: String?
    /** An optional label that categorizes the conversation. Max-utilization settings can be configured at a per-label level. */
    public var label: String?
    /** Metadata about this communication. */
    public var initialConfiguration: MessagingInitialConfiguration?
    /** Metadata about the source of this communication's interaction. */
    public var sourceConfiguration: SourceConfiguration?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, queueId: String?, skillIds: [String]?, languageId: String?, label: String?, initialConfiguration: MessagingInitialConfiguration?, sourceConfiguration: SourceConfiguration?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.queueId = queueId
        self.skillIds = skillIds
        self.languageId = languageId
        self.label = label
        self.initialConfiguration = initialConfiguration
        self.sourceConfiguration = sourceConfiguration
    }


}




public class MessagingUserTransferEvent: Codable {







    public enum TransferType: String, Codable { 
        case attended = "Attended"
        case unattended = "Unattended"
    }











    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** Indicates the desired type of transfer. */
    public var transferType: TransferType?
    /** The id (V4 UUID) used by the external platform to refer to the transfer in subsequent Transfer events. */
    public var commandId: String?
    /** The id (V4 UUID) of the communication representing the participant that is initiating the transfer. */
    public var initiatingCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred away from. In many cases this will be the same as the `initiatingCommunicationId`. */
    public var targetCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred. */
    public var objectCommunicationId: String?
    /** The id (V4 UUID) of the desired destination user that the object communication should be transferred to. */
    public var destinationUserId: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, transferType: TransferType?, commandId: String?, initiatingCommunicationId: String?, targetCommunicationId: String?, objectCommunicationId: String?, destinationUserId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.transferType = transferType
        self.commandId = commandId
        self.initiatingCommunicationId = initiatingCommunicationId
        self.targetCommunicationId = targetCommunicationId
        self.objectCommunicationId = objectCommunicationId
        self.destinationUserId = destinationUserId
    }


}




public class Metabase: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }





    public enum ModelType: String, Codable { 
        case external = "EXTERNAL"
        case externalPcv = "EXTERNAL_PCV"
        case externalPcvAws = "EXTERNAL_PCV_AWS"
        case externalByocCarrier = "EXTERNAL_BYOC_CARRIER"
        case externalByocPbx = "EXTERNAL_BYOC_PBX"
        case stationCdm = "STATION_CDM"
        case stationCdmWebrtc = "STATION_CDM_WEBRTC"
        case station = "STATION"
        case tie = "TIE"
        case tieDirect = "TIE_DIRECT"
        case tieIndirect = "TIE_INDIRECT"
        case tieCloudProxy = "TIE_CLOUD_PROXY"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    public var type: ModelType?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, type: ModelType?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.type = type
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case type
        case selfUri
    }


}



/** A representation of data fields to be gathered for installing the accelerator */

public class MetadataPresentation: Codable {





    /** title for a set of data to be gathered */
    public var title: String?
    /** description of the contents of the data gathering interface */
    public var schema: MetadataSchema?

    public init(title: String?, schema: MetadataSchema?) {
        self.title = title
        self.schema = schema
    }


}



/** A Genesys Cloud resource created or modified as a result of running an accelerator */

public class MetadataResultEntity: Codable {





    public enum Visibility: String, Codable { 
        case visible = "Visible"
        case hidden = "Hidden"
    }

    /** object type of the modified resource */
    public var type: String?
    /** description of the modified resource */
    public var _description: String?
    /** whether the modified resource is visible or hidden */
    public var visibility: Visibility?

    public init(type: String?, _description: String?, visibility: Visibility?) {
        self.type = type
        self._description = _description
        self.visibility = visibility
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case _description = "description"
        case visibility
    }


}




public class MeteredEvaluationAssignment: Codable {













    public var evaluationContextId: String?
    public var evaluators: [User]?
    public var maxNumberEvaluations: Int?
    public var evaluationForm: EvaluationForm?
    public var assignToActiveUser: Bool?
    public var timeInterval: TimeInterval?

    public init(evaluationContextId: String?, evaluators: [User]?, maxNumberEvaluations: Int?, evaluationForm: EvaluationForm?, assignToActiveUser: Bool?, timeInterval: TimeInterval?) {
        self.evaluationContextId = evaluationContextId
        self.evaluators = evaluators
        self.maxNumberEvaluations = maxNumberEvaluations
        self.evaluationForm = evaluationForm
        self.assignToActiveUser = assignToActiveUser
        self.timeInterval = timeInterval
    }


}




public class Metric: Codable {





















    public enum TimeDisplayUnit: String, Codable { 
        case _none = "None"
        case seconds = "Seconds"
        case minutes = "Minutes"
        case hours = "Hours"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of this metric */
    public var name: String?
    /** The id of associated metric definition */
    public var metricDefinitionId: String?
    /** The id of associated external metric definition */
    public var externalMetricDefinitionId: String?
    /** Associated objective for this metric */
    public var objective: Objective?
    /** Performance profile id of this metric */
    public var performanceProfileId: String?
    /** The linked metric entity reference */
    public var linkedMetric: AddressableEntityRef?
    /** The created date of this metric. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The unlinked workday for this metric if this metric was ever unlinked. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateUnlinked: Date?
    /** The precision of the metric, must be between 0 and 5 */
    public var precision: Int?
    /** The time unit in which the metric should be displayed -- this parameter is ignored when displaying non-time values */
    public var timeDisplayUnit: TimeDisplayUnit?
    /** The source performance profile when this metric is linked */
    public var sourcePerformanceProfile: PerformanceProfile?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, metricDefinitionId: String?, externalMetricDefinitionId: String?, objective: Objective?, performanceProfileId: String?, linkedMetric: AddressableEntityRef?, dateCreated: Date?, dateUnlinked: Date?, precision: Int?, timeDisplayUnit: TimeDisplayUnit?, sourcePerformanceProfile: PerformanceProfile?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.metricDefinitionId = metricDefinitionId
        self.externalMetricDefinitionId = externalMetricDefinitionId
        self.objective = objective
        self.performanceProfileId = performanceProfileId
        self.linkedMetric = linkedMetric
        self.dateCreated = dateCreated
        self.dateUnlinked = dateUnlinked
        self.precision = precision
        self.timeDisplayUnit = timeDisplayUnit
        self.sourcePerformanceProfile = sourcePerformanceProfile
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case metricDefinitionId
        case externalMetricDefinitionId
        case objective
        case performanceProfileId
        case linkedMetric
        case dateCreated
        case dateUnlinked
        case precision
        case timeDisplayUnit
        case sourcePerformanceProfile
        case selfUri
    }


}




public class Metrics: Codable {













    public enum UnitType: String, Codable { 
        case _none = "None"
        case percent = "Percent"
        case currency = "Currency"
        case seconds = "Seconds"
        case number = "Number"
        case attendanceStatus = "AttendanceStatus"
        case unit = "Unit"
    }





















    public enum TimeDisplayUnit: String, Codable { 
        case _none = "None"
        case seconds = "Seconds"
        case minutes = "Minutes"
        case hours = "Hours"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The order of metric within a performance profile */
    public var order: Int?
    /** The name of associated metric definition */
    public var metricDefinitionName: String?
    /** The id of associated metric definition */
    public var metricDefinitionId: String?
    /** The id of associated external metric definition */
    public var externalMetricDefinitionId: String?
    /** Corresponding unit type for this metric */
    public var unitType: UnitType?
    /** A flag for whether this metric is enabled for a performance profile */
    public var enabled: Bool?
    /** The name of associated objective template */
    public var templateName: String?
    /** Achievable maximum points for this metric */
    public var maxPoints: Int?
    /** Performance profile id of this metric */
    public var performanceProfileId: String?
    /** The linked metric entity reference */
    public var linkedMetric: AddressableEntityRef?
    /** The created date of this metric. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The unlinked workday for this metric if this metric was ever unlinked. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateUnlinked: Date?
    /** The source performance profile when this metric is linked */
    public var sourcePerformanceProfile: PerformanceProfile?
    /** Unit definition of linked external metric */
    public var unitDefinition: String?
    /** Precision of linked external metric */
    public var precision: Int?
    /** The time unit in which the metric should be displayed -- this parameter is ignored when displaying non-time values */
    public var timeDisplayUnit: TimeDisplayUnit?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, order: Int?, metricDefinitionName: String?, metricDefinitionId: String?, externalMetricDefinitionId: String?, unitType: UnitType?, enabled: Bool?, templateName: String?, maxPoints: Int?, performanceProfileId: String?, linkedMetric: AddressableEntityRef?, dateCreated: Date?, dateUnlinked: Date?, sourcePerformanceProfile: PerformanceProfile?, unitDefinition: String?, precision: Int?, timeDisplayUnit: TimeDisplayUnit?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.order = order
        self.metricDefinitionName = metricDefinitionName
        self.metricDefinitionId = metricDefinitionId
        self.externalMetricDefinitionId = externalMetricDefinitionId
        self.unitType = unitType
        self.enabled = enabled
        self.templateName = templateName
        self.maxPoints = maxPoints
        self.performanceProfileId = performanceProfileId
        self.linkedMetric = linkedMetric
        self.dateCreated = dateCreated
        self.dateUnlinked = dateUnlinked
        self.sourcePerformanceProfile = sourcePerformanceProfile
        self.unitDefinition = unitDefinition
        self.precision = precision
        self.timeDisplayUnit = timeDisplayUnit
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case order
        case metricDefinitionName
        case metricDefinitionId
        case externalMetricDefinitionId
        case unitType
        case enabled
        case templateName
        case maxPoints
        case performanceProfileId
        case linkedMetric
        case dateCreated
        case dateUnlinked
        case sourcePerformanceProfile
        case unitDefinition
        case precision
        case timeDisplayUnit
        case selfUri
    }


}




public class MinLength: Codable {





    /** A non-negative integer for a text-based schema field denoting the minimum smallest length a string field can contain for a schema instance. */
    public var min: Int64?
    /** A non-negative integer for a text-based schema field denoting the maximum smallest length string the field can contain for a schema instance. */
    public var max: Int64?

    public init(min: Int64?, max: Int64?) {
        self.min = min
        self.max = max
    }


}




public class Miner: Codable {





    public enum Language: String, Codable { 
        case enUs = "en-us"
        case enGb = "en-gb"
        case enAu = "en-au"
        case enIn = "en-in"
        case enZa = "en-za"
        case esUs = "es-us"
        case esEs = "es-es"
        case frFr = "fr-fr"
        case frCa = "fr-ca"
        case deDe = "de-de"
        case ptPt = "pt-pt"
        case ptBr = "pt-br"
    }

    public enum MinerType: String, Codable { 
        case intent = "Intent"
        case topic = "Topic"
    }



    public enum Status: String, Codable { 
        case notStarted = "NotStarted"
        case fetchingConversationIds = "FetchingConversationIds"
        case conversationIdsFetched = "ConversationIdsFetched"
        case conversationIdsFetchError = "ConversationIdsFetchError"
        case fetchingConversations = "FetchingConversations"
        case conversationsFetched = "ConversationsFetched"
        case conversationsFetchError = "ConversationsFetchError"
        case queued = "Queued"
        case queuingError = "QueuingError"
        case miningStarted = "MiningStarted"
        case maskingUtterances = "MaskingUtterances"
        case maskingError = "MaskingError"
        case computingAnalytics = "ComputingAnalytics"
        case computingAnalyticsError = "ComputingAnalyticsError"
        case miningCompleted = "MiningCompleted"
        case miningError = "MiningError"
        case modelValidationError = "ModelValidationError"
        case deleted = "Deleted"
    }















    public enum MediaType: String, Codable { 
        case chat = "Chat"
        case call = "Call"
        case message = "Message"
        case email = "Email"
    }

    public enum ParticipantType: String, Codable { 
        case customer = "Customer"
        case agent = "Agent"
        case both = "Both"
    }

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Chat Corpus Name. */
    public var name: String?
    /** Language Localization code. */
    public var language: Language?
    /** Type of the miner, intent or topic. */
    public var minerType: MinerType?
    /** Date when the miner was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Status of the miner. */
    public var status: Status?
    /** Date from which the conversations need to be taken for mining. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var conversationsDateRangeStart: Date?
    /** Date till which the conversations need to be taken for mining. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var conversationsDateRangeEnd: Date?
    /** Date when the mining process was completed. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCompleted: Date?
    /** Mining message if present. */
    public var message: String?
    /** Error Information */
    public var errorInfo: MinerErrorInfo?
    /** Warning Information */
    public var warningInfo: MinerErrorInfo?
    /** Flag to indicate whether data file to be mined was uploaded. */
    public var conversationDataUploaded: Bool?
    /** Media type for filtering conversations. */
    public var mediaType: MediaType?
    /** Type of the participant, either agent, customer or both. */
    public var participantType: ParticipantType?
    /** List of queue IDs for filtering conversations. */
    public var queueIds: [String]?
    /** Date when the miner started execution. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateTriggered: Date?
    /** Date when the miner was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Latest draft details of the miner. */
    public var latestDraftVersion: Draft?
    /** Number of conversations/transcripts fetched. */
    public var conversationsFetchedCount: Int?
    /** Number of conversations/recordings/transcripts that were found valid for mining purposes. */
    public var conversationsValidCount: Int?
    /** Number of intents or topics based on the miner type. */
    public var getminedItemCount: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, language: Language?, minerType: MinerType?, dateCreated: Date?, status: Status?, conversationsDateRangeStart: Date?, conversationsDateRangeEnd: Date?, dateCompleted: Date?, message: String?, errorInfo: MinerErrorInfo?, warningInfo: MinerErrorInfo?, conversationDataUploaded: Bool?, mediaType: MediaType?, participantType: ParticipantType?, queueIds: [String]?, dateTriggered: Date?, dateModified: Date?, latestDraftVersion: Draft?, conversationsFetchedCount: Int?, conversationsValidCount: Int?, getminedItemCount: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.language = language
        self.minerType = minerType
        self.dateCreated = dateCreated
        self.status = status
        self.conversationsDateRangeStart = conversationsDateRangeStart
        self.conversationsDateRangeEnd = conversationsDateRangeEnd
        self.dateCompleted = dateCompleted
        self.message = message
        self.errorInfo = errorInfo
        self.warningInfo = warningInfo
        self.conversationDataUploaded = conversationDataUploaded
        self.mediaType = mediaType
        self.participantType = participantType
        self.queueIds = queueIds
        self.dateTriggered = dateTriggered
        self.dateModified = dateModified
        self.latestDraftVersion = latestDraftVersion
        self.conversationsFetchedCount = conversationsFetchedCount
        self.conversationsValidCount = conversationsValidCount
        self.getminedItemCount = getminedItemCount
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case language
        case minerType
        case dateCreated
        case status
        case conversationsDateRangeStart
        case conversationsDateRangeEnd
        case dateCompleted
        case message
        case errorInfo
        case warningInfo
        case conversationDataUploaded
        case mediaType
        case participantType
        case queueIds
        case dateTriggered
        case dateModified
        case latestDraftVersion
        case conversationsFetchedCount
        case conversationsValidCount
        case getminedItemCount
        case selfUri
    }


}




public class MinerListing: Codable {









    public var entities: [Miner]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [Miner]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class MoveAgentsRequest: Codable {





    /** The list of user ids to move */
    public var userIds: [String]?
    /** The id of the management unit for which the move will be performed. To remove users from their management unit this should be set to null. */
    public var destinationManagementUnitId: String?

    public init(userIds: [String]?, destinationManagementUnitId: String?) {
        self.userIds = userIds
        self.destinationManagementUnitId = destinationManagementUnitId
    }


}




public class NamedEntity: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the object. */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class NamedEntityTypeMechanism: Codable {





    public enum ModelType: String, Codable { 
        case dynamicList = "DynamicList"
        case list = "List"
        case regex = "Regex"
        case unknown = "Unknown"
    }

    /** The items that define the named entity type. */
    public var items: [NamedEntityTypeItem]?
    /** Whether the named entity type is restricted to the items provided. Default: false */
    public var restricted: Bool?
    /** The type of the mechanism. */
    public var type: ModelType?

    public init(items: [NamedEntityTypeItem]?, restricted: Bool?, type: ModelType?) {
        self.items = items
        self.restricted = restricted
        self.type = type
    }


}




public class NluConfusionMatrixColumn: Codable {





    /** The name of the intent for the column. */
    public var name: String?
    /** The confusion value between the intents */
    public var value: Float?

    public init(name: String?, value: Float?) {
        self.name = name
        self.value = value
    }


}




public class NluConfusionMatrixRow: Codable {





    /** The name of the intent for the row. */
    public var name: String?
    /** The columns of confusion matrix for the intent */
    public var columns: [NluConfusionMatrixColumn]?

    public init(name: String?, columns: [NluConfusionMatrixColumn]?) {
        self.name = name
        self.columns = columns
    }


}




public class NluDetectionOutput: Codable {





    /** The detected intents. */
    public var intents: [DetectedIntent]?
    /** The detected dialog acts. */
    public var dialogActs: [DetectedDialogAct]?

    public init(intents: [DetectedIntent]?, dialogActs: [DetectedDialogAct]?) {
        self.intents = intents
        self.dialogActs = dialogActs
    }


}




public class NluDetectionResponse: Codable {







    /** The NLU domain version which performed the detection. */
    public var version: NluDomainVersion?
    public var output: NluDetectionOutput?
    public var input: NluDetectionInput?

    public init(version: NluDomainVersion?, output: NluDetectionOutput?, input: NluDetectionInput?) {
        self.version = version
        self.output = output
        self.input = input
    }


}




public class NluUtterance: Codable {





    /** ID of the utterance. */
    public var _id: String?
    /** The list of segments that that constitute this utterance for the given intent. */
    public var segments: [NluUtteranceSegment]?

    public init(_id: String?, segments: [NluUtteranceSegment]?) {
        self._id = _id
        self.segments = segments
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case segments
    }


}



/** Template parameters for placeholders in template. */

public class NotificationTemplateParameter: Codable {





    /** Parameter name. */
    public var name: String?
    /** Parameter text value. */
    public var text: String?

    public init(name: String?, text: String?) {
        self.name = name
        self.text = text
    }


}




public class NotificationsResponse: Codable {



    public var entities: [WfmUserNotification]?

    public init(entities: [WfmUserNotification]?) {
        self.entities = entities
    }


}



/** Model for a Nuance bot application */

public class NuanceApplication: Codable {







    /** The application ID */
    public var _id: String?
    /** The application Tag */
    public var tag: String?
    /** The application name */
    public var name: String?

    public init(_id: String?, tag: String?, name: String?) {
        self._id = _id
        self.tag = tag
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case tag
        case name
    }


}



/** Model for a paged listing of Nuance bots */

public class NuanceBotEntityListing: Codable {





















    public var entities: [NuanceBot]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [NuanceBot]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** Model for setting the launch configuration for Nuance bots available to Genesys Cloud */

public class NuanceBotLaunchSettings: Codable {



    /** The list of Nuance bots that are configured as available to the Genesys Cloud system */
    public var botExecutionConfigurations: [BotExecutionConfiguration]?

    public init(botExecutionConfigurations: [BotExecutionConfiguration]?) {
        self.botExecutionConfigurations = botExecutionConfigurations
    }


}



/** Model for a Nuance bot transfer node */

public class NuanceBotTransferNode: Codable {





    public enum ModelType: String, Codable { 
        case end = "End"
        case escalate = "Escalate"
    }





    /** The transfer node ID */
    public var _id: String?
    /** The transfer node name */
    public var name: String?
    /** The transfer node type */
    public var type: ModelType?
    /** The transfer node description */
    public var _description: String?
    /** List of variables associated with this transfer node */
    public var requestVariables: [NuanceBotVariable]?

    public init(_id: String?, name: String?, type: ModelType?, _description: String?, requestVariables: [NuanceBotVariable]?) {
        self._id = _id
        self.name = name
        self.type = type
        self._description = _description
        self.requestVariables = requestVariables
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case type
        case _description = "description"
        case requestVariables
    }


}




public class NuanceMixDlgSettings: Codable {





    /** The Nuance channel ID to use when launching the Nuance bot, which must one of the code names of the bot's registered input channels. */
    public var channelId: String?
    /** Name/value pairs of input variables to be sent to the Nuance bot. The values must be in the appropriate format for the variable's type (see https://docs.mix.nuance.com/dialog-grpc/v1/#simple-variable-types for help) */
    public var inputParameters: [String:JSON]?

    public init(channelId: String?, inputParameters: [String:JSON]?) {
        self.channelId = channelId
        self.inputParameters = inputParameters
    }


}




public class Number: Codable {





    public var start: String?
    public var end: String?

    public init(start: String?, end: String?) {
        self.start = start
        self.end = end
    }


}




public class NumberPlan: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }





















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    public var match: String?
    public var normalizedFormat: String?
    public var priority: Int?
    public var numbers: [Number]?
    public var digitLength: DigitLength?
    public var classification: String?
    public var matchType: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, match: String?, normalizedFormat: String?, priority: Int?, numbers: [Number]?, digitLength: DigitLength?, classification: String?, matchType: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.match = match
        self.normalizedFormat = normalizedFormat
        self.priority = priority
        self.numbers = numbers
        self.digitLength = digitLength
        self.classification = classification
        self.matchType = matchType
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case match
        case normalizedFormat
        case priority
        case numbers
        case digitLength
        case classification
        case matchType
        case selfUri
    }


}




public class OAuthScope: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var _description: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, _description: String?, selfUri: String?) {
        self._id = _id
        self._description = _description
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case _description = "description"
        case selfUri
    }


}




public class OAuthScopeListing: Codable {







    public var total: Int64?
    public var entities: [OAuthScope]?
    public var selfUri: String?

    public init(total: Int64?, entities: [OAuthScope]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class OpenActionFields: Codable {





    /** The specific type of the open action. */
    public var openAction: DomainEntityRef?
    /** Custom fields defined in the schema referenced by the open action type selected. */
    public var configurationFields: [String:JSON]?

    public init(openAction: DomainEntityRef?, configurationFields: [String:JSON]?) {
        self.openAction = openAction
        self.configurationFields = configurationFields
    }


}




public class OpenActionProperties: Codable {





    /** The specific type of the open action. */
    public var openActionName: String?
    /** Custom fields defined in the schema referenced by the open action type selected. */
    public var configurationFields: [String:JSON]?

    public init(openActionName: String?, configurationFields: [String:JSON]?) {
        self.openActionName = openActionName
        self.configurationFields = configurationFields
    }


}



/** Open Messaging rich media message structure */

public class OpenInboundNormalizedReceipt: Codable {





    public enum Status: String, Codable { 
        case sent = "Sent"
        case delivered = "Delivered"
        case failed = "Failed"
        case published = "Published"
        case removed = "Removed"
    }





    /** The original unique message Id generated by the messaging platform, that this receipt message is referencing. */
    public var _id: String?
    /** Channel-specific information that describes the message and the message channel/provider. */
    public var channel: OpenInboundMessagingReceiptChannel?
    /** Message receipt status. */
    public var status: Status?
    /** List of reasons for a message receipt that indicates the message has failed. Only used with Failed status. */
    public var reasons: [ConversationReason]?
    /** Indicates if this is the last message receipt for this message, or if another message receipt can be expected. */
    public var isFinalReceipt: Bool?

    public init(_id: String?, channel: OpenInboundMessagingReceiptChannel?, status: Status?, reasons: [ConversationReason]?, isFinalReceipt: Bool?) {
        self._id = _id
        self.channel = channel
        self.status = status
        self.reasons = reasons
        self.isFinalReceipt = isFinalReceipt
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case channel
        case status
        case reasons
        case isFinalReceipt
    }


}



/** Message content element. */

public class OpenMessageContent: Codable {

    public enum ContentType: String, Codable { 
        case attachment = "Attachment"
    }



    /** Type of this content element. If contentType = \"Attachment\" only one item is allowed. */
    public var contentType: ContentType?
    /** Attachment content. */
    public var attachment: ConversationContentAttachment?

    public init(contentType: ContentType?, attachment: ConversationContentAttachment?) {
        self.contentType = contentType
        self.attachment = attachment
    }


}



/** Open Messaging rich media message structure */

public class OpenReceiptNormalizedMessage: Codable {





    public enum ModelType: String, Codable { 
        case receipt = "Receipt"
    }

    public enum Status: String, Codable { 
        case sent = "Sent"
        case delivered = "Delivered"
        case failed = "Failed"
        case published = "Published"
        case removed = "Removed"
    }





    public enum Direction: String, Codable { 
        case inbound = "Inbound"
        case outbound = "Outbound"
    }

    /** The original unique message Id generated by the messaging platform, that this receipt message is referencing. */
    public var _id: String?
    /** Channel-specific information that describes the message and the message channel/provider. */
    public var channel: OpenMessagingChannel?
    /** Message type. */
    public var type: ModelType?
    /** Message receipt status. */
    public var status: Status?
    /** List of reasons for a message receipt that indicates the message has failed. Only used with Failed status. */
    public var reasons: [ConversationReason]?
    /** Indicates if this is the last message receipt for this message, or if another message receipt can be expected. */
    public var isFinalReceipt: Bool?
    /** The direction of the message. */
    public var direction: Direction?

    public init(_id: String?, channel: OpenMessagingChannel?, type: ModelType?, status: Status?, reasons: [ConversationReason]?, isFinalReceipt: Bool?, direction: Direction?) {
        self._id = _id
        self.channel = channel
        self.type = type
        self.status = status
        self.reasons = reasons
        self.isFinalReceipt = isFinalReceipt
        self.direction = direction
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case channel
        case type
        case status
        case reasons
        case isFinalReceipt
        case direction
    }


}




public class OrgAuthSettings: Codable {











    /** Indicates whether multi-factor authentication is required. */
    public var multifactorAuthenticationRequired: Bool?
    /** Indicates whether the domain allowlist is enabled. */
    public var domainAllowlistEnabled: Bool?
    /** The list of domains that will be allowed to embed Genesys Cloud applications. */
    public var domainAllowlist: [String]?
    /** The list of IP addresses that will be allowed to authenticate with Genesys Cloud. */
    public var ipAddressAllowlist: [String]?
    /** The password requirements for the organization. */
    public var passwordRequirements: PasswordRequirements?

    public init(multifactorAuthenticationRequired: Bool?, domainAllowlistEnabled: Bool?, domainAllowlist: [String]?, ipAddressAllowlist: [String]?, passwordRequirements: PasswordRequirements?) {
        self.multifactorAuthenticationRequired = multifactorAuthenticationRequired
        self.domainAllowlistEnabled = domainAllowlistEnabled
        self.domainAllowlist = domainAllowlist
        self.ipAddressAllowlist = ipAddressAllowlist
        self.passwordRequirements = passwordRequirements
    }


}




public class OrgWhitelistSettings: Codable {





    public var enableWhitelist: Bool?
    public var domainWhitelist: [String]?

    public init(enableWhitelist: Bool?, domainWhitelist: [String]?) {
        self.enableWhitelist = enableWhitelist
        self.domainWhitelist = domainWhitelist
    }


}




public class OrganizationPresenceEntityListing: Codable {





















    public var entities: [OrganizationPresence]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [OrganizationPresence]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class OrphanUpdateRequest: Codable {











    /** The orphan recording's archive date. Must be greater than 1 day from now if set. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var archiveDate: Date?
    /** The orphan recording's delete date. Must be greater than archiveDate and exportDate if set, otherwise one day from now. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var deleteDate: Date?
    /** The orphan recording's export date. Must be greater than 1 day from now if set. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var exportDate: Date?
    /** IntegrationId to access AWS S3 bucket for export. This field is required if exportDate is set. */
    public var integrationId: String?
    /** A conversation Id that this orphan's recording is to be attached to. If not present, the conversationId will be deduced from the recording media. */
    public var conversationId: String?

    public init(archiveDate: Date?, deleteDate: Date?, exportDate: Date?, integrationId: String?, conversationId: String?) {
        self.archiveDate = archiveDate
        self.deleteDate = deleteDate
        self.exportDate = exportDate
        self.integrationId = integrationId
        self.conversationId = conversationId
    }


}




public class OutboundMessagingMessagingCampaignConfigChangeErrorDetail: Codable {





    /** The name of the error code. */
    public var error: String?
    /** The additional information regarding the error message. */
    public var details: String?

    public init(error: String?, details: String?) {
        self.error = error
        self.details = details
    }


}



/** An outbound-messaging messaging campaign email address */

public class OutboundMessagingMessagingCampaignConfigChangeFromEmailAddress: Codable {







    /** The friendly name of the email address. */
    public var friendlyName: String?
    /** The local part of the email address. */
    public var localPart: String?
    /** A UriReference for a resource */
    public var domain: OutboundMessagingMessagingCampaignConfigChangeUriReference?

    public init(friendlyName: String?, localPart: String?, domain: OutboundMessagingMessagingCampaignConfigChangeUriReference?) {
        self.friendlyName = friendlyName
        self.localPart = localPart
        self.domain = domain
    }


}



/** An outbound-messaging messaging campaign email address */

public class OutboundMessagingMessagingCampaignConfigChangeReplyToEmailAddress: Codable {





    /** A UriReference for a resource */
    public var domain: OutboundMessagingMessagingCampaignConfigChangeUriReference?
    /** A UriReference for a resource */
    public var route: OutboundMessagingMessagingCampaignConfigChangeUriReference?

    public init(domain: OutboundMessagingMessagingCampaignConfigChangeUriReference?, route: OutboundMessagingMessagingCampaignConfigChangeUriReference?) {
        self.domain = domain
        self.route = route
    }


}



/** A reference for a Response */

public class OutboundMessagingMessagingCampaignConfigChangeResponseRef: Codable {



    /** The unique response id */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}



/** A UriReference for a resource */

public class OutboundMessagingMessagingCampaignProgressEventUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class OutboundRouteEntityListing: Codable {





















    public var entities: [OutboundRoute]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [OutboundRoute]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class OutboundSettings: Codable {



















    public enum ComplianceAbandonRateDenominator: String, Codable { 
        case allCalls = "ALL_CALLS"
        case callsThatReachedQueue = "CALLS_THAT_REACHED_QUEUE"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** The maximum number of calls that can be placed per agent on any campaign */
    public var maxCallsPerAgent: Int?
    /** The maximum number of calls that can be configured to be placed per agent on any campaign */
    public var maxConfigurableCallsPerAgent: Int?
    /** The maximum percentage of lines that should be used for Outbound, expressed as a decimal in the range [0.0, 1.0] */
    public var maxLineUtilization: Double?
    /** The number of seconds used to determine if a call is abandoned */
    public var abandonSeconds: Double?
    /** The denominator to be used in determining the compliance abandon rate */
    public var complianceAbandonRateDenominator: ComplianceAbandonRateDenominator?
    /** The settings for automatic time zone mapping. Note that changing these settings will change them for both voice and messaging campaigns. */
    public var automaticTimeZoneMapping: AutomaticTimeZoneMappingSettings?
    /** Whether or not to reschedule time-zone blocked contacts */
    public var rescheduleTimeZoneSkippedContacts: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, maxCallsPerAgent: Int?, maxConfigurableCallsPerAgent: Int?, maxLineUtilization: Double?, abandonSeconds: Double?, complianceAbandonRateDenominator: ComplianceAbandonRateDenominator?, automaticTimeZoneMapping: AutomaticTimeZoneMappingSettings?, rescheduleTimeZoneSkippedContacts: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.maxCallsPerAgent = maxCallsPerAgent
        self.maxConfigurableCallsPerAgent = maxConfigurableCallsPerAgent
        self.maxLineUtilization = maxLineUtilization
        self.abandonSeconds = abandonSeconds
        self.complianceAbandonRateDenominator = complianceAbandonRateDenominator
        self.automaticTimeZoneMapping = automaticTimeZoneMapping
        self.rescheduleTimeZoneSkippedContacts = rescheduleTimeZoneSkippedContacts
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case maxCallsPerAgent
        case maxConfigurableCallsPerAgent
        case maxLineUtilization
        case abandonSeconds
        case complianceAbandonRateDenominator
        case automaticTimeZoneMapping
        case rescheduleTimeZoneSkippedContacts
        case selfUri
    }


}




public class Outcome: Codable {

























    /** ID of the outcome. */
    public var _id: String?
    /** Whether or not the outcome is active. */
    public var isActive: Bool?
    /** The display name of the outcome. */
    public var displayName: String?
    /** The version of the outcome. */
    public var version: Int?
    /** A description of the outcome. */
    public var _description: String?
    /** Whether or not the outcome is positive. */
    public var isPositive: Bool?
    /** The context of the outcome. */
    public var context: Context?
    /** The pattern of rules defining the filter of the outcome. */
    public var journey: Journey?
    /** The field from the event indicating the associated value. */
    public var associatedValueField: AssociatedValueField?
    /** The URI for this object */
    public var selfUri: String?
    /** Timestamp indicating when the outcome was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    /** Timestamp indicating when the outcome was last updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?

    public init(_id: String?, isActive: Bool?, displayName: String?, version: Int?, _description: String?, isPositive: Bool?, context: Context?, journey: Journey?, associatedValueField: AssociatedValueField?, selfUri: String?, createdDate: Date?, modifiedDate: Date?) {
        self._id = _id
        self.isActive = isActive
        self.displayName = displayName
        self.version = version
        self._description = _description
        self.isPositive = isPositive
        self.context = context
        self.journey = journey
        self.associatedValueField = associatedValueField
        self.selfUri = selfUri
        self.createdDate = createdDate
        self.modifiedDate = modifiedDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case isActive
        case displayName
        case version
        case _description = "description"
        case isPositive
        case context
        case journey
        case associatedValueField
        case selfUri
        case createdDate
        case modifiedDate
    }


}




public class OutcomeListing: Codable {





















    public var entities: [Outcome]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Outcome]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class OutcomePercentileCondition: Codable {







    /** The outcome ID. */
    public var outcomeId: String?
    /** Percentile value for the selected outcome, at or above which the action map will trigger. */
    public var maximumPercentile: Float?
    /** Additional percentile condition, where if set, the action map will trigger if the current outcome percentile is lower or equal to the value. */
    public var fallbackPercentile: Float?

    public init(outcomeId: String?, maximumPercentile: Float?, fallbackPercentile: Float?) {
        self.outcomeId = outcomeId
        self.maximumPercentile = maximumPercentile
        self.fallbackPercentile = fallbackPercentile
    }


}




public class OutcomePredictor: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The outcome for which this predictor will provide predictions. */
    public var outcome: OutcomeRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, outcome: OutcomeRef?, selfUri: String?) {
        self._id = _id
        self.outcome = outcome
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case outcome
        case selfUri
    }


}




public class OutcomePredictorListing: Codable {



    public var entities: [OutcomePredictor]?

    public init(entities: [OutcomePredictor]?) {
        self.entities = entities
    }


}




public class OutcomePredictorRequest: Codable {



    /** The outcome for which this predictor will provide predictions. */
    public var outcome: OutcomeRefRequest?

    public init(outcome: OutcomeRefRequest?) {
        self.outcome = outcome
    }


}




public class OutcomeQuantileCondition: Codable {







    /** The outcome ID. */
    public var outcomeId: String?
    /** This Outcome Quantile Condition is met when sessionMaxQuantile of the OutcomeScore is above this value, (unless fallbackQuantile is set). Range 0.00-1.00 */
    public var maxQuantileThreshold: Float?
    /** (Optional) If set, this Condition is met when maxQuantileThreshold is met, AND the current quantile of the OutcomeScore is below this fallbackQuantileThreshold. Range 0.00-1.00 */
    public var fallbackQuantileThreshold: Float?

    public init(outcomeId: String?, maxQuantileThreshold: Float?, fallbackQuantileThreshold: Float?) {
        self.outcomeId = outcomeId
        self.maxQuantileThreshold = maxQuantileThreshold
        self.fallbackQuantileThreshold = fallbackQuantileThreshold
    }


}




public class OutcomeRef: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class OutcomeRefRequest: Codable {



    /** ID of outcome. */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class OutcomeRequest: Codable {

















    /** Whether or not the outcome is active. */
    public var isActive: Bool?
    /** The display name of the outcome. */
    public var displayName: String?
    /** The version of the outcome. */
    public var version: Int?
    /** A description of the outcome. */
    public var _description: String?
    /** Whether or not the outcome is positive. */
    public var isPositive: Bool?
    /** The context of the outcome. */
    public var context: RequestContext?
    /** The pattern of rules defining the filter of the outcome. */
    public var journey: RequestJourney?
    /** The field from the event indicating the associated value. */
    public var associatedValueField: AssociatedValueField?

    public init(isActive: Bool?, displayName: String?, version: Int?, _description: String?, isPositive: Bool?, context: RequestContext?, journey: RequestJourney?, associatedValueField: AssociatedValueField?) {
        self.isActive = isActive
        self.displayName = displayName
        self.version = version
        self._description = _description
        self.isPositive = isPositive
        self.context = context
        self.journey = journey
        self.associatedValueField = associatedValueField
    }

    public enum CodingKeys: String, CodingKey { 
        case isActive
        case displayName
        case version
        case _description = "description"
        case isPositive
        case context
        case journey
        case associatedValueField
    }


}




public class PagelessDomainEntityListingEvaluationVersion: Codable {







    public var total: Int64?
    public var entities: [EvaluationVersion]?
    public var selfUri: String?

    public init(total: Int64?, entities: [EvaluationVersion]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class PagelessEntityListing: Codable {







    public var total: Int64?
    public var entities: [AddressableEntity]?
    public var selfUri: String?

    public init(total: Int64?, entities: [AddressableEntity]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class PatchAction: Codable {

    public enum MediaType: String, Codable { 
        case webchat = "webchat"
        case webmessagingoffer = "webMessagingOffer"
        case contentoffer = "contentOffer"
        case integrationaction = "integrationAction"
        case architectflow = "architectFlow"
        case openaction = "openAction"
    }















    /** Media type of action. */
    public var mediaType: MediaType?
    /** Action template associated with the action map. */
    public var actionTemplate: ActionMapActionTemplate?
    /** Action target ID. */
    public var actionTargetId: String?
    /** Whether this action should be throttled. */
    public var isPacingEnabled: Bool?
    /** Additional properties. */
    public var props: PatchActionProperties?
    /** Architect Flow Id and input contract. */
    public var architectFlowFields: ArchitectFlowFields?
    /** Admin-configurable fields of a web messaging offer action. */
    public var webMessagingOfferFields: PatchWebMessagingOfferFields?
    /** Admin-configurable fields of an open action. */
    public var openActionFields: OpenActionFields?

    public init(mediaType: MediaType?, actionTemplate: ActionMapActionTemplate?, actionTargetId: String?, isPacingEnabled: Bool?, props: PatchActionProperties?, architectFlowFields: ArchitectFlowFields?, webMessagingOfferFields: PatchWebMessagingOfferFields?, openActionFields: OpenActionFields?) {
        self.mediaType = mediaType
        self.actionTemplate = actionTemplate
        self.actionTargetId = actionTargetId
        self.isPacingEnabled = isPacingEnabled
        self.props = props
        self.architectFlowFields = architectFlowFields
        self.webMessagingOfferFields = webMessagingOfferFields
        self.openActionFields = openActionFields
    }


}




public class PatchActionTarget: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Service Level of the action target. Chat offers for the target will be throttled with the aim of achieving this service level. */
    public var serviceLevel: ServiceLevel?
    /** Indicates the non-default short abandon threshold */
    public var shortAbandonThreshold: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, serviceLevel: ServiceLevel?, shortAbandonThreshold: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.serviceLevel = serviceLevel
        self.shortAbandonThreshold = shortAbandonThreshold
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case serviceLevel
        case shortAbandonThreshold
        case selfUri
    }


}




public class PatchBuReschedulingOptionsRequest: Codable {



    /** Per-management unit rescheduling options to update */
    public var managementUnits: [PatchBuReschedulingOptionsManagementUnitRequest]?

    public init(managementUnits: [PatchBuReschedulingOptionsManagementUnitRequest]?) {
        self.managementUnits = managementUnits
    }


}




public class PatchCallToAction: Codable {





    public enum Target: String, Codable { 
        case blank = "Blank"
        case _self = "Self"
    }

    /** Text displayed on the call to action button. */
    public var text: String?
    /** URL to open when user clicks on the call to action button. */
    public var url: String?
    /** Where the URL should be opened when the user clicks on the call to action button. */
    public var target: Target?

    public init(text: String?, url: String?, target: Target?) {
        self.text = text
        self.url = url
        self.target = target
    }


}




public class PatchCallbackRequest: Codable {









    /** The conversationId. */
    public var conversationId: String?
    /** The identifier of the queue to be used for the callback. */
    public var queueId: String?
    /** The agentId. */
    public var agentId: String?
    /** The scheduled date-time for the callback. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var callbackScheduledTime: Date?

    public init(conversationId: String?, queueId: String?, agentId: String?, callbackScheduledTime: Date?) {
        self.conversationId = conversationId
        self.queueId = queueId
        self.agentId = agentId
        self.callbackScheduledTime = callbackScheduledTime
    }


}




public class PatchCloseButtonStyleProperties: Codable {





    /** Color of button. (eg. #FF0000) */
    public var color: String?
    /** Opacity of button. */
    public var opacity: Float?

    public init(color: String?, opacity: Float?) {
        self.color = color
        self.opacity = opacity
    }


}




public class PatchContext: Codable {



    /** A list of one or more patterns to match. */
    public var patterns: [PatchContextPattern]?

    public init(patterns: [PatchContextPattern]?) {
        self.patterns = patterns
    }


}




public class PatchIntegrationActionFields: Codable {





    /** Reference to the Integration Action to be used when integrationAction type is qualified */
    public var integrationAction: PatchIntegrationAction?
    /** Collection of Request Mappings to use */
    public var requestMappings: [RequestMapping]?

    public init(integrationAction: PatchIntegrationAction?, requestMappings: [RequestMapping]?) {
        self.integrationAction = integrationAction
        self.requestMappings = requestMappings
    }


}




public class PatchShiftTradeRequest: Codable {









    /** Update the ID of the receiving user to direct the request at a specific user, or set the wrapped id to null to open up a trade to be matched by any user. */
    public var receivingUserId: ValueWrapperString?
    /** Update the expiration time for this shift trade. */
    public var expiration: ValueWrapperDate?
    /** Update the acceptable intervals the initiating user is willing to accept in trade. Setting the enclosed list to empty will make this a one sided trade request */
    public var acceptableIntervals: ListWrapperInterval?
    /** Version metadata */
    public var metadata: WfmVersionedEntityMetadata?

    public init(receivingUserId: ValueWrapperString?, expiration: ValueWrapperDate?, acceptableIntervals: ListWrapperInterval?, metadata: WfmVersionedEntityMetadata?) {
        self.receivingUserId = receivingUserId
        self.expiration = expiration
        self.acceptableIntervals = acceptableIntervals
        self.metadata = metadata
    }


}




public class PhoneBaseEntityListing: Codable {























    public var entities: [PhoneBase]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    /** The total organization-wide number of entities. */
    public var totalNumberOfEntities: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [PhoneBase]?, pageSize: Int?, pageNumber: Int?, total: Int64?, totalNumberOfEntities: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.totalNumberOfEntities = totalNumberOfEntities
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class PhoneCapabilities: Codable {















    public enum MediaCodecs: String, Codable { 
        case audioOpus = "audio/opus"
        case audioPcmu = "audio/pcmu"
        case audioPcma = "audio/pcma"
        case audioG729 = "audio/g729"
        case audioG722 = "audio/g722"
    }



    public var provisions: Bool?
    public var registers: Bool?
    public var dualRegisters: Bool?
    public var hardwareIdType: String?
    public var allowReboot: Bool?
    public var noRebalance: Bool?
    public var noCloudProvisioning: Bool?
    public var mediaCodecs: [MediaCodecs]?
    public var cdm: Bool?

    public init(provisions: Bool?, registers: Bool?, dualRegisters: Bool?, hardwareIdType: String?, allowReboot: Bool?, noRebalance: Bool?, noCloudProvisioning: Bool?, mediaCodecs: [MediaCodecs]?, cdm: Bool?) {
        self.provisions = provisions
        self.registers = registers
        self.dualRegisters = dualRegisters
        self.hardwareIdType = hardwareIdType
        self.allowReboot = allowReboot
        self.noRebalance = noRebalance
        self.noCloudProvisioning = noCloudProvisioning
        self.mediaCodecs = mediaCodecs
        self.cdm = cdm
    }


}




public class PhoneNumberStatus: Codable {



    /** Indicates whether or not a phone number is callable. */
    public var callable: Bool?

    public init(callable: Bool?) {
        self.callable = callable
    }


}




public class PhoneTransferEvent: Codable {







    public enum TransferType: String, Codable { 
        case attended = "Attended"
        case unattended = "Unattended"
    }











    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** Indicates the desired type of transfer. */
    public var transferType: TransferType?
    /** The id (V4 UUID) used by the external platform to refer to the transfer in subsequent Transfer events. */
    public var commandId: String?
    /** The id (V4 UUID) of the communication representing the participant that is initiating the transfer. */
    public var initiatingCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred away from. In many cases this will be the same as the `initiatingCommunicationId`. */
    public var targetCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred. */
    public var objectCommunicationId: String?
    /** The desired destination phone number that the object communication should be transferred to. */
    public var destinationPhoneNumber: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, transferType: TransferType?, commandId: String?, initiatingCommunicationId: String?, targetCommunicationId: String?, objectCommunicationId: String?, destinationPhoneNumber: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.transferType = transferType
        self.commandId = commandId
        self.initiatingCommunicationId = initiatingCommunicationId
        self.targetCommunicationId = targetCommunicationId
        self.objectCommunicationId = objectCommunicationId
        self.destinationPhoneNumber = destinationPhoneNumber
    }


}



/** Settings concerning position */

public class PositionSettings: Codable {

    public enum Alignment: String, Codable { 
        case auto = "Auto"
        case _left = "Left"
        case _right = "Right"
    }





    /** The alignment for position */
    public var alignment: Alignment?
    /** The sidespace value for position */
    public var sideSpace: Int?
    /** The bottomspace value for position */
    public var bottomSpace: Int?

    public init(alignment: Alignment?, sideSpace: Int?, bottomSpace: Int?) {
        self.alignment = alignment
        self.sideSpace = sideSpace
        self.bottomSpace = bottomSpace
    }


}




public class PostTextMessage: Codable {

    public enum ModelType: String, Codable { 
        case text = "Text"
        case structured = "Structured"
        case receipt = "Receipt"
        case event = "Event"
        case message = "Message"
        case unknown = "Unknown"
    }





    /** Message type */
    public var type: ModelType?
    /** Message text. If type is structured, used as fallback for clients that do not support particular structured content */
    public var text: String?
    /** A list of content elements in message */
    public var content: [ConversationMessageContent]?

    public init(type: ModelType?, text: String?, content: [ConversationMessageContent]?) {
        self.type = type
        self.text = text
        self.content = content
    }


}




public class PredictorModel: Codable {











    public enum MediaType: String, Codable { 
        case voice = "voice"
        case email = "email"
        case message = "message"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The key performance indicator used in the model. */
    public var kpi: String?
    /** The List of Queues that are assessed for Predictive Routing. */
    public var queues: [AddressableEntityRef]?
    /** DateTime indicating when the model was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** DateTime indicating when the model was last trained. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateTrained: Date?
    /** The media type of the model. */
    public var mediaType: MediaType?
    public var features: [PredictorModelFeature]?

    public init(_id: String?, kpi: String?, queues: [AddressableEntityRef]?, dateCreated: Date?, dateTrained: Date?, mediaType: MediaType?, features: [PredictorModelFeature]?) {
        self._id = _id
        self.kpi = kpi
        self.queues = queues
        self.dateCreated = dateCreated
        self.dateTrained = dateTrained
        self.mediaType = mediaType
        self.features = features
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case kpi
        case queues
        case dateCreated
        case dateTrained
        case mediaType
        case features
    }


}




public class PredictorModelRetrainingError: Codable {



    public enum ErrorCode: String, Codable { 
        case notEnoughData = "NotEnoughData"
        case serviceError = "ServiceError"
        case unknownError = "UnknownError"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Error code describing model training failure. */
    public var errorCode: ErrorCode?
    /** Date when the first retraining failure happened. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateOfFirstOccurrence: Date?

    public init(_id: String?, errorCode: ErrorCode?, dateOfFirstOccurrence: Date?) {
        self._id = _id
        self.errorCode = errorCode
        self.dateOfFirstOccurrence = dateOfFirstOccurrence
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case errorCode
        case dateOfFirstOccurrence
    }


}




public class PredictorModels: Codable {





    public var entities: [PredictorModel]?
    public var predictorModels: [PredictorModel]?

    public init(entities: [PredictorModel]?, predictorModels: [PredictorModel]?) {
        self.entities = entities
        self.predictorModels = predictorModels
    }


}




public class ProcessScheduleUpdateUploadRequest: Codable {







    /** The uploadKey provided by the request to get an upload URL */
    public var uploadKey: String?
    /** The list of teams to which the users being modified belong. Only required if the requesting user has conditional permission to wfm:schedule:edit */
    public var teamIds: [String]?
    /** The set of muIds to which agents belong if agents are being newly added to the schedule, if the requesting user has conditional permission to wfm:schedule:edit */
    public var managementUnitIdsForAddedTeamUsers: [String]?

    public init(uploadKey: String?, teamIds: [String]?, managementUnitIdsForAddedTeamUsers: [String]?) {
        self.uploadKey = uploadKey
        self.teamIds = teamIds
        self.managementUnitIdsForAddedTeamUsers = managementUnitIdsForAddedTeamUsers
    }


}




public class Prompt: Codable {













    /** The prompt identifier */
    public var _id: String?
    /** The prompt name. */
    public var name: String?
    public var _description: String?
    /** List of resources associated with this prompt */
    public var resources: [PromptAsset]?
    /** Current prompt operation status */
    public var currentOperation: Operation?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, resources: [PromptAsset]?, currentOperation: Operation?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.resources = resources
        self.currentOperation = currentOperation
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case resources
        case currentOperation
        case selfUri
    }


}



/** Draft to be published */

public class PublishDraftInput: Codable {



    /** The current draft version. */
    public var version: Int?

    public init(version: Int?) {
        self.version = version
    }


}




public class PublishProgramTopicsDefinitionsJob: Codable {



    public enum State: String, Codable { 
        case completed = "Completed"
        case failed = "Failed"
    }

    public var _id: String?
    public var state: State?

    public init(_id: String?, state: State?) {
        self._id = _id
        self.state = state
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
    }


}




public class PublishedSurveyFormReference: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The context id of this form. */
    public var contextId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, contextId: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.contextId = contextId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case contextId
        case selfUri
    }


}




public class QualityAuditLogMessage: Codable {













    public enum ServiceName: String, Codable { 
        case recordingService = "RecordingService"
        case recordingPlaybackService = "RecordingPlaybackService"
        case qualityService = "QualityService"
    }

    public enum Level: String, Codable { 
        case user = "User"
        case system = "System"
    }

    public enum Status: String, Codable { 
        case success = "Success"
        case failure = "Failure"
        case warning = "Warning"
    }





    public enum Action: String, Codable { 
        case read = "Read"
        case create = "Create"
        case update = "Update"
        case delete = "Delete"
        case abandon = "Abandon"
        case archive = "Archive"
        case export = "Export"
        case restoreRequest = "RestoreRequest"
        case restoreComplete = "RestoreComplete"
        case applyProtection = "ApplyProtection"
        case revokeProtection = "RevokeProtection"
        case updateRetention = "UpdateRetention"
    }



    public enum EntityType: String, Codable { 
        case recording = "Recording"
        case evaluation = "Evaluation"
        case calibration = "Calibration"
        case annotation = "Annotation"
        case screenRecording = "ScreenRecording"
        case survey = "Survey"
    }





    /** Id of the audit message. */
    public var _id: String?
    /** Home Organization Id associated with this audit message. */
    public var userHomeOrgId: String?
    /** Trustee Organization Id if this audit message is from trustee access. */
    public var userTrusteeOrgId: String?
    /** User associated with this audit message. */
    public var user: DomainEntityRef?
    /** Client associated with this audit message. */
    public var client: AddressableEntityRef?
    /** List of IP addresses of systems that originated or handled the request. */
    public var remoteIps: [String]?
    /** Name of the service that logged this audit message. */
    public var serviceName: ServiceName?
    /** The level of this audit message. */
    public var level: Level?
    /** The status of the action of this audit message. */
    public var status: Status?
    /** Date and time of when the audit message was logged. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDate: Date?
    /** Message describing the event being audited. */
    public var messageInfo: MessageInfo?
    /** Action that took place. */
    public var action: Action?
    /** Entity that was impacted. */
    public var entity: DomainEntityRef?
    /** Type of the entity that was impacted. */
    public var entityType: EntityType?
    /** List of properties that were changed and changes made to those properties. */
    public var propertyChanges: [PropertyChange]?
    /** Additional context for this message. */
    public var context: [String:String]?

    public init(_id: String?, userHomeOrgId: String?, userTrusteeOrgId: String?, user: DomainEntityRef?, client: AddressableEntityRef?, remoteIps: [String]?, serviceName: ServiceName?, level: Level?, status: Status?, eventDate: Date?, messageInfo: MessageInfo?, action: Action?, entity: DomainEntityRef?, entityType: EntityType?, propertyChanges: [PropertyChange]?, context: [String:String]?) {
        self._id = _id
        self.userHomeOrgId = userHomeOrgId
        self.userTrusteeOrgId = userTrusteeOrgId
        self.user = user
        self.client = client
        self.remoteIps = remoteIps
        self.serviceName = serviceName
        self.level = level
        self.status = status
        self.eventDate = eventDate
        self.messageInfo = messageInfo
        self.action = action
        self.entity = entity
        self.entityType = entityType
        self.propertyChanges = propertyChanges
        self.context = context
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case userHomeOrgId
        case userTrusteeOrgId
        case user
        case client
        case remoteIps
        case serviceName
        case level
        case status
        case eventDate
        case messageInfo
        case action
        case entity
        case entityType
        case propertyChanges
        case context
    }


}




public class QueryRequestPredicate: Codable {

    public enum Dimension: String, Codable { 
        case attendeeid = "attendeeId"
        case facilitatorid = "facilitatorId"
        case status = "status"
    }



    /** The dimension to be filtered */
    public var dimension: Dimension?
    /** The value to filter by */
    public var value: String?

    public init(dimension: Dimension?, value: String?) {
        self.dimension = dimension
        self.value = value
    }


}




public class Queue: Codable {































    public enum ScoringMethod: String, Codable { 
        case timestampAndPriority = "TimestampAndPriority"
        case priorityOnly = "PriorityOnly"
    }



    public enum SkillEvaluationMethod: String, Codable { 
        case _none = "NONE"
        case best = "BEST"
        case all = "ALL"
    }









































    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The queue description. */
    public var _description: String?
    /** The date the queue was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the queue. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the queue. */
    public var modifiedBy: String?
    /** The ID of the user that created the queue. */
    public var createdBy: String?
    /** The total number of members in the queue. */
    public var memberCount: Int?
    /** The number of user members (i.e., non-group members) in the queue. */
    public var userMemberCount: Int?
    /** The number of joined members in the queue. */
    public var joinedMemberCount: Int?
    /** The media settings for the queue. */
    public var mediaSettings: QueueMediaSettings?
    /** The routing rules for the queue, used for Preferred Agent Routing. */
    public var routingRules: [RoutingRule]?
    /** The Conditional Group Routing settings for the queue. */
    public var conditionalGroupRouting: ConditionalGroupRouting?
    /** The bullseye settings for the queue. */
    public var bullseye: Bullseye?
    /** The Scoring Method for the queue */
    public var scoringMethod: ScoringMethod?
    /** The ACW settings for the queue. */
    public var acwSettings: AcwSettings?
    /** The skill evaluation method to use when routing conversations. */
    public var skillEvaluationMethod: SkillEvaluationMethod?
    /** The groups of agents associated with the queue, if any.  Queue membership will update to match group membership changes. */
    public var memberGroups: [MemberGroup]?
    /** The in-queue flow to use for call conversations waiting in queue. */
    public var queueFlow: DomainEntityRef?
    /** The in-queue flow to use for email conversations waiting in queue. */
    public var emailInQueueFlow: DomainEntityRef?
    /** The in-queue flow to use for message conversations waiting in queue. */
    public var messageInQueueFlow: DomainEntityRef?
    /** The prompt used for whisper on the queue, if configured. */
    public var whisperPrompt: DomainEntityRef?
    /** The audio to be played when calls on this queue are on hold. If not configured, the default on-hold music will play. */
    public var onHoldPrompt: DomainEntityRef?
    /** Specifies whether the configured whisper should play for all ACD calls, or only for those which are auto-answered. */
    public var autoAnswerOnly: Bool?
    /** Indicates whether voice transcription is enabled for this queue. */
    public var enableTranscription: Bool?
    /** Indicates whether audio monitoring is enabled for this queue. */
    public var enableAudioMonitoring: Bool?
    /** Indicates whether manual assignment is enabled for this queue. */
    public var enableManualAssignment: Bool?
    /** The Agent Owned Routing settings for the queue */
    public var agentOwnedRouting: AgentOwnedRouting?
    /** The Direct Routing settings for the queue */
    public var directRouting: DirectRouting?
    /** The name to use for caller identification for outbound calls from this queue. */
    public var callingPartyName: String?
    /** The phone number to use for caller identification for outbound calls from this queue. */
    public var callingPartyNumber: String?
    /** The default script Ids for the communication types. */
    public var defaultScripts: [String:Script]?
    /** The messaging addresses for the queue. */
    public var outboundMessagingAddresses: QueueMessagingAddresses?
    public var outboundEmailAddress: QueueEmailAddress?
    /** The ID of an associated external queue. */
    public var peerId: String?
    /** Indicates whether recording in-queue calls is suppressed for this queue. */
    public var suppressInQueueCallRecording: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, memberCount: Int?, userMemberCount: Int?, joinedMemberCount: Int?, mediaSettings: QueueMediaSettings?, routingRules: [RoutingRule]?, conditionalGroupRouting: ConditionalGroupRouting?, bullseye: Bullseye?, scoringMethod: ScoringMethod?, acwSettings: AcwSettings?, skillEvaluationMethod: SkillEvaluationMethod?, memberGroups: [MemberGroup]?, queueFlow: DomainEntityRef?, emailInQueueFlow: DomainEntityRef?, messageInQueueFlow: DomainEntityRef?, whisperPrompt: DomainEntityRef?, onHoldPrompt: DomainEntityRef?, autoAnswerOnly: Bool?, enableTranscription: Bool?, enableAudioMonitoring: Bool?, enableManualAssignment: Bool?, agentOwnedRouting: AgentOwnedRouting?, directRouting: DirectRouting?, callingPartyName: String?, callingPartyNumber: String?, defaultScripts: [String:Script]?, outboundMessagingAddresses: QueueMessagingAddresses?, outboundEmailAddress: QueueEmailAddress?, peerId: String?, suppressInQueueCallRecording: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.memberCount = memberCount
        self.userMemberCount = userMemberCount
        self.joinedMemberCount = joinedMemberCount
        self.mediaSettings = mediaSettings
        self.routingRules = routingRules
        self.conditionalGroupRouting = conditionalGroupRouting
        self.bullseye = bullseye
        self.scoringMethod = scoringMethod
        self.acwSettings = acwSettings
        self.skillEvaluationMethod = skillEvaluationMethod
        self.memberGroups = memberGroups
        self.queueFlow = queueFlow
        self.emailInQueueFlow = emailInQueueFlow
        self.messageInQueueFlow = messageInQueueFlow
        self.whisperPrompt = whisperPrompt
        self.onHoldPrompt = onHoldPrompt
        self.autoAnswerOnly = autoAnswerOnly
        self.enableTranscription = enableTranscription
        self.enableAudioMonitoring = enableAudioMonitoring
        self.enableManualAssignment = enableManualAssignment
        self.agentOwnedRouting = agentOwnedRouting
        self.directRouting = directRouting
        self.callingPartyName = callingPartyName
        self.callingPartyNumber = callingPartyNumber
        self.defaultScripts = defaultScripts
        self.outboundMessagingAddresses = outboundMessagingAddresses
        self.outboundEmailAddress = outboundEmailAddress
        self.peerId = peerId
        self.suppressInQueueCallRecording = suppressInQueueCallRecording
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case memberCount
        case userMemberCount
        case joinedMemberCount
        case mediaSettings
        case routingRules
        case conditionalGroupRouting
        case bullseye
        case scoringMethod
        case acwSettings
        case skillEvaluationMethod
        case memberGroups
        case queueFlow
        case emailInQueueFlow
        case messageInQueueFlow
        case whisperPrompt
        case onHoldPrompt
        case autoAnswerOnly
        case enableTranscription
        case enableAudioMonitoring
        case enableManualAssignment
        case agentOwnedRouting
        case directRouting
        case callingPartyName
        case callingPartyNumber
        case defaultScripts
        case outboundMessagingAddresses
        case outboundEmailAddress
        case peerId
        case suppressInQueueCallRecording
        case selfUri
    }


}




public class QueueConversationCallEventTopicCallConversation: Codable {









    public enum RecordingState: String, Codable { 
        case _none = "none"
        case active = "active"
        case paused = "paused"
    }





    public var _id: String?
    public var name: String?
    public var participants: [QueueConversationCallEventTopicCallMediaParticipant]?
    public var otherMediaUris: [String]?
    public var recordingState: RecordingState?
    public var securePause: Bool?
    public var maxParticipants: Int?

    public init(_id: String?, name: String?, participants: [QueueConversationCallEventTopicCallMediaParticipant]?, otherMediaUris: [String]?, recordingState: RecordingState?, securePause: Bool?, maxParticipants: Int?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
        self.recordingState = recordingState
        self.securePause = securePause
        self.maxParticipants = maxParticipants
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
        case recordingState
        case securePause
        case maxParticipants
    }


}




public class QueueConversationCallEventTopicDetail: Codable {









    public var errorCode: String?
    public var fieldName: String?
    public var entityId: String?
    public var entityName: String?

    public init(errorCode: String?, fieldName: String?, entityId: String?, entityName: String?) {
        self.errorCode = errorCode
        self.fieldName = fieldName
        self.entityId = entityId
        self.entityName = entityName
    }


}




public class QueueConversationCallEventTopicErrorBody: Codable {





















    public var message: String?
    public var code: String?
    public var status: Int?
    public var entityId: String?
    public var entityName: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var contextId: String?
    public var details: [QueueConversationCallEventTopicDetail]?
    public var errors: [QueueConversationCallEventTopicErrorBody]?

    public init(message: String?, code: String?, status: Int?, entityId: String?, entityName: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, details: [QueueConversationCallEventTopicDetail]?, errors: [QueueConversationCallEventTopicErrorBody]?) {
        self.message = message
        self.code = code
        self.status = status
        self.entityId = entityId
        self.entityName = entityName
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.details = details
        self.errors = errors
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class QueueConversationCallEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int?

    public init(_id: String?, version: Int?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}




public class QueueConversationCallEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class QueueConversationCallbackEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: QueueConversationCallbackEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: QueueConversationCallbackEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}




public class QueueConversationCallbackEventTopicJourneyContext: Codable {







    public var customer: QueueConversationCallbackEventTopicJourneyCustomer?
    public var customerSession: QueueConversationCallbackEventTopicJourneyCustomerSession?
    public var triggeringAction: QueueConversationCallbackEventTopicJourneyAction?

    public init(customer: QueueConversationCallbackEventTopicJourneyCustomer?, customerSession: QueueConversationCallbackEventTopicJourneyCustomerSession?, triggeringAction: QueueConversationCallbackEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class QueueConversationCallbackEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}




public class QueueConversationChatEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class QueueConversationCobrowseEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: QueueConversationCobrowseEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: QueueConversationCobrowseEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}




public class QueueConversationCobrowseEventTopicJourneyContext: Codable {







    public var customer: QueueConversationCobrowseEventTopicJourneyCustomer?
    public var customerSession: QueueConversationCobrowseEventTopicJourneyCustomerSession?
    public var triggeringAction: QueueConversationCobrowseEventTopicJourneyAction?

    public init(customer: QueueConversationCobrowseEventTopicJourneyCustomer?, customerSession: QueueConversationCobrowseEventTopicJourneyCustomerSession?, triggeringAction: QueueConversationCobrowseEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class QueueConversationCobrowseEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}




public class QueueConversationEmailEventTopicConversationRoutingData: Codable {











    /** A UriReference for a resource */
    public var queue: QueueConversationEmailEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: QueueConversationEmailEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int?
    /** The skills to use for routing decisions */
    public var skills: [QueueConversationEmailEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [QueueConversationEmailEventTopicScoredAgent]?

    public init(queue: QueueConversationEmailEventTopicUriReference?, language: QueueConversationEmailEventTopicUriReference?, priority: Int?, skills: [QueueConversationEmailEventTopicUriReference]?, scoredAgents: [QueueConversationEmailEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}



/** Address and name data for a call endpoint. */

public class QueueConversationEventTopicAddress: Codable {











    /** This will be nameRaw if present, or a locality lookup of the address field otherwise. */
    public var name: String?
    /** The name as close to the bits on the wire as possible. */
    public var nameRaw: String?
    /** The normalized address. This field is acquired from the Address Normalization Table.  The addressRaw could have gone through some transformations, such as only using the numeric portion, before being run through the Address Normalization Table. */
    public var addressNormalized: String?
    /** The address as close to the bits on the wire as possible. */
    public var addressRaw: String?
    /** The displayable address. This field is acquired from the Address Normalization Table.  The addressRaw could have gone through some transformations, such as only using the numeric portion, before being run through the Address Normalization Table. */
    public var addressDisplayable: String?

    public init(name: String?, nameRaw: String?, addressNormalized: String?, addressRaw: String?, addressDisplayable: String?) {
        self.name = name
        self.nameRaw = nameRaw
        self.addressNormalized = addressNormalized
        self.addressRaw = addressRaw
        self.addressDisplayable = addressDisplayable
    }


}




public class QueueConversationEventTopicCall: Codable {



    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case uploading = "uploading"
        case converting = "converting"
        case transmitting = "transmitting"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case uploading = "uploading"
        case converting = "converting"
        case transmitting = "transmitting"
        case _none = "none"
    }



    public enum RecordingState: String, Codable { 
        case _none = "none"
        case active = "active"
        case paused = "paused"
    }











    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }



    public enum Direction: String, Codable { 
        case outbound = "outbound"
        case inbound = "inbound"
    }



































    /** A globally unique identifier for this communication. */
    public var _id: String?
    public var state: State?
    public var initialState: InitialState?
    /** True if this call is being recorded. */
    public var recording: Bool?
    /** State of recording on this call. */
    public var recordingState: RecordingState?
    /** True if this call is muted so that remote participants can't hear any audio from this end. */
    public var muted: Bool?
    /** True if this call is held and the person on this side hears hold music. */
    public var confined: Bool?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** True when the recording of this call is in secure pause status. */
    public var securePause: Bool?
    public var errorInfo: QueueConversationEventTopicErrorDetails?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the call was placed on hold in the cloud clock if the call is currently on hold. */
    public var startHoldTime: Date?
    /** Whether a call is inbound or outbound. */
    public var direction: Direction?
    /** If call is a fax of a document in content management, the id of the document in content management. */
    public var documentId: String?
    public var _self: QueueConversationEventTopicAddress?
    /** Address and name data for a call endpoint. */
    public var other: QueueConversationEventTopicAddress?
    /** The source provider of the call. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** List of reasons that this call was disconnected. This will be set once the call disconnects. */
    public var disconnectReasons: [QueueConversationEventTopicDisconnectReason]?
    public var faxStatus: QueueConversationEventTopicFaxStatus?
    /** User to User Information (UUI) data managed by SIP session application. */
    public var uuiData: String?
    /** The timestamp when this participant was connected to the barge conference in the provider clock. */
    public var bargedTime: Date?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationEventTopicWrapup?
    public var afterCallWork: QueueConversationEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** UUID of virtual agent assistant that provide suggestions to the agent participant during the conversation. */
    public var agentAssistantId: String?
    public var queueMediaSettings: QueueConversationEventTopicQueueMediaSettings?

    public init(_id: String?, state: State?, initialState: InitialState?, recording: Bool?, recordingState: RecordingState?, muted: Bool?, confined: Bool?, held: Bool?, securePause: Bool?, errorInfo: QueueConversationEventTopicErrorDetails?, disconnectType: DisconnectType?, startHoldTime: Date?, direction: Direction?, documentId: String?, _self: QueueConversationEventTopicAddress?, other: QueueConversationEventTopicAddress?, provider: String?, scriptId: String?, peerId: String?, connectedTime: Date?, disconnectedTime: Date?, disconnectReasons: [QueueConversationEventTopicDisconnectReason]?, faxStatus: QueueConversationEventTopicFaxStatus?, uuiData: String?, bargedTime: Date?, wrapup: QueueConversationEventTopicWrapup?, afterCallWork: QueueConversationEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, agentAssistantId: String?, queueMediaSettings: QueueConversationEventTopicQueueMediaSettings?) {
        self._id = _id
        self.state = state
        self.initialState = initialState
        self.recording = recording
        self.recordingState = recordingState
        self.muted = muted
        self.confined = confined
        self.held = held
        self.securePause = securePause
        self.errorInfo = errorInfo
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.direction = direction
        self.documentId = documentId
        self._self = _self
        self.other = other
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.disconnectReasons = disconnectReasons
        self.faxStatus = faxStatus
        self.uuiData = uuiData
        self.bargedTime = bargedTime
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.agentAssistantId = agentAssistantId
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case initialState
        case recording
        case recordingState
        case muted
        case confined
        case held
        case securePause
        case errorInfo
        case disconnectType
        case startHoldTime
        case direction
        case documentId
        case _self = "self"
        case other
        case provider
        case scriptId
        case peerId
        case connectedTime
        case disconnectedTime
        case disconnectReasons
        case faxStatus
        case uuiData
        case bargedTime
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case agentAssistantId
        case queueMediaSettings
    }


}




public class QueueConversationEventTopicConversation: Codable {

















    public var _id: String?
    public var maxParticipants: Int?
    public var participants: [QueueConversationEventTopicParticipant]?
    public var recentTransfers: [QueueConversationEventTopicRecentTransfer]?
    public var recordingState: String?
    public var address: String?
    public var externalTag: String?
    public var securePause: Bool?

    public init(_id: String?, maxParticipants: Int?, participants: [QueueConversationEventTopicParticipant]?, recentTransfers: [QueueConversationEventTopicRecentTransfer]?, recordingState: String?, address: String?, externalTag: String?, securePause: Bool?) {
        self._id = _id
        self.maxParticipants = maxParticipants
        self.participants = participants
        self.recentTransfers = recentTransfers
        self.recordingState = recordingState
        self.address = address
        self.externalTag = externalTag
        self.securePause = securePause
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case maxParticipants
        case participants
        case recentTransfers
        case recordingState
        case address
        case externalTag
        case securePause
    }


}




public class QueueConversationEventTopicDisconnectReason: Codable {

    public enum ModelType: String, Codable { 
        case q850 = "q850"
        case sip = "sip"
    }





    /** Disconnect reason protocol type. */
    public var type: ModelType?
    /** Protocol specific reason code. See the Q.850 and SIP specs. */
    public var code: Int?
    /** Human readable English description of the disconnect reason. */
    public var phrase: String?

    public init(type: ModelType?, code: Int?, phrase: String?) {
        self.type = type
        self.code = code
        self.phrase = phrase
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class QueueConversationEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int?

    public init(_id: String?, version: Int?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}



/** Metadata information about a message. */

public class QueueConversationEventTopicMessageMetadata: Codable {







    /** Message type. */
    public var type: String?
    /** List of message events, if any */
    public var events: [QueueConversationEventTopicMessageMetadataEvent]?
    /** List of message content, if any */
    public var content: [QueueConversationEventTopicMessageMetadataContent]?

    public init(type: String?, events: [QueueConversationEventTopicMessageMetadataEvent]?, content: [QueueConversationEventTopicMessageMetadataContent]?) {
        self.type = type
        self.events = events
        self.content = content
    }


}




public class QueueConversationEventTopicPhoneNumberColumn: Codable {





    public var columnName: String?
    public var type: String?

    public init(columnName: String?, type: String?) {
        self.columnName = columnName
        self.type = type
    }


}




public class QueueConversationEventTopicSocialExpression: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }





















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }













    public var state: State?
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** A globally unique identifier for the social media. */
    public var socialMediaId: String?
    /** The social network of the communication */
    public var socialMediaHub: String?
    /** The social media user name of the communication */
    public var socialUserName: String?
    /** The text preview of the communication contents */
    public var previewText: String?
    /** A globally unique identifier for the recording associated with this chat. */
    public var recordingId: String?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** The source provider of the social expression. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the chat was placed on hold in the cloud clock if the chat is currently on hold. */
    public var startHoldTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?

    public init(state: State?, initialState: InitialState?, _id: String?, socialMediaId: String?, socialMediaHub: String?, socialUserName: String?, previewText: String?, recordingId: String?, held: Bool?, provider: String?, scriptId: String?, peerId: String?, disconnectType: DisconnectType?, startHoldTime: Date?, connectedTime: Date?, disconnectedTime: Date?, wrapup: QueueConversationEventTopicWrapup?, afterCallWork: QueueConversationEventTopicAfterCallWork?, afterCallWorkRequired: Bool?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.socialMediaId = socialMediaId
        self.socialMediaHub = socialMediaHub
        self.socialUserName = socialUserName
        self.previewText = previewText
        self.recordingId = recordingId
        self.held = held
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case socialMediaId
        case socialMediaHub
        case socialUserName
        case previewText
        case recordingId
        case held
        case provider
        case scriptId
        case peerId
        case disconnectType
        case startHoldTime
        case connectedTime
        case disconnectedTime
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
    }


}



/** A UriReference for a resource */

public class QueueConversationEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class QueueConversationMessageEventTopicMessageMetadataContent: Codable {





    /** Type of this content element. */
    public var contentType: String?
    /** Content subtype, if any */
    public var subType: String?

    public init(contentType: String?, subType: String?) {
        self.contentType = contentType
        self.subType = subType
    }


}




public class QueueConversationMessageEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationScreenShareEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationScreenShareEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}




public class QueueConversationScreenShareEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: QueueConversationScreenShareEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int?

    public init(agent: QueueConversationScreenShareEventTopicUriReference?, score: Int?) {
        self.agent = agent
        self.score = score
    }


}




public class QueueConversationScreenShareEventTopicScreenShareMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case timeout = "timeout"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }







































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }

















    public var _id: String?
    public var name: String?
    public var address: String?
    public var startTime: Date?
    public var connectedTime: Date?
    public var endTime: Date?
    public var startHoldTime: Date?
    public var purpose: String?
    public var state: State?
    public var initialState: InitialState?
    public var direction: Direction?
    public var disconnectType: DisconnectType?
    public var held: Bool?
    public var wrapupRequired: Bool?
    public var wrapupPrompt: String?
    public var user: QueueConversationScreenShareEventTopicUriReference?
    public var queue: QueueConversationScreenShareEventTopicUriReference?
    public var team: QueueConversationScreenShareEventTopicUriReference?
    public var attributes: [String:String]?
    public var errorInfo: QueueConversationScreenShareEventTopicErrorBody?
    public var script: QueueConversationScreenShareEventTopicUriReference?
    public var wrapupTimeoutMs: Int?
    public var wrapupSkipped: Bool?
    public var alertingTimeoutMs: Int?
    public var provider: String?
    public var externalContact: QueueConversationScreenShareEventTopicUriReference?
    public var externalOrganization: QueueConversationScreenShareEventTopicUriReference?
    public var wrapup: QueueConversationScreenShareEventTopicWrapup?
    public var conversationRoutingData: QueueConversationScreenShareEventTopicConversationRoutingData?
    public var peer: String?
    public var screenRecordingState: String?
    public var flaggedReason: FlaggedReason?
    public var journeyContext: QueueConversationScreenShareEventTopicJourneyContext?
    public var startAcwTime: Date?
    public var endAcwTime: Date?
    public var mediaRoles: [String]?
    public var queueMediaSettings: QueueConversationScreenShareEventTopicQueueMediaSettings?
    public var context: String?
    public var peerCount: Int?
    public var sharing: Bool?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, initialState: InitialState?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, user: QueueConversationScreenShareEventTopicUriReference?, queue: QueueConversationScreenShareEventTopicUriReference?, team: QueueConversationScreenShareEventTopicUriReference?, attributes: [String:String]?, errorInfo: QueueConversationScreenShareEventTopicErrorBody?, script: QueueConversationScreenShareEventTopicUriReference?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, alertingTimeoutMs: Int?, provider: String?, externalContact: QueueConversationScreenShareEventTopicUriReference?, externalOrganization: QueueConversationScreenShareEventTopicUriReference?, wrapup: QueueConversationScreenShareEventTopicWrapup?, conversationRoutingData: QueueConversationScreenShareEventTopicConversationRoutingData?, peer: String?, screenRecordingState: String?, flaggedReason: FlaggedReason?, journeyContext: QueueConversationScreenShareEventTopicJourneyContext?, startAcwTime: Date?, endAcwTime: Date?, mediaRoles: [String]?, queueMediaSettings: QueueConversationScreenShareEventTopicQueueMediaSettings?, context: String?, peerCount: Int?, sharing: Bool?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.conversationRoutingData = conversationRoutingData
        self.peer = peer
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.mediaRoles = mediaRoles
        self.queueMediaSettings = queueMediaSettings
        self.context = context
        self.peerCount = peerCount
        self.sharing = sharing
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case initialState
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalOrganization
        case wrapup
        case conversationRoutingData
        case peer
        case screenRecordingState
        case flaggedReason
        case journeyContext
        case startAcwTime
        case endAcwTime
        case mediaRoles
        case queueMediaSettings
        case context
        case peerCount
        case sharing
    }


}



/** Address and name data for a call endpoint. */

public class QueueConversationSocialExpressionEventTopicAddress: Codable {











    /** This will be nameRaw if present, or a locality lookup of the address field otherwise. */
    public var name: String?
    /** The name as close to the bits on the wire as possible. */
    public var nameRaw: String?
    /** The normalized address. This field is acquired from the Address Normalization Table.  The addressRaw could have gone through some transformations, such as only using the numeric portion, before being run through the Address Normalization Table. */
    public var addressNormalized: String?
    /** The address as close to the bits on the wire as possible. */
    public var addressRaw: String?
    /** The displayable address. This field is acquired from the Address Normalization Table.  The addressRaw could have gone through some transformations, such as only using the numeric portion, before being run through the Address Normalization Table. */
    public var addressDisplayable: String?

    public init(name: String?, nameRaw: String?, addressNormalized: String?, addressRaw: String?, addressDisplayable: String?) {
        self.name = name
        self.nameRaw = nameRaw
        self.addressNormalized = addressNormalized
        self.addressRaw = addressRaw
        self.addressDisplayable = addressDisplayable
    }


}




public class QueueConversationSocialExpressionEventTopicCall: Codable {



    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case uploading = "uploading"
        case converting = "converting"
        case transmitting = "transmitting"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case uploading = "uploading"
        case converting = "converting"
        case transmitting = "transmitting"
        case _none = "none"
    }



    public enum RecordingState: String, Codable { 
        case _none = "none"
        case active = "active"
        case paused = "paused"
    }











    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }



    public enum Direction: String, Codable { 
        case outbound = "outbound"
        case inbound = "inbound"
    }



































    /** A globally unique identifier for this communication. */
    public var _id: String?
    public var state: State?
    public var initialState: InitialState?
    /** True if this call is being recorded. */
    public var recording: Bool?
    /** State of recording on this call. */
    public var recordingState: RecordingState?
    /** True if this call is muted so that remote participants can't hear any audio from this end. */
    public var muted: Bool?
    /** True if this call is held and the person on this side hears hold music. */
    public var confined: Bool?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** True when the recording of this call is in secure pause status. */
    public var securePause: Bool?
    public var errorInfo: QueueConversationSocialExpressionEventTopicErrorDetails?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the call was placed on hold in the cloud clock if the call is currently on hold. */
    public var startHoldTime: Date?
    /** Whether a call is inbound or outbound. */
    public var direction: Direction?
    /** If call is a fax of a document in content management, the id of the document in content management. */
    public var documentId: String?
    public var _self: QueueConversationSocialExpressionEventTopicAddress?
    /** Address and name data for a call endpoint. */
    public var other: QueueConversationSocialExpressionEventTopicAddress?
    /** The source provider of the call. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** List of reasons that this call was disconnected. This will be set once the call disconnects. */
    public var disconnectReasons: [QueueConversationSocialExpressionEventTopicDisconnectReason]?
    public var faxStatus: QueueConversationSocialExpressionEventTopicFaxStatus?
    /** User to User Information (UUI) data managed by SIP session application. */
    public var uuiData: String?
    /** The timestamp when this participant was connected to the barge conference in the provider clock. */
    public var bargedTime: Date?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationSocialExpressionEventTopicWrapup?
    public var afterCallWork: QueueConversationSocialExpressionEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** UUID of virtual agent assistant that provide suggestions to the agent participant during the conversation. */
    public var agentAssistantId: String?
    public var queueMediaSettings: QueueConversationSocialExpressionEventTopicQueueMediaSettings?

    public init(_id: String?, state: State?, initialState: InitialState?, recording: Bool?, recordingState: RecordingState?, muted: Bool?, confined: Bool?, held: Bool?, securePause: Bool?, errorInfo: QueueConversationSocialExpressionEventTopicErrorDetails?, disconnectType: DisconnectType?, startHoldTime: Date?, direction: Direction?, documentId: String?, _self: QueueConversationSocialExpressionEventTopicAddress?, other: QueueConversationSocialExpressionEventTopicAddress?, provider: String?, scriptId: String?, peerId: String?, connectedTime: Date?, disconnectedTime: Date?, disconnectReasons: [QueueConversationSocialExpressionEventTopicDisconnectReason]?, faxStatus: QueueConversationSocialExpressionEventTopicFaxStatus?, uuiData: String?, bargedTime: Date?, wrapup: QueueConversationSocialExpressionEventTopicWrapup?, afterCallWork: QueueConversationSocialExpressionEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, agentAssistantId: String?, queueMediaSettings: QueueConversationSocialExpressionEventTopicQueueMediaSettings?) {
        self._id = _id
        self.state = state
        self.initialState = initialState
        self.recording = recording
        self.recordingState = recordingState
        self.muted = muted
        self.confined = confined
        self.held = held
        self.securePause = securePause
        self.errorInfo = errorInfo
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.direction = direction
        self.documentId = documentId
        self._self = _self
        self.other = other
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.disconnectReasons = disconnectReasons
        self.faxStatus = faxStatus
        self.uuiData = uuiData
        self.bargedTime = bargedTime
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.agentAssistantId = agentAssistantId
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case initialState
        case recording
        case recordingState
        case muted
        case confined
        case held
        case securePause
        case errorInfo
        case disconnectType
        case startHoldTime
        case direction
        case documentId
        case _self = "self"
        case other
        case provider
        case scriptId
        case peerId
        case connectedTime
        case disconnectedTime
        case disconnectReasons
        case faxStatus
        case uuiData
        case bargedTime
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case agentAssistantId
        case queueMediaSettings
    }


}




public class QueueConversationSocialExpressionEventTopicConversation: Codable {

















    public var _id: String?
    public var maxParticipants: Int?
    public var participants: [QueueConversationSocialExpressionEventTopicParticipant]?
    public var recentTransfers: [QueueConversationSocialExpressionEventTopicRecentTransfer]?
    public var recordingState: String?
    public var address: String?
    public var externalTag: String?
    public var securePause: Bool?

    public init(_id: String?, maxParticipants: Int?, participants: [QueueConversationSocialExpressionEventTopicParticipant]?, recentTransfers: [QueueConversationSocialExpressionEventTopicRecentTransfer]?, recordingState: String?, address: String?, externalTag: String?, securePause: Bool?) {
        self._id = _id
        self.maxParticipants = maxParticipants
        self.participants = participants
        self.recentTransfers = recentTransfers
        self.recordingState = recordingState
        self.address = address
        self.externalTag = externalTag
        self.securePause = securePause
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case maxParticipants
        case participants
        case recentTransfers
        case recordingState
        case address
        case externalTag
        case securePause
    }


}




public class QueueConversationSocialExpressionEventTopicDisconnectReason: Codable {

    public enum ModelType: String, Codable { 
        case q850 = "q850"
        case sip = "sip"
    }





    /** Disconnect reason protocol type. */
    public var type: ModelType?
    /** Protocol specific reason code. See the Q.850 and SIP specs. */
    public var code: Int?
    /** Human readable English description of the disconnect reason. */
    public var phrase: String?

    public init(type: ModelType?, code: Int?, phrase: String?) {
        self.type = type
        self.code = code
        self.phrase = phrase
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class QueueConversationSocialExpressionEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int?

    public init(_id: String?, version: Int?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}



/** Metadata information about a message. */

public class QueueConversationSocialExpressionEventTopicMessageMetadata: Codable {







    /** Message type. */
    public var type: String?
    /** List of message events, if any */
    public var events: [QueueConversationSocialExpressionEventTopicMessageMetadataEvent]?
    /** List of message content, if any */
    public var content: [QueueConversationSocialExpressionEventTopicMessageMetadataContent]?

    public init(type: String?, events: [QueueConversationSocialExpressionEventTopicMessageMetadataEvent]?, content: [QueueConversationSocialExpressionEventTopicMessageMetadataContent]?) {
        self.type = type
        self.events = events
        self.content = content
    }


}




public class QueueConversationSocialExpressionEventTopicPhoneNumberColumn: Codable {





    public var columnName: String?
    public var type: String?

    public init(columnName: String?, type: String?) {
        self.columnName = columnName
        self.type = type
    }


}




public class QueueConversationSocialExpressionEventTopicSocialExpression: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }





















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }













    public var state: State?
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** A globally unique identifier for the social media. */
    public var socialMediaId: String?
    /** The social network of the communication */
    public var socialMediaHub: String?
    /** The social media user name of the communication */
    public var socialUserName: String?
    /** The text preview of the communication contents */
    public var previewText: String?
    /** A globally unique identifier for the recording associated with this chat. */
    public var recordingId: String?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** The source provider of the social expression. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the chat was placed on hold in the cloud clock if the chat is currently on hold. */
    public var startHoldTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationSocialExpressionEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationSocialExpressionEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?

    public init(state: State?, initialState: InitialState?, _id: String?, socialMediaId: String?, socialMediaHub: String?, socialUserName: String?, previewText: String?, recordingId: String?, held: Bool?, provider: String?, scriptId: String?, peerId: String?, disconnectType: DisconnectType?, startHoldTime: Date?, connectedTime: Date?, disconnectedTime: Date?, wrapup: QueueConversationSocialExpressionEventTopicWrapup?, afterCallWork: QueueConversationSocialExpressionEventTopicAfterCallWork?, afterCallWorkRequired: Bool?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.socialMediaId = socialMediaId
        self.socialMediaHub = socialMediaHub
        self.socialUserName = socialUserName
        self.previewText = previewText
        self.recordingId = recordingId
        self.held = held
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case socialMediaId
        case socialMediaHub
        case socialUserName
        case previewText
        case recordingId
        case held
        case provider
        case scriptId
        case peerId
        case disconnectType
        case startHoldTime
        case connectedTime
        case disconnectedTime
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
    }


}



/** A UriReference for a resource */

public class QueueConversationSocialExpressionEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}



/** A communication's after-call work data. */

public class QueueConversationVideoEventTopicAfterCallWork: Codable {

    public enum State: String, Codable { 
        case unknown = "unknown"
        case skipped = "skipped"
        case pending = "pending"
        case complete = "complete"
        case notapplicable = "notApplicable"
    }





    /** The communication's after-call work state. */
    public var state: State?
    /** The timestamp when this communication started after-call work in the cloud clock. */
    public var startTime: Date?
    /** The timestamp when this communication ended after-call work in the cloud clock. */
    public var endTime: Date?

    public init(state: State?, startTime: Date?, endTime: Date?) {
        self.state = state
        self.startTime = startTime
        self.endTime = endTime
    }


}



/** Information on how a communication should be routed to an agent. */

public class QueueConversationVideoEventTopicConversationRoutingData: Codable {











    public var queue: QueueConversationVideoEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: QueueConversationVideoEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int?
    /** The skills to use for routing decisions */
    public var skills: [QueueConversationVideoEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [QueueConversationVideoEventTopicScoredAgent]?

    public init(queue: QueueConversationVideoEventTopicUriReference?, language: QueueConversationVideoEventTopicUriReference?, priority: Int?, skills: [QueueConversationVideoEventTopicUriReference]?, scoredAgents: [QueueConversationVideoEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}



/** Detailed information about an error response. */

public class QueueConversationVideoEventTopicErrorDetails: Codable {















    /** The HTTP status code for this message (400, 401, 403, 404, 500, etc. */
    public var status: Int?
    /** A code unique to this error. */
    public var code: String?
    /** Friendly description of this error. */
    public var message: String?
    /** This is the same as message except it uses template fields for variable replacement. For instance: 'User {username} was not found' */
    public var messageWithParams: String?
    /** Used in conjunction with messageWithParams. These are the template parameters. For instance: UserParam.key = 'username', UserParam.value = 'john.doe' */
    public var messageParams: [String:String]?
    /** The correlation Id or context Id for this message. If left blank the Public API will look at the HTTP response header 'ININ-Correlation-Id' instead. */
    public var contextId: String?
    public var uri: String?

    public init(status: Int?, code: String?, message: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, uri: String?) {
        self.status = status
        self.code = code
        self.message = message
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.uri = uri
    }


}



/** Fields identifying the initiator of a given conversation command. */

public class QueueConversationVideoEventTopicInitiator: Codable {



    /** The id of the user who initiated the command if it was initiated by a user. */
    public var userId: String?

    public init(userId: String?) {
        self.userId = userId
    }


}




public class QueueMember: Codable {

















    /** The queue member's id. */
    public var _id: String?
    public var name: String?
    public var user: User?
    public var ringNumber: Int?
    public var joined: Bool?
    public var memberBy: String?
    public var routingStatus: RoutingStatus?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, user: User?, ringNumber: Int?, joined: Bool?, memberBy: String?, routingStatus: RoutingStatus?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.user = user
        self.ringNumber = ringNumber
        self.joined = joined
        self.memberBy = memberBy
        self.routingStatus = routingStatus
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case user
        case ringNumber
        case joined
        case memberBy
        case routingStatus
        case selfUri
    }


}




public class QueueObservationQueryResponse: Codable {





    /** A mapping from system presence to a list of organization presence ids */
    public var systemToOrganizationMappings: [String:[String]]?
    public var results: [QueueObservationDataContainer]?

    public init(systemToOrganizationMappings: [String:[String]]?, results: [QueueObservationDataContainer]?) {
        self.systemToOrganizationMappings = systemToOrganizationMappings
        self.results = results
    }


}




public class QueueRequest: Codable {































    public enum ScoringMethod: String, Codable { 
        case timestampAndPriority = "TimestampAndPriority"
        case priorityOnly = "PriorityOnly"
    }



    public enum SkillEvaluationMethod: String, Codable { 
        case _none = "NONE"
        case best = "BEST"
        case all = "ALL"
    }









































    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The queue name */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    /** The queue description. */
    public var _description: String?
    /** The date the queue was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the queue. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the queue. */
    public var modifiedBy: String?
    /** The ID of the user that created the queue. */
    public var createdBy: String?
    /** The total number of members in the queue. */
    public var memberCount: Int?
    /** The number of user members (i.e., non-group members) in the queue. */
    public var userMemberCount: Int?
    /** The number of joined members in the queue. */
    public var joinedMemberCount: Int?
    /** The media settings for the queue. */
    public var mediaSettings: QueueMediaSettings?
    /** The routing rules for the queue, used for Preferred Agent Routing. */
    public var routingRules: [RoutingRule]?
    /** The Conditional Group Routing settings for the queue. */
    public var conditionalGroupRouting: ConditionalGroupRouting?
    /** The bullseye settings for the queue. */
    public var bullseye: Bullseye?
    /** The Scoring Method for the queue */
    public var scoringMethod: ScoringMethod?
    /** The ACW settings for the queue. */
    public var acwSettings: AcwSettings?
    /** The skill evaluation method to use when routing conversations. */
    public var skillEvaluationMethod: SkillEvaluationMethod?
    /** The groups of agents associated with the queue, if any.  Queue membership will update to match group membership changes. */
    public var memberGroups: [MemberGroup]?
    /** The in-queue flow to use for call conversations waiting in queue. */
    public var queueFlow: DomainEntityRef?
    /** The in-queue flow to use for email conversations waiting in queue. */
    public var emailInQueueFlow: DomainEntityRef?
    /** The in-queue flow to use for message conversations waiting in queue. */
    public var messageInQueueFlow: DomainEntityRef?
    /** The prompt used for whisper on the queue, if configured. */
    public var whisperPrompt: DomainEntityRef?
    /** The audio to be played when calls on this queue are on hold. If not configured, the default on-hold music will play. */
    public var onHoldPrompt: DomainEntityRef?
    /** Specifies whether the configured whisper should play for all ACD calls, or only for those which are auto-answered. */
    public var autoAnswerOnly: Bool?
    /** Indicates whether voice transcription is enabled for this queue. */
    public var enableTranscription: Bool?
    /** Indicates whether audio monitoring is enabled for this queue. */
    public var enableAudioMonitoring: Bool?
    /** Indicates whether manual assignment is enabled for this queue. */
    public var enableManualAssignment: Bool?
    /** The Agent Owned Routing settings for the queue */
    public var agentOwnedRouting: AgentOwnedRouting?
    /** The Direct Routing settings for the queue */
    public var directRouting: DirectRouting?
    /** The name to use for caller identification for outbound calls from this queue. */
    public var callingPartyName: String?
    /** The phone number to use for caller identification for outbound calls from this queue. */
    public var callingPartyNumber: String?
    /** The default script Ids for the communication types. */
    public var defaultScripts: [String:Script]?
    /** The messaging addresses for the queue. */
    public var outboundMessagingAddresses: QueueMessagingAddresses?
    public var outboundEmailAddress: QueueEmailAddress?
    /** The ID of an associated external queue. */
    public var peerId: String?
    /** Indicates whether recording in-queue calls is suppressed for this queue. */
    public var suppressInQueueCallRecording: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, _description: String?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, memberCount: Int?, userMemberCount: Int?, joinedMemberCount: Int?, mediaSettings: QueueMediaSettings?, routingRules: [RoutingRule]?, conditionalGroupRouting: ConditionalGroupRouting?, bullseye: Bullseye?, scoringMethod: ScoringMethod?, acwSettings: AcwSettings?, skillEvaluationMethod: SkillEvaluationMethod?, memberGroups: [MemberGroup]?, queueFlow: DomainEntityRef?, emailInQueueFlow: DomainEntityRef?, messageInQueueFlow: DomainEntityRef?, whisperPrompt: DomainEntityRef?, onHoldPrompt: DomainEntityRef?, autoAnswerOnly: Bool?, enableTranscription: Bool?, enableAudioMonitoring: Bool?, enableManualAssignment: Bool?, agentOwnedRouting: AgentOwnedRouting?, directRouting: DirectRouting?, callingPartyName: String?, callingPartyNumber: String?, defaultScripts: [String:Script]?, outboundMessagingAddresses: QueueMessagingAddresses?, outboundEmailAddress: QueueEmailAddress?, peerId: String?, suppressInQueueCallRecording: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.memberCount = memberCount
        self.userMemberCount = userMemberCount
        self.joinedMemberCount = joinedMemberCount
        self.mediaSettings = mediaSettings
        self.routingRules = routingRules
        self.conditionalGroupRouting = conditionalGroupRouting
        self.bullseye = bullseye
        self.scoringMethod = scoringMethod
        self.acwSettings = acwSettings
        self.skillEvaluationMethod = skillEvaluationMethod
        self.memberGroups = memberGroups
        self.queueFlow = queueFlow
        self.emailInQueueFlow = emailInQueueFlow
        self.messageInQueueFlow = messageInQueueFlow
        self.whisperPrompt = whisperPrompt
        self.onHoldPrompt = onHoldPrompt
        self.autoAnswerOnly = autoAnswerOnly
        self.enableTranscription = enableTranscription
        self.enableAudioMonitoring = enableAudioMonitoring
        self.enableManualAssignment = enableManualAssignment
        self.agentOwnedRouting = agentOwnedRouting
        self.directRouting = directRouting
        self.callingPartyName = callingPartyName
        self.callingPartyNumber = callingPartyNumber
        self.defaultScripts = defaultScripts
        self.outboundMessagingAddresses = outboundMessagingAddresses
        self.outboundEmailAddress = outboundEmailAddress
        self.peerId = peerId
        self.suppressInQueueCallRecording = suppressInQueueCallRecording
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case memberCount
        case userMemberCount
        case joinedMemberCount
        case mediaSettings
        case routingRules
        case conditionalGroupRouting
        case bullseye
        case scoringMethod
        case acwSettings
        case skillEvaluationMethod
        case memberGroups
        case queueFlow
        case emailInQueueFlow
        case messageInQueueFlow
        case whisperPrompt
        case onHoldPrompt
        case autoAnswerOnly
        case enableTranscription
        case enableAudioMonitoring
        case enableManualAssignment
        case agentOwnedRouting
        case directRouting
        case callingPartyName
        case callingPartyNumber
        case defaultScripts
        case outboundMessagingAddresses
        case outboundEmailAddress
        case peerId
        case suppressInQueueCallRecording
        case selfUri
    }


}




public class RateLimitAggregateQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case correlationid = "correlationId"
        case entityid = "entityId"
        case limitname = "limitName"
        case max = "max"
        case namespace = "namespace"
        case timeunit = "timeUnit"
        case userid = "userId"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension predicates */
    public var value: String?
    /** Right hand side for dimension predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case _operator = "operator"
        case value
        case range
    }


}




public class RealTimeAdherenceExplanation: Codable {







    public enum Status: String, Codable { 
        case pending = "Pending"
        case approved = "Approved"
        case denied = "Denied"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The start timestamp of the adherence explanation in ISO-8601 format */
    public var startDate: Date?
    /** The length of the adherence explanation in minutes */
    public var lengthMinutes: Int?
    /** The status of the adherence explanation */
    public var status: Status?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, startDate: Date?, lengthMinutes: Int?, status: Status?, selfUri: String?) {
        self._id = _id
        self.startDate = startDate
        self.lengthMinutes = lengthMinutes
        self.status = status
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case startDate
        case lengthMinutes
        case status
        case selfUri
    }


}




public class Record: Codable {







    /** The name of the record. */
    public var name: String?
    /** The type of the record. (Example values:  MX, TXT, CNAME) */
    public var type: String?
    /** The value of the record. */
    public var value: String?

    public init(name: String?, type: String?, value: String?) {
        self.name = name
        self.type = type
        self.value = value
    }


}




public class RecordingArchiveRestoreTopicRecording: Codable {













    public var _id: String?
    public var conversationId: String?
    public var fileState: String?
    public var mediaUris: [RecordingArchiveRestoreTopicMediaResult]?
    public var estimatedTranscodeTimeMs: Int?
    public var actualTranscodeTimeMs: Int?

    public init(_id: String?, conversationId: String?, fileState: String?, mediaUris: [RecordingArchiveRestoreTopicMediaResult]?, estimatedTranscodeTimeMs: Int?, actualTranscodeTimeMs: Int?) {
        self._id = _id
        self.conversationId = conversationId
        self.fileState = fileState
        self.mediaUris = mediaUris
        self.estimatedTranscodeTimeMs = estimatedTranscodeTimeMs
        self.actualTranscodeTimeMs = actualTranscodeTimeMs
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case conversationId
        case fileState
        case mediaUris
        case estimatedTranscodeTimeMs
        case actualTranscodeTimeMs
    }


}



/** User actions available on the content. All actions are optional and all actions are executed simultaneously. */

public class RecordingContentActions: Codable {







    /** A URL of a web page to direct the user to. */
    public var url: String?
    /** The target window in which to open the URL. If empty will open a blank page or tab. */
    public var urlTarget: String?
    /** Text to be sent back in reply when the item is selected. */
    public var textback: String?

    public init(url: String?, urlTarget: String?, textback: String?) {
        self.url = url
        self.urlTarget = urlTarget
        self.textback = textback
    }


}




public class RecordingEmailMessage: Codable {





















    public var htmlBody: String?
    public var textBody: String?
    public var _id: String?
    public var to: [EmailAddress]?
    public var cc: [EmailAddress]?
    public var bcc: [EmailAddress]?
    public var from: EmailAddress?
    public var subject: String?
    public var attachments: [EmailAttachment]?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var time: Date?

    public init(htmlBody: String?, textBody: String?, _id: String?, to: [EmailAddress]?, cc: [EmailAddress]?, bcc: [EmailAddress]?, from: EmailAddress?, subject: String?, attachments: [EmailAttachment]?, time: Date?) {
        self.htmlBody = htmlBody
        self.textBody = textBody
        self._id = _id
        self.to = to
        self.cc = cc
        self.bcc = bcc
        self.from = from
        self.subject = subject
        self.attachments = attachments
        self.time = time
    }

    public enum CodingKeys: String, CodingKey { 
        case htmlBody
        case textBody
        case _id = "id"
        case to
        case cc
        case bcc
        case from
        case subject
        case attachments
        case time
    }


}




public class RecordingJobsQuery: Codable {

    public enum Action: String, Codable { 
        case archive = "ARCHIVE"
        case delete = "DELETE"
        case export = "EXPORT"
    }





















    /** Operation to perform bulk task. If the operation will cause the delete date of a recording to be older than the export date, the export date will be adjusted to the delete date. */
    public var action: Action?
    /** The date when the action will be performed. If screenRecordingActionDate is also provided, this value is only used for non-screen recordings. Otherwise this value is used for all recordings. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var actionDate: Date?
    /** The number of days after each recording's creation date when the action will be performed. If screenRecordingActionAge is also provided, this value is only used for non-screen recordings. Otherwise this value is used for all recordings. */
    public var actionAge: Int?
    /** The date when the action will be performed for screen recordings. If this is provided then includeScreenRecordings must be true. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var screenRecordingActionDate: Date?
    /** The number of days after each screen recording's creation date when the action will be performed. If this is provided then includeScreenRecordings must be true. */
    public var screenRecordingActionAge: Int?
    /** IntegrationId to Access AWS S3 bucket for bulk recording exports. This field is required and used only for EXPORT action. */
    public var integrationId: String?
    /** Whether to include recordings with PCI DSS and/or PII data, default value = false  */
    public var includeRecordingsWithSensitiveData: Bool?
    /** Whether to include Screen recordings for the action, default value = true  */
    public var includeScreenRecordings: Bool?
    /** For DELETE action, setting this to true will clear any pending exports for recordings. This field is only used for DELETE action. Default value = false */
    public var clearExport: Bool?
    /** Conversation Query. Note: After the recording is created, it might take up to 48 hours for the recording to be included in the submitted job query.  This result depends on the analytics data lake job completion. See also: https://developer.genesys.cloud/analyticsdatamanagement/analytics/jobs/conversation-details-job#data-availability.This is supported only when querying for conversations up to and including 5 years old. */
    public var conversationQuery: AsyncConversationQuery?
    /** As an alternative to conversationQuery, specify the date and time range of conversations that are older than 5 years to query.Results will include all conversations that had activity during the interval. This is supported only when querying for conversations older than 5 years;conversationQuery must not be provided when this is provided. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss.Interval duration must not exceed 6 months. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var agedConversationInterval: String?

    public init(action: Action?, actionDate: Date?, actionAge: Int?, screenRecordingActionDate: Date?, screenRecordingActionAge: Int?, integrationId: String?, includeRecordingsWithSensitiveData: Bool?, includeScreenRecordings: Bool?, clearExport: Bool?, conversationQuery: AsyncConversationQuery?, agedConversationInterval: String?) {
        self.action = action
        self.actionDate = actionDate
        self.actionAge = actionAge
        self.screenRecordingActionDate = screenRecordingActionDate
        self.screenRecordingActionAge = screenRecordingActionAge
        self.integrationId = integrationId
        self.includeRecordingsWithSensitiveData = includeRecordingsWithSensitiveData
        self.includeScreenRecordings = includeScreenRecordings
        self.clearExport = clearExport
        self.conversationQuery = conversationQuery
        self.agedConversationInterval = agedConversationInterval
    }


}




public class RecordingRetention: Codable {







    public enum ArchiveMedium: String, Codable { 
        case cloudarchive = "CLOUDARCHIVE"
    }









    public var conversationId: String?
    public var recordingId: String?
    /** The date the recording will be archived. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var archiveDate: Date?
    /** The type of archive medium used. Example: CloudArchive */
    public var archiveMedium: ArchiveMedium?
    /** The date the recording will be deleted. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var deleteDate: Date?
    /** The date the recording will be exported. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var exportDate: Date?
    /** The date the recording was exported. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var exportedDate: Date?
    /** The creation time of the recording. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var creationTime: Date?

    public init(conversationId: String?, recordingId: String?, archiveDate: Date?, archiveMedium: ArchiveMedium?, deleteDate: Date?, exportDate: Date?, exportedDate: Date?, creationTime: Date?) {
        self.conversationId = conversationId
        self.recordingId = recordingId
        self.archiveDate = archiveDate
        self.archiveMedium = archiveMedium
        self.deleteDate = deleteDate
        self.exportDate = exportDate
        self.exportedDate = exportedDate
        self.creationTime = creationTime
    }


}




public class RecordingRetentionCursorEntityListing: Codable {









    public var entities: [RecordingRetention]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [RecordingRetention]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class RecordingTranscodeCompleteTopicRecording: Codable {













    public var _id: String?
    public var conversationId: String?
    public var fileState: String?
    public var mediaUris: [RecordingTranscodeCompleteTopicMediaResult]?
    public var estimatedTranscodeTimeMs: Int?
    public var actualTranscodeTimeMs: Int?

    public init(_id: String?, conversationId: String?, fileState: String?, mediaUris: [RecordingTranscodeCompleteTopicMediaResult]?, estimatedTranscodeTimeMs: Int?, actualTranscodeTimeMs: Int?) {
        self._id = _id
        self.conversationId = conversationId
        self.fileState = fileState
        self.mediaUris = mediaUris
        self.estimatedTranscodeTimeMs = estimatedTranscodeTimeMs
        self.actualTranscodeTimeMs = actualTranscodeTimeMs
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case conversationId
        case fileState
        case mediaUris
        case estimatedTranscodeTimeMs
        case actualTranscodeTimeMs
    }


}




public class ReplaceResponse: Codable {











    public enum UploadMethod: String, Codable { 
        case singlePut = "SINGLE_PUT"
        case multipartPost = "MULTIPART_POST"
    }

    public var _id: String?
    public var name: String?
    public var changeNumber: Int?
    public var uploadStatus: DomainEntityRef?
    public var uploadDestinationUri: String?
    public var uploadMethod: UploadMethod?

    public init(_id: String?, name: String?, changeNumber: Int?, uploadStatus: DomainEntityRef?, uploadDestinationUri: String?, uploadMethod: UploadMethod?) {
        self._id = _id
        self.name = name
        self.changeNumber = changeNumber
        self.uploadStatus = uploadStatus
        self.uploadDestinationUri = uploadDestinationUri
        self.uploadMethod = uploadMethod
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case changeNumber
        case uploadStatus
        case uploadDestinationUri
        case uploadMethod
    }


}




public class ReplyToEmailAddress: Codable {





    /** The InboundDomain used for the email address. */
    public var domain: DomainEntityRef?
    /** The InboundRoute used for the email address. */
    public var route: DomainEntityRef?

    public init(domain: DomainEntityRef?, route: DomainEntityRef?) {
        self.domain = domain
        self.route = route
    }


}




public class ReportMetaDataEntityListing: Codable {





















    public var entities: [ReportMetaData]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ReportMetaData]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ReportRunEntryEntityDomainListing: Codable {





















    public var entities: [ReportRunEntry]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ReportRunEntry]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ReportingExportMetadataJobResponse: Codable {





    public enum ViewType: String, Codable { 
        case queuePerformanceSummaryView = "QUEUE_PERFORMANCE_SUMMARY_VIEW"
        case queuePerformanceDetailView = "QUEUE_PERFORMANCE_DETAIL_VIEW"
        case interactionSearchView = "INTERACTION_SEARCH_VIEW"
        case agentPerformanceSummaryView = "AGENT_PERFORMANCE_SUMMARY_VIEW"
        case agentPerformanceDetailView = "AGENT_PERFORMANCE_DETAIL_VIEW"
        case agentStatusSummaryView = "AGENT_STATUS_SUMMARY_VIEW"
        case agentStatusDetailView = "AGENT_STATUS_DETAIL_VIEW"
        case agentEvaluationSummaryView = "AGENT_EVALUATION_SUMMARY_VIEW"
        case agentEvaluationDetailView = "AGENT_EVALUATION_DETAIL_VIEW"
        case agentQueueDetailView = "AGENT_QUEUE_DETAIL_VIEW"
        case agentInteractionDetailView = "AGENT_INTERACTION_DETAIL_VIEW"
        case abandonInsightsView = "ABANDON_INSIGHTS_VIEW"
        case skillsPerformanceView = "SKILLS_PERFORMANCE_VIEW"
        case surveyFormPerformanceSummaryView = "SURVEY_FORM_PERFORMANCE_SUMMARY_VIEW"
        case surveyFormPerformanceDetailView = "SURVEY_FORM_PERFORMANCE_DETAIL_VIEW"
        case dnisPerformanceSummaryView = "DNIS_PERFORMANCE_SUMMARY_VIEW"
        case dnisPerformanceDetailView = "DNIS_PERFORMANCE_DETAIL_VIEW"
        case wrapUpPerformanceSummaryView = "WRAP_UP_PERFORMANCE_SUMMARY_VIEW"
        case agentWrapUpPerformanceDetailView = "AGENT_WRAP_UP_PERFORMANCE_DETAIL_VIEW"
        case queueActivitySummaryView = "QUEUE_ACTIVITY_SUMMARY_VIEW"
        case queueActivityDetailView = "QUEUE_ACTIVITY_DETAIL_VIEW"
        case agentQueueActivitySummaryView = "AGENT_QUEUE_ACTIVITY_SUMMARY_VIEW"
        case queueAgentDetailView = "QUEUE_AGENT_DETAIL_VIEW"
        case queueInteractionDetailView = "QUEUE_INTERACTION_DETAIL_VIEW"
        case agentScheduleDetailView = "AGENT_SCHEDULE_DETAIL_VIEW"
        case ivrPerformanceSummaryView = "IVR_PERFORMANCE_SUMMARY_VIEW"
        case ivrPerformanceDetailView = "IVR_PERFORMANCE_DETAIL_VIEW"
        case answerInsightsView = "ANSWER_INSIGHTS_VIEW"
        case handleInsightsView = "HANDLE_INSIGHTS_VIEW"
        case talkInsightsView = "TALK_INSIGHTS_VIEW"
        case holdInsightsView = "HOLD_INSIGHTS_VIEW"
        case acwInsightsView = "ACW_INSIGHTS_VIEW"
        case waitInsightsView = "WAIT_INSIGHTS_VIEW"
        case agentWrapUpPerformanceIntervalDetailView = "AGENT_WRAP_UP_PERFORMANCE_INTERVAL_DETAIL_VIEW"
        case flowOutcomeSummaryView = "FLOW_OUTCOME_SUMMARY_VIEW"
        case flowOutcomePerformanceDetailView = "FLOW_OUTCOME_PERFORMANCE_DETAIL_VIEW"
        case flowOutcomePerformanceIntervalDetailView = "FLOW_OUTCOME_PERFORMANCE_INTERVAL_DETAIL_VIEW"
        case flowDestinationSummaryView = "FLOW_DESTINATION_SUMMARY_VIEW"
        case flowDestinationDetailView = "FLOW_DESTINATION_DETAIL_VIEW"
        case apiUsageView = "API_USAGE_VIEW"
        case scheduledCallbacksView = "SCHEDULED_CALLBACKS_VIEW"
        case contentSearchView = "CONTENT_SEARCH_VIEW"
        case landingPage = "LANDING_PAGE"
        case dashboardSummary = "DASHBOARD_SUMMARY"
        case dashboardDetail = "DASHBOARD_DETAIL"
        case dashboardUsers = "DASHBOARD_USERS"
        case dashboardUsersDetail = "DASHBOARD_USERS_DETAIL"
        case journeyActionMapSummaryView = "JOURNEY_ACTION_MAP_SUMMARY_VIEW"
        case journeyOutcomeSummaryView = "JOURNEY_OUTCOME_SUMMARY_VIEW"
        case journeySegmentSummaryView = "JOURNEY_SEGMENT_SUMMARY_VIEW"
        case agentDevelopmentDetailView = "AGENT_DEVELOPMENT_DETAIL_VIEW"
        case agentDevelopmentDetailMeView = "AGENT_DEVELOPMENT_DETAIL_ME_VIEW"
        case agentDevelopmentSummaryView = "AGENT_DEVELOPMENT_SUMMARY_VIEW"
        case agentPerformanceMeView = "AGENT_PERFORMANCE_ME_VIEW"
        case agentStatusMeView = "AGENT_STATUS_ME_VIEW"
        case agentEvaluationMeView = "AGENT_EVALUATION_ME_VIEW"
        case agentScorecardView = "AGENT_SCORECARD_VIEW"
        case agentScorecardMeView = "AGENT_SCORECARD_ME_VIEW"
        case agentGamificationLeadershipView = "AGENT_GAMIFICATION_LEADERSHIP_VIEW"
        case agentScheduleMeView = "AGENT_SCHEDULE_ME_VIEW"
        case botPerformanceSummaryView = "BOT_PERFORMANCE_SUMMARY_VIEW"
        case botPerformanceDetailView = "BOT_PERFORMANCE_DETAIL_VIEW"
        case scheduledExportsView = "SCHEDULED_EXPORTS_VIEW"
        case topicTrendSummaryView = "TOPIC_TREND_SUMMARY_VIEW"
        case topicTrendDetailView = "TOPIC_TREND_DETAIL_VIEW"
        case actionMapBlockedConstraintsDetailView = "ACTION_MAP_BLOCKED_CONSTRAINTS_DETAIL_VIEW"
        case actionMapBlockedConstraintsIntervalDetailView = "ACTION_MAP_BLOCKED_CONSTRAINTS_INTERVAL_DETAIL_VIEW"
        case flowMilestonePerformanceDetailView = "FLOW_MILESTONE_PERFORMANCE_DETAIL_VIEW"
        case flowMilestonePerformanceIntervalDetailView = "FLOW_MILESTONE_PERFORMANCE_INTERVAL_DETAIL_VIEW"
        case agentTopicSummaryView = "AGENT_TOPIC_SUMMARY_VIEW"
        case agentTopicDetailView = "AGENT_TOPIC_DETAIL_VIEW"
        case queueTopicSummaryView = "QUEUE_TOPIC_SUMMARY_VIEW"
        case queueTopicDetailView = "QUEUE_TOPIC_DETAIL_VIEW"
        case flowTopicSummaryView = "FLOW_TOPIC_SUMMARY_VIEW"
        case flowTopicDetailView = "FLOW_TOPIC_DETAIL_VIEW"
        case agentInteractionsMeView = "AGENT_INTERACTIONS_ME_VIEW"
        case alertRulesView = "ALERT_RULES_VIEW"
        case configureAlertRuleView = "CONFIGURE_ALERT_RULE_VIEW"
        case predictiveRoutingView = "PREDICTIVE_ROUTING_VIEW"
        case predictiveRoutingQueueOverview = "PREDICTIVE_ROUTING_QUEUE_OVERVIEW"
        case predictiveRoutingModelView = "PREDICTIVE_ROUTING_MODEL_VIEW"
        case predictiveRoutingImpactView = "PREDICTIVE_ROUTING_IMPACT_VIEW"
        case dataActionsPerformanceSummaryView = "DATA_ACTIONS_PERFORMANCE_SUMMARY_VIEW"
        case dataActionsPerformanceDetailView = "DATA_ACTIONS_PERFORMANCE_DETAIL_VIEW"
        case agentTimelineSummaryView = "AGENT_TIMELINE_SUMMARY_VIEW"
        case agentTimelineDetailView = "AGENT_TIMELINE_DETAIL_VIEW"
        case agentLoginLogoutSummaryView = "AGENT_LOGIN_LOGOUT_SUMMARY_VIEW"
        case agentLoginLogoutDetailView = "AGENT_LOGIN_LOGOUT_DETAIL_VIEW"
        case campaignPerformanceSummaryView = "CAMPAIGN_PERFORMANCE_SUMMARY_VIEW"
        case campaignPerformanceDetailView = "CAMPAIGN_PERFORMANCE_DETAIL_VIEW"
        case knowledgePerformanceView = "KNOWLEDGE_PERFORMANCE_VIEW"
        case agentScorecardInsightsSummaryView = "AGENT_SCORECARD_INSIGHTS_SUMMARY_VIEW"
        case agentScorecardInsightsDetailView = "AGENT_SCORECARD_INSIGHTS_DETAIL_VIEW"
        case queueWrapupDetailView = "QUEUE_WRAPUP_DETAIL_VIEW"
        case interactionDetailView = "INTERACTION_DETAIL_VIEW"
        case campaignInteractionDetailView = "CAMPAIGN_INTERACTION_DETAIL_VIEW"
        case campaignAttemptDetailView = "CAMPAIGN_ATTEMPT_DETAIL_VIEW"
        case workitemPerformanceSummaryView = "WORKITEM_PERFORMANCE_SUMMARY_VIEW"
        case agentAssistPerformanceView = "AGENT_ASSIST_PERFORMANCE_VIEW"
        case contactCenterPerformanceView = "CONTACT_CENTER_PERFORMANCE_VIEW"
        case queueRoutingPerformanceView = "QUEUE_ROUTING_PERFORMANCE_VIEW"
        case agentWorkitemPerformanceSummaryView = "AGENT_WORKITEM_PERFORMANCE_SUMMARY_VIEW"
        case agentWorkitemPerformanceDetailView = "AGENT_WORKITEM_PERFORMANCE_DETAIL_VIEW"
        case queueWorkitemPerformanceSummaryView = "QUEUE_WORKITEM_PERFORMANCE_SUMMARY_VIEW"
        case queueWorkitemPerformanceDetailView = "QUEUE_WORKITEM_PERFORMANCE_DETAIL_VIEW"
    }















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The view type of the export metadata */
    public var viewType: ViewType?
    /** The date limitations of the export metadata */
    public var dateLimitations: String?
    /** The list of required filters for the export metadata */
    public var requiredFilters: [String]?
    /** The list of supported filters for the export metadata */
    public var supportedFilters: [String]?
    /** The list of required column ids for the export metadata */
    public var requiredColumnIds: [String]?
    /** The list of dependent column ids for the export metadata */
    public var dependentColumnIds: [String:[String]]?
    /** The list of available column ids for the export metadata */
    public var availableColumnIds: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, viewType: ViewType?, dateLimitations: String?, requiredFilters: [String]?, supportedFilters: [String]?, requiredColumnIds: [String]?, dependentColumnIds: [String:[String]]?, availableColumnIds: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.viewType = viewType
        self.dateLimitations = dateLimitations
        self.requiredFilters = requiredFilters
        self.supportedFilters = supportedFilters
        self.requiredColumnIds = requiredColumnIds
        self.dependentColumnIds = dependentColumnIds
        self.availableColumnIds = availableColumnIds
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case viewType
        case dateLimitations
        case requiredFilters
        case supportedFilters
        case requiredColumnIds
        case dependentColumnIds
        case availableColumnIds
        case selfUri
    }


}




public class ReportingTurnKnowledge: Codable {







    /** The Knowledge Base ID that the captured knowledge data relates to. */
    public var knowledgeBaseId: String?
    /** The knowledge feedback data that was captured during this reporting turn. */
    public var feedback: ReportingTurnKnowledgeFeedback?
    /** The knowledge search data that was captured during this reporting turn. */
    public var search: ReportingTurnKnowledgeSearch?

    public init(knowledgeBaseId: String?, feedback: ReportingTurnKnowledgeFeedback?, search: ReportingTurnKnowledgeSearch?) {
        self.knowledgeBaseId = knowledgeBaseId
        self.feedback = feedback
        self.search = search
    }


}




public class RequestDevice: Codable {

    public enum Category: String, Codable { 
        case desktop = "desktop"
        case mobile = "mobile"
        case tablet = "tablet"
        case other = "other"
    }



















    /** Device category. */
    public var category: Category?
    /** Device type (e.g. iPad, iPhone, Other). */
    public var type: String?
    /** Flag that is true for mobile devices. */
    public var isMobile: Bool?
    /** Device's screen height. */
    public var screenHeight: Int?
    /** Device's screen width. */
    public var screenWidth: Int?
    /** Device's screen density, measured as a scale factor where a value of 1 represents a baseline 1:1 ratio of pixels to logical (device-independent) pixels. */
    public var screenDensity: Int?
    /** Fingerprint generated by looking at the individual device features. */
    public var fingerprint: String?
    /** Operating system family. */
    public var osFamily: String?
    /** Operating system version. */
    public var osVersion: String?
    /** Manufacturer of the device. */
    public var manufacturer: String?

    public init(category: Category?, type: String?, isMobile: Bool?, screenHeight: Int?, screenWidth: Int?, screenDensity: Int?, fingerprint: String?, osFamily: String?, osVersion: String?, manufacturer: String?) {
        self.category = category
        self.type = type
        self.isMobile = isMobile
        self.screenHeight = screenHeight
        self.screenWidth = screenWidth
        self.screenDensity = screenDensity
        self.fingerprint = fingerprint
        self.osFamily = osFamily
        self.osVersion = osVersion
        self.manufacturer = manufacturer
    }


}




public class RequestJourneyPattern: Codable {





    public enum StreamType: String, Codable { 
        case web = "Web"
        case custom = "Custom"
        case conversation = "Conversation"
        case app = "App"
    }





    /** A list of one or more criteria to satisfy. */
    public var criteria: [RequestCriteria]?
    /** The number of times the pattern must match. */
    public var count: Int?
    /** The stream type for which this pattern can be matched on. */
    public var streamType: StreamType?
    /** The session type for which this pattern can be matched on. */
    public var sessionType: String?
    /** The name of the event for which this pattern can be matched on. */
    public var eventName: String?

    public init(criteria: [RequestCriteria]?, count: Int?, streamType: StreamType?, sessionType: String?, eventName: String?) {
        self.criteria = criteria
        self.count = count
        self.streamType = streamType
        self.sessionType = sessionType
        self.eventName = eventName
    }


}




public class ResponseAssetSearchRequest: Codable {





    public enum SortOrder: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
    }





    /** The number of results per page. Default: 25, Maximum: 100. */
    public var pageSize: Int?
    /** The page of resources you want to retrieve */
    public var pageNumber: Int?
    /** The sort order for results */
    public var sortOrder: SortOrder?
    /** The field in the resource that you want to sort the results by */
    public var sortBy: String?
    /** Filter the query results. */
    public var query: [ResponseAssetFilter]?

    public init(pageSize: Int?, pageNumber: Int?, sortOrder: SortOrder?, sortBy: String?, query: [ResponseAssetFilter]?) {
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.sortOrder = sortOrder
        self.sortBy = sortBy
        self.query = query
    }


}




public class ResponseSet: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the ResponseSet. */
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** Map of disposition identifiers to reactions. For example: {\"disposition.classification.callable.person\": {\"reactionType\": \"transfer\"}}. */
    public var responses: [String:Reaction]?
    /** Whether to enable answering machine beep detection */
    public var beepDetectionEnabled: Bool?
    /** Whether to enable answering machine detection */
    public var amdSpeechDistinguishEnabled: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, responses: [String:Reaction]?, beepDetectionEnabled: Bool?, amdSpeechDistinguishEnabled: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.responses = responses
        self.beepDetectionEnabled = beepDetectionEnabled
        self.amdSpeechDistinguishEnabled = amdSpeechDistinguishEnabled
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case responses
        case beepDetectionEnabled
        case amdSpeechDistinguishEnabled
        case selfUri
    }


}




public class RoleDivisionGrants: Codable {



    /** A list containing pairs of role and division IDs */
    public var grants: [RoleDivisionPair]?

    public init(grants: [RoleDivisionPair]?) {
        self.grants = grants
    }


}




public class RoutingConversationAttributesRequest: Codable {









    /** Priority for the conversation.  Each point of priority is equivalent to one minute of time in queue.  Range:[-25000000, 25000000].  To reset, specify 0. */
    public var priority: Int?
    /** Skill requirements for the conversation.  To remove all skill requirements, specify an empty list, i.e. []. */
    public var skillIds: [String]?
    /** Language requirement for the conversation.  To remove the language requirement, specify an empty string, i.e., \"\". */
    public var languageId: String?
    public var requestScoredAgents: [RequestScoredAgent]?

    public init(priority: Int?, skillIds: [String]?, languageId: String?, requestScoredAgents: [RequestScoredAgent]?) {
        self.priority = priority
        self.skillIds = skillIds
        self.languageId = languageId
        self.requestScoredAgents = requestScoredAgents
    }


}




public class RoutingData: Codable {

















    /** The identifier of the routing queue */
    public var queueId: String?
    /** The identifier of a language to be considered in routing */
    public var languageId: String?
    /** An optional label that categorizes the conversation.  Max-utilization settings can be configured at a per-label level */
    public var label: String?
    /** The priority for routing */
    public var priority: Int?
    /** A list of skill identifiers to be considered in routing */
    public var skillIds: [String]?
    /** A list of agents to be preferred in routing */
    public var preferredAgentIds: [String]?
    /** A list of scored agents for routing decisions. For Agent Owned Callbacks use one scored agent with a score of 100. */
    public var scoredAgents: [ScoredAgent]?
    /** An array of flags indicating how the conversation should be routed. Use \"AGENT_OWNED_CALLBACK\" when creating an Agent Owned Callback. */
    public var routingFlags: [String]?

    public init(queueId: String?, languageId: String?, label: String?, priority: Int?, skillIds: [String]?, preferredAgentIds: [String]?, scoredAgents: [ScoredAgent]?, routingFlags: [String]?) {
        self.queueId = queueId
        self.languageId = languageId
        self.label = label
        self.priority = priority
        self.skillIds = skillIds
        self.preferredAgentIds = preferredAgentIds
        self.scoredAgents = scoredAgents
        self.routingFlags = routingFlags
    }


}




public class RoutingRule: Codable {

    public enum Operator: String, Codable { 
        case meetsThreshold = "MEETS_THRESHOLD"
        case any = "ANY"
    }





    /** matching operator.  MEETS_THRESHOLD matches any agent with a score at or above the rule's threshold.  ANY matches all specified agents, regardless of score. */
    public var _operator: Operator?
    /** threshold required for routing attempt (generally an agent score).  may be null for operator ANY. */
    public var threshold: Int?
    /** seconds to wait in this rule before moving to the next */
    public var waitSeconds: Double?

    public init(_operator: Operator?, threshold: Int?, waitSeconds: Double?) {
        self._operator = _operator
        self.threshold = threshold
        self.waitSeconds = waitSeconds
    }

    public enum CodingKeys: String, CodingKey { 
        case _operator = "operator"
        case threshold
        case waitSeconds
    }


}




public class RoutingStatusDetailQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [RoutingStatusDetailQueryPredicate]?

    public init(type: ModelType?, predicates: [RoutingStatusDetailQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class RuleSetDiagnostic: Codable {



    public enum Warnings: String, Codable { 
        case wrapupCodeNotInQueue = "WRAPUP_CODE_NOT_IN_QUEUE"
        case contactAttributeNotInContactList = "CONTACT_ATTRIBUTE_NOT_IN_CONTACT_LIST"
        case noDncListForAppend = "NO_DNC_LIST_FOR_APPEND"
        case phoneConditionsWithMulticolumnPreview = "PHONE_CONDITIONS_WITH_MULTICOLUMN_PREVIEW"
    }

    /** A campaign rule set */
    public var ruleSet: DomainEntityRef?
    /** Diagnostic warnings for the rule set */
    public var warnings: [Warnings]?

    public init(ruleSet: DomainEntityRef?, warnings: [Warnings]?) {
        self.ruleSet = ruleSet
        self.warnings = warnings
    }


}




public class SchedulingTestingOptionsRequest: Codable {











    /** Whether to enable fast scheduling */
    public var fastScheduling: Bool?
    /** Whether to force delayed scheduling */
    public var delayScheduling: Bool?
    /** Whether to force scheduling to fail */
    public var failScheduling: Bool?
    /** Whether to populate warnings in the generated schedule */
    public var populateWarnings: Bool?
    /** Whether to populate deprecated warnings in the generated schedule */
    public var populateDeprecatedWarnings: Bool?

    public init(fastScheduling: Bool?, delayScheduling: Bool?, failScheduling: Bool?, populateWarnings: Bool?, populateDeprecatedWarnings: Bool?) {
        self.fastScheduling = fastScheduling
        self.delayScheduling = delayScheduling
        self.failScheduling = failScheduling
        self.populateWarnings = populateWarnings
        self.populateDeprecatedWarnings = populateDeprecatedWarnings
    }


}




public class SchemaQuantityLimits: Codable {





























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The minimum number of schema field name characters allowed. */
    public var minFieldNameCharacters: Int?
    /** The maximum number of schema field name characters allowed. */
    public var maxFieldNameCharacters: Int?
    /** The minimum number of schema field description characters allowed. */
    public var minFieldDescriptionCharacters: Int?
    /** The maximum number of schema field description characters allowed. */
    public var maxFieldDescriptionCharacters: Int?
    /** The minimum number of schema name characters allowed. */
    public var minSchemaNameCharacters: Int?
    /** The maximum number of schema name characters allowed. */
    public var maxSchemaNameCharacters: Int?
    /** The minimum number of schema description characters allowed. */
    public var minSchemaDescriptionCharacters: Int?
    /** The maximum number of schema description characters allowed. */
    public var maxSchemaDescriptionCharacters: Int?
    /** The maximum number of schema allowed per org. */
    public var maxNumberOfSchemasPerOrg: Int?
    /** The maximum number of schema fields allowed per schema. */
    public var maxNumberOfFieldsPerSchema: Int?
    /** The maximum number of schema fields allowed per organization across all of their schemas. */
    public var maxNumberOfFieldsPerOrg: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, minFieldNameCharacters: Int?, maxFieldNameCharacters: Int?, minFieldDescriptionCharacters: Int?, maxFieldDescriptionCharacters: Int?, minSchemaNameCharacters: Int?, maxSchemaNameCharacters: Int?, minSchemaDescriptionCharacters: Int?, maxSchemaDescriptionCharacters: Int?, maxNumberOfSchemasPerOrg: Int?, maxNumberOfFieldsPerSchema: Int?, maxNumberOfFieldsPerOrg: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.minFieldNameCharacters = minFieldNameCharacters
        self.maxFieldNameCharacters = maxFieldNameCharacters
        self.minFieldDescriptionCharacters = minFieldDescriptionCharacters
        self.maxFieldDescriptionCharacters = maxFieldDescriptionCharacters
        self.minSchemaNameCharacters = minSchemaNameCharacters
        self.maxSchemaNameCharacters = maxSchemaNameCharacters
        self.minSchemaDescriptionCharacters = minSchemaDescriptionCharacters
        self.maxSchemaDescriptionCharacters = maxSchemaDescriptionCharacters
        self.maxNumberOfSchemasPerOrg = maxNumberOfSchemasPerOrg
        self.maxNumberOfFieldsPerSchema = maxNumberOfFieldsPerSchema
        self.maxNumberOfFieldsPerOrg = maxNumberOfFieldsPerOrg
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case minFieldNameCharacters
        case maxFieldNameCharacters
        case minFieldDescriptionCharacters
        case maxFieldDescriptionCharacters
        case minSchemaNameCharacters
        case maxSchemaNameCharacters
        case minSchemaDescriptionCharacters
        case maxSchemaDescriptionCharacters
        case maxNumberOfSchemasPerOrg
        case maxNumberOfFieldsPerSchema
        case maxNumberOfFieldsPerOrg
        case selfUri
    }


}



/** Defines a SCIM resource. */

public class ScimConfigResourceType: Codable {

















    /** The ID of the SCIM resource. Set by the service provider. \"caseExact\" is set to \"true\". \"mutability\" is set to \"readOnly\". \"returned\" is set to \"always\". */
    public var _id: String?
    /** The list of supported schemas. */
    public var schemas: [String]?
    /** The name of the resource type. */
    public var name: String?
    /** The description of the resource type. */
    public var _description: String?
    /** The URI of the primary or base schema for the resource type. */
    public var schema: String?
    /** The list of schema extensions for the resource type. */
    public var schemaExtensions: [ScimConfigResourceTypeSchemaExtension]?
    /** The HTTP-addressable endpoint of the resource type. Appears after the base URL. */
    public var endpoint: String?
    /** The metadata of the SCIM resource. Only \"location\" and \"resourceType\" are set for \"ResourceType\" resources. */
    public var meta: ScimMetadata?

    public init(_id: String?, schemas: [String]?, name: String?, _description: String?, schema: String?, schemaExtensions: [ScimConfigResourceTypeSchemaExtension]?, endpoint: String?, meta: ScimMetadata?) {
        self._id = _id
        self.schemas = schemas
        self.name = name
        self._description = _description
        self.schema = schema
        self.schemaExtensions = schemaExtensions
        self.endpoint = endpoint
        self.meta = meta
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case schemas
        case name
        case _description = "description"
        case schema
        case schemaExtensions
        case endpoint
        case meta
    }


}



/** Defines a SCIM resource type's schema extension. */

public class ScimConfigResourceTypeSchemaExtension: Codable {





    /** The URI of an extended schema, for example, \"urn:edu:2.0:Staff\". Must be equal to the \"id\" attribute of a schema. */
    public var schema: String?
    /** Indicates whether a schema extension is required. */
    public var _required: Bool?

    public init(schema: String?, _required: Bool?) {
        self.schema = schema
        self._required = _required
    }

    public enum CodingKeys: String, CodingKey { 
        case schema
        case _required = "required"
    }


}



/** Defines the SCIM metadata. */

public class ScimMetadata: Codable {

    public enum ResourceType: String, Codable { 
        case user = "User"
        case group = "Group"
        case serviceProviderConfig = "ServiceProviderConfig"
        case resourceType = "ResourceType"
        case schema = "Schema"
    }







    /** The type of SCIM resource. */
    public var resourceType: ResourceType?
    /** The last time that the resource was modified. Date time is represented as an \"ISO-8601 string\", for example, yyyy-MM-ddTHH:mm:ss.SSSZ. Not included with \"Schema\" and \"ResourceType\" resources. */
    public var lastModified: Date?
    /** The URI of the resource. */
    public var location: String?
    /** The version of the resource. Matches the ETag HTTP response header. Not included with \"Schema\" and \"ResourceType\" resources. */
    public var version: String?

    public init(resourceType: ResourceType?, lastModified: Date?, location: String?, version: String?) {
        self.resourceType = resourceType
        self.lastModified = lastModified
        self.location = location
        self.version = version
    }


}



/** Defines an authentication scheme in the SCIM service provider's configuration. */

public class ScimServiceProviderConfigAuthenticationScheme: Codable {









    public enum ModelType: String, Codable { 
        case oauth = "oauth"
        case oauth2 = "oauth2"
        case oauthbearertoken = "oauthbearertoken"
        case httpbasic = "httpbasic"
        case httpdigest = "httpdigest"
    }



    /** The name of the authentication scheme, for example, HTTP Basic. */
    public var name: String?
    /** The description of the authentication scheme. */
    public var _description: String?
    /** The HTTP-addressable URL that points to the authentication scheme's specification. */
    public var specUri: String?
    /** The HTTP-addressable URL that points to the authentication scheme's usage documentation. */
    public var documentationUri: String?
    /** The type of authentication scheme. */
    public var type: ModelType?
    /** Indicates whether this authentication scheme is the primary method of authentication. */
    public var primary: Bool?

    public init(name: String?, _description: String?, specUri: String?, documentationUri: String?, type: ModelType?, primary: Bool?) {
        self.name = name
        self._description = _description
        self.specUri = specUri
        self.documentationUri = documentationUri
        self.type = type
        self.primary = primary
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _description = "description"
        case specUri
        case documentationUri
        case type
        case primary
    }


}



/** Defines a \"bulk\" request in the SCIM service provider's configuration. */

public class ScimServiceProviderConfigBulkFeature: Codable {







    /** Indicates whether configuration options are supported. */
    public var supported: Bool?
    /** The maximum number of operations for each bulk request. */
    public var maxOperations: Int?
    /** The maximum payload size. */
    public var maxPayloadSize: Int?

    public init(supported: Bool?, maxOperations: Int?, maxPayloadSize: Int?) {
        self.supported = supported
        self.maxOperations = maxOperations
        self.maxPayloadSize = maxPayloadSize
    }


}



/** Defines a request in the SCIM service provider's configuration. */

public class ScimServiceProviderConfigSimpleFeature: Codable {



    /** Indicates whether configuration options are supported. */
    public var supported: Bool?

    public init(supported: Bool?) {
        self.supported = supported
    }


}



/** Defines a SCIM group. */

public class ScimV2Group: Codable {













    /** The ID of the SCIM resource. Set by the service provider. \"caseExact\" is set to \"true\". \"mutability\" is set to \"readOnly\". \"returned\" is set to \"always\". */
    public var _id: String?
    /** The list of supported schemas. */
    public var schemas: [String]?
    /** The display name of the group. */
    public var displayName: String?
    /** The external ID of the group. Set by the provisioning client. \"caseExact\" is set to \"true\". \"mutability\" is set to \"readWrite\". */
    public var externalId: String?
    /** The list of members in the group. */
    public var members: [ScimV2MemberReference]?
    /** The metadata of the SCIM resource. Metadata is defined as immutable per SCIM RFC. */
    public var meta: ScimMetadata?

    public init(_id: String?, schemas: [String]?, displayName: String?, externalId: String?, members: [ScimV2MemberReference]?, meta: ScimMetadata?) {
        self._id = _id
        self.schemas = schemas
        self.displayName = displayName
        self.externalId = externalId
        self.members = members
        self.meta = meta
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case schemas
        case displayName
        case externalId
        case members
        case meta
    }


}



/** Defines a SCIM user. */

public class ScimV2User: Codable {































    /** The ID of the SCIM resource. Set by the service provider. \"caseExact\" is set to \"true\". \"mutability\" is set to \"readOnly\". \"returned\" is set to \"always\". */
    public var _id: String?
    /** The list of supported schemas. */
    public var schemas: [String]?
    /** Indicates whether the user's administrative status is active. */
    public var active: Bool?
    /** The user's Genesys Cloud email address. Must be unique. */
    public var userName: String?
    /** The display name of the user. */
    public var displayName: String?
    /** The new password for the Genesys Cloud user. Does not return an existing password. When creating a user, if a password is not supplied, then a password will be randomly generated that is 40 characters in length and contains five characters from each of the password policy groups. */
    public var password: String?
    /** The user's title. */
    public var title: String?
    /** The list of the user's phone numbers. */
    public var phoneNumbers: [ScimPhoneNumber]?
    /** The list of the user's email addresses. */
    public var emails: [ScimEmail]?
    /** The external ID of the user. Set by the provisioning client. \"caseExact\" is set to \"true\". \"mutability\" is set to \"readWrite\". */
    public var externalId: String?
    /** The list of groups that the user is a member of. This list is immutable per SCIM RFC and may only be updated using the GROUPS resource endpoint. */
    public var groups: [ScimV2GroupReference]?
    /** The list of roles assigned to the user. */
    public var roles: [ScimUserRole]?
    /** The URI of the schema for the enterprise user. */
    public var urnietfparamsscimschemasextensionenterprise20User: ScimV2EnterpriseUser?
    /** The URI of the schema for the Genesys Cloud user. */
    public var urnietfparamsscimschemasextensiongenesyspurecloud20User: ScimUserExtensions?
    /** The metadata of the SCIM resource. Metadata is defined as immutable per SCIM RFC. */
    public var meta: ScimMetadata?

    public init(_id: String?, schemas: [String]?, active: Bool?, userName: String?, displayName: String?, password: String?, title: String?, phoneNumbers: [ScimPhoneNumber]?, emails: [ScimEmail]?, externalId: String?, groups: [ScimV2GroupReference]?, roles: [ScimUserRole]?, urnietfparamsscimschemasextensionenterprise20User: ScimV2EnterpriseUser?, urnietfparamsscimschemasextensiongenesyspurecloud20User: ScimUserExtensions?, meta: ScimMetadata?) {
        self._id = _id
        self.schemas = schemas
        self.active = active
        self.userName = userName
        self.displayName = displayName
        self.password = password
        self.title = title
        self.phoneNumbers = phoneNumbers
        self.emails = emails
        self.externalId = externalId
        self.groups = groups
        self.roles = roles
        self.urnietfparamsscimschemasextensionenterprise20User = urnietfparamsscimschemasextensionenterprise20User
        self.urnietfparamsscimschemasextensiongenesyspurecloud20User = urnietfparamsscimschemasextensiongenesyspurecloud20User
        self.meta = meta
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case schemas
        case active
        case userName
        case displayName
        case password
        case title
        case phoneNumbers
        case emails
        case externalId
        case groups
        case roles
        case urnietfparamsscimschemasextensionenterprise20User = "urn:ietf:params:scim:schemas:extension:enterprise:2.0:User"
        case urnietfparamsscimschemasextensiongenesyspurecloud20User = "urn:ietf:params:scim:schemas:extension:genesys:purecloud:2.0:User"
        case meta
    }


}




public class ScreenRecordingMetaData: Codable {















    public var trackId: String?
    public var mediaId: String?
    public var screenId: String?
    public var originX: Int?
    public var originY: Int?
    public var primary: Bool?
    public var main: Bool?

    public init(trackId: String?, mediaId: String?, screenId: String?, originX: Int?, originY: Int?, primary: Bool?, main: Bool?) {
        self.trackId = trackId
        self.mediaId = mediaId
        self.screenId = screenId
        self.originX = originX
        self.originY = originY
        self.primary = primary
        self.main = main
    }


}




public class ScreenRecordingMetaDataRequest: Codable {







    public var participantJid: String?
    public var roomId: String?
    public var metaData: [ScreenRecordingMetaData]?

    public init(participantJid: String?, roomId: String?, metaData: [ScreenRecordingMetaData]?) {
        self.participantJid = participantJid
        self.roomId = roomId
        self.metaData = metaData
    }


}




public class SearchCriteria: Codable {









    public enum Operator: String, Codable { 
        case and = "AND"
        case or = "OR"
        case not = "NOT"
    }





    public enum ModelType: String, Codable { 
        case exact = "EXACT"
        case contains = "CONTAINS"
        case startsWith = "STARTS_WITH"
        case requiredFields = "REQUIRED_FIELDS"
        case range = "RANGE"
        case dateRange = "DATE_RANGE"
        case lessThan = "LESS_THAN"
        case lessThanEqualTo = "LESS_THAN_EQUAL_TO"
        case greaterThan = "GREATER_THAN"
        case greaterThanEqualTo = "GREATER_THAN_EQUAL_TO"
        case simple = "SIMPLE"
        case term = "TERM"
        case terms = "TERMS"
        case queryString = "QUERY_STRING"
        case matchAll = "MATCH_ALL"
        case regex = "REGEX"
    }



    /** The end value of the range. This field is used for range search types. */
    public var endValue: String?
    /** A list of values for the search to match against */
    public var values: [String]?
    /** The start value of the range. This field is used for range search types. */
    public var startValue: String?
    /** A value for the search to match against */
    public var value: String?
    /** How to apply this search criteria against other criteria */
    public var _operator: Operator?
    /** Groups multiple conditions */
    public var group: [SearchCriteria]?
    /** Set date format for criteria values when using date range search type.  Supports Java date format syntax, example yyyy-MM-dd'T'HH:mm:ss.SSSX. */
    public var dateFormat: String?
    public var type: ModelType?
    /** Field names to search against */
    public var fields: [String]?

    public init(endValue: String?, values: [String]?, startValue: String?, value: String?, _operator: Operator?, group: [SearchCriteria]?, dateFormat: String?, type: ModelType?, fields: [String]?) {
        self.endValue = endValue
        self.values = values
        self.startValue = startValue
        self.value = value
        self._operator = _operator
        self.group = group
        self.dateFormat = dateFormat
        self.type = type
        self.fields = fields
    }

    public enum CodingKeys: String, CodingKey { 
        case endValue
        case values
        case startValue
        case value
        case _operator = "operator"
        case group
        case dateFormat
        case type
        case fields
    }


}




public class SearchSort: Codable {

    public enum SortOrder: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
        case score = "SCORE"
    }



    /** The sort order for results */
    public var sortOrder: SortOrder?
    /** The field in the resource that you want to sort the results by */
    public var sortBy: String?

    public init(sortOrder: SortOrder?, sortBy: String?) {
        self.sortOrder = sortOrder
        self.sortBy = sortBy
    }


}




public class SecondaryPresence: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class SecureSessionEntityListing: Codable {



    public var entities: [SecureSession]?

    public init(entities: [SecureSession]?) {
        self.entities = entities
    }


}




public class SecurityProfile: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var permissions: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, permissions: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.permissions = permissions
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case permissions
        case selfUri
    }


}




public class SegmentDetailQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [SegmentDetailQueryPredicate]?

    public init(type: ModelType?, predicates: [SegmentDetailQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class SegmentEstimateCount: Codable {





    /** ID of Segment. */
    public var segmentId: String?
    /** Estimate count per segment. */
    public var count: Int?

    public init(segmentId: String?, count: Int?) {
        self.segmentId = segmentId
        self.count = count
    }


}




public class SendAgentlessOutboundMessageResponse: Codable {









    public enum MessengerType: String, Codable { 
        case sms = "sms"
        case whatsapp = "whatsapp"
        case _open = "open"
    }















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The identifier of the conversation. */
    public var conversationId: String?
    /** The sender of the message. */
    public var fromAddress: String?
    /** The recipient of the message. */
    public var toAddress: String?
    /** Type of messenger. */
    public var messengerType: MessengerType?
    /** The body of the text message. */
    public var textBody: String?
    /** The messaging template sent */
    public var messagingTemplate: MessagingTemplateRequest?
    /** Use an existing active conversation to send the agentless outbound message. Set this parameter to 'true' to use active conversation. Default value: false */
    public var useExistingActiveConversation: Bool?
    /** Sent agentless outbound message in normalized format */
    public var message: MessageData?
    /** The time when the message was sent. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var timestamp: Date?
    /** The URI for this object */
    public var selfUri: String?
    /** Details of the user created the job */
    public var user: AddressableEntityRef?

    public init(_id: String?, conversationId: String?, fromAddress: String?, toAddress: String?, messengerType: MessengerType?, textBody: String?, messagingTemplate: MessagingTemplateRequest?, useExistingActiveConversation: Bool?, message: MessageData?, timestamp: Date?, selfUri: String?, user: AddressableEntityRef?) {
        self._id = _id
        self.conversationId = conversationId
        self.fromAddress = fromAddress
        self.toAddress = toAddress
        self.messengerType = messengerType
        self.textBody = textBody
        self.messagingTemplate = messagingTemplate
        self.useExistingActiveConversation = useExistingActiveConversation
        self.message = message
        self.timestamp = timestamp
        self.selfUri = selfUri
        self.user = user
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case conversationId
        case fromAddress
        case toAddress
        case messengerType
        case textBody
        case messagingTemplate
        case useExistingActiveConversation
        case message
        case timestamp
        case selfUri
        case user
    }


}




public class ServiceContext: Codable {



    /** Unused field for the purpose of ensuring a Swagger definition is created for a class with only @JsonIgnore members. */
    public var name: String?

    public init(name: String?) {
        self.name = name
    }


}




public class ServiceGoalTemplateReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class SessionSegmentAssignment: Codable {





    /** The segment that was assigned. */
    public var segment: AssignedSegment?
    /** Timestamp indicating when the segment was assigned. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var assignedDate: Date?

    public init(segment: AssignedSegment?, assignedDate: Date?) {
        self.segment = segment
        self.assignedDate = assignedDate
    }


}




public class SessionsResponse: Codable {









    public var entities: [BotFlowSession]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [BotFlowSession]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class SetTimeOffIntegrationStatusRequest: Codable {

    public enum IntegrationStatus: String, Codable { 
        case processing = "Processing"
        case error = "Error"
        case automaticallyComplete = "AutomaticallyComplete"
        case manuallyComplete = "ManuallyComplete"
    }

    /** The integration status value for the time off request */
    public var integrationStatus: IntegrationStatus?

    public init(integrationStatus: IntegrationStatus?) {
        self.integrationStatus = integrationStatus
    }


}




public class SetTimeOffLimitValuesRequest: Codable {





    public var values: [TimeOffLimitRange]?
    /** Version metadata for the time off limit */
    public var metadata: WfmVersionedEntityMetadata?

    public init(values: [TimeOffLimitRange]?, metadata: WfmVersionedEntityMetadata?) {
        self.values = values
        self.metadata = metadata
    }


}




public class ShiftTradeMatchReviewResponse: Codable {









    /** Details for the initiatingUser side of the shift trade */
    public var initiatingUser: ShiftTradeMatchReviewUserResponse?
    /** Details for the receivingUser side of the shift trade */
    public var receivingUser: ShiftTradeMatchReviewUserResponse?
    /** Constraint violations introduced after being matched that would normally disallow a trade, but which can still be overridden by the shift trade administrator */
    public var violations: [ShiftTradeMatchViolation]?
    /** Constraint violations associated with this shift trade which require shift trade administrator review */
    public var adminReviewViolations: [ShiftTradeMatchViolation]?

    public init(initiatingUser: ShiftTradeMatchReviewUserResponse?, receivingUser: ShiftTradeMatchReviewUserResponse?, violations: [ShiftTradeMatchViolation]?, adminReviewViolations: [ShiftTradeMatchViolation]?) {
        self.initiatingUser = initiatingUser
        self.receivingUser = receivingUser
        self.violations = violations
        self.adminReviewViolations = adminReviewViolations
    }


}




public class ShiftTradeMatchReviewUserResponse: Codable {











    /** The minimum weekly paid minutes for this user per the work plan tied to the agent schedule */
    public var weeklyMinimumPaidMinutes: Int?
    /** The maximum weekly paid minutes for this user per the work plan tied to the agent schedule */
    public var weeklyMaximumPaidMinutes: Int?
    /** The paid minutes on the week schedule for this user prior to the shift trade */
    public var preTradeSchedulePaidMinutes: Int?
    /** The paid minutes on the week schedule for this user if the shift trade is approved */
    public var postTradeSchedulePaidMinutes: Int?
    /** Preview of what the shift will look like for the opposite side of this trade after the match is approved */
    public var postTradeNewShift: ShiftTradePreviewResponse?

    public init(weeklyMinimumPaidMinutes: Int?, weeklyMaximumPaidMinutes: Int?, preTradeSchedulePaidMinutes: Int?, postTradeSchedulePaidMinutes: Int?, postTradeNewShift: ShiftTradePreviewResponse?) {
        self.weeklyMinimumPaidMinutes = weeklyMinimumPaidMinutes
        self.weeklyMaximumPaidMinutes = weeklyMaximumPaidMinutes
        self.preTradeSchedulePaidMinutes = preTradeSchedulePaidMinutes
        self.postTradeSchedulePaidMinutes = postTradeSchedulePaidMinutes
        self.postTradeNewShift = postTradeNewShift
    }


}




public class ShiftTradeMatchesSummaryResponse: Codable {



    public var entities: [WeekShiftTradeMatchesSummaryResponse]?

    public init(entities: [WeekShiftTradeMatchesSummaryResponse]?) {
        self.entities = entities
    }


}




public class SipSearchResult: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Status of the search request */
    public var status: Int?
    /** Session id associated to the search request */
    public var sid: String?
    /** Auth token used for this search request */
    public var auth: String?
    /** Any messages returned from homer as part of the response */
    public var message: String?
    /** Homer search data that is returned */
    public var data: [HomerRecord]?
    /** Number of records returned */
    public var count: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, status: Int?, sid: String?, auth: String?, message: String?, data: [HomerRecord]?, count: Int?, selfUri: String?) {
        self._id = _id
        self.status = status
        self.sid = sid
        self.auth = auth
        self.message = message
        self.data = data
        self.count = count
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case status
        case sid
        case auth
        case message
        case data
        case count
        case selfUri
    }


}




public class SiteEntityListing: Codable {





















    public var entities: [Site]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Site]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class SmsAddress: Codable {



















    /** The id of this address. */
    public var _id: String?
    public var name: String?
    /** The number and street address where this address is located. */
    public var street: String?
    /** The city in which this address is in */
    public var city: String?
    /** The state or region this address is in */
    public var region: String?
    /** The postal code this address is in */
    public var postalCode: String?
    /** The ISO country code of this address */
    public var countryCode: String?
    /** In some countries, addresses are validated to comply with local regulation. In those countries, if the address you provide does not pass validation, it will not be accepted as an Address. This value will be true if the Address has been validated, or false for countries that don't require validation or if the Address is non-compliant. */
    public var validated: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, street: String?, city: String?, region: String?, postalCode: String?, countryCode: String?, validated: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.street = street
        self.city = city
        self.region = region
        self.postalCode = postalCode
        self.countryCode = countryCode
        self.validated = validated
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case street
        case city
        case region
        case postalCode
        case countryCode
        case validated
        case selfUri
    }


}




public class SmsAvailablePhoneNumber: Codable {













    public enum Capabilities: String, Codable { 
        case sms = "sms"
        case mms = "mms"
        case voice = "voice"
    }

    public enum PhoneNumberType: String, Codable { 
        case local = "local"
        case mobile = "mobile"
        case tollfree = "tollfree"
        case shortcode = "shortcode"
    }

    public enum AddressRequirement: String, Codable { 
        case _none = "none"
        case any = "any"
        case local = "local"
        case foreign = "foreign"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** A phone number available for provisioning in E.164 format. E.g. +13175555555 or +34234234234 */
    public var phoneNumber: String?
    /** The ISO 3166-1 alpha-2 country code of the country this phone number is associated with. */
    public var countryCode: String?
    /** The region/province/state the phone number is associated with. */
    public var region: String?
    /** The city the phone number is associated with. */
    public var city: String?
    /** The capabilities of the phone number available for provisioning. */
    public var capabilities: [Capabilities]?
    /** The type of phone number available for provisioning. */
    public var phoneNumberType: PhoneNumberType?
    /** The address requirement needed for provisioning this number. If there is a requirement, the address must be the residence or place of business of the individual or entity using the phone number. */
    public var addressRequirement: AddressRequirement?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, phoneNumber: String?, countryCode: String?, region: String?, city: String?, capabilities: [Capabilities]?, phoneNumberType: PhoneNumberType?, addressRequirement: AddressRequirement?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.phoneNumber = phoneNumber
        self.countryCode = countryCode
        self.region = region
        self.city = city
        self.capabilities = capabilities
        self.phoneNumberType = phoneNumberType
        self.addressRequirement = addressRequirement
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case phoneNumber
        case countryCode
        case region
        case city
        case capabilities
        case phoneNumberType
        case addressRequirement
        case selfUri
    }


}




public class SmsPhoneNumberEntityListing: Codable {





















    public var entities: [SmsPhoneNumber]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [SmsPhoneNumber]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class SourceEntityListing: Codable {







    public var total: Int64?
    public var entities: [Source]?
    public var selfUri: String?

    public init(total: Int64?, entities: [Source]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class StatEventFlowTopicStatsNotification: Codable {





    public var group: [String:String]?
    public var data: [StatEventFlowTopicIntervalMetrics]?

    public init(group: [String:String]?, data: [StatEventFlowTopicIntervalMetrics]?) {
        self.group = group
        self.data = data
    }


}




public class StatEventWrapUpCodeTopicIntervalMetrics: Codable {





    public var interval: String?
    public var metrics: [StatEventWrapUpCodeTopicMetricStats]?

    public init(interval: String?, metrics: [StatEventWrapUpCodeTopicMetricStats]?) {
        self.interval = interval
        self.metrics = metrics
    }


}




public class StatEventWrapUpCodeTopicMetricStats: Codable {







    public var metric: String?
    public var qualifier: String?
    public var stats: [String:Double]?

    public init(metric: String?, qualifier: String?, stats: [String:Double]?) {
        self.metric = metric
        self.qualifier = qualifier
        self.stats = stats
    }


}




public class StatisticalSummary: Codable {



























    public var max: Double?
    public var min: Double?
    public var count: Int64?
    public var countNegative: Int64?
    public var countPositive: Int64?
    public var sum: Double?
    public var current: Double?
    public var ratio: Double?
    public var numerator: Double?
    public var denominator: Double?
    public var target: Double?
    public var p95: Int64?
    public var p99: Int64?

    public init(max: Double?, min: Double?, count: Int64?, countNegative: Int64?, countPositive: Int64?, sum: Double?, current: Double?, ratio: Double?, numerator: Double?, denominator: Double?, target: Double?, p95: Int64?, p99: Int64?) {
        self.max = max
        self.min = min
        self.count = count
        self.countNegative = countNegative
        self.countPositive = countPositive
        self.sum = sum
        self.current = current
        self.ratio = ratio
        self.numerator = numerator
        self.denominator = denominator
        self.target = target
        self.p95 = p95
        self.p99 = p99
    }


}




public class SubjectDivisionGrantsEntityListing: Codable {





















    public var entities: [SubjectDivisionGrants]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [SubjectDivisionGrants]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class SubjectDivisions: Codable {





    /** A collection of subject IDs to associate with the given divisions */
    public var subjectIds: [String]?
    /** A collection of division IDs to associate with the given subjects */
    public var divisionIds: [String]?

    public init(subjectIds: [String]?, divisionIds: [String]?) {
        self.subjectIds = subjectIds
        self.divisionIds = divisionIds
    }


}




public class SupportCenterCompactCategoryModuleTemplate: Codable {



    /** Whether this template is active or not */
    public var active: Bool?

    public init(active: Bool?) {
        self.active = active
    }


}




public class SupportCenterDetailedCategoryModuleSidebar: Codable {



    /** Whether sidebar is enabled or not */
    public var enabled: Bool?

    public init(enabled: Bool?) {
        self.enabled = enabled
    }


}




public class SupportCenterDetailedCategoryModuleTemplate: Codable {





    /** Whether this template is active or not */
    public var active: Bool?
    /** Sidebar settings for the template */
    public var sidebar: SupportCenterDetailedCategoryModuleSidebar?

    public init(active: Bool?, sidebar: SupportCenterDetailedCategoryModuleSidebar?) {
        self.active = active
        self.sidebar = sidebar
    }


}




public class SupportCenterImage: Codable {



    /** Source URLs for image */
    public var source: SupportCenterImageSource?

    public init(source: SupportCenterImageSource?) {
        self.source = source
    }


}




public class SupportCenterImageSource: Codable {



    /** Default URL for image */
    public var defaultUrl: String?

    public init(defaultUrl: String?) {
        self.defaultUrl = defaultUrl
    }


}




public class SupportCenterModuleSetting: Codable {

    public enum ModelType: String, Codable { 
        case search = "Search"
        case categories = "Categories"
        case faq = "FAQ"
        case contact = "Contact"
        case results = "Results"
        case article = "Article"
        case topViewedArticles = "TopViewedArticles"
    }







    /** Screen module type */
    public var type: ModelType?
    /** Whether or not knowledge portal (previously support center) screen module is enabled */
    public var enabled: Bool?
    /** Compact category module template */
    public var compactCategoryModuleTemplate: SupportCenterCompactCategoryModuleTemplate?
    /** Detailed category module template */
    public var detailedCategoryModuleTemplate: SupportCenterDetailedCategoryModuleTemplate?

    public init(type: ModelType?, enabled: Bool?, compactCategoryModuleTemplate: SupportCenterCompactCategoryModuleTemplate?, detailedCategoryModuleTemplate: SupportCenterDetailedCategoryModuleTemplate?) {
        self.type = type
        self.enabled = enabled
        self.compactCategoryModuleTemplate = compactCategoryModuleTemplate
        self.detailedCategoryModuleTemplate = detailedCategoryModuleTemplate
    }


}




public class SupportCenterScreen: Codable {

    public enum ModelType: String, Codable { 
        case home = "Home"
        case category = "Category"
        case searchResults = "SearchResults"
        case article = "Article"
    }



    /** The type of the screen */
    public var type: ModelType?
    /** Module settings for the screen, valid modules for each screenType: Home: Search, Categories, TopViewedArticles; Category: Search, Categories; SearchResults: Search, Results; Article: Search, Article; */
    public var moduleSettings: [SupportCenterModuleSetting]?

    public init(type: ModelType?, moduleSettings: [SupportCenterModuleSetting]?) {
        self.type = type
        self.moduleSettings = moduleSettings
    }


}




public class SupportCenterStyleSetting: Codable {





    /** Knowledge portal (previously support center) hero customizations */
    public var heroStyle: SupportCenterHeroStyle?
    /** Knowledge portal (previously support center) global customizations */
    public var globalStyle: SupportCenterGlobalStyle?

    public init(heroStyle: SupportCenterHeroStyle?, globalStyle: SupportCenterGlobalStyle?) {
        self.heroStyle = heroStyle
        self.globalStyle = globalStyle
    }


}



/** Supported content profile for inbound and outbound messages */

public class SupportedContent: Codable {



















    /** A unique supported content Id. */
    public var _id: String?
    /** The name of the supported content profile */
    public var name: String?
    /** Date this supported content profile was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date this supported content profile was modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** User reference that created this supported content profile */
    public var createdBy: DomainEntityRef?
    /** User reference that modified this supported content profile */
    public var modifiedBy: DomainEntityRef?
    /** Version number */
    public var version: Int?
    /** Defines the allowable media that may be accepted for an inbound message or to be sent in an outbound message. The following is an example of allowing all inbound media, and for outbound all images and only mpeg video: {   \"mediaTypes\": {     \"allow\": {       \"inbound\": [{\"type\": \"*_/_*\"}],       \"outbound\": [{\"type\": \"image/_*\"}, {\"type\": \"video/mpeg\"}]     }   } } */
    public var mediaTypes: MediaTypes?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, createdBy: DomainEntityRef?, modifiedBy: DomainEntityRef?, version: Int?, mediaTypes: MediaTypes?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.version = version
        self.mediaTypes = mediaTypes
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case createdBy
        case modifiedBy
        case version
        case mediaTypes
        case selfUri
    }


}




public class SupportedContentListing: Codable {





















    public var entities: [SupportedContent]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [SupportedContent]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class SupportedDialectsEntityListing: Codable {



    public var entities: [TranscriptionEngines]?

    public init(entities: [TranscriptionEngines]?) {
        self.entities = entities
    }


}




public class SurveyDetailQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [SurveyDetailQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [SurveyDetailQueryPredicate]?

    public init(type: ModelType?, clauses: [SurveyDetailQueryClause]?, predicates: [SurveyDetailQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class SystemPrompt: Codable {











    /** The system prompt identifier */
    public var _id: String?
    public var name: String?
    public var _description: String?
    public var resources: [SystemPromptAsset]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, resources: [SystemPromptAsset]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.resources = resources
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case resources
        case selfUri
    }


}




public class TeamReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class TemplateParameter: Codable {





    /** Response substitution identifier */
    public var _id: String?
    /** Response substitution value */
    public var value: String?

    public init(_id: String?, value: String?) {
        self._id = _id
        self.value = value
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case value
    }


}



/** Description of the Bot Flow. */

public class TextBotFlow: Codable {



    /** The Bot Flow ID. */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}



/** Information related to a successful launch of a bot flow. The ID will be used in subsequent turn requests of the bot flow. */

public class TextBotFlowLaunchResponse: Codable {



    /** The session ID of the bot flow, used to send to subsequent turn requests */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}



/** Describes a flow location. */

public class TextBotFlowLocation: Codable {







    /** The name of the action that was active when the event of interest happened. */
    public var actionName: String?
    /** The number of the action that was active when the event of interest happened. */
    public var actionNumber: Int?
    /** The name of the state or task which was active when the event of interest happened. */
    public var sequenceName: String?

    public init(actionName: String?, actionNumber: Int?, sequenceName: String?) {
        self.actionName = actionName
        self.actionNumber = actionNumber
        self.sequenceName = sequenceName
    }


}



/** Settings for a turn request to a bot flow. */

public class TextBotFlowTurnRequest: Codable {



    public enum InputEventType: String, Codable { 
        case noOp = "NoOp"
        case userInput = "UserInput"
        case error = "Error"
        case noMatch = "NoMatch"
        case noInput = "NoInput"
        case userDisconnect = "UserDisconnect"
        case clientSessionExpired = "ClientSessionExpired"
    }





    /** The reference to a previous turn if appropriate, used to avoid race conditions. */
    public var previousTurn: TextBotTurnReference?
    /** Indicates the type of input event being requested. If appropriate, fill out the matching user input object details on this request. */
    public var inputEventType: InputEventType?
    /** The data for the input event of this turn if it is a user input event. Only one inputEvent may be set. */
    public var inputEventUserInput: TextBotUserInputEvent?
    /** The data for the input event of this turn if it is an error event. Only one inputEvent may be set. */
    public var inputEventError: TextBotErrorInputEvent?

    public init(previousTurn: TextBotTurnReference?, inputEventType: InputEventType?, inputEventUserInput: TextBotUserInputEvent?, inputEventError: TextBotErrorInputEvent?) {
        self.previousTurn = previousTurn
        self.inputEventType = inputEventType
        self.inputEventUserInput = inputEventUserInput
        self.inputEventError = inputEventError
    }


}



/** Input/Output data related to a bot flow which is exiting gracefully. */

public class TextBotInputOutputData: Codable {



    /** The input/output variables using the format as appropriate for the variable data type in the flow definition. */
    public var variables: [String:JSON]?

    public init(variables: [String:JSON]?) {
        self.variables = variables
    }


}



/** Prompt information related to a bot flow turn. */

public class TextBotModeOutputPrompts: Codable {



    /** The list of prompt segments. */
    public var segments: [TextBotPromptSegment]?

    public init(segments: [TextBotPromptSegment]?) {
        self.segments = segments
    }


}




public class TimeOffBalanceResponse: Codable {











    /** The ID for activity code associated with time off balance */
    public var activityCodeId: String?
    /** The ID of the time off type configured in HRIS integration */
    public var hrisTimeOffTypeId: String?
    /** The secondary ID of the time off type configured in HRIS integration */
    public var hrisTimeOffTypeSecondaryId: String?
    /** The Start date of the requested date range. The end date is determined by the size of interval list. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var startDate: Date?
    /** The list of available time off balance values in minutes for each day */
    public var balanceMinutesPerDay: [Int]?

    public init(activityCodeId: String?, hrisTimeOffTypeId: String?, hrisTimeOffTypeSecondaryId: String?, startDate: Date?, balanceMinutesPerDay: [Int]?) {
        self.activityCodeId = activityCodeId
        self.hrisTimeOffTypeId = hrisTimeOffTypeId
        self.hrisTimeOffTypeSecondaryId = hrisTimeOffTypeSecondaryId
        self.startDate = startDate
        self.balanceMinutesPerDay = balanceMinutesPerDay
    }


}




public class TimeOffBalancesResponse: Codable {





    /** The asynchronous job handling the query */
    public var job: TimeOffBalanceJobReference?
    /** The list of time off balances. May come via notification */
    public var entities: [TimeOffBalanceResponse]?

    public init(job: TimeOffBalanceJobReference?, entities: [TimeOffBalanceResponse]?) {
        self.job = job
        self.entities = entities
    }


}




public class TimeOffPlan: Codable {









    public enum AutoApprovalRule: String, Codable { 
        case never = "Never"
        case always = "Always"
        case checkLimits = "CheckLimits"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of this time off plan. */
    public var name: String?
    /** The set of activity code IDs associated with this time off plan. */
    public var activityCodeIds: [String]?
    /** The set of time off limit IDs associated with this time off plan. */
    public var timeOffLimits: [TimeOffLimitReference]?
    /** Auto approval rule for this time off plan */
    public var autoApprovalRule: AutoApprovalRule?
    /** The number of days before the time off request start date for when the request will be expired from the waitlist. */
    public var daysBeforeStartToExpireFromWaitlist: Int?
    /** Time off type, if this time off plan is associated with the integration. */
    public var hrisTimeOffType: HrisTimeOffType?
    /** Whether this time off plan is currently being used by agents. */
    public var active: Bool?
    /** Version metadata for the time off plan. */
    public var metadata: WfmVersionedEntityMetadata?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, activityCodeIds: [String]?, timeOffLimits: [TimeOffLimitReference]?, autoApprovalRule: AutoApprovalRule?, daysBeforeStartToExpireFromWaitlist: Int?, hrisTimeOffType: HrisTimeOffType?, active: Bool?, metadata: WfmVersionedEntityMetadata?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.activityCodeIds = activityCodeIds
        self.timeOffLimits = timeOffLimits
        self.autoApprovalRule = autoApprovalRule
        self.daysBeforeStartToExpireFromWaitlist = daysBeforeStartToExpireFromWaitlist
        self.hrisTimeOffType = hrisTimeOffType
        self.active = active
        self.metadata = metadata
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case activityCodeIds
        case timeOffLimits
        case autoApprovalRule
        case daysBeforeStartToExpireFromWaitlist
        case hrisTimeOffType
        case active
        case metadata
        case selfUri
    }


}




public class TimeOffPlanListing: Codable {



    public var entities: [TimeOffPlan]?

    public init(entities: [TimeOffPlan]?) {
        self.entities = entities
    }


}




public class TimeOffRequest: Codable {













    public enum Status: String, Codable { 
        case pending = "PENDING"
        case approved = "APPROVED"
        case denied = "DENIED"
        case canceled = "CANCELED"
    }

    public enum Substatus: String, Codable { 
        case advanceTimeElapsed = "AdvanceTimeElapsed"
        case autoApproved = "AutoApproved"
        case insufficientBalance = "InsufficientBalance"
        case invalidDailyDuration = "InvalidDailyDuration"
        case outsideShift = "OutsideShift"
        case removedFromWaitlist = "RemovedFromWaitlist"
        case waitlisted = "Waitlisted"
    }



























    /** The id of the time off request */
    public var _id: String?
    /** The user that the time off request belongs to */
    public var user: UserReference?
    /** Whether this is a full day request (false means partial day) */
    public var isFullDayRequest: Bool?
    /** Whether this request has been marked as read by the agent */
    public var markedAsRead: Bool?
    /** The ID of the activity code associated with this time off request. Activity code must be of the TimeOff category */
    public var activityCodeId: String?
    /** Whether this is a paid time off request */
    public var paid: Bool?
    /** The status of this time off request */
    public var status: Status?
    /** The substatus of this time off request */
    public var substatus: Substatus?
    /** A set of start date-times in ISO-8601 format for partial day requests.  Will be not empty if isFullDayRequest == false */
    public var partialDayStartDateTimes: [Date]?
    /** A set of dates in yyyy-MM-dd format.  Should be interpreted in the management unit's configured time zone.  Will be not empty if isFullDayRequest == true */
    public var fullDayManagementUnitDates: [String]?
    /** The daily duration of this time off request in minutes */
    public var dailyDurationMinutes: Int?
    /** Daily durations for each day of this time off request in minutes */
    public var durationMinutes: [Int]?
    /** Payable minutes for each day of this time off request */
    public var payableMinutes: [Int]?
    /** Notes about the time off request */
    public var notes: String?
    /** The user who submitted this time off request */
    public var submittedBy: UserReference?
    /** The timestamp when this request was submitted. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var submittedDate: Date?
    /** The user who reviewed this time off request */
    public var reviewedBy: UserReference?
    /** The timestamp when this request was reviewed. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var reviewedDate: Date?
    /** The sync version of this time off request for which the scheduled activity is associated */
    public var syncVersion: Int?
    /** The version metadata of the time off request */
    public var metadata: WfmVersionedEntityMetadata?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, user: UserReference?, isFullDayRequest: Bool?, markedAsRead: Bool?, activityCodeId: String?, paid: Bool?, status: Status?, substatus: Substatus?, partialDayStartDateTimes: [Date]?, fullDayManagementUnitDates: [String]?, dailyDurationMinutes: Int?, durationMinutes: [Int]?, payableMinutes: [Int]?, notes: String?, submittedBy: UserReference?, submittedDate: Date?, reviewedBy: UserReference?, reviewedDate: Date?, syncVersion: Int?, metadata: WfmVersionedEntityMetadata?, selfUri: String?) {
        self._id = _id
        self.user = user
        self.isFullDayRequest = isFullDayRequest
        self.markedAsRead = markedAsRead
        self.activityCodeId = activityCodeId
        self.paid = paid
        self.status = status
        self.substatus = substatus
        self.partialDayStartDateTimes = partialDayStartDateTimes
        self.fullDayManagementUnitDates = fullDayManagementUnitDates
        self.dailyDurationMinutes = dailyDurationMinutes
        self.durationMinutes = durationMinutes
        self.payableMinutes = payableMinutes
        self.notes = notes
        self.submittedBy = submittedBy
        self.submittedDate = submittedDate
        self.reviewedBy = reviewedBy
        self.reviewedDate = reviewedDate
        self.syncVersion = syncVersion
        self.metadata = metadata
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case user
        case isFullDayRequest
        case markedAsRead
        case activityCodeId
        case paid
        case status
        case substatus
        case partialDayStartDateTimes
        case fullDayManagementUnitDates
        case dailyDurationMinutes
        case durationMinutes
        case payableMinutes
        case notes
        case submittedBy
        case submittedDate
        case reviewedBy
        case reviewedDate
        case syncVersion
        case metadata
        case selfUri
    }


}




public class TimeOffRequestListing: Codable {





    /** List of time off requests */
    public var entities: [TimeOffRequest]?
    /** URL from which to fetch results for requests with a large result set. If populated, the downloaded data will conform to the same schema as would normally be returned, excepting downloaded data will never itself contain a downloadUrl */
    public var downloadUrl: String?

    public init(entities: [TimeOffRequest]?, downloadUrl: String?) {
        self.entities = entities
        self.downloadUrl = downloadUrl
    }


}




public class TimeOffRequestNotification: Codable {







    public enum Status: String, Codable { 
        case pending = "PENDING"
        case approved = "APPROVED"
        case denied = "DENIED"
        case canceled = "CANCELED"
    }





    /** The ID of this time off request */
    public var timeOffRequestId: String?
    /** The user associated with this time off request */
    public var user: UserReference?
    /** Whether this is a full day request (false means partial day) */
    public var isFullDayRequest: Bool?
    /** The status of this time off request */
    public var status: Status?
    /** A set of start date-times in ISO-8601 format for partial day requests.  Will be not empty if isFullDayRequest == false */
    public var partialDayStartDateTimes: [Date]?
    /** A set of dates in yyyy-MM-dd format.  Should be interpreted in the management unit's configured time zone.  Will be not empty if isFullDayRequest == true */
    public var fullDayManagementUnitDates: [String]?

    public init(timeOffRequestId: String?, user: UserReference?, isFullDayRequest: Bool?, status: Status?, partialDayStartDateTimes: [Date]?, fullDayManagementUnitDates: [String]?) {
        self.timeOffRequestId = timeOffRequestId
        self.user = user
        self.isFullDayRequest = isFullDayRequest
        self.status = status
        self.partialDayStartDateTimes = partialDayStartDateTimes
        self.fullDayManagementUnitDates = fullDayManagementUnitDates
    }


}




public class TimeSlot: Codable {







    /** start time in xx:xx:xx.xxx format */
    public var startTime: String?
    /** stop time in xx:xx:xx.xxx format */
    public var stopTime: String?
    /** Day for this time slot, Monday = 1 ... Sunday = 7 */
    public var day: Int?

    public init(startTime: String?, stopTime: String?, day: Int?) {
        self.startTime = startTime
        self.stopTime = stopTime
        self.day = day
    }


}




public class TopicPhrase: Codable {







    public var _id: String?
    public var text: String?
    public var utteranceCount: Int?

    public init(_id: String?, text: String?, utteranceCount: Int?) {
        self._id = _id
        self.text = text
        self.utteranceCount = utteranceCount
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case text
        case utteranceCount
    }


}




public class TranscriptAggregateQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [TranscriptAggregateQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [TranscriptAggregateQueryPredicate]?

    public init(type: ModelType?, clauses: [TranscriptAggregateQueryClause]?, predicates: [TranscriptAggregateQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class TranscriptTopic: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the object. */
    public var name: String?
    /** The phrase which detected the topic.  */
    public var topicPhrase: String?
    /** The transcript phrase which detected the topic. */
    public var transcriptPhrase: String?
    /** The detection confidence of the topic. */
    public var confidence: Int?
    /** The start time of the topic phrase. */
    public var startTimeMilliseconds: Int64?
    public var duration: TopicDuration?
    /** Location of the phrase */
    public var offset: TopicOffset?
    /** Location of the phrase in the recording in milliseconds */
    public var recordingLocation: Int64?

    public init(_id: String?, name: String?, topicPhrase: String?, transcriptPhrase: String?, confidence: Int?, startTimeMilliseconds: Int64?, duration: TopicDuration?, offset: TopicOffset?, recordingLocation: Int64?) {
        self._id = _id
        self.name = name
        self.topicPhrase = topicPhrase
        self.transcriptPhrase = transcriptPhrase
        self.confidence = confidence
        self.startTimeMilliseconds = startTimeMilliseconds
        self.duration = duration
        self.offset = offset
        self.recordingLocation = recordingLocation
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case topicPhrase
        case transcriptPhrase
        case confidence
        case startTimeMilliseconds
        case duration
        case offset
        case recordingLocation
    }


}




public class TranscriptTopics: Codable {





    /** List of topics which need to be included in exact match criteria. This field is not mutually exclusive with excludes topic list. */
    public var includes: [String]?
    /** List of topics which need to be excluded in exact match criteria. This field is not mutually exclusive with includes topic list. */
    public var excludes: [String]?

    public init(includes: [String]?, excludes: [String]?) {
        self.includes = includes
        self.excludes = excludes
    }


}




public class TransferRequest: Codable {

    public enum TransferType: String, Codable { 
        case attended = "Attended"
        case unattended = "Unattended"
    }











    public var transferType: TransferType?
    /** The user ID of the transfer target. */
    public var userId: String?
    /** The user ID or queue ID of the transfer target. Address like a phone number can not be used for callbacks, but they can be used for other forms of communication. */
    public var address: String?
    /** The user name of the transfer target. */
    public var userName: String?
    /** The queue ID of the transfer target. */
    public var queueId: String?
    /** If true, transfer to the voicemail inbox of the participant that is being replaced. */
    public var voicemail: Bool?

    public init(transferType: TransferType?, userId: String?, address: String?, userName: String?, queueId: String?, voicemail: Bool?) {
        self.transferType = transferType
        self.userId = userId
        self.address = address
        self.userName = userName
        self.queueId = queueId
        self.voicemail = voicemail
    }


}




public class TransferResponseModifiedBy: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class TransferToAgentRequest: Codable {

    public enum TransferType: String, Codable { 
        case attended = "Attended"
        case unattended = "Unattended"
    }









    public var transferType: TransferType?
    /** The id of the internal user. */
    public var userId: String?
    /** The userName (like users email) of the internal user. */
    public var userName: String?
    /** The name of the internal user. */
    public var userDisplayName: String?
    /** If true, transfer to the voicemail inbox of the participant that is being replaced. */
    public var voicemail: Bool?

    public init(transferType: TransferType?, userId: String?, userName: String?, userDisplayName: String?, voicemail: Bool?) {
        self.transferType = transferType
        self.userId = userId
        self.userName = userName
        self.userDisplayName = userDisplayName
        self.voicemail = voicemail
    }


}




public class TransferToExternalRequest: Codable {

    public enum TransferType: String, Codable { 
        case attended = "Attended"
        case unattended = "Unattended"
    }



    public var transferType: TransferType?
    /** The address (like phone number) of the external contact. */
    public var address: String?

    public init(transferType: TransferType?, address: String?) {
        self.transferType = transferType
        self.address = address
    }


}




public class TrendData: Codable {









    /** Start workday used as the date range. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStartWorkday: Date?
    /** End workday used as the date range. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEndWorkday: Date?
    /** Percent of goal */
    public var percentOfGoal: Double?
    /** Average metric value */
    public var averageValue: Double?

    public init(dateStartWorkday: Date?, dateEndWorkday: Date?, percentOfGoal: Double?, averageValue: Double?) {
        self.dateStartWorkday = dateStartWorkday
        self.dateEndWorkday = dateEndWorkday
        self.percentOfGoal = percentOfGoal
        self.averageValue = averageValue
    }


}




public class Trunk: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }





    public enum TrunkType: String, Codable { 
        case external = "EXTERNAL"
        case phone = "PHONE"
        case edge = "EDGE"
    }























    public enum OptionsEnabledStatus: String, Codable { 
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        case notSupported = "NOT_SUPPORTED"
    }

    public enum RegistersEnabledStatus: String, Codable { 
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        case notSupported = "NOT_SUPPORTED"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** The type of this trunk. */
    public var trunkType: TrunkType?
    /** The Edge using this trunk. */
    public var edge: DomainEntityRef?
    /** The trunk base configuration used on this trunk. */
    public var trunkBase: DomainEntityRef?
    /** The metabase used to create this trunk. */
    public var trunkMetabase: DomainEntityRef?
    /** The edge group associated with this trunk. */
    public var edgeGroup: DomainEntityRef?
    /** True if this trunk is in-service.  This comes from the trunk_enabled property of the referenced trunk base. */
    public var inService: Bool?
    /** True if the Edge used by this trunk is in-service */
    public var enabled: Bool?
    /** The Logical Interface on the Edge to which the trunk is assigned. */
    public var logicalInterface: DomainEntityRef?
    /** The connected status of the trunk */
    public var connectedStatus: TrunkConnectedStatus?
    /** The trunk optionsStatus */
    public var optionsStatus: [TrunkMetricsOptions]?
    /** The trunk registersStatus */
    public var registersStatus: [TrunkMetricsRegisters]?
    /** The trunk ipStatus */
    public var ipStatus: TrunkMetricsNetworkTypeIp?
    /** Returns Enabled when the trunk base supports the availability interval and it has a value greater than 0. */
    public var optionsEnabledStatus: OptionsEnabledStatus?
    /** Returns Enabled when the trunk base supports the registration interval and it has a value greater than 0. */
    public var registersEnabledStatus: RegistersEnabledStatus?
    /** The IP Network Family of the trunk */
    public var family: Int?
    /** The list of proxy addresses (ports if provided) for the trunk */
    public var proxyAddressList: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, trunkType: TrunkType?, edge: DomainEntityRef?, trunkBase: DomainEntityRef?, trunkMetabase: DomainEntityRef?, edgeGroup: DomainEntityRef?, inService: Bool?, enabled: Bool?, logicalInterface: DomainEntityRef?, connectedStatus: TrunkConnectedStatus?, optionsStatus: [TrunkMetricsOptions]?, registersStatus: [TrunkMetricsRegisters]?, ipStatus: TrunkMetricsNetworkTypeIp?, optionsEnabledStatus: OptionsEnabledStatus?, registersEnabledStatus: RegistersEnabledStatus?, family: Int?, proxyAddressList: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.trunkType = trunkType
        self.edge = edge
        self.trunkBase = trunkBase
        self.trunkMetabase = trunkMetabase
        self.edgeGroup = edgeGroup
        self.inService = inService
        self.enabled = enabled
        self.logicalInterface = logicalInterface
        self.connectedStatus = connectedStatus
        self.optionsStatus = optionsStatus
        self.registersStatus = registersStatus
        self.ipStatus = ipStatus
        self.optionsEnabledStatus = optionsEnabledStatus
        self.registersEnabledStatus = registersEnabledStatus
        self.family = family
        self.proxyAddressList = proxyAddressList
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case trunkType
        case edge
        case trunkBase
        case trunkMetabase
        case edgeGroup
        case inService
        case enabled
        case logicalInterface
        case connectedStatus
        case optionsStatus
        case registersStatus
        case ipStatus
        case optionsEnabledStatus
        case registersEnabledStatus
        case family
        case proxyAddressList
        case selfUri
    }


}




public class TrunkInstanceTopicTrunkMetricsNetworkTypeIp: Codable {





    public var address: String?
    public var errorInfo: TrunkInstanceTopicTrunkErrorInfo?

    public init(address: String?, errorInfo: TrunkInstanceTopicTrunkErrorInfo?) {
        self.address = address
        self.errorInfo = errorInfo
    }


}




public class TrunkMetricsOptions: Codable {









    /** Server proxy address that this options array element represents. */
    public var proxyAddress: String?
    public var optionState: Bool?
    /** ISO 8601 format UTC absolute date & time of the last change of the option state. */
    public var optionStateTime: Date?
    public var errorInfo: TrunkErrorInfo?

    public init(proxyAddress: String?, optionState: Bool?, optionStateTime: Date?, errorInfo: TrunkErrorInfo?) {
        self.proxyAddress = proxyAddress
        self.optionState = optionState
        self.optionStateTime = optionStateTime
        self.errorInfo = errorInfo
    }


}




public class TrustCreate: Codable {











    /** The pairing Id created by the trustee. This is required to prove that the trustee agrees to the relationship.  Not required when creating a default pairing with Customer Care. */
    public var pairingId: String?
    /** If disabled no trustee user will have access, even if they were previously added. */
    public var enabled: Bool?
    /** The list of users and their roles to which access will be granted. The users are from the trustee and the roles are from the trustor. If no users are specified, at least one group is required. */
    public var users: [TrustMemberCreate]?
    /** The list of groups and their roles to which access will be granted. The groups are from the trustee and the roles are from the trustor. If no groups are specified, at least one user is required. */
    public var groups: [TrustMemberCreate]?
    /** The expiration date of the trust. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateExpired: Date?

    public init(pairingId: String?, enabled: Bool?, users: [TrustMemberCreate]?, groups: [TrustMemberCreate]?, dateExpired: Date?) {
        self.pairingId = pairingId
        self.enabled = enabled
        self.users = users
        self.groups = groups
        self.dateExpired = dateExpired
    }


}




public class TrustMemberCreate: Codable {







    /** Trustee User or Group Id */
    public var _id: String?
    /** The list of roles to be granted to this user or group. Roles will be granted in all divisions. */
    public var roleIds: [String]?
    /** The list of trustor organization roles granting this user or group access paired with the divisions for those roles. */
    public var roleDivisions: RoleDivisionGrants?

    public init(_id: String?, roleIds: [String]?, roleDivisions: RoleDivisionGrants?) {
        self._id = _id
        self.roleIds = roleIds
        self.roleDivisions = roleDivisions
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case roleIds
        case roleDivisions
    }


}




public class TrustRequestCreate: Codable {





    /** The list of trustee users that are requesting access. If no users are specified, at least one group is required. */
    public var userIds: [String]?
    /** The list of trustee groups that are requesting access. If no groups are specified, at least one user is required. */
    public var groupIds: [String]?

    public init(userIds: [String]?, groupIds: [String]?) {
        self.userIds = userIds
        self.groupIds = groupIds
    }


}




public class TrustUpdate: Codable {





    /** If disabled no trustee user will have access, even if they were previously added. */
    public var enabled: Bool?
    /** The expiration date of the trust. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateExpired: Date?

    public init(enabled: Bool?, dateExpired: Date?) {
        self.enabled = enabled
        self.dateExpired = dateExpired
    }


}




public class UCI10n: Codable {



    public var name: String?

    public init(name: String?) {
        self.name = name
    }


}




public class UnansweredGroup: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Knowledge base unanswered group label */
    public var label: String?
    /** Represents a list of phrase groups inside an unanswered group */
    public var phraseGroups: [UnansweredPhraseGroup]?
    /** Represents a list of documents that may be linked to an unanswered group */
    public var suggestedDocuments: [UnansweredGroupSuggestedDocument]?
    /** Statistics object containing the various hit counts for an unanswered group */
    public var statistics: KnowledgeGroupStatistics?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, label: String?, phraseGroups: [UnansweredPhraseGroup]?, suggestedDocuments: [UnansweredGroupSuggestedDocument]?, statistics: KnowledgeGroupStatistics?, selfUri: String?) {
        self._id = _id
        self.label = label
        self.phraseGroups = phraseGroups
        self.suggestedDocuments = suggestedDocuments
        self.statistics = statistics
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case label
        case phraseGroups
        case suggestedDocuments
        case statistics
        case selfUri
    }


}




public class UnansweredGroupSuggestedDocument: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class UnansweredGroups: Codable {



    public var entities: [UnansweredGroup]?

    public init(entities: [UnansweredGroup]?) {
        self.entities = entities
    }


}




public class UnansweredPhraseGroupPatchRequestBody: Codable {







    /** List of phrases and documents to be linked */
    public var phraseAssociations: [PhraseAssociations]?
    /** The start date to be used for filtering phrases. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStart: Date?
    /** The end date to be used for filtering phrases. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEnd: Date?

    public init(phraseAssociations: [PhraseAssociations]?, dateStart: Date?, dateEnd: Date?) {
        self.phraseAssociations = phraseAssociations
        self.dateStart = dateStart
        self.dateEnd = dateEnd
    }


}




public class UpdateAnalyticsDataRetentionRequest: Codable {



    /** Analytics data retention period in days to set for the organization. */
    public var retentionDays: Int?

    public init(retentionDays: Int?) {
        self.retentionDays = retentionDays
    }


}




public class UpdateServiceGoalTemplate: Codable {













    /** The name of the service goal template. */
    public var name: String?
    /** Service level targets for this service goal template */
    public var serviceLevel: BuServiceLevel?
    /** Average speed of answer targets for this service goal template */
    public var averageSpeedOfAnswer: BuAverageSpeedOfAnswer?
    /** Abandon rate targets for this service goal template */
    public var abandonRate: BuAbandonRate?
    /** Version metadata for the service goal template */
    public var metadata: WfmVersionedEntityMetadata?
    /** Settings controlling max percent increase and decrease of service goals for this service goal template */
    public var impactOverride: ServiceGoalTemplateImpactOverride?

    public init(name: String?, serviceLevel: BuServiceLevel?, averageSpeedOfAnswer: BuAverageSpeedOfAnswer?, abandonRate: BuAbandonRate?, metadata: WfmVersionedEntityMetadata?, impactOverride: ServiceGoalTemplateImpactOverride?) {
        self.name = name
        self.serviceLevel = serviceLevel
        self.averageSpeedOfAnswer = averageSpeedOfAnswer
        self.abandonRate = abandonRate
        self.metadata = metadata
        self.impactOverride = impactOverride
    }


}




public class UploadUrlResponse: Codable {







    /** Presigned URL to PUT the file to */
    public var url: String?
    /** Key that identifies the file in the storage including the file name */
    public var uploadKey: String?
    /** Required headers when uploading a file through PUT request to the URL */
    public var headers: [String:String]?

    public init(url: String?, uploadKey: String?, headers: [String:String]?) {
        self.url = url
        self.uploadKey = uploadKey
        self.headers = headers
    }


}




public class UrlCondition: Codable {



    public enum Operator: String, Codable { 
        case containsall = "containsAll"
        case containsany = "containsAny"
        case notcontainsall = "notContainsAll"
        case notcontainsany = "notContainsAny"
        case equal = "equal"
        case notequal = "notEqual"
        case greaterthan = "greaterThan"
        case greaterthanorequal = "greaterThanOrEqual"
        case lessthan = "lessThan"
        case lessthanorequal = "lessThanOrEqual"
        case startswith = "startsWith"
        case endswith = "endsWith"
    }

    /** The URL condition value. */
    public var values: [String]?
    /** The comparison operator. */
    public var _operator: Operator?

    public init(values: [String]?, _operator: Operator?) {
        self.values = values
        self._operator = _operator
    }

    public enum CodingKeys: String, CodingKey { 
        case values
        case _operator = "operator"
    }


}




public class UserAggregateDataContainer: Codable {





    /** A mapping from dimension to value */
    public var group: [String:String]?
    public var data: [StatisticalResponse]?

    public init(group: [String:String]?, data: [StatisticalResponse]?) {
        self.group = group
        self.data = data
    }


}




public class UserAggregateQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [UserAggregateQueryPredicate]?

    public init(type: ModelType?, predicates: [UserAggregateQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class UserAggregationQuery: Codable {







    public enum GroupBy: String, Codable { 
        case userid = "userId"
    }



    public enum Metrics: String, Codable { 
        case tagentroutingstatus = "tAgentRoutingStatus"
        case torganizationpresence = "tOrganizationPresence"
        case tsystempresence = "tSystemPresence"
    }





    public enum AlternateTimeDimension: String, Codable { 
        case eventtime = "eventTime"
    }

    /** Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H */
    public var granularity: String?
    /** Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var timeZone: String?
    /** Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group. */
    public var groupBy: [GroupBy]?
    /** Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters */
    public var filter: UserAggregateQueryFilter?
    /** Behaves like a SQL SELECT clause. Only named metrics will be retrieved. */
    public var metrics: [Metrics]?
    /** Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c') */
    public var flattenMultivaluedDimensions: Bool?
    /** Custom derived metric views */
    public var views: [UserAggregationView]?
    /** Dimension to use as the alternative timestamp for data in the aggregate.  Choosing \"eventTime\" uses the actual time of the data event. */
    public var alternateTimeDimension: AlternateTimeDimension?

    public init(interval: String?, granularity: String?, timeZone: String?, groupBy: [GroupBy]?, filter: UserAggregateQueryFilter?, metrics: [Metrics]?, flattenMultivaluedDimensions: Bool?, views: [UserAggregationView]?, alternateTimeDimension: AlternateTimeDimension?) {
        self.interval = interval
        self.granularity = granularity
        self.timeZone = timeZone
        self.groupBy = groupBy
        self.filter = filter
        self.metrics = metrics
        self.flattenMultivaluedDimensions = flattenMultivaluedDimensions
        self.views = views
        self.alternateTimeDimension = alternateTimeDimension
    }


}




public class UserDetailQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case userid = "userId"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension predicates */
    public var value: String?
    /** Right hand side for dimension predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case _operator = "operator"
        case value
        case range
    }


}




public class UserDevice: Codable {















    public enum ModelType: String, Codable { 
        case android = "android"
        case ios = "ios"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** device token sent by mobile clients. */
    public var deviceToken: String?
    /** notification id of the device. */
    public var notificationId: String?
    /** make of the device. */
    public var make: String?
    /** Device model */
    public var model: String?
    /** if the device accepts notifications */
    public var acceptNotifications: Bool?
    /** type of the device; ios or android */
    public var type: ModelType?
    public var sessionHash: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, deviceToken: String?, notificationId: String?, make: String?, model: String?, acceptNotifications: Bool?, type: ModelType?, sessionHash: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.deviceToken = deviceToken
        self.notificationId = notificationId
        self.make = make
        self.model = model
        self.acceptNotifications = acceptNotifications
        self.type = type
        self.sessionHash = sessionHash
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case deviceToken
        case notificationId
        case make
        case model
        case acceptNotifications
        case type
        case sessionHash
        case selfUri
    }


}




public class UserEndDetailEventTopicUserEndEvent: Codable {









    public enum DisconnectType: String, Codable { 
        case unknown = "UNKNOWN"
        case endpoint = "ENDPOINT"
        case client = "CLIENT"
        case system = "SYSTEM"
        case transfer = "TRANSFER"
        case error = "ERROR"
        case peer = "PEER"
        case other = "OTHER"
        case spam = "SPAM"
        case timeout = "TIMEOUT"
        case transportFailure = "TRANSPORT_FAILURE"
        case conferenceTransfer = "CONFERENCE_TRANSFER"
        case consultTransfer = "CONSULT_TRANSFER"
        case forwardTransfer = "FORWARD_TRANSFER"
        case noAnswerTransfer = "NO_ANSWER_TRANSFER"
        case notAvailableTransfer = "NOT_AVAILABLE_TRANSFER"
        case uncallable = "UNCALLABLE"
        case dndEndpoint = "DND_ENDPOINT"
        case dndTransfer = "DND_TRANSFER"
    }

    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
    }



    public enum Direction: String, Codable { 
        case unknown = "UNKNOWN"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }

















    public enum MessageType: String, Codable { 
        case unknown = "UNKNOWN"
        case sms = "SMS"
        case twitter = "TWITTER"
        case facebook = "FACEBOOK"
        case line = "LINE"
        case whatsapp = "WHATSAPP"
        case webmessaging = "WEBMESSAGING"
        case _open = "OPEN"
        case instagram = "INSTAGRAM"
    }





















    public var eventTime: Int?
    public var conversationId: String?
    public var participantId: String?
    public var sessionId: String?
    public var disconnectType: DisconnectType?
    public var mediaType: MediaType?
    public var provider: String?
    public var direction: Direction?
    public var ani: String?
    public var dnis: String?
    public var addressTo: String?
    public var addressFrom: String?
    public var callbackUserName: String?
    public var callbackNumbers: [String]?
    public var callbackScheduledTime: Int?
    public var subject: String?
    public var messageType: MessageType?
    public var userId: String?
    public var divisionId: String?
    public var queueId: String?
    public var interactingDurationMs: Int?
    public var heldDurationMs: Int?
    public var alertingDurationMs: Int?
    public var contactingDurationMs: Int?
    public var dialingDurationMs: Int?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?

    public init(eventTime: Int?, conversationId: String?, participantId: String?, sessionId: String?, disconnectType: DisconnectType?, mediaType: MediaType?, provider: String?, direction: Direction?, ani: String?, dnis: String?, addressTo: String?, addressFrom: String?, callbackUserName: String?, callbackNumbers: [String]?, callbackScheduledTime: Int?, subject: String?, messageType: MessageType?, userId: String?, divisionId: String?, queueId: String?, interactingDurationMs: Int?, heldDurationMs: Int?, alertingDurationMs: Int?, contactingDurationMs: Int?, dialingDurationMs: Int?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.sessionId = sessionId
        self.disconnectType = disconnectType
        self.mediaType = mediaType
        self.provider = provider
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.addressTo = addressTo
        self.addressFrom = addressFrom
        self.callbackUserName = callbackUserName
        self.callbackNumbers = callbackNumbers
        self.callbackScheduledTime = callbackScheduledTime
        self.subject = subject
        self.messageType = messageType
        self.userId = userId
        self.divisionId = divisionId
        self.queueId = queueId
        self.interactingDurationMs = interactingDurationMs
        self.heldDurationMs = heldDurationMs
        self.alertingDurationMs = alertingDurationMs
        self.contactingDurationMs = contactingDurationMs
        self.dialingDurationMs = dialingDurationMs
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
    }


}




public class UserEntityListing: Codable {





















    public var entities: [User]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [User]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class UserEstablishedEvent: Codable {



























    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication */
    public var communicationId: String?
    /** Identifies the phone number used to reach this user if it is different from the information that would be accessed by userId. */
    public var phoneNumber: String?
    /** The userId (V4 UUID) for the user this communication belongs to. */
    public var userId: String?
    /** A Station ID (V4 UUID) that identifies the station being used if the user is using a station and the stationId is known. */
    public var stationId: String?
    /** The automatic number identification if it is available for this conversation. */
    public var ani: String?
    /** The dialed number identification if it is available for this conversation. */
    public var dnis: String?
    /** Indicates whether or not this user will be required to complete after call work. */
    public var afterCallWorkRequired: Bool?
    /** The id (V4 UUID) of the queue that the user is calling on behalf of. Applies to outbound calls only. */
    public var queueId: String?
    /** Metadata about this communication. */
    public var initialConfiguration: InitialConfiguration?
    /** Metadata about the source of this communication's interaction. */
    public var sourceConfiguration: SourceConfiguration?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, phoneNumber: String?, userId: String?, stationId: String?, ani: String?, dnis: String?, afterCallWorkRequired: Bool?, queueId: String?, initialConfiguration: InitialConfiguration?, sourceConfiguration: SourceConfiguration?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.phoneNumber = phoneNumber
        self.userId = userId
        self.stationId = stationId
        self.ani = ani
        self.dnis = dnis
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueId = queueId
        self.initialConfiguration = initialConfiguration
        self.sourceConfiguration = sourceConfiguration
    }


}



/** Defines a link between an External Identifier and Authority pair to a Entity Type and Entity Identifier pair. Represents the two way, one to one mapping of an External Authority or System of Record's identifier to a PureCloud entity. e.g. (ExternalId='05001',Authority='XyzCRM') to (entityType=user,entityId='8eb03b33-3acb-4bc1-a244-50b9b9f19495') */

public class UserExternalIdentifier: Codable {







    /** Authority or System of Record which owns the External Identifier */
    public var authorityName: String?
    /** External Key */
    public var externalKey: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(authorityName: String?, externalKey: String?, selfUri: String?) {
        self.authorityName = authorityName
        self.externalKey = externalKey
        self.selfUri = selfUri
    }


}




public class UserLicenses: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var licenses: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, licenses: [String]?, selfUri: String?) {
        self._id = _id
        self.licenses = licenses
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case licenses
        case selfUri
    }


}




public class UserObservationQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [UserObservationQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [UserObservationQueryPredicate]?

    public init(type: ModelType?, clauses: [UserObservationQueryClause]?, predicates: [UserObservationQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class UserParam: Codable {





    public var key: String?
    public var value: String?

    public init(key: String?, value: String?) {
        self.key = key
        self.value = value
    }


}




public class UserQueue: Codable {































    public enum ScoringMethod: String, Codable { 
        case timestampAndPriority = "TimestampAndPriority"
        case priorityOnly = "PriorityOnly"
    }



    public enum SkillEvaluationMethod: String, Codable { 
        case _none = "NONE"
        case best = "BEST"
        case all = "ALL"
    }









































    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The queue description. */
    public var _description: String?
    /** The date the queue was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the queue. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the queue. */
    public var modifiedBy: String?
    /** The ID of the user that created the queue. */
    public var createdBy: String?
    /** The total number of members in the queue. */
    public var memberCount: Int?
    /** The number of user members (i.e., non-group members) in the queue. */
    public var userMemberCount: Int?
    /** The number of joined members in the queue. */
    public var joinedMemberCount: Int?
    /** The media settings for the queue. */
    public var mediaSettings: QueueMediaSettings?
    /** The routing rules for the queue, used for Preferred Agent Routing. */
    public var routingRules: [RoutingRule]?
    /** The Conditional Group Routing settings for the queue. */
    public var conditionalGroupRouting: ConditionalGroupRouting?
    /** The bullseye settings for the queue. */
    public var bullseye: Bullseye?
    /** The Scoring Method for the queue */
    public var scoringMethod: ScoringMethod?
    /** The ACW settings for the queue. */
    public var acwSettings: AcwSettings?
    /** The skill evaluation method to use when routing conversations. */
    public var skillEvaluationMethod: SkillEvaluationMethod?
    /** The groups of agents associated with the queue, if any.  Queue membership will update to match group membership changes. */
    public var memberGroups: [MemberGroup]?
    /** The in-queue flow to use for call conversations waiting in queue. */
    public var queueFlow: DomainEntityRef?
    /** The in-queue flow to use for email conversations waiting in queue. */
    public var emailInQueueFlow: DomainEntityRef?
    /** The in-queue flow to use for message conversations waiting in queue. */
    public var messageInQueueFlow: DomainEntityRef?
    /** The prompt used for whisper on the queue, if configured. */
    public var whisperPrompt: DomainEntityRef?
    /** The audio to be played when calls on this queue are on hold. If not configured, the default on-hold music will play. */
    public var onHoldPrompt: DomainEntityRef?
    /** Indicates whether voice transcription is enabled for this queue. */
    public var enableTranscription: Bool?
    /** Indicates whether audio monitoring is enabled for this queue. */
    public var enableAudioMonitoring: Bool?
    /** Indicates whether manual assignment is enabled for this queue. */
    public var enableManualAssignment: Bool?
    /** The Agent Owned Routing settings for the queue */
    public var agentOwnedRouting: AgentOwnedRouting?
    /** The Direct Routing settings for the queue */
    public var directRouting: DirectRouting?
    /** The name to use for caller identification for outbound calls from this queue. */
    public var callingPartyName: String?
    /** The phone number to use for caller identification for outbound calls from this queue. */
    public var callingPartyNumber: String?
    /** The default script Ids for the communication types. */
    public var defaultScripts: [String:Script]?
    /** The messaging addresses for the queue. */
    public var outboundMessagingAddresses: QueueMessagingAddresses?
    public var outboundEmailAddress: QueueEmailAddress?
    /** The ID of an associated external queue. */
    public var peerId: String?
    /** Indicates whether recording in-queue calls is suppressed for this queue. */
    public var suppressInQueueCallRecording: Bool?
    public var joined: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, memberCount: Int?, userMemberCount: Int?, joinedMemberCount: Int?, mediaSettings: QueueMediaSettings?, routingRules: [RoutingRule]?, conditionalGroupRouting: ConditionalGroupRouting?, bullseye: Bullseye?, scoringMethod: ScoringMethod?, acwSettings: AcwSettings?, skillEvaluationMethod: SkillEvaluationMethod?, memberGroups: [MemberGroup]?, queueFlow: DomainEntityRef?, emailInQueueFlow: DomainEntityRef?, messageInQueueFlow: DomainEntityRef?, whisperPrompt: DomainEntityRef?, onHoldPrompt: DomainEntityRef?, enableTranscription: Bool?, enableAudioMonitoring: Bool?, enableManualAssignment: Bool?, agentOwnedRouting: AgentOwnedRouting?, directRouting: DirectRouting?, callingPartyName: String?, callingPartyNumber: String?, defaultScripts: [String:Script]?, outboundMessagingAddresses: QueueMessagingAddresses?, outboundEmailAddress: QueueEmailAddress?, peerId: String?, suppressInQueueCallRecording: Bool?, joined: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.memberCount = memberCount
        self.userMemberCount = userMemberCount
        self.joinedMemberCount = joinedMemberCount
        self.mediaSettings = mediaSettings
        self.routingRules = routingRules
        self.conditionalGroupRouting = conditionalGroupRouting
        self.bullseye = bullseye
        self.scoringMethod = scoringMethod
        self.acwSettings = acwSettings
        self.skillEvaluationMethod = skillEvaluationMethod
        self.memberGroups = memberGroups
        self.queueFlow = queueFlow
        self.emailInQueueFlow = emailInQueueFlow
        self.messageInQueueFlow = messageInQueueFlow
        self.whisperPrompt = whisperPrompt
        self.onHoldPrompt = onHoldPrompt
        self.enableTranscription = enableTranscription
        self.enableAudioMonitoring = enableAudioMonitoring
        self.enableManualAssignment = enableManualAssignment
        self.agentOwnedRouting = agentOwnedRouting
        self.directRouting = directRouting
        self.callingPartyName = callingPartyName
        self.callingPartyNumber = callingPartyNumber
        self.defaultScripts = defaultScripts
        self.outboundMessagingAddresses = outboundMessagingAddresses
        self.outboundEmailAddress = outboundEmailAddress
        self.peerId = peerId
        self.suppressInQueueCallRecording = suppressInQueueCallRecording
        self.joined = joined
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case memberCount
        case userMemberCount
        case joinedMemberCount
        case mediaSettings
        case routingRules
        case conditionalGroupRouting
        case bullseye
        case scoringMethod
        case acwSettings
        case skillEvaluationMethod
        case memberGroups
        case queueFlow
        case emailInQueueFlow
        case messageInQueueFlow
        case whisperPrompt
        case onHoldPrompt
        case enableTranscription
        case enableAudioMonitoring
        case enableManualAssignment
        case agentOwnedRouting
        case directRouting
        case callingPartyName
        case callingPartyNumber
        case defaultScripts
        case outboundMessagingAddresses
        case outboundEmailAddress
        case peerId
        case suppressInQueueCallRecording
        case joined
        case selfUri
    }


}




public class UserRecordingEntityListing: Codable {





















    public var entities: [UserRecording]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [UserRecording]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** Represents an organization skill assigned to a user. When assigning to a user specify the organization skill id as the id. */

public class UserRoutingSkillPost: Codable {









    /** The id of the existing routing skill to add to the user */
    public var _id: String?
    /** Proficiency is a rating from 0.0 to 5.0 on how competent an agent is for a particular skill. It is used when a queue is set to \"Best available skills\" mode to allow acd interactions to target agents with higher proficiency ratings. */
    public var proficiency: Double?
    /** URI to the organization skill used by this user skill. */
    public var skillUri: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, proficiency: Double?, skillUri: String?, selfUri: String?) {
        self._id = _id
        self.proficiency = proficiency
        self.skillUri = skillUri
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case proficiency
        case skillUri
        case selfUri
    }


}




public class UserRoutingStatusEvent: Codable {







    public enum Status: String, Codable { 
        case offQueue = "OffQueue"
        case idle = "Idle"
        case interacting = "Interacting"
        case communicating = "Communicating"
        case notResponding = "NotResponding"
    }



    /** A unique (UUID) eventId for this event */
    public var eventId: String?
    /** A timestamp as epoch representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** Unique identifier of the agent. */
    public var agentId: String?
    /** The agent's current routing status. */
    public var status: Status?
    /** The agent's source platform Id. */
    public var sourceId: String?

    public init(eventId: String?, eventDateTime: Date?, agentId: String?, status: Status?, sourceId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.agentId = agentId
        self.status = status
        self.sourceId = sourceId
    }


}




public class UserSearchCriteria: Codable {









    public enum Operator: String, Codable { 
        case and = "AND"
        case or = "OR"
        case not = "NOT"
    }







    public enum ModelType: String, Codable { 
        case exact = "EXACT"
        case startsWith = "STARTS_WITH"
        case contains = "CONTAINS"
        case regex = "REGEX"
        case term = "TERM"
        case terms = "TERMS"
        case requiredFields = "REQUIRED_FIELDS"
        case matchAll = "MATCH_ALL"
        case queryString = "QUERY_STRING"
    }

    /** The end value of the range. This field is used for range search types. */
    public var endValue: String?
    /** A list of values for the search to match against */
    public var values: [String]?
    /** The start value of the range. This field is used for range search types. */
    public var startValue: String?
    /** A value for the search to match against */
    public var value: String?
    /** How to apply this search criteria against other criteria */
    public var _operator: Operator?
    /** Groups multiple conditions */
    public var group: [UserSearchCriteria]?
    /** Set date format for criteria values when using date range search type.  Supports Java date format syntax, example yyyy-MM-dd'T'HH:mm:ss.SSSX. */
    public var dateFormat: String?
    /** Field names to search against */
    public var fields: [String]?
    /** Search Type */
    public var type: ModelType?

    public init(endValue: String?, values: [String]?, startValue: String?, value: String?, _operator: Operator?, group: [UserSearchCriteria]?, dateFormat: String?, fields: [String]?, type: ModelType?) {
        self.endValue = endValue
        self.values = values
        self.startValue = startValue
        self.value = value
        self._operator = _operator
        self.group = group
        self.dateFormat = dateFormat
        self.fields = fields
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case endValue
        case values
        case startValue
        case value
        case _operator = "operator"
        case group
        case dateFormat
        case fields
        case type
    }


}




public class UserTokensTopicTokenNotification: Codable {















    public var user: UserTokensTopicUriReference?
    public var ipAddress: String?
    public var dateCreated: String?
    public var tokenExpirationDate: String?
    public var sessionId: String?
    public var clientId: String?
    public var tokenHash: String?

    public init(user: UserTokensTopicUriReference?, ipAddress: String?, dateCreated: String?, tokenExpirationDate: String?, sessionId: String?, clientId: String?, tokenHash: String?) {
        self.user = user
        self.ipAddress = ipAddress
        self.dateCreated = dateCreated
        self.tokenExpirationDate = tokenExpirationDate
        self.sessionId = sessionId
        self.clientId = clientId
        self.tokenHash = tokenHash
    }


}




public class UserTrendData: Codable {













    /** Start workday used as the date range. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStartWorkday: Date?
    /** End workday used as the date range. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEndWorkday: Date?
    /** Percent of goal */
    public var percentOfGoal: Double?
    /** Average metric value */
    public var averageValue: Double?
    /** Rank, ordered by total points */
    public var rankTotalPoints: Int?
    /** Rank, ordered by percentage of points */
    public var rankPercentagePoints: Int?

    public init(dateStartWorkday: Date?, dateEndWorkday: Date?, percentOfGoal: Double?, averageValue: Double?, rankTotalPoints: Int?, rankPercentagePoints: Int?) {
        self.dateStartWorkday = dateStartWorkday
        self.dateEndWorkday = dateEndWorkday
        self.percentOfGoal = percentOfGoal
        self.averageValue = averageValue
        self.rankTotalPoints = rankTotalPoints
        self.rankPercentagePoints = rankPercentagePoints
    }


}




public class UtilizationResponse: Codable {



    /** Map of media type to utilization settings. */
    public var utilization: [String:MediaUtilization]?

    public init(utilization: [String:MediaUtilization]?) {
        self.utilization = utilization
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationContentActions: Codable {







    public var url: String?
    public var urlTarget: String?
    public var textback: String?

    public init(url: String?, urlTarget: String?, textback: String?) {
        self.url = url
        self.urlTarget = urlTarget
        self.textback = textback
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationContentGeneric: Codable {













    public var title: String?
    public var _description: String?
    public var image: String?
    public var video: String?
    public var actions: V2ConversationMessageTypingEventForUserTopicConversationContentActions?
    public var components: [V2ConversationMessageTypingEventForUserTopicConversationButtonComponent]?

    public init(title: String?, _description: String?, image: String?, video: String?, actions: V2ConversationMessageTypingEventForUserTopicConversationContentActions?, components: [V2ConversationMessageTypingEventForUserTopicConversationButtonComponent]?) {
        self.title = title
        self._description = _description
        self.image = image
        self.video = video
        self.actions = actions
        self.components = components
    }

    public enum CodingKeys: String, CodingKey { 
        case title
        case _description = "description"
        case image
        case video
        case actions
        case components
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationMessagingToRecipient: Codable {





    public enum IdType: String, Codable { 
        case email = "Email"
        case phone = "Phone"
        case opaque = "Opaque"
    }











    public var nickname: String?
    public var _id: String?
    public var idType: IdType?
    public var image: String?
    public var firstName: String?
    public var lastName: String?
    public var email: String?
    public var additionalIds: [V2ConversationMessageTypingEventForUserTopicConversationRecipientAdditionalIdentifier]?

    public init(nickname: String?, _id: String?, idType: IdType?, image: String?, firstName: String?, lastName: String?, email: String?, additionalIds: [V2ConversationMessageTypingEventForUserTopicConversationRecipientAdditionalIdentifier]?) {
        self.nickname = nickname
        self._id = _id
        self.idType = idType
        self.image = image
        self.firstName = firstName
        self.lastName = lastName
        self.email = email
        self.additionalIds = additionalIds
    }

    public enum CodingKeys: String, CodingKey { 
        case nickname
        case _id = "id"
        case idType
        case image
        case firstName
        case lastName
        case email
        case additionalIds
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationNotificationTemplateParameter: Codable {





    public var name: String?
    public var text: String?

    public init(name: String?, text: String?) {
        self.name = name
        self.text = text
    }


}




public class V2ConversationMessageTypingEventForUserTopicMessageData: Codable {





    public var conversationId: String?
    public var normalizedMessage: V2ConversationMessageTypingEventForUserTopicConversationNormalizedMessage?

    public init(conversationId: String?, normalizedMessage: V2ConversationMessageTypingEventForUserTopicConversationNormalizedMessage?) {
        self.conversationId = conversationId
        self.normalizedMessage = normalizedMessage
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationButtonComponent: Codable {





    public var title: String?
    public var actions: V2ConversationMessageTypingEventForWorkflowTopicConversationContentActions?

    public init(title: String?, actions: V2ConversationMessageTypingEventForWorkflowTopicConversationContentActions?) {
        self.title = title
        self.actions = actions
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationEventCoBrowse: Codable {

    public enum ModelType: String, Codable { 
        case offering = "Offering"
        case offeringExpired = "OfferingExpired"
        case offeringAccepted = "OfferingAccepted"
        case offeringRejected = "OfferingRejected"
    }





    public var type: ModelType?
    public var sessionId: String?
    public var sessionJoinToken: String?

    public init(type: ModelType?, sessionId: String?, sessionJoinToken: String?) {
        self.type = type
        self.sessionId = sessionId
        self.sessionJoinToken = sessionJoinToken
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationMessageEvent: Codable {

    public enum EventType: String, Codable { 
        case coBrowse = "CoBrowse"
        case typing = "Typing"
    }





    public var eventType: EventType?
    public var coBrowse: V2ConversationMessageTypingEventForWorkflowTopicConversationEventCoBrowse?
    public var typing: V2ConversationMessageTypingEventForWorkflowTopicConversationEventTyping?

    public init(eventType: EventType?, coBrowse: V2ConversationMessageTypingEventForWorkflowTopicConversationEventCoBrowse?, typing: V2ConversationMessageTypingEventForWorkflowTopicConversationEventTyping?) {
        self.eventType = eventType
        self.coBrowse = coBrowse
        self.typing = typing
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationMessagingChannel: Codable {



    public enum Platform: String, Codable { 
        case twitter = "Twitter"
        case facebook = "Facebook"
        case instagram = "Instagram"
        case line = "Line"
        case whatsapp = "Whatsapp"
        case webMessaging = "WebMessaging"
        case _open = "Open"
        case sms = "Sms"
    }















    public var _id: String?
    public var platform: Platform?
    public var messageId: String?
    public var to: V2ConversationMessageTypingEventForWorkflowTopicConversationMessagingToRecipient?
    public var from: V2ConversationMessageTypingEventForWorkflowTopicConversationMessagingFromRecipient?
    public var time: Date?
    public var dateModified: Date?
    public var dateDeleted: Date?
    public var metadata: V2ConversationMessageTypingEventForWorkflowTopicConversationMessagingChannelMetadata?

    public init(_id: String?, platform: Platform?, messageId: String?, to: V2ConversationMessageTypingEventForWorkflowTopicConversationMessagingToRecipient?, from: V2ConversationMessageTypingEventForWorkflowTopicConversationMessagingFromRecipient?, time: Date?, dateModified: Date?, dateDeleted: Date?, metadata: V2ConversationMessageTypingEventForWorkflowTopicConversationMessagingChannelMetadata?) {
        self._id = _id
        self.platform = platform
        self.messageId = messageId
        self.to = to
        self.from = from
        self.time = time
        self.dateModified = dateModified
        self.dateDeleted = dateDeleted
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case platform
        case messageId
        case to
        case from
        case time
        case dateModified
        case dateDeleted
        case metadata
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationNotificationTemplateHeader: Codable {

    public enum ModelType: String, Codable { 
        case text = "Text"
        case media = "Media"
    }







    public var type: ModelType?
    public var text: String?
    public var media: V2ConversationMessageTypingEventForWorkflowTopicConversationContentAttachment?
    public var parameters: [V2ConversationMessageTypingEventForWorkflowTopicConversationNotificationTemplateParameter]?

    public init(type: ModelType?, text: String?, media: V2ConversationMessageTypingEventForWorkflowTopicConversationContentAttachment?, parameters: [V2ConversationMessageTypingEventForWorkflowTopicConversationNotificationTemplateParameter]?) {
        self.type = type
        self.text = text
        self.media = media
        self.parameters = parameters
    }


}




public class V2FlowExecutionDataFlowidTopicExecution: Codable {

















    /** The type of executionItem that was executed. */
    public var objectType: String?
    /** If applicable, the actionId, menuId or taskId for the executionItem. */
    public var objectId: String?
    /** If applicable, the identifier of the OutputPath that was taken. */
    public var outputPathId: String?
    /** If applicable, the executionId for the executionItem. */
    public var executionId: String?
    /** This is the starting time of the executionItem. */
    public var startDateTime: Date?
    /** Event generated when a Flow's Execution History is received and logged. */
    public var error: V2FlowExecutionDataFlowidTopicFlowErrorWarningInfo?
    /** Event generated when a Flow's Execution History is received and logged. */
    public var warning: V2FlowExecutionDataFlowidTopicFlowErrorWarningInfo?
    /** If applicable, the language tag associated set by the execution. */
    public var languageTag: String?

    public init(objectType: String?, objectId: String?, outputPathId: String?, executionId: String?, startDateTime: Date?, error: V2FlowExecutionDataFlowidTopicFlowErrorWarningInfo?, warning: V2FlowExecutionDataFlowidTopicFlowErrorWarningInfo?, languageTag: String?) {
        self.objectType = objectType
        self.objectId = objectId
        self.outputPathId = outputPathId
        self.executionId = executionId
        self.startDateTime = startDateTime
        self.error = error
        self.warning = warning
        self.languageTag = languageTag
    }


}



/** This contains information about the flow that invoked this execution.  Both a flow execution and action identifier are needed to uniquely identify the invocation point. */

public class V2FlowExecutionDataFlowidTopicFlow: Codable {





    /** The flow execution identifier whose runtime that invoked this. */
    public var flowExecutionId: String?
    /** The object execution identifier within the flow whose runtime that invoked this.  In Architect flows, this object execution identifier will be either an action execution identifier or a menu execution identifier. */
    public var objectExecutionId: String?

    public init(flowExecutionId: String?, objectExecutionId: String?) {
        self.flowExecutionId = flowExecutionId
        self.objectExecutionId = objectExecutionId
    }


}



/** This contains contextual information about an invoking entity. */

public class V2FlowExecutionDataFlowidTopicInvokingContext: Codable {









    public var flow: V2FlowExecutionDataFlowidTopicFlow?
    public var journeyActionMap: V2FlowExecutionDataFlowidTopicJourneyActionMap?
    public var processAutomation: V2FlowExecutionDataFlowidTopicProcessAutomation?
    public var quality: V2FlowExecutionDataFlowidTopicQuality?

    public init(flow: V2FlowExecutionDataFlowidTopicFlow?, journeyActionMap: V2FlowExecutionDataFlowidTopicJourneyActionMap?, processAutomation: V2FlowExecutionDataFlowidTopicProcessAutomation?, quality: V2FlowExecutionDataFlowidTopicQuality?) {
        self.flow = flow
        self.journeyActionMap = journeyActionMap
        self.processAutomation = processAutomation
        self.quality = quality
    }


}




public class V2MobiusRulesTopicAlertNotification: Codable {



    public enum NotificationTypes: String, Codable { 
        case device = "Device"
        case email = "Email"
        case sms = "Sms"
        case push = "Push"
        case unknown = "Unknown"
    }

    public var recipient: String?
    public var notificationTypes: [NotificationTypes]?

    public init(recipient: String?, notificationTypes: [NotificationTypes]?) {
        self.recipient = recipient
        self.notificationTypes = notificationTypes
    }


}




public class ValidateAddressResponse: Codable {





    /** Was the passed in address valid */
    public var valid: Bool?
    /** Subscriber schema */
    public var response: SubscriberResponse?

    public init(valid: Bool?, response: SubscriberResponse?) {
        self.valid = valid
        self.response = response
    }


}




public class ValueWrapperHrisTimeOffType: Codable {



    /** The value for the associated field */
    public var value: HrisTimeOffType?

    public init(value: HrisTimeOffType?) {
        self.value = value
    }


}




public class ValueWrapperString: Codable {



    /** The value for the associated field */
    public var value: String?

    public init(value: String?) {
        self.value = value
    }


}




public class VoicemailMediaInfo: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var mediaFileUri: String?
    public var mediaImageUri: String?
    public var waveformData: [Float]?

    public init(_id: String?, mediaFileUri: String?, mediaImageUri: String?, waveformData: [Float]?) {
        self._id = _id
        self.mediaFileUri = mediaFileUri
        self.mediaImageUri = mediaImageUri
        self.waveformData = waveformData
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case mediaFileUri
        case mediaImageUri
        case waveformData
    }


}




public class VoicemailMessageEntityListing: Codable {





















    public var entities: [VoicemailMessage]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [VoicemailMessage]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** Governs how the voicemail is retained */

public class VoicemailRetentionPolicy: Codable {

    public enum VoicemailRetentionPolicyType: String, Codable { 
        case retainIndefinitely = "RETAIN_INDEFINITELY"
        case retainWithTtl = "RETAIN_WITH_TTL"
        case immediateDelete = "IMMEDIATE_DELETE"
    }



    /** The retention policy type */
    public var voicemailRetentionPolicyType: VoicemailRetentionPolicyType?
    /** If retentionPolicyType == RETAIN_WITH_TTL, then this value represents the number of days for the TTL */
    public var numberOfDays: Int?

    public init(voicemailRetentionPolicyType: VoicemailRetentionPolicyType?, numberOfDays: Int?) {
        self.voicemailRetentionPolicyType = voicemailRetentionPolicyType
        self.numberOfDays = numberOfDays
    }


}




public class WaitlistPosition: Codable {









    /** The time off request for this wait list position */
    public var timeOffRequest: TimeOffRequestReference?
    /** The time off limit for which time off request is waitlisted */
    public var timeOffLimit: TimeOffLimitReference?
    /** The date to which this wait list position applies, as defined by the time zone of the business unit. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var date: Date?
    /** The time off request's position in the waitlist on the date. 1 means time off is the first in the waitlist */
    public var waitlistPosition: Int?

    public init(timeOffRequest: TimeOffRequestReference?, timeOffLimit: TimeOffLimitReference?, date: Date?, waitlistPosition: Int?) {
        self.timeOffRequest = timeOffRequest
        self.timeOffLimit = timeOffLimit
        self.date = date
        self.waitlistPosition = waitlistPosition
    }


}




public class WaitlistPositionListing: Codable {



    public var entities: [WaitlistPosition]?

    public init(entities: [WaitlistPosition]?) {
        self.entities = entities
    }


}




public class WebChatDeployment: Codable {





















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var _description: String?
    public var authenticationRequired: Bool?
    /** URL for third party service authenticating web chat clients. See https://github.com/MyPureCloud/authenticated-web-chat-server-examples */
    public var authenticationUrl: String?
    public var disabled: Bool?
    public var webChatConfig: WebChatConfig?
    public var allowedDomains: [String]?
    /** The URI of the Inbound Chat Flow to run when new chats are initiated under this Deployment. */
    public var flow: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, authenticationRequired: Bool?, authenticationUrl: String?, disabled: Bool?, webChatConfig: WebChatConfig?, allowedDomains: [String]?, flow: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.authenticationRequired = authenticationRequired
        self.authenticationUrl = authenticationUrl
        self.disabled = disabled
        self.webChatConfig = webChatConfig
        self.allowedDomains = allowedDomains
        self.flow = flow
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case authenticationRequired
        case authenticationUrl
        case disabled
        case webChatConfig
        case allowedDomains
        case flow
        case selfUri
    }


}




public class WebDeploymentsJourneyContext: Codable {







    /** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */
    public var journeyAction: JourneyAction?
    /** Journey customer information. Used for linking the authenticated customer with the journey.  */
    public var customer: JourneyCustomer?
    /** Contains the Journey System's customer session details. */
    public var customerSession: JourneyCustomerSession?

    public init(journeyAction: JourneyAction?, customer: JourneyCustomer?, customerSession: JourneyCustomerSession?) {
        self.journeyAction = journeyAction
        self.customer = customer
        self.customerSession = customerSession
    }


}




public class WebDeploymentsOAuthExchangeRequest: Codable {







    /** The WebDeployment ID */
    public var deploymentId: String?
    /** A Customer journey context. */
    public var journeyContext: WebDeploymentsJourneyContext?
    public var oauth: WebDeploymentsOAuthRequestParameters?

    public init(deploymentId: String?, journeyContext: WebDeploymentsJourneyContext?, oauth: WebDeploymentsOAuthRequestParameters?) {
        self.deploymentId = deploymentId
        self.journeyContext = journeyContext
        self.oauth = oauth
    }


}




public class WebDeploymentsRefreshJWTRequest: Codable {





    /** Refresh token used to issue a new JWT. */
    public var refreshToken: String?
    /** The WebDeployment ID */
    public var deploymentId: String?

    public init(refreshToken: String?, deploymentId: String?) {
        self.refreshToken = refreshToken
        self.deploymentId = deploymentId
    }


}



/** A Presence event. */

public class WebMessagingEventPresence: Codable {

    public enum ModelType: String, Codable { 
        case join = "Join"
        case disconnect = "Disconnect"
        case clear = "Clear"
        case signIn = "SignIn"
    }

    /** Describes the type of Presence event. */
    public var type: ModelType?

    public init(type: ModelType?) {
        self.type = type
    }


}




public class WeekScheduleListItemResponse: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?
    /** First day of this week schedule in yyyy-MM-dd format */
    public var weekDate: String?
    /** Description of the week schedule */
    public var _description: String?
    /** Whether the week schedule is published */
    public var published: Bool?
    /** Summary of the results from the schedule run */
    public var generationResults: WeekScheduleGenerationResult?
    /** Short term forecast associated with this schedule */
    public var shortTermForecast: ShortTermForecastReference?
    /** Version metadata for this work plan */
    public var metadata: WfmVersionedEntityMetadata?

    public init(_id: String?, selfUri: String?, weekDate: String?, _description: String?, published: Bool?, generationResults: WeekScheduleGenerationResult?, shortTermForecast: ShortTermForecastReference?, metadata: WfmVersionedEntityMetadata?) {
        self._id = _id
        self.selfUri = selfUri
        self.weekDate = weekDate
        self._description = _description
        self.published = published
        self.generationResults = generationResults
        self.shortTermForecast = shortTermForecast
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case weekDate
        case _description = "description"
        case published
        case generationResults
        case shortTermForecast
        case metadata
    }


}




public class WfmAdherenceExplanationJobCompleteTopicBusinessUnit: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmAdherenceExplanationJobCompleteTopicErrorBody: Codable {









    public var status: Int?
    public var code: String?
    public var message: String?
    public var messageParams: [String:String]?

    public init(status: Int?, code: String?, message: String?, messageParams: [String:String]?) {
        self.status = status
        self.code = code
        self.message = message
        self.messageParams = messageParams
    }


}




public class WfmAgentAdherenceExplanationChangedAgentTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmAgentAdherenceExplanationChangedBusinessUnitTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmAgentScheduleUpdateTopicAgentScheduleShiftUpdate: Codable {

    public enum ModelType: String, Codable { 
        case added = "Added"
        case edited = "Edited"
        case deleted = "Deleted"
    }



    public var type: ModelType?
    public var shiftStartDates: [Date]?

    public init(type: ModelType?, shiftStartDates: [Date]?) {
        self.type = type
        self.shiftStartDates = shiftStartDates
    }


}




public class WfmAgentScheduleUpdateTopicAgentScheduleUpdateNotification: Codable {









    public var user: WfmAgentScheduleUpdateTopicUserReference?
    public var startDate: Date?
    public var endDate: Date?
    public var updates: [WfmAgentScheduleUpdateTopicAgentScheduleShiftUpdate]?

    public init(user: WfmAgentScheduleUpdateTopicUserReference?, startDate: Date?, endDate: Date?, updates: [WfmAgentScheduleUpdateTopicAgentScheduleShiftUpdate]?) {
        self.user = user
        self.startDate = startDate
        self.endDate = endDate
        self.updates = updates
    }


}




public class WfmBuIntradayDataUpdateTopicBuShortTermForecastReference: Codable {







    public var _id: String?
    public var weekDate: String?
    public var _description: String?

    public init(_id: String?, weekDate: String?, _description: String?) {
        self._id = _id
        self.weekDate = weekDate
        self._description = _description
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case _description = "description"
    }


}




public class WfmBuScheduleTopicBuScheduleMetadata: Codable {



















    public var _id: String?
    public var weekDate: Date?
    public var weekCount: Int?
    public var _description: String?
    public var published: Bool?
    public var shortTermForecast: WfmBuScheduleTopicBuShortTermForecastReference?
    public var managementUnits: [WfmBuScheduleTopicBuManagementUnitScheduleSummary]?
    public var generationResults: WfmBuScheduleTopicBuScheduleGenerationResultSummary?
    public var metadata: WfmBuScheduleTopicWfmVersionedEntityMetadata?

    public init(_id: String?, weekDate: Date?, weekCount: Int?, _description: String?, published: Bool?, shortTermForecast: WfmBuScheduleTopicBuShortTermForecastReference?, managementUnits: [WfmBuScheduleTopicBuManagementUnitScheduleSummary]?, generationResults: WfmBuScheduleTopicBuScheduleGenerationResultSummary?, metadata: WfmBuScheduleTopicWfmVersionedEntityMetadata?) {
        self._id = _id
        self.weekDate = weekDate
        self.weekCount = weekCount
        self._description = _description
        self.published = published
        self.shortTermForecast = shortTermForecast
        self.managementUnits = managementUnits
        self.generationResults = generationResults
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case weekCount
        case _description = "description"
        case published
        case shortTermForecast
        case managementUnits
        case generationResults
        case metadata
    }


}




public class WfmBuScheduleTopicManagementUnit: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmBuShortTermForecastGenerateProgressTopicBuShortTermForecast: Codable {





    public enum CreationMethod: String, Codable { 
        case _import = "Import"
        case importedHistoricalWeightedAverage = "ImportedHistoricalWeightedAverage"
        case historicalWeightedAverage = "HistoricalWeightedAverage"
        case advanced = "Advanced"
    }





















    public var _id: String?
    public var weekDate: String?
    public var creationMethod: CreationMethod?
    public var _description: String?
    public var legacy: Bool?
    public var referenceStartDate: Date?
    public var sourceDays: [WfmBuShortTermForecastGenerateProgressTopicForecastSourceDayPointer]?
    public var modifications: [WfmBuShortTermForecastGenerateProgressTopicBuForecastModification]?
    public var timeZone: String?
    public var planningGroupsVersion: Int?
    public var weekCount: Int?
    public var metadata: WfmBuShortTermForecastGenerateProgressTopicWfmVersionedEntityMetadata?
    public var canUseForScheduling: Bool?

    public init(_id: String?, weekDate: String?, creationMethod: CreationMethod?, _description: String?, legacy: Bool?, referenceStartDate: Date?, sourceDays: [WfmBuShortTermForecastGenerateProgressTopicForecastSourceDayPointer]?, modifications: [WfmBuShortTermForecastGenerateProgressTopicBuForecastModification]?, timeZone: String?, planningGroupsVersion: Int?, weekCount: Int?, metadata: WfmBuShortTermForecastGenerateProgressTopicWfmVersionedEntityMetadata?, canUseForScheduling: Bool?) {
        self._id = _id
        self.weekDate = weekDate
        self.creationMethod = creationMethod
        self._description = _description
        self.legacy = legacy
        self.referenceStartDate = referenceStartDate
        self.sourceDays = sourceDays
        self.modifications = modifications
        self.timeZone = timeZone
        self.planningGroupsVersion = planningGroupsVersion
        self.weekCount = weekCount
        self.metadata = metadata
        self.canUseForScheduling = canUseForScheduling
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case creationMethod
        case _description = "description"
        case legacy
        case referenceStartDate
        case sourceDays
        case modifications
        case timeZone
        case planningGroupsVersion
        case weekCount
        case metadata
        case canUseForScheduling
    }


}




public class WfmBuShortTermForecastImportCompleteTopicForecastSourceDayPointer: Codable {

    public enum DayOfWeek: String, Codable { 
        case sunday = "Sunday"
        case monday = "Monday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
        case thursday = "Thursday"
        case friday = "Friday"
        case saturday = "Saturday"
        case eighthDay = "EighthDay"
    }









    public var dayOfWeek: DayOfWeek?
    public var weight: Int?
    public var date: String?
    public var fileName: String?
    public var dataKey: String?

    public init(dayOfWeek: DayOfWeek?, weight: Int?, date: String?, fileName: String?, dataKey: String?) {
        self.dayOfWeek = dayOfWeek
        self.weight = weight
        self.date = date
        self.fileName = fileName
        self.dataKey = dataKey
    }


}




public class WfmBuShortTermForecastImportCompleteTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmBuShortTermForecastStaffingRequirementsGenerateCompleteTopicBuForecastShortTermStaffingRequirementsResults: Codable {







    public var weekNumber: Int?
    public var downloadUrl: String?
    public var downloadUrlExpirationDate: Date?

    public init(weekNumber: Int?, downloadUrl: String?, downloadUrlExpirationDate: Date?) {
        self.weekNumber = weekNumber
        self.downloadUrl = downloadUrl
        self.downloadUrlExpirationDate = downloadUrlExpirationDate
    }


}




public class WfmBuShortTermForecastStaffingRequirementsGenerateCompleteTopicBuShortTermForecastReference: Codable {







    public var _id: String?
    public var weekDate: String?
    public var _description: String?

    public init(_id: String?, weekDate: String?, _description: String?) {
        self._id = _id
        self.weekDate = weekDate
        self._description = _description
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case _description = "description"
    }


}




public class WfmHistoricalAdherenceBulkCalculationsCompleteTopicWfmHistoricalAdherenceBulkCalculationsCompleteNotification: Codable {





    public enum QueryState: String, Codable { 
        case unknown = "Unknown"
        case complete = "Complete"
        case error = "Error"
        case processing = "Processing"
    }

    public var _id: String?
    public var downloadUrls: [String]?
    public var queryState: QueryState?

    public init(_id: String?, downloadUrls: [String]?, queryState: QueryState?) {
        self._id = _id
        self.downloadUrls = downloadUrls
        self.queryState = queryState
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case downloadUrls
        case queryState
    }


}




public class WfmHistoricalAdherenceBulkItem: Codable {













    /** The ID of the management unit to query */
    public var managementUnitId: String?
    /** Beginning of the date range to query in ISO-8601 format */
    public var startDate: Date?
    /** End of the date range to query in ISO-8601 format */
    public var endDate: Date?
    /** The IDs of the users to query. If not included, will query every user in the management unit */
    public var userIds: [String]?
    /** Whether user exceptions should be returned as part of the results. Defaults to false if not specified. */
    public var includeExceptions: Bool?
    /** Whether user actual activities should be returned as part of the results. Defaults to false if not specified. */
    public var includeActuals: Bool?

    public init(managementUnitId: String?, startDate: Date?, endDate: Date?, userIds: [String]?, includeExceptions: Bool?, includeActuals: Bool?) {
        self.managementUnitId = managementUnitId
        self.startDate = startDate
        self.endDate = endDate
        self.userIds = userIds
        self.includeExceptions = includeExceptions
        self.includeActuals = includeActuals
    }


}




public class WfmHistoricalAdherenceBulkJobReference: Codable {



    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case error = "Error"
    }



    /** The ID of the historical adherence bulk job to listen for via notification or query using the jobs route */
    public var _id: String?
    /** The status of the historical adherence bulk job */
    public var status: Status?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, status: Status?, selfUri: String?) {
        self._id = _id
        self.status = status
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case status
        case selfUri
    }


}




public class WfmHistoricalAdherenceBulkQuery: Codable {





    /** The historical adherence items to query */
    public var items: [WfmHistoricalAdherenceBulkItem]?
    /** The time zone, in olson format, to use in defining days when computing adherence. The results will be returned as UTC timestamps regardless of the time zone input. */
    public var timeZone: String?

    public init(items: [WfmHistoricalAdherenceBulkItem]?, timeZone: String?) {
        self.items = items
        self.timeZone = timeZone
    }


}




public class WfmHistoricalAdherenceBulkResult: Codable {











    /** Beginning of the date range for this result in ISO-8601 format */
    public var startDate: Date?
    /** End of the date range for this result in ISO-8601 format */
    public var endDate: Date?
    /** The ID of the management unit for this result */
    public var managementUnitId: String?
    /** The individual results for each user */
    public var userResults: [WfmHistoricalAdherenceBulkUserResult]?
    /** Map of secondary presence lookup ID to corresponding secondary presence ID */
    public var lookupIdToSecondaryPresenceId: [String:String]?

    public init(startDate: Date?, endDate: Date?, managementUnitId: String?, userResults: [WfmHistoricalAdherenceBulkUserResult]?, lookupIdToSecondaryPresenceId: [String:String]?) {
        self.startDate = startDate
        self.endDate = endDate
        self.managementUnitId = managementUnitId
        self.userResults = userResults
        self.lookupIdToSecondaryPresenceId = lookupIdToSecondaryPresenceId
    }


}




public class WfmHistoricalAdherenceBulkUserResult: Codable {







    public enum Impact: String, Codable { 
        case positive = "Positive"
        case negative = "Negative"
        case neutral = "Neutral"
        case unknown = "Unknown"
    }







    /** The ID of the user for whom the adherence is queried */
    public var userId: String?
    /** Adherence percentage for this user, in the scale of 0 - 100 */
    public var adherencePercentage: Double?
    /** Conformance percentage for this user, in the scale of 0 - 100. Conformance percentage can be greater than 100 when the actual on queue time is greater than the scheduled on queue time for the same period. */
    public var conformancePercentage: Double?
    /** The impact of the current adherence state for this user */
    public var impact: Impact?
    /** List of adherence exceptions for this user */
    public var exceptionInfo: [HistoricalAdherenceExceptionInfo]?
    /** List of adherence actuals for this user */
    public var actuals: [HistoricalAdherenceActuals]?
    /** Adherence and conformance metrics for days in query range */
    public var dayMetrics: [WfmHistoricalAdherenceBulkUserDayMetrics]?

    public init(userId: String?, adherencePercentage: Double?, conformancePercentage: Double?, impact: Impact?, exceptionInfo: [HistoricalAdherenceExceptionInfo]?, actuals: [HistoricalAdherenceActuals]?, dayMetrics: [WfmHistoricalAdherenceBulkUserDayMetrics]?) {
        self.userId = userId
        self.adherencePercentage = adherencePercentage
        self.conformancePercentage = conformancePercentage
        self.impact = impact
        self.exceptionInfo = exceptionInfo
        self.actuals = actuals
        self.dayMetrics = dayMetrics
    }


}




public class WfmHistoricalAdherenceResponse: Codable {









    public enum QueryState: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case error = "Error"
    }

    /** The query ID to listen for */
    public var _id: String?
    /** Deprecated. Use downloadUrls instead. */
    public var downloadUrl: String?
    /** Result will always come via downloadUrls; however the schema is included for documentation */
    public var downloadResult: WfmHistoricalAdherenceResultWrapper?
    /** The uri list to GET the results of the Historical Adherence query. For notification purposes only */
    public var downloadUrls: [String]?
    /** The state of the adherence query */
    public var queryState: QueryState?

    public init(_id: String?, downloadUrl: String?, downloadResult: WfmHistoricalAdherenceResultWrapper?, downloadUrls: [String]?, queryState: QueryState?) {
        self._id = _id
        self.downloadUrl = downloadUrl
        self.downloadResult = downloadResult
        self.downloadUrls = downloadUrls
        self.queryState = queryState
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case downloadUrl
        case downloadResult
        case downloadUrls
        case queryState
    }


}




public class WfmIntradayDataUpdateTopicIntradayDataGroup: Codable {

    public enum MediaType: String, Codable { 
        case voice = "Voice"
        case chat = "Chat"
        case email = "Email"
        case callback = "Callback"
        case message = "Message"
    }













    public var mediaType: MediaType?
    public var forecastDataPerInterval: [WfmIntradayDataUpdateTopicIntradayForecastData]?
    public var scheduleDataPerInterval: [WfmIntradayDataUpdateTopicIntradayScheduleData]?
    public var historicalAgentDataPerInterval: [WfmIntradayDataUpdateTopicIntradayHistoricalAgentData]?
    public var historicalQueueDataPerInterval: [WfmIntradayDataUpdateTopicIntradayHistoricalQueueData]?
    public var performancePredictionAgentDataPerInterval: [WfmIntradayDataUpdateTopicIntradayPerformancePredictionAgentData]?
    public var performancePredictionQueueDataPerInterval: [WfmIntradayDataUpdateTopicIntradayPerformancePredictionQueueData]?

    public init(mediaType: MediaType?, forecastDataPerInterval: [WfmIntradayDataUpdateTopicIntradayForecastData]?, scheduleDataPerInterval: [WfmIntradayDataUpdateTopicIntradayScheduleData]?, historicalAgentDataPerInterval: [WfmIntradayDataUpdateTopicIntradayHistoricalAgentData]?, historicalQueueDataPerInterval: [WfmIntradayDataUpdateTopicIntradayHistoricalQueueData]?, performancePredictionAgentDataPerInterval: [WfmIntradayDataUpdateTopicIntradayPerformancePredictionAgentData]?, performancePredictionQueueDataPerInterval: [WfmIntradayDataUpdateTopicIntradayPerformancePredictionQueueData]?) {
        self.mediaType = mediaType
        self.forecastDataPerInterval = forecastDataPerInterval
        self.scheduleDataPerInterval = scheduleDataPerInterval
        self.historicalAgentDataPerInterval = historicalAgentDataPerInterval
        self.historicalQueueDataPerInterval = historicalQueueDataPerInterval
        self.performancePredictionAgentDataPerInterval = performancePredictionAgentDataPerInterval
        self.performancePredictionQueueDataPerInterval = performancePredictionQueueDataPerInterval
    }


}




public class WfmMoveAgentsCompleteTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmMoveManagementUnitTopicMoveManagementUnitNotification: Codable {



    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }

    public var businessUnit: WfmMoveManagementUnitTopicBusinessUnit?
    public var status: Status?

    public init(businessUnit: WfmMoveManagementUnitTopicBusinessUnit?, status: Status?) {
        self.businessUnit = businessUnit
        self.status = status
    }


}




public class WfmScheduleReference: Codable {









    /** The ID of the WFM schedule */
    public var _id: String?
    /** A reference to a Workforce Management Business Unit */
    public var businessUnit: WfmBusinessUnitReference?
    /** The start week date for this schedule. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekDate: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, businessUnit: WfmBusinessUnitReference?, weekDate: Date?, selfUri: String?) {
        self._id = _id
        self.businessUnit = businessUnit
        self.weekDate = weekDate
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case businessUnit
        case weekDate
        case selfUri
    }


}




public class WfmServiceGoalImpact: Codable {





    /** The maximum allowed percent increase from the configured goal */
    public var increaseByPercent: Double?
    /** The maximum allowed percent decrease from the configured goal */
    public var decreaseByPercent: Double?

    public init(increaseByPercent: Double?, decreaseByPercent: Double?) {
        self.increaseByPercent = increaseByPercent
        self.decreaseByPercent = decreaseByPercent
    }


}




public class WfmTimeOffBalanceJobTopicErrorBody: Codable {









    public var status: Int?
    public var code: String?
    public var message: String?
    public var messageParams: [String:String]?

    public init(status: Int?, code: String?, message: String?, messageParams: [String:String]?) {
        self.status = status
        self.code = code
        self.message = message
        self.messageParams = messageParams
    }


}




public class WfmTimeOffBalanceJobTopicTimeOffBalance: Codable {











    public var activityCodeId: String?
    public var hrisTimeOffTypeId: String?
    public var hrisTimeOffTypeSecondaryId: String?
    public var startDate: Date?
    public var balanceMinutesPerDay: [Int]?

    public init(activityCodeId: String?, hrisTimeOffTypeId: String?, hrisTimeOffTypeSecondaryId: String?, startDate: Date?, balanceMinutesPerDay: [Int]?) {
        self.activityCodeId = activityCodeId
        self.hrisTimeOffTypeId = hrisTimeOffTypeId
        self.hrisTimeOffTypeSecondaryId = hrisTimeOffTypeSecondaryId
        self.startDate = startDate
        self.balanceMinutesPerDay = balanceMinutesPerDay
    }


}




public class WfmUserNotificationTopicWfmUserNotification: Codable {







    public enum ModelType: String, Codable { 
        case shiftTrade = "ShiftTrade"
        case timeOffRequest = "TimeOffRequest"
        case adherenceExplanation = "AdherenceExplanation"
    }













    public var _id: String?
    public var mutableGroupId: String?
    public var timestamp: Date?
    public var type: ModelType?
    public var shiftTrade: WfmUserNotificationTopicShiftTradeNotification?
    public var timeOffRequest: WfmUserNotificationTopicTimeOffRequestNotification?
    public var adherenceExplanation: WfmUserNotificationTopicAdherenceExplanationNotification?
    public var agentNotification: Bool?
    public var otherNotificationIdsInGroup: [String]?
    public var markedAsRead: Bool?

    public init(_id: String?, mutableGroupId: String?, timestamp: Date?, type: ModelType?, shiftTrade: WfmUserNotificationTopicShiftTradeNotification?, timeOffRequest: WfmUserNotificationTopicTimeOffRequestNotification?, adherenceExplanation: WfmUserNotificationTopicAdherenceExplanationNotification?, agentNotification: Bool?, otherNotificationIdsInGroup: [String]?, markedAsRead: Bool?) {
        self._id = _id
        self.mutableGroupId = mutableGroupId
        self.timestamp = timestamp
        self.type = type
        self.shiftTrade = shiftTrade
        self.timeOffRequest = timeOffRequest
        self.adherenceExplanation = adherenceExplanation
        self.agentNotification = agentNotification
        self.otherNotificationIdsInGroup = otherNotificationIdsInGroup
        self.markedAsRead = markedAsRead
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case mutableGroupId
        case timestamp
        case type
        case shiftTrade
        case timeOffRequest
        case adherenceExplanation
        case agentNotification
        case otherNotificationIdsInGroup
        case markedAsRead
    }


}




public class WfmUserScheduleAdherenceUpdatedMuTopicActivityCodeReference: Codable {





    public var _id: String?
    public var secondaryPresences: [WfmUserScheduleAdherenceUpdatedMuTopicSecondaryPresenceReference]?

    public init(_id: String?, secondaryPresences: [WfmUserScheduleAdherenceUpdatedMuTopicSecondaryPresenceReference]?) {
        self._id = _id
        self.secondaryPresences = secondaryPresences
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case secondaryPresences
    }


}




public class WfmUserScheduleAdherenceUpdatedMuTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class WfmUserScheduleAdherenceUpdatedTeamTopicQueueReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmUserScheduleAdherenceUpdatedTeamTopicSecondaryPresenceReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmUserScheduleAdherenceUpdatedTopicUserScheduleAdherenceUpdate: Codable {















    public enum RoutingStatus: String, Codable { 
        case empty = "__EMPTY__"
        case offQueue = "OFF_QUEUE"
        case idle = "IDLE"
        case interacting = "INTERACTING"
        case notResponding = "NOT_RESPONDING"
        case communicating = "COMMUNICATING"
        case offline = "OFFLINE"
    }





    public enum AdherenceState: String, Codable { 
        case inAdherence = "InAdherence"
        case outOfAdherence = "OutOfAdherence"
        case unscheduled = "Unscheduled"
        case unknown = "Unknown"
        case ignored = "Ignored"
        case explained = "Explained"
    }















    public var user: WfmUserScheduleAdherenceUpdatedTopicUserReference?
    public var managementUnitId: String?
    public var team: WfmUserScheduleAdherenceUpdatedTopicUriReference?
    public var scheduledActivityCategory: String?
    public var scheduledActivityCode: WfmUserScheduleAdherenceUpdatedTopicActivityCodeReference?
    public var systemPresence: String?
    public var organizationSecondaryPresenceId: String?
    public var routingStatus: RoutingStatus?
    public var actualActivityCategory: String?
    public var isOutOfOffice: Bool?
    public var adherenceState: AdherenceState?
    public var impact: String?
    public var adherenceExplanation: WfmUserScheduleAdherenceUpdatedTopicRealTimeAdherenceExplanation?
    public var adherenceChangeTime: Date?
    public var presenceUpdateTime: Date?
    public var activeQueues: [WfmUserScheduleAdherenceUpdatedTopicQueueReference]?
    public var activeQueuesModifiedTime: Date?
    public var removedFromManagementUnit: Bool?

    public init(user: WfmUserScheduleAdherenceUpdatedTopicUserReference?, managementUnitId: String?, team: WfmUserScheduleAdherenceUpdatedTopicUriReference?, scheduledActivityCategory: String?, scheduledActivityCode: WfmUserScheduleAdherenceUpdatedTopicActivityCodeReference?, systemPresence: String?, organizationSecondaryPresenceId: String?, routingStatus: RoutingStatus?, actualActivityCategory: String?, isOutOfOffice: Bool?, adherenceState: AdherenceState?, impact: String?, adherenceExplanation: WfmUserScheduleAdherenceUpdatedTopicRealTimeAdherenceExplanation?, adherenceChangeTime: Date?, presenceUpdateTime: Date?, activeQueues: [WfmUserScheduleAdherenceUpdatedTopicQueueReference]?, activeQueuesModifiedTime: Date?, removedFromManagementUnit: Bool?) {
        self.user = user
        self.managementUnitId = managementUnitId
        self.team = team
        self.scheduledActivityCategory = scheduledActivityCategory
        self.scheduledActivityCode = scheduledActivityCode
        self.systemPresence = systemPresence
        self.organizationSecondaryPresenceId = organizationSecondaryPresenceId
        self.routingStatus = routingStatus
        self.actualActivityCategory = actualActivityCategory
        self.isOutOfOffice = isOutOfOffice
        self.adherenceState = adherenceState
        self.impact = impact
        self.adherenceExplanation = adherenceExplanation
        self.adherenceChangeTime = adherenceChangeTime
        self.presenceUpdateTime = presenceUpdateTime
        self.activeQueues = activeQueues
        self.activeQueuesModifiedTime = activeQueuesModifiedTime
        self.removedFromManagementUnit = removedFromManagementUnit
    }


}




public class WhatsAppEmbeddedSignupIntegrationRequest: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the WhatsApp Integration */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    /** Defines the message settings to be applied for this integration */
    public var messagingSetting: MessagingSettingRequestReference?
    /** The access token returned from the embedded signup flow */
    public var embeddedSignupAccessToken: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingRequestReference?, embeddedSignupAccessToken: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.embeddedSignupAccessToken = embeddedSignupAccessToken
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case embeddedSignupAccessToken
        case selfUri
    }


}




public class WidgetClientConfig: Codable {









    public var v1: WidgetClientConfigV1?
    public var v2: JSON?
    public var v1Http: WidgetClientConfigV1Http?
    public var thirdParty: JSON?

    public init(v1: WidgetClientConfigV1?, v2: JSON?, v1Http: WidgetClientConfigV1Http?, thirdParty: JSON?) {
        self.v1 = v1
        self.v2 = v2
        self.v1Http = v1Http
        self.thirdParty = thirdParty
    }

    public enum CodingKeys: String, CodingKey { 
        case v1
        case v2
        case v1Http = "v1-http"
        case thirdParty = "third-party"
    }


}




public class WidgetClientConfigV1: Codable {

    public enum WebChatSkin: String, Codable { 
        case basic = "basic"
        case modernCaretSkin = "modern-caret-skin"
    }



    public var webChatSkin: WebChatSkin?
    public var authenticationUrl: String?

    public init(webChatSkin: WebChatSkin?, authenticationUrl: String?) {
        self.webChatSkin = webChatSkin
        self.authenticationUrl = authenticationUrl
    }


}




public class WorkPlanConstraintConflictMessage: Codable {

    public enum ModelType: String, Codable { 
        case unknownFix = "UnknownFix"
        case withPotentialFixes = "WithPotentialFixes"
    }



    /** Type of constraint conflict that can be resolved by clients in order to generate agent schedules */
    public var type: ModelType?
    /** The arguments to the type of the message that can help clients resolve validation issues */
    public var arguments: [WorkPlanValidationMessageArgument]?

    public init(type: ModelType?, arguments: [WorkPlanValidationMessageArgument]?) {
        self.type = type
        self.arguments = arguments
    }


}




public class WorkPlanListItemResponse: Codable {





















































    public enum ShiftStartVarianceType: String, Codable { 
        case shiftStart = "ShiftStart"
        case shiftStartAndPaidDuration = "ShiftStartAndPaidDuration"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Whether the work plan is enabled for scheduling */
    public var enabled: Bool?
    /** Whether the work plan is valid or not */
    public var valid: Bool?
    /** Whether the weekly paid time constraint is enabled for this work plan */
    public var constrainWeeklyPaidTime: Bool?
    /** Whether the weekly paid time constraint is flexible for this work plan */
    public var flexibleWeeklyPaidTime: Bool?
    /** Exact weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == false */
    public var weeklyExactPaidMinutes: Int?
    /** Minimum weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == true */
    public var weeklyMinimumPaidMinutes: Int?
    /** Maximum weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == true */
    public var weeklyMaximumPaidMinutes: Int?
    /** Whether paid time granularity is constrained for this work plan */
    public var constrainPaidTimeGranularity: Bool?
    /** Granularity in minutes allowed for shift paid time in this work plan. Used if constrainPaidTimeGranularity == true */
    public var paidTimeGranularityMinutes: Int?
    /** Whether the minimum time between shifts constraint is enabled for this work plan */
    public var constrainMinimumTimeBetweenShifts: Bool?
    /** Minimum time between shifts in minutes defined in this work plan. Used if constrainMinimumTimeBetweenShifts == true */
    public var minimumTimeBetweenShiftsMinutes: Int?
    /** Maximum number days in a week allowed to be scheduled for this work plan */
    public var maximumDays: Int?
    /** Minimum amount of consecutive non working minutes per week that agents who are assigned this work plan are allowed to have off */
    public var minimumConsecutiveNonWorkingMinutesPerWeek: Int?
    /** Whether to constrain the maximum consecutive working weekends */
    public var constrainMaximumConsecutiveWorkingWeekends: Bool?
    /** The maximum number of consecutive weekends that agents who are assigned to this work plan are allowed to work */
    public var maximumConsecutiveWorkingWeekends: Int?
    /** The minimum number of days that agents assigned to a work plan must work per week */
    public var minimumWorkingDaysPerWeek: Int?
    /** Whether to constrain the maximum consecutive working days */
    public var constrainMaximumConsecutiveWorkingDays: Bool?
    /** The maximum number of consecutive days that agents assigned to this work plan are allowed to work. Used if constrainMaximumConsecutiveWorkingDays == true */
    public var maximumConsecutiveWorkingDays: Int?
    /** The time period in minutes for the duration between the start times of two consecutive working days */
    public var minimumShiftStartDistanceMinutes: Int?
    /** Minimum days off in the planning period */
    public var minimumDaysOffPerPlanningPeriod: Int?
    /** Maximum days off in the planning period */
    public var maximumDaysOffPerPlanningPeriod: Int?
    /** Minimum paid minutes in the planning period */
    public var minimumPaidMinutesPerPlanningPeriod: Int?
    /** Maximum paid minutes in the planning period */
    public var maximumPaidMinutesPerPlanningPeriod: Int?
    /** Optional days to schedule for this work plan. Populate with expand=details */
    public var optionalDays: SetWrapperDayOfWeek?
    /** This constraint ensures that an agent starts each workday within a user-defined time threshold */
    public var shiftStartVarianceType: ShiftStartVarianceType?
    /** Variance in minutes among start times of shifts in this work plan. Populate with expand=details */
    public var shiftStartVariances: ListWrapperShiftStartVariance?
    /** Shifts in this work plan. Populate with expand=details (defaults to empty list) */
    public var shifts: [WorkPlanShift]?
    /** Agents in this work plan. Populate with expand=details (defaults to empty list) */
    public var agents: [DeletableUserReference]?
    /** Number of agents in this work plan.  Populate with expand=agentCount */
    public var agentCount: Int?
    /** Version metadata for this work plan */
    public var metadata: WfmVersionedEntityMetadata?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, enabled: Bool?, valid: Bool?, constrainWeeklyPaidTime: Bool?, flexibleWeeklyPaidTime: Bool?, weeklyExactPaidMinutes: Int?, weeklyMinimumPaidMinutes: Int?, weeklyMaximumPaidMinutes: Int?, constrainPaidTimeGranularity: Bool?, paidTimeGranularityMinutes: Int?, constrainMinimumTimeBetweenShifts: Bool?, minimumTimeBetweenShiftsMinutes: Int?, maximumDays: Int?, minimumConsecutiveNonWorkingMinutesPerWeek: Int?, constrainMaximumConsecutiveWorkingWeekends: Bool?, maximumConsecutiveWorkingWeekends: Int?, minimumWorkingDaysPerWeek: Int?, constrainMaximumConsecutiveWorkingDays: Bool?, maximumConsecutiveWorkingDays: Int?, minimumShiftStartDistanceMinutes: Int?, minimumDaysOffPerPlanningPeriod: Int?, maximumDaysOffPerPlanningPeriod: Int?, minimumPaidMinutesPerPlanningPeriod: Int?, maximumPaidMinutesPerPlanningPeriod: Int?, optionalDays: SetWrapperDayOfWeek?, shiftStartVarianceType: ShiftStartVarianceType?, shiftStartVariances: ListWrapperShiftStartVariance?, shifts: [WorkPlanShift]?, agents: [DeletableUserReference]?, agentCount: Int?, metadata: WfmVersionedEntityMetadata?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.enabled = enabled
        self.valid = valid
        self.constrainWeeklyPaidTime = constrainWeeklyPaidTime
        self.flexibleWeeklyPaidTime = flexibleWeeklyPaidTime
        self.weeklyExactPaidMinutes = weeklyExactPaidMinutes
        self.weeklyMinimumPaidMinutes = weeklyMinimumPaidMinutes
        self.weeklyMaximumPaidMinutes = weeklyMaximumPaidMinutes
        self.constrainPaidTimeGranularity = constrainPaidTimeGranularity
        self.paidTimeGranularityMinutes = paidTimeGranularityMinutes
        self.constrainMinimumTimeBetweenShifts = constrainMinimumTimeBetweenShifts
        self.minimumTimeBetweenShiftsMinutes = minimumTimeBetweenShiftsMinutes
        self.maximumDays = maximumDays
        self.minimumConsecutiveNonWorkingMinutesPerWeek = minimumConsecutiveNonWorkingMinutesPerWeek
        self.constrainMaximumConsecutiveWorkingWeekends = constrainMaximumConsecutiveWorkingWeekends
        self.maximumConsecutiveWorkingWeekends = maximumConsecutiveWorkingWeekends
        self.minimumWorkingDaysPerWeek = minimumWorkingDaysPerWeek
        self.constrainMaximumConsecutiveWorkingDays = constrainMaximumConsecutiveWorkingDays
        self.maximumConsecutiveWorkingDays = maximumConsecutiveWorkingDays
        self.minimumShiftStartDistanceMinutes = minimumShiftStartDistanceMinutes
        self.minimumDaysOffPerPlanningPeriod = minimumDaysOffPerPlanningPeriod
        self.maximumDaysOffPerPlanningPeriod = maximumDaysOffPerPlanningPeriod
        self.minimumPaidMinutesPerPlanningPeriod = minimumPaidMinutesPerPlanningPeriod
        self.maximumPaidMinutesPerPlanningPeriod = maximumPaidMinutesPerPlanningPeriod
        self.optionalDays = optionalDays
        self.shiftStartVarianceType = shiftStartVarianceType
        self.shiftStartVariances = shiftStartVariances
        self.shifts = shifts
        self.agents = agents
        self.agentCount = agentCount
        self.metadata = metadata
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case enabled
        case valid
        case constrainWeeklyPaidTime
        case flexibleWeeklyPaidTime
        case weeklyExactPaidMinutes
        case weeklyMinimumPaidMinutes
        case weeklyMaximumPaidMinutes
        case constrainPaidTimeGranularity
        case paidTimeGranularityMinutes
        case constrainMinimumTimeBetweenShifts
        case minimumTimeBetweenShiftsMinutes
        case maximumDays
        case minimumConsecutiveNonWorkingMinutesPerWeek
        case constrainMaximumConsecutiveWorkingWeekends
        case maximumConsecutiveWorkingWeekends
        case minimumWorkingDaysPerWeek
        case constrainMaximumConsecutiveWorkingDays
        case maximumConsecutiveWorkingDays
        case minimumShiftStartDistanceMinutes
        case minimumDaysOffPerPlanningPeriod
        case maximumDaysOffPerPlanningPeriod
        case minimumPaidMinutesPerPlanningPeriod
        case maximumPaidMinutesPerPlanningPeriod
        case optionalDays
        case shiftStartVarianceType
        case shiftStartVariances
        case shifts
        case agents
        case agentCount
        case metadata
        case selfUri
    }


}




public class WorkdayPointsTrendItem: Codable {





    /** workday date for the points trend. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateWorkday: Date?
    /** workday points for the date */
    public var points: Double?

    public init(dateWorkday: Date?, points: Double?) {
        self.dateWorkday = dateWorkday
        self.points = points
    }


}




public class WorkdayValuesMetricItem: Codable {







    public enum UnitType: String, Codable { 
        case _none = "None"
        case percent = "Percent"
        case currency = "Currency"
        case seconds = "Seconds"
        case number = "Number"
        case attendanceStatus = "AttendanceStatus"
        case unit = "Unit"
    }



    /** Gamification metric for the average and the trend */
    public var metric: AddressableEntityRef?
    /** Gamification metric definition for the average and the trend */
    public var metricDefinition: DomainEntityRef?
    /** The average value of the metric */
    public var average: Double?
    /** The unit type of the metric value */
    public var unitType: UnitType?
    /** The metric value trend */
    public var trend: [WorkdayValuesTrendItem]?

    public init(metric: AddressableEntityRef?, metricDefinition: DomainEntityRef?, average: Double?, unitType: UnitType?, trend: [WorkdayValuesTrendItem]?) {
        self.metric = metric
        self.metricDefinition = metricDefinition
        self.average = average
        self.unitType = unitType
        self.trend = trend
    }


}




public class WorkitemsEventsNotificationCustomAttribute: Codable {

    public enum DataType: String, Codable { 
        case unknown = "unknown"
        case string = "string"
        case number = "number"
        case boolean_ = "boolean$"
        case integer = "integer"
    }



    public var dataType: DataType?
    public var value: String?

    public init(dataType: DataType?, value: String?) {
        self.dataType = dataType
        self.value = value
    }


}




public class WorkitemsUserEventsNotificationCustomAttribute: Codable {

    public enum DataType: String, Codable { 
        case unknown = "unknown"
        case string = "string"
        case number = "number"
        case boolean_ = "boolean$"
        case integer = "integer"
    }



    public var dataType: DataType?
    public var value: String?

    public init(dataType: DataType?, value: String?) {
        self.dataType = dataType
        self.value = value
    }


}




public class WrapUpCodeMapping: Codable {












    public enum DefaultSet: String, Codable { 
        case contactUncallable = "CONTACT_UNCALLABLE"
        case numberUncallable = "NUMBER_UNCALLABLE"
        case rightPartyContact = "RIGHT_PARTY_CONTACT"
    }




    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** The default set of wrap-up flags. These will be used if there is no entry for a given wrap-up code in the mapping. */
    public var defaultSet: [DefaultSet]?
    /** A map from wrap-up code identifiers to a set of wrap-up flags. */
    public var mapping: [String:[String]]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, defaultSet: [DefaultSet]?, mapping: [String:[String]]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.defaultSet = defaultSet
        self.mapping = mapping
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case defaultSet
        case mapping
        case selfUri
    }


}




public class WrapUpCodeReference: Codable {



    /** The globally unique identifier for the object. */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WrapupDetailEventTopicWrapupEvent: Codable {









    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
    }



    public enum Direction: String, Codable { 
        case unknown = "UNKNOWN"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }

















    public enum MessageType: String, Codable { 
        case unknown = "UNKNOWN"
        case sms = "SMS"
        case twitter = "TWITTER"
        case facebook = "FACEBOOK"
        case line = "LINE"
        case whatsapp = "WHATSAPP"
        case webmessaging = "WEBMESSAGING"
        case _open = "OPEN"
        case instagram = "INSTAGRAM"
    }













    public var eventTime: Int?
    public var conversationId: String?
    public var participantId: String?
    public var sessionId: String?
    public var mediaType: MediaType?
    public var provider: String?
    public var direction: Direction?
    public var ani: String?
    public var dnis: String?
    public var addressTo: String?
    public var addressFrom: String?
    public var callbackUserName: String?
    public var callbackNumbers: [String]?
    public var callbackScheduledTime: Int?
    public var subject: String?
    public var messageType: MessageType?
    public var queueId: String?
    public var wrapupCode: String?
    public var wrapupNotes: String?
    public var wrapupDurationMs: Int?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?

    public init(eventTime: Int?, conversationId: String?, participantId: String?, sessionId: String?, mediaType: MediaType?, provider: String?, direction: Direction?, ani: String?, dnis: String?, addressTo: String?, addressFrom: String?, callbackUserName: String?, callbackNumbers: [String]?, callbackScheduledTime: Int?, subject: String?, messageType: MessageType?, queueId: String?, wrapupCode: String?, wrapupNotes: String?, wrapupDurationMs: Int?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.sessionId = sessionId
        self.mediaType = mediaType
        self.provider = provider
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.addressTo = addressTo
        self.addressFrom = addressFrom
        self.callbackUserName = callbackUserName
        self.callbackNumbers = callbackNumbers
        self.callbackScheduledTime = callbackScheduledTime
        self.subject = subject
        self.messageType = messageType
        self.queueId = queueId
        self.wrapupCode = wrapupCode
        self.wrapupNotes = wrapupNotes
        self.wrapupDurationMs = wrapupDurationMs
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
    }


}




public class WrapupInput: Codable {

















    /** The user configured wrap up code id. */
    public var code: String?
    /** The user configured wrap up code name. */
    public var name: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work. */
    public var durationSeconds: Int?
    /** The timestamp when the wrapup was finished. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?
    /** Indicates if this is a pending save and should not require a code to be specified.  This allows someone to save some temporary wrapup that will be used later. */
    public var provisional: Bool?
    /** Prevent updates to wrapup end time when set to true. */
    public var disableEndTimeUpdates: Bool?

    public init(code: String?, name: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?, provisional: Bool?, disableEndTimeUpdates: Bool?) {
        self.code = code
        self.name = name
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
        self.provisional = provisional
        self.disableEndTimeUpdates = disableEndTimeUpdates
    }


}

