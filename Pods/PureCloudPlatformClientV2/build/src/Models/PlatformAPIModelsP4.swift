//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation


/** Metadata for a CX infrastructure as code accelerator */

public class AcceleratorSpecification: Codable {







    public enum Origin: String, Codable { 
        case community = "Community"
        case partner = "Partner"
        case genesys = "Genesys"
    }

    public enum ModelType: String, Codable { 
        case module = "Module"
        case accelerator = "Accelerator"
        case blueprint = "Blueprint"
    }

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** name of this accelerator */
    public var name: String?
    /** a description of the general purpose of this accelerator */
    public var _description: String?
    /** where the accelerator originated */
    public var origin: Origin?
    /** type of the artifact */
    public var type: ModelType?
    /** architectural classification into which the accelerator belongs */
    public var classification: String?
    /** tags */
    public var tags: [String]?
    /** Genesys Cloud permissions required to install the accelerator */
    public var permissions: [String]?
    /** Genesys Cloud products required to install the accelerator */
    public var products: [String]?
    /** additional documentation about the artifact */
    public var documentation: [MetadataDocumentation]?
    /** presentation of data fields to be gathered for the accelerator */
    public var presentation: [MetadataPresentation]?
    /** resources created or modified as a result of running the accelerator */
    public var results: MetadataResults?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, origin: Origin?, type: ModelType?, classification: String?, tags: [String]?, permissions: [String]?, products: [String]?, documentation: [MetadataDocumentation]?, presentation: [MetadataPresentation]?, results: MetadataResults?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.origin = origin
        self.type = type
        self.classification = classification
        self.tags = tags
        self.permissions = permissions
        self.products = products
        self.documentation = documentation
        self.presentation = presentation
        self.results = results
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case origin
        case type
        case classification
        case tags
        case permissions
        case products
        case documentation
        case presentation
        case results
        case selfUri
    }


}




public class AcdEndDetailEventTopicAcdEndEvent: Codable {









    public enum DisconnectType: String, Codable { 
        case unknown = "UNKNOWN"
        case endpoint = "ENDPOINT"
        case client = "CLIENT"
        case system = "SYSTEM"
        case transfer = "TRANSFER"
        case error = "ERROR"
        case peer = "PEER"
        case other = "OTHER"
        case spam = "SPAM"
        case timeout = "TIMEOUT"
        case transportFailure = "TRANSPORT_FAILURE"
        case conferenceTransfer = "CONFERENCE_TRANSFER"
        case consultTransfer = "CONSULT_TRANSFER"
        case forwardTransfer = "FORWARD_TRANSFER"
        case noAnswerTransfer = "NO_ANSWER_TRANSFER"
        case notAvailableTransfer = "NOT_AVAILABLE_TRANSFER"
        case uncallable = "UNCALLABLE"
        case dndEndpoint = "DND_ENDPOINT"
        case dndTransfer = "DND_TRANSFER"
    }

    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
    }



    public enum Direction: String, Codable { 
        case unknown = "UNKNOWN"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }

















    public enum MessageType: String, Codable { 
        case unknown = "UNKNOWN"
        case sms = "SMS"
        case twitter = "TWITTER"
        case facebook = "FACEBOOK"
        case line = "LINE"
        case whatsapp = "WHATSAPP"
        case webmessaging = "WEBMESSAGING"
        case _open = "OPEN"
        case instagram = "INSTAGRAM"
    }





    public enum AcdOutcome: String, Codable { 
        case unknown = "UNKNOWN"
        case abandon = "ABANDON"
        case answered = "ANSWERED"
        case flowOut = "FLOW_OUT"
    }



    public enum RequestedRoutings: String, Codable { 
        case unknown = "UNKNOWN"
        case manual = "MANUAL"
        case predictive = "PREDICTIVE"
        case preferred = "PREFERRED"
        case last = "LAST"
        case bullseye = "BULLSEYE"
        case standard = "STANDARD"
        case other = "OTHER"
        case conditional = "CONDITIONAL"
        case vip = "VIP"
    }

    public enum UsedRouting: String, Codable { 
        case unknown = "UNKNOWN"
        case manual = "MANUAL"
        case predictive = "PREDICTIVE"
        case preferred = "PREFERRED"
        case last = "LAST"
        case bullseye = "BULLSEYE"
        case standard = "STANDARD"
        case other = "OTHER"
        case conditional = "CONDITIONAL"
        case vip = "VIP"
    }















    public var eventTime: Int?
    public var conversationId: String?
    public var participantId: String?
    public var sessionId: String?
    public var disconnectType: DisconnectType?
    public var mediaType: MediaType?
    public var provider: String?
    public var direction: Direction?
    public var ani: String?
    public var dnis: String?
    public var addressTo: String?
    public var addressFrom: String?
    public var callbackUserName: String?
    public var callbackNumbers: [String]?
    public var callbackScheduledTime: Int?
    public var subject: String?
    public var messageType: MessageType?
    public var queueId: String?
    public var divisionId: String?
    public var acdOutcome: AcdOutcome?
    public var answeredUserId: String?
    public var requestedRoutings: [RequestedRoutings]?
    public var usedRouting: UsedRouting?
    public var requestedRoutingSkillIds: [String]?
    public var requestedLanguageId: String?
    public var requestedRoutingUserIds: [String]?
    public var routingPriority: Int?
    public var connectedDurationMs: Int?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?

    public init(eventTime: Int?, conversationId: String?, participantId: String?, sessionId: String?, disconnectType: DisconnectType?, mediaType: MediaType?, provider: String?, direction: Direction?, ani: String?, dnis: String?, addressTo: String?, addressFrom: String?, callbackUserName: String?, callbackNumbers: [String]?, callbackScheduledTime: Int?, subject: String?, messageType: MessageType?, queueId: String?, divisionId: String?, acdOutcome: AcdOutcome?, answeredUserId: String?, requestedRoutings: [RequestedRoutings]?, usedRouting: UsedRouting?, requestedRoutingSkillIds: [String]?, requestedLanguageId: String?, requestedRoutingUserIds: [String]?, routingPriority: Int?, connectedDurationMs: Int?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.sessionId = sessionId
        self.disconnectType = disconnectType
        self.mediaType = mediaType
        self.provider = provider
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.addressTo = addressTo
        self.addressFrom = addressFrom
        self.callbackUserName = callbackUserName
        self.callbackNumbers = callbackNumbers
        self.callbackScheduledTime = callbackScheduledTime
        self.subject = subject
        self.messageType = messageType
        self.queueId = queueId
        self.divisionId = divisionId
        self.acdOutcome = acdOutcome
        self.answeredUserId = answeredUserId
        self.requestedRoutings = requestedRoutings
        self.usedRouting = usedRouting
        self.requestedRoutingSkillIds = requestedRoutingSkillIds
        self.requestedLanguageId = requestedLanguageId
        self.requestedRoutingUserIds = requestedRoutingUserIds
        self.routingPriority = routingPriority
        self.connectedDurationMs = connectedDurationMs
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
    }


}




public class AchievedOutcome: Codable {





    /** The ID of the outcome achieved. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class ActionAggregateQueryResponse: Codable {



    public var results: [ActionAggregateDataContainer]?

    public init(results: [ActionAggregateDataContainer]?) {
        self.results = results
    }


}




public class ActionAggregationView: Codable {

    public enum Target: String, Codable { 
        case ttotalexecution = "tTotalExecution"
    }



    public enum Function: String, Codable { 
        case rangebound = "rangeBound"
    }



    /** Target metric name */
    public var target: Target?
    /** A unique name for this view. Must be distinct from other views and built-in metric names. */
    public var name: String?
    /** Type of view you wish to create */
    public var function: Function?
    /** Range of numbers for slicing up data */
    public var range: AggregationRange?

    public init(target: Target?, name: String?, function: Function?, range: AggregationRange?) {
        self.target = target
        self.name = name
        self.function = function
        self.range = range
    }


}




public class ActionEventRequest: Codable {







    public enum ActionState: String, Codable { 
        case accepted = "accepted"
        case rejected = "rejected"
        case timedout = "timedout"
        case errored = "errored"
        case ignored = "ignored"
        case qualified = "qualified"
        case offered = "offered"
        case started = "started"
        case engaged = "engaged"
        case qualifiedoutsideschedule = "qualifiedOutsideSchedule"
        case offeredoutsideschedule = "offeredOutsideSchedule"
        case abandoned = "abandoned"
        case completed = "completed"
        case frequencycapreached = "frequencyCapReached"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** UUID of the customer session for this action. */
    public var sessionId: String?
    /** UUID for the action, as returned by the Ping endpoint when the action was qualified. */
    public var actionId: String?
    /** State the action is transitioning to. */
    public var actionState: ActionState?
    /** Client defined error code (when state transitions to errored) */
    public var errorCode: String?
    /** Message of the error returned when the action fails (when state transitions to errored) */
    public var errorMessage: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, sessionId: String?, actionId: String?, actionState: ActionState?, errorCode: String?, errorMessage: String?, selfUri: String?) {
        self._id = _id
        self.sessionId = sessionId
        self.actionId = actionId
        self.actionState = actionState
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case sessionId
        case actionId
        case actionState
        case errorCode
        case errorMessage
        case selfUri
    }


}




public class ActionMapEstimateRequest: Codable {





    /** List of Segment IDs. */
    public var segmentIds: [String]?
    /** Outcome Criteria containing outcomeId and probability thresholds. */
    public var outcomeCriteria: ActionMapEstimateOutcomeCriteria?

    public init(segmentIds: [String]?, outcomeCriteria: ActionMapEstimateOutcomeCriteria?) {
        self.segmentIds = segmentIds
        self.outcomeCriteria = outcomeCriteria
    }


}




public class ActionMapScheduleGroup: Codable {



    /** The ID of the action maps's associated schedule group. */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class ActionMapScheduleGroups: Codable {





    /** The actions map's associated schedule group. */
    public var actionMapScheduleGroup: ActionMapScheduleGroup?
    /** The action map's associated emergency schedule group. */
    public var emergencyActionMapScheduleGroup: ActionMapScheduleGroup?

    public init(actionMapScheduleGroup: ActionMapScheduleGroup?, emergencyActionMapScheduleGroup: ActionMapScheduleGroup?) {
        self.actionMapScheduleGroup = actionMapScheduleGroup
        self.emergencyActionMapScheduleGroup = emergencyActionMapScheduleGroup
    }


}




public class ActionProperties: Codable {











    /** Prompt message shown to user, used for webchat type action. */
    public var webchatPrompt: String?
    /** Title shown to the user, used for webchat type action. */
    public var webchatTitleText: String?
    /** Accept button text shown to user, used for webchat type action. */
    public var webchatAcceptText: String?
    /** Decline button text shown to user, used for webchat type action. */
    public var webchatDeclineText: String?
    /** Survey provided to the user, used for webchat type action. */
    public var webchatSurvey: ActionSurvey?

    public init(webchatPrompt: String?, webchatTitleText: String?, webchatAcceptText: String?, webchatDeclineText: String?, webchatSurvey: ActionSurvey?) {
        self.webchatPrompt = webchatPrompt
        self.webchatTitleText = webchatTitleText
        self.webchatAcceptText = webchatAcceptText
        self.webchatDeclineText = webchatDeclineText
        self.webchatSurvey = webchatSurvey
    }


}




public class ActionSurvey: Codable {



    /** Questions shown to the user. */
    public var questions: [JourneySurveyQuestion]?

    public init(questions: [JourneySurveyQuestion]?) {
        self.questions = questions
    }


}




public class ActivityCodeContainer: Codable {





    /** Map of activity code id to activity code */
    public var activityCodes: [String:ActivityCode]?
    /** Version metadata for the associated management unit's list of activity codes */
    public var metadata: WfmVersionedEntityMetadata?

    public init(activityCodes: [String:ActivityCode]?, metadata: WfmVersionedEntityMetadata?) {
        self.activityCodes = activityCodes
        self.metadata = metadata
    }


}




public class ActivityCodeReference: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The secondary presences of this activity code. */
    public var secondaryPresences: [SecondaryPresence]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, secondaryPresences: [SecondaryPresence]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.secondaryPresences = secondaryPresences
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case secondaryPresences
        case selfUri
    }


}




public class AddAdherenceExplanationAgentRequest: Codable {

    public enum ModelType: String, Codable { 
        case late = "Late"
    }







    /** The type of the adherence explanation */
    public var type: ModelType?
    /** The start timestamp of the adherence explanation in ISO-8601 format */
    public var startDate: Date?
    /** The length of the adherence explanation in minutes */
    public var lengthMinutes: Int?
    /** Notes about the adherence explanation */
    public var notes: String?

    public init(type: ModelType?, startDate: Date?, lengthMinutes: Int?, notes: String?) {
        self.type = type
        self.startDate = startDate
        self.lengthMinutes = lengthMinutes
        self.notes = notes
    }


}



/** Update coaching appointment request */

public class AddConversationRequest: Codable {



    /** The id of the conversation to add */
    public var conversationId: String?

    public init(conversationId: String?) {
        self.conversationId = conversationId
    }


}




public class Address: Codable {











    /** This will be nameRaw if present, or a locality lookup of the address field otherwise. */
    public var name: String?
    /** The name as close to the bits on the wire as possible. */
    public var nameRaw: String?
    /** The normalized address. This field is acquired from the Address Normalization Table.  The addressRaw could have gone through some transformations, such as only using the numeric portion, before being run through the Address Normalization Table. */
    public var addressNormalized: String?
    /** The address as close to the bits on the wire as possible. */
    public var addressRaw: String?
    /** The displayable address. This field is acquired from the Address Normalization Table.  The addressRaw could have gone through some transformations, such as only using the numeric portion, before being run through the Address Normalization Table. */
    public var addressDisplayable: String?

    public init(name: String?, nameRaw: String?, addressNormalized: String?, addressRaw: String?, addressDisplayable: String?) {
        self.name = name
        self.nameRaw = nameRaw
        self.addressNormalized = addressNormalized
        self.addressRaw = addressRaw
        self.addressDisplayable = addressDisplayable
    }


}




public class AdherenceExplanationListing: Codable {



    public var entities: [AdherenceExplanationResponse]?

    public init(entities: [AdherenceExplanationResponse]?) {
        self.entities = entities
    }


}




public class AdherenceExplanationNotification: Codable {













    public enum Status: String, Codable { 
        case pending = "Pending"
        case approved = "Approved"
        case denied = "Denied"
    }

    public enum ModelType: String, Codable { 
        case late = "Late"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The agent for whom the adherence explanation applies */
    public var agent: UserReference?
    /** The management unit to which the agent belonged at the time the adherence explanation was submitted */
    public var managementUnit: ManagementUnitReference?
    /** The business unit to which the agent belonged at the time the adherence explanation was submitted */
    public var businessUnit: BusinessUnitReference?
    /** The start date of the adherence explanation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** The length of the adherence explanation in minutes */
    public var lengthMinutes: Int?
    /** The status of the adherence explanation */
    public var status: Status?
    /** The type of the adherence explanation */
    public var type: ModelType?
    /** Notes about the adherence explanation */
    public var notes: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, agent: UserReference?, managementUnit: ManagementUnitReference?, businessUnit: BusinessUnitReference?, startDate: Date?, lengthMinutes: Int?, status: Status?, type: ModelType?, notes: String?, selfUri: String?) {
        self._id = _id
        self.agent = agent
        self.managementUnit = managementUnit
        self.businessUnit = businessUnit
        self.startDate = startDate
        self.lengthMinutes = lengthMinutes
        self.status = status
        self.type = type
        self.notes = notes
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case agent
        case managementUnit
        case businessUnit
        case startDate
        case lengthMinutes
        case status
        case type
        case notes
        case selfUri
    }


}




public class AdjustableLiveSpeakerDetection: Codable {

    public enum Mode: String, Codable { 
        case unknown = "unknown"
        case disabled = "disabled"
        case low = "low"
        case medium = "medium"
        case high = "high"
    }











    /** Modes to tune between speed to live speaker detection vs accuracy. */
    public var mode: Mode?
    /** ISO 8601 formatted relative duration (e.g., PT30.8427419S for 30.8 seconds), calculated on line connect. */
    public var preconnectDuration: String?
    /** The name of the event that triggered the ALSD evaluation (e.g., line.connect, speech.generic). */
    public var eventName: String?
    /** The output of the ALSD detector, evaluating whether there is likely a person on the call based on the above inputs, and if so, a person is detected early (person disposition name and speech.person analyzer result) and the associated action taken (e.g., speech.person postconnect entry in the disposition table has the action to transfer to a queue). */
    public var isPersonLikely: Bool?
    /** Number of tone.ring.* analyzer events detected during the call (expected mostly during pre-connect but the last ringback tone detection could potentially complete after line connect, which will increment totalRingbacks still). */
    public var totalRingbacks: Int?
    /** Protocol line connect received (answered by a person, machine, busy, fax). */
    public var lineConnected: Bool?

    public init(mode: Mode?, preconnectDuration: String?, eventName: String?, isPersonLikely: Bool?, totalRingbacks: Int?, lineConnected: Bool?) {
        self.mode = mode
        self.preconnectDuration = preconnectDuration
        self.eventName = eventName
        self.isPersonLikely = isPersonLikely
        self.totalRingbacks = totalRingbacks
        self.lineConnected = lineConnected
    }


}




public class Agent: Codable {



    /** The current stage for this agent */
    public var stage: String?

    public init(stage: String?) {
        self.stage = stage
    }


}




public class AgentActivity: Codable {





























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var agent: User?
    public var numEvaluations: Int?
    public var averageEvaluationScore: Int?
    public var numCriticalEvaluations: Int?
    public var averageCriticalScore: Float?
    public var highestEvaluationScore: Float?
    public var lowestEvaluationScore: Float?
    public var highestCriticalScore: Float?
    public var lowestCriticalScore: Float?
    public var agentEvaluatorActivityList: [AgentEvaluatorActivity]?
    public var numEvaluationsWithoutViewPermission: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, agent: User?, numEvaluations: Int?, averageEvaluationScore: Int?, numCriticalEvaluations: Int?, averageCriticalScore: Float?, highestEvaluationScore: Float?, lowestEvaluationScore: Float?, highestCriticalScore: Float?, lowestCriticalScore: Float?, agentEvaluatorActivityList: [AgentEvaluatorActivity]?, numEvaluationsWithoutViewPermission: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.agent = agent
        self.numEvaluations = numEvaluations
        self.averageEvaluationScore = averageEvaluationScore
        self.numCriticalEvaluations = numCriticalEvaluations
        self.averageCriticalScore = averageCriticalScore
        self.highestEvaluationScore = highestEvaluationScore
        self.lowestEvaluationScore = lowestEvaluationScore
        self.highestCriticalScore = highestCriticalScore
        self.lowestCriticalScore = lowestCriticalScore
        self.agentEvaluatorActivityList = agentEvaluatorActivityList
        self.numEvaluationsWithoutViewPermission = numEvaluationsWithoutViewPermission
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case agent
        case numEvaluations
        case averageEvaluationScore
        case numCriticalEvaluations
        case averageCriticalScore
        case highestEvaluationScore
        case lowestEvaluationScore
        case highestCriticalScore
        case lowestCriticalScore
        case agentEvaluatorActivityList
        case numEvaluationsWithoutViewPermission
        case selfUri
    }


}




public class AgentIntegrationAssociationRequest: Codable {







    /** The ID of the agent in external system */
    public var agentExternalId: String?
    /** The ID of the integration associated with the agent */
    public var integrationId: String?
    /** Whether agentExternalId should be protected from update by automatic processes */
    public var locked: Bool?

    public init(agentExternalId: String?, integrationId: String?, locked: Bool?) {
        self.agentExternalId = agentExternalId
        self.integrationId = integrationId
        self.locked = locked
    }


}




public class AnalyticsConversationWithoutAttributes: Codable {







    public enum ConversationInitiator: String, Codable { 
        case acd = "acd"
        case agent = "agent"
        case api = "api"
        case botflow = "botflow"
        case campaign = "campaign"
        case customer = "customer"
        case dialer = "dialer"
        case external = "external"
        case fax = "fax"
        case group = "group"
        case inbound = "inbound"
        case ivr = "ivr"
        case manual = "manual"
        case outbound = "outbound"
        case station = "station"
        case user = "user"
        case voicemail = "voicemail"
        case workflow = "workflow"
    }















    public enum OriginatingDirection: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }











    /** The start time of a conference call. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var conferenceStart: Date?
    /** The end time of a conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var conversationEnd: Date?
    /** Unique identifier for the conversation */
    public var conversationId: String?
    /** Indicates the participant purpose of the participant initiating a message conversation */
    public var conversationInitiator: ConversationInitiator?
    /** The start time of a conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var conversationStart: Date?
    /** Indicates a messaging conversation in which the customer participated by sending at least one message */
    public var customerParticipation: Bool?
    /** Identifier(s) of division(s) associated with a conversation */
    public var divisionIds: [String]?
    /** External tag for the conversation */
    public var externalTag: String?
    /** The unique identifier(s) of the knowledge base(s) used */
    public var knowledgeBaseIds: [String]?
    /** The lowest estimated average MOS among all the audio streams belonging to this conversation */
    public var mediaStatsMinConversationMos: Double?
    /** The lowest R-factor value among all of the audio streams belonging to this conversation */
    public var mediaStatsMinConversationRFactor: Double?
    /** The original direction of the conversation */
    public var originatingDirection: OriginatingDirection?
    /** Indicates whether all flow sessions were self serviced */
    public var selfServed: Bool?
    /** Evaluations associated with this conversation */
    public var evaluations: [AnalyticsEvaluation]?
    /** Surveys associated with this conversation */
    public var surveys: [AnalyticsSurvey]?
    /** Resolutions associated with this conversation */
    public var resolutions: [AnalyticsResolution]?
    /** Participants in the conversation */
    public var participants: [AnalyticsParticipantWithoutAttributes]?

    public init(conferenceStart: Date?, conversationEnd: Date?, conversationId: String?, conversationInitiator: ConversationInitiator?, conversationStart: Date?, customerParticipation: Bool?, divisionIds: [String]?, externalTag: String?, knowledgeBaseIds: [String]?, mediaStatsMinConversationMos: Double?, mediaStatsMinConversationRFactor: Double?, originatingDirection: OriginatingDirection?, selfServed: Bool?, evaluations: [AnalyticsEvaluation]?, surveys: [AnalyticsSurvey]?, resolutions: [AnalyticsResolution]?, participants: [AnalyticsParticipantWithoutAttributes]?) {
        self.conferenceStart = conferenceStart
        self.conversationEnd = conversationEnd
        self.conversationId = conversationId
        self.conversationInitiator = conversationInitiator
        self.conversationStart = conversationStart
        self.customerParticipation = customerParticipation
        self.divisionIds = divisionIds
        self.externalTag = externalTag
        self.knowledgeBaseIds = knowledgeBaseIds
        self.mediaStatsMinConversationMos = mediaStatsMinConversationMos
        self.mediaStatsMinConversationRFactor = mediaStatsMinConversationRFactor
        self.originatingDirection = originatingDirection
        self.selfServed = selfServed
        self.evaluations = evaluations
        self.surveys = surveys
        self.resolutions = resolutions
        self.participants = participants
    }


}




public class AnalyticsProperty: Codable {



    public enum PropertyType: String, Codable { 
        case bool = "bool"
        case integer = "integer"
        case real = "real"
        case date = "date"
        case string = "string"
        case uuid = "uuid"
    }



    /** User-defined rather than intrinsic system-observed values. These are tagged onto segments by other components within PureCloud or by API users directly.  This is the name of the user-defined property. */
    public var property: String?
    /** Indicates what the data type is (e.g. integer vs string) and therefore how to evaluate what would constitute a match */
    public var propertyType: PropertyType?
    /** What property value to match against */
    public var value: String?

    public init(property: String?, propertyType: PropertyType?, value: String?) {
        self.property = property
        self.propertyType = propertyType
        self.value = value
    }


}




public class AnalyticsProposedAgent: Codable {





    /** Proposed agent rank for this conversation from predictive routing (lower is better) */
    public var agentRank: Int?
    /** Unique identifier for the agent that was proposed by predictive routing */
    public var proposedAgentId: String?

    public init(agentRank: Int?, proposedAgentId: String?) {
        self.agentRank = agentRank
        self.proposedAgentId = proposedAgentId
    }


}




public class AnalyticsSurvey: Codable {























    /** Specifies when an event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventTime: Date?
    /** The ID of the associated queue */
    public var queueId: String?
    /** Completion datetime of the survey in ISO 8601 format */
    public var surveyCompletedDate: Date?
    /** Unique identifier for the survey form, regardless of version */
    public var surveyFormContextId: String?
    /** ID of the survey form used */
    public var surveyFormId: String?
    /** Name of the survey form used */
    public var surveyFormName: String?
    /** ID of the survey */
    public var surveyId: String?
    /** Score of the survey used with NPS */
    public var surveyPromoterScore: Int?
    /** The status of the survey */
    public var surveyStatus: String?
    /** ID of the agent the survey was performed against */
    public var userId: String?
    public var oSurveyTotalScore: Int64?

    public init(eventTime: Date?, queueId: String?, surveyCompletedDate: Date?, surveyFormContextId: String?, surveyFormId: String?, surveyFormName: String?, surveyId: String?, surveyPromoterScore: Int?, surveyStatus: String?, userId: String?, oSurveyTotalScore: Int64?) {
        self.eventTime = eventTime
        self.queueId = queueId
        self.surveyCompletedDate = surveyCompletedDate
        self.surveyFormContextId = surveyFormContextId
        self.surveyFormId = surveyFormId
        self.surveyFormName = surveyFormName
        self.surveyId = surveyId
        self.surveyPromoterScore = surveyPromoterScore
        self.surveyStatus = surveyStatus
        self.userId = userId
        self.oSurveyTotalScore = oSurveyTotalScore
    }


}




public class ApiUsageRow: Codable {



























    /** Client Id associated with this query result */
    public var clientId: String?
    /** Client Name associated with this query result */
    public var clientName: String?
    /** Organization Id associated with this query result */
    public var organizationId: String?
    /** User Id associated with this query result */
    public var userId: String?
    /** Template Uri associated with this query result */
    public var templateUri: String?
    /** HTTP Method associated with this query result */
    public var httpMethod: String?
    /** Number of requests resulting in a 2xx HTTP status code */
    public var status200: Int64?
    /** Number of requests resulting in a 3xx HTTP status code */
    public var status300: Int64?
    /** Number of requests resulting in a 4xx HTTP status code */
    public var status400: Int64?
    /** Number of requests resulting in a 5xx HTTP status code */
    public var status500: Int64?
    /** Number of requests resulting in a 429 HTTP status code, this is a subset of the count returned with status400 */
    public var status429: Int64?
    /** Total number of requests */
    public var requests: Int64?
    /** Date of requests, based on granularity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var date: Date?

    public init(clientId: String?, clientName: String?, organizationId: String?, userId: String?, templateUri: String?, httpMethod: String?, status200: Int64?, status300: Int64?, status400: Int64?, status500: Int64?, status429: Int64?, requests: Int64?, date: Date?) {
        self.clientId = clientId
        self.clientName = clientName
        self.organizationId = organizationId
        self.userId = userId
        self.templateUri = templateUri
        self.httpMethod = httpMethod
        self.status200 = status200
        self.status300 = status300
        self.status400 = status400
        self.status500 = status500
        self.status429 = status429
        self.requests = requests
        self.date = date
    }


}




public class AppEventResponse: Codable {



































    /** System-generated UUID for the event. */
    public var _id: String?
    /** Identifier of the customer in the source of the event. */
    public var customerId: String?
    /** Type of identifier for the customer ID (cookie, email etc.). */
    public var customerIdType: String?
    /** Represents the action the customer performed. A good event name is typically an object followed by the action performed in past tense (e.g. screen_viewed, order_completed, user_registered). */
    public var eventName: String?
    /** The name of the screen in the app that the event took place. */
    public var screenName: String?
    /** Application that the customer is interacting with. */
    public var app: JourneyApp?
    /** Customer's device. */
    public var device: Device?
    /** Customer's IP-based organization or ISP name. */
    public var ipOrganization: String?
    /** Customer's geolocation. */
    public var geolocation: JourneyGeolocation?
    /** SDK library used to generate the event. */
    public var sdkLibrary: SdkLibrary?
    /** Information relating to the device's network connectivity. */
    public var networkConnectivity: NetworkConnectivity?
    /** Marketing / traffic source information. */
    public var mktCampaign: JourneyCampaign?
    /** The app session the event belongs to. */
    public var session: AppEventResponseSession?
    /** Represents the keywords in a customer search query. */
    public var searchQuery: String?
    /** User-defined attributes associated with a particular event. */
    public var attributes: [String:CustomEventAttribute]?
    /** Traits are attributes intrinsic to the customer that may be sent in selected events (e.g. email, name, phone). */
    public var traits: [String:CustomEventAttribute]?
    /** UTC timestamp indicating when the event actually took place. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?

    public init(_id: String?, customerId: String?, customerIdType: String?, eventName: String?, screenName: String?, app: JourneyApp?, device: Device?, ipOrganization: String?, geolocation: JourneyGeolocation?, sdkLibrary: SdkLibrary?, networkConnectivity: NetworkConnectivity?, mktCampaign: JourneyCampaign?, session: AppEventResponseSession?, searchQuery: String?, attributes: [String:CustomEventAttribute]?, traits: [String:CustomEventAttribute]?, createdDate: Date?) {
        self._id = _id
        self.customerId = customerId
        self.customerIdType = customerIdType
        self.eventName = eventName
        self.screenName = screenName
        self.app = app
        self.device = device
        self.ipOrganization = ipOrganization
        self.geolocation = geolocation
        self.sdkLibrary = sdkLibrary
        self.networkConnectivity = networkConnectivity
        self.mktCampaign = mktCampaign
        self.session = session
        self.searchQuery = searchQuery
        self.attributes = attributes
        self.traits = traits
        self.createdDate = createdDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case customerId
        case customerIdType
        case eventName
        case screenName
        case app
        case device
        case ipOrganization
        case geolocation
        case sdkLibrary
        case networkConnectivity
        case mktCampaign
        case session
        case searchQuery
        case attributes
        case traits
        case createdDate
    }


}




public class AppEventResponseSession: Codable {















    /** ID of the app session. */
    public var _id: String?
    /** Indicates how long the customer has been in the app within this session. */
    public var durationInSeconds: Int?
    /** The count of all events recorded during this session. */
    public var eventCount: Int?
    /** The count of all screen views recorded during this session. */
    public var screenviewCount: Int?
    /** The referrer of the first event in the app session. */
    public var referrer: Referrer?
    /** The URI for this object */
    public var selfUri: String?
    /** UTC timestamp of the session's first event, that is when the session starts. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?

    public init(_id: String?, durationInSeconds: Int?, eventCount: Int?, screenviewCount: Int?, referrer: Referrer?, selfUri: String?, createdDate: Date?) {
        self._id = _id
        self.durationInSeconds = durationInSeconds
        self.eventCount = eventCount
        self.screenviewCount = screenviewCount
        self.referrer = referrer
        self.selfUri = selfUri
        self.createdDate = createdDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case durationInSeconds
        case eventCount
        case screenviewCount
        case referrer
        case selfUri
        case createdDate
    }


}




public class ArchitectDependencyTrackingBuildNotificationDependencyTrackingBuildNotification: Codable {









    /** The organization's new dependency tracking build status */
    public var status: String?
    public var user: ArchitectDependencyTrackingBuildNotificationUser?
    public var client: ArchitectDependencyTrackingBuildNotificationClient?
    /** The time the last build started, in ISO 8601 format */
    public var startTime: Date?

    public init(status: String?, user: ArchitectDependencyTrackingBuildNotificationUser?, client: ArchitectDependencyTrackingBuildNotificationClient?, startTime: Date?) {
        self.status = status
        self.user = user
        self.client = client
        self.startTime = startTime
    }


}



/** The error message params, if the action failed */

public class ArchitectFlowNotificationErrorMessageParams: Codable {



    public var additionalProperties: [String:String]?

    public init(additionalProperties: [String:String]?) {
        self.additionalProperties = additionalProperties
    }


}




public class ArchitectFlowNotificationFlowNotification: Codable {

















    /** The flow ID */
    public var _id: String?
    /** The flow name */
    public var name: String?
    /** The flow description */
    public var _description: String?
    /** The flow deleted state */
    public var deleted: Bool?
    public var checkedInVersion: ArchitectFlowNotificationFlowVersion?
    /** A bare-bones flow version object */
    public var savedVersion: ArchitectFlowNotificationFlowVersion?
    /** A bare-bones flow version object */
    public var publishedVersion: ArchitectFlowNotificationFlowVersion?
    public var currentOperation: ArchitectFlowNotificationArchitectOperation?

    public init(_id: String?, name: String?, _description: String?, deleted: Bool?, checkedInVersion: ArchitectFlowNotificationFlowVersion?, savedVersion: ArchitectFlowNotificationFlowVersion?, publishedVersion: ArchitectFlowNotificationFlowVersion?, currentOperation: ArchitectFlowNotificationArchitectOperation?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.deleted = deleted
        self.checkedInVersion = checkedInVersion
        self.savedVersion = savedVersion
        self.publishedVersion = publishedVersion
        self.currentOperation = currentOperation
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case deleted
        case checkedInVersion
        case savedVersion
        case publishedVersion
        case currentOperation
    }


}



/** Describes an operation being performed on an Architect object */

public class ArchitectPromptNotificationArchitectOperation: Codable {









    public enum ActionName: String, Codable { 
        case create = "CREATE"
        case checkin = "CHECKIN"
        case checkout = "CHECKOUT"
        case debug = "DEBUG"
        case delete = "DELETE"
        case history = "HISTORY"
        case publish = "PUBLISH"
        case revert = "REVERT"
        case save = "SAVE"
        case stateChange = "STATE_CHANGE"
        case update = "UPDATE"
        case validate = "VALIDATE"
    }

    public enum ActionStatus: String, Codable { 
        case locked = "LOCKED"
        case unlocked = "UNLOCKED"
        case started = "STARTED"
        case pendingGeneration = "PENDING_GENERATION"
        case pendingBackendNotification = "PENDING_BACKEND_NOTIFICATION"
        case success = "SUCCESS"
        case failure = "FAILURE"
    }









    /** A unique identifier for this operation, as generated by the initiating client */
    public var _id: String?
    /** Indicates if the operation is complete */
    public var complete: Bool?
    public var user: ArchitectPromptNotificationUser?
    public var client: ArchitectPromptNotificationClient?
    /** The action being performed */
    public var actionName: ActionName?
    /** The action status */
    public var actionStatus: ActionStatus?
    /** The error message, if the action failed */
    public var errorMessage: String?
    /** The error code, if the action failed */
    public var errorCode: String?
    public var errorMessageParams: ArchitectPromptNotificationErrorMessageParams?
    /** The error details, if the action failed */
    public var errorDetails: [ArchitectPromptNotificationErrorDetail]?

    public init(_id: String?, complete: Bool?, user: ArchitectPromptNotificationUser?, client: ArchitectPromptNotificationClient?, actionName: ActionName?, actionStatus: ActionStatus?, errorMessage: String?, errorCode: String?, errorMessageParams: ArchitectPromptNotificationErrorMessageParams?, errorDetails: [ArchitectPromptNotificationErrorDetail]?) {
        self._id = _id
        self.complete = complete
        self.user = user
        self.client = client
        self.actionName = actionName
        self.actionStatus = actionStatus
        self.errorMessage = errorMessage
        self.errorCode = errorCode
        self.errorMessageParams = errorMessageParams
        self.errorDetails = errorDetails
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case complete
        case user
        case client
        case actionName
        case actionStatus
        case errorMessage
        case errorCode
        case errorMessageParams
        case errorDetails
    }


}




public class AssessmentJobListing: Codable {







    public var total: Int64?
    public var entities: [BenefitAssessmentJob]?
    public var selfUri: String?

    public init(total: Int64?, entities: [BenefitAssessmentJob]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class AsyncIntradayResponse: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }





    /** The status of the operation */
    public var status: Status?
    /** The ID for the operation */
    public var operationId: String?
    /** The result of the operation.  Null unless status == Complete */
    public var result: BuIntradayResponse?

    public init(status: Status?, operationId: String?, result: BuIntradayResponse?) {
        self.status = status
        self.operationId = operationId
        self.result = result
    }


}




public class AuditEntity: Codable {









    /** The type of the entity the action of this AuditEntity targeted. */
    public var type: String?
    /** The id of the entity the action of this AuditEntity targeted. */
    public var _id: String?
    /** The name of the entity the action of this AuditEntity targeted. */
    public var name: String?
    /** The selfUri for this entity. */
    public var selfUri: String?

    public init(type: String?, _id: String?, name: String?, selfUri: String?) {
        self.type = type
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case _id = "id"
        case name
        case selfUri
    }


}




public class AuditSearchResult: Codable {













    /** Which page was returned. */
    public var pageNumber: Int?
    /** The number of results in a page. */
    public var pageSize: Int?
    /** The total number of results. */
    public var total: Int?
    /** The number of pages of results. */
    public var pageCount: Int?
    public var facetInfo: [FacetInfo]?
    public var auditMessages: [AuditMessage]?

    public init(pageNumber: Int?, pageSize: Int?, total: Int?, pageCount: Int?, facetInfo: [FacetInfo]?, auditMessages: [AuditMessage]?) {
        self.pageNumber = pageNumber
        self.pageSize = pageSize
        self.total = total
        self.pageCount = pageCount
        self.facetInfo = facetInfo
        self.auditMessages = auditMessages
    }


}




public class AuditTopicAddressableEntityRef: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class AuditTopicPropertyChange: Codable {







    public var property: String?
    public var oldValues: [String]?
    public var newValues: [String]?

    public init(property: String?, oldValues: [String]?, newValues: [String]?) {
        self.property = property
        self.oldValues = oldValues
        self.newValues = newValues
    }


}




public class AutoStart: Codable {



    /** whether or not auto start is enabled */
    public var enabled: Bool?

    public init(enabled: Bool?) {
        self.enabled = enabled
    }


}




public class AvailableMediaType: Codable {





    /** Name of the available media type */
    public var mediaType: String?
    /** List of available subtypes for this media type */
    public var availableSubTypes: [String]?

    public init(mediaType: String?, availableSubTypes: [String]?) {
        self.mediaType = mediaType
        self.availableSubTypes = availableSubTypes
    }


}




public class AvailableTopicEntityListing: Codable {



    public var entities: [AvailableTopic]?

    public init(entities: [AvailableTopic]?) {
        self.entities = entities
    }


}




public class BotAggregateDataContainer: Codable {





    /** A mapping from dimension to value */
    public var group: [String:String]?
    public var data: [StatisticalResponse]?

    public init(group: [String:String]?, data: [StatisticalResponse]?) {
        self.group = group
        self.data = data
    }


}




public class BotAggregateQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [BotAggregateQueryPredicate]?

    public init(type: ModelType?, predicates: [BotAggregateQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class BotAggregationQuery: Codable {







    public enum GroupBy: String, Codable { 
        case askactionid = "askActionId"
        case askactionresult = "askActionResult"
        case askactiontype = "askActionType"
        case botfinalintent = "botFinalIntent"
        case botid = "botId"
        case botintent = "botIntent"
        case botproduct = "botProduct"
        case botprovider = "botProvider"
        case botrecognitionfailurereason = "botRecognitionFailureReason"
        case botresult = "botResult"
        case botsessionid = "botSessionId"
        case botslot = "botSlot"
        case botversion = "botVersion"
        case conversationid = "conversationId"
        case externalcontactid = "externalContactId"
        case intermediateintentname = "intermediateIntentName"
        case knowledgebaseid = "knowledgeBaseId"
        case languagecode = "languageCode"
        case lastactionid = "lastActionId"
        case lastinputactionid = "lastInputActionId"
        case mediatype = "mediaType"
        case messagetype = "messageType"
        case selfserved = "selfServed"
    }



    public enum Metrics: String, Codable { 
        case nbotsessionturns = "nBotSessionTurns"
        case nbotsessions = "nBotSessions"
        case obotintent = "oBotIntent"
        case obotsessionquery = "oBotSessionQuery"
        case obotsessionqueryselfserved = "oBotSessionQuerySelfServed"
        case obotsessionturn = "oBotSessionTurn"
        case obotslot = "oBotSlot"
        case tbotdisconnect = "tBotDisconnect"
        case tbotexit = "tBotExit"
        case tbotrecognitionfailure = "tBotRecognitionFailure"
        case tbotsession = "tBotSession"
    }





    public enum AlternateTimeDimension: String, Codable { 
        case eventtime = "eventTime"
    }

    /** Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H */
    public var granularity: String?
    /** Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var timeZone: String?
    /** Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group. */
    public var groupBy: [GroupBy]?
    /** Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters */
    public var filter: BotAggregateQueryFilter?
    /** Behaves like a SQL SELECT clause. Only named metrics will be retrieved. */
    public var metrics: [Metrics]?
    /** Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c') */
    public var flattenMultivaluedDimensions: Bool?
    /** Custom derived metric views */
    public var views: [BotAggregationView]?
    /** Dimension to use as the alternative timestamp for data in the aggregate.  Choosing \"eventTime\" uses the actual time of the data event. */
    public var alternateTimeDimension: AlternateTimeDimension?

    public init(interval: String?, granularity: String?, timeZone: String?, groupBy: [GroupBy]?, filter: BotAggregateQueryFilter?, metrics: [Metrics]?, flattenMultivaluedDimensions: Bool?, views: [BotAggregationView]?, alternateTimeDimension: AlternateTimeDimension?) {
        self.interval = interval
        self.granularity = granularity
        self.timeZone = timeZone
        self.groupBy = groupBy
        self.filter = filter
        self.metrics = metrics
        self.flattenMultivaluedDimensions = flattenMultivaluedDimensions
        self.views = views
        self.alternateTimeDimension = alternateTimeDimension
    }


}



/** Channel information relevant to a bot flow. */

public class BotChannel: Codable {

    public enum Name: String, Codable { 
        case chat = "Chat"
        case call = "Call"
        case messaging = "Messaging"
    }


    public enum InputModes: String, Codable { 
        case text = "Text"
        case voice = "Voice"
        case dtmf = "DTMF"
    }

    public enum OutputModes: String, Codable { 
        case text = "Text"
        case voice = "Voice"
    }


    /** The name of the channel. */
    public var name: Name?
    /** The input modes for the channel. */
    public var inputModes: [InputModes]?
    /** The output modes for the channel. */
    public var outputModes: [OutputModes]?
    /** Information about the end user agent calling the bot flow. */
    public var userAgent: TextBotUserAgent?

    public init(name: Name?, inputModes: [InputModes]?, outputModes: [OutputModes]?, userAgent: TextBotUserAgent?) {
        self.name = name
        self.inputModes = inputModes
        self.outputModes = outputModes
        self.userAgent = userAgent
    }


}



/** A botConnector Bot Instance */

public class BotConnectorBot: Codable {













    /** The Botconnector Bot Id - this is configurable by the user when put */
    public var _id: String?
    public var name: String?
    /** An optional description of the bot.  This can be up to 256 characters long and must be comprised of displayable characters without leading or trailing whitespace */
    public var _description: String?
    /** This bots versions, limit of 50 per bot */
    public var versions: [BotConnectorBotVersion]?
    /** A system-generated string that contains metadata about this bot. */
    public var botCompositeTag: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, versions: [BotConnectorBotVersion]?, botCompositeTag: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.versions = versions
        self.botCompositeTag = botCompositeTag
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case versions
        case botCompositeTag
        case selfUri
    }


}



/** A list of BotConnectorBots */

public class BotList: Codable {



    /** A list of botConnector Bots. Max 50 */
    public var chatBots: [BotConnectorBot]?

    public init(chatBots: [BotConnectorBot]?) {
        self.chatBots = chatBots
    }


}




public class BotSearchResponseEntityListing: Codable {



    public var entities: [BotSearchResponse]?

    public init(entities: [BotSearchResponse]?) {
        self.entities = entities
    }


}



/** A version summary for a botConnector bot. */

public class BotVersionSummary: Codable {











    /** The name of the bot. */
    public var name: String?
    /** The id of the bot. */
    public var _id: String?
    /** An optional description of the bot. */
    public var _description: String?
    /** A system-generated string that contains metadata about this bot. */
    public var botCompositeTag: String?
    /** The name of the version. */
    public var version: String?

    public init(name: String?, _id: String?, _description: String?, botCompositeTag: String?, version: String?) {
        self.name = name
        self._id = _id
        self._description = _description
        self.botCompositeTag = botCompositeTag
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _id = "id"
        case _description = "description"
        case botCompositeTag
        case version
    }


}




public class Browser: Codable {























    /** Browser family (e.g. Chrome, Safari, Firefox). */
    public var family: String?
    /** Browser version (e.g. 68.0.3440.84). */
    public var version: String?
    /** Language the browser is set to. Must conform to BCP 47. */
    public var lang: String?
    /** Fingerprint generated by looking at the individual browser features. */
    public var fingerprint: String?
    /** Flag that is true for mobile devices. */
    public var isMobile: Bool?
    /** Browser's viewport height. */
    public var viewHeight: Int?
    /** Browser's viewport width. */
    public var viewWidth: Int?
    /** Whether Flash is installed. */
    public var featuresFlash: Bool?
    /** Whether Java is installed. */
    public var featuresJava: Bool?
    /** Whether the browser recognizes PDFs. */
    public var featuresPdf: Bool?
    /** Whether WebRTC is supported. */
    public var featuresWebrtc: Bool?

    public init(family: String?, version: String?, lang: String?, fingerprint: String?, isMobile: Bool?, viewHeight: Int?, viewWidth: Int?, featuresFlash: Bool?, featuresJava: Bool?, featuresPdf: Bool?, featuresWebrtc: Bool?) {
        self.family = family
        self.version = version
        self.lang = lang
        self.fingerprint = fingerprint
        self.isMobile = isMobile
        self.viewHeight = viewHeight
        self.viewWidth = viewWidth
        self.featuresFlash = featuresFlash
        self.featuresJava = featuresJava
        self.featuresPdf = featuresPdf
        self.featuresWebrtc = featuresWebrtc
    }


}




public class BuAbandonRate: Codable {





    /** Whether to include abandon rate in the associated configuration */
    public var include: Bool?
    /** Abandon rate percent goal. Required if include == true */
    public var percent: Int?

    public init(include: Bool?, percent: Int?) {
        self.include = include
        self.percent = percent
    }


}




public class BuAgentScheduleHistoryDroppedChange: Codable {









    /** The metadata of the change, including who and when the change was made */
    public var metadata: BuAgentScheduleHistoryChangeMetadata?
    /** The IDs of deleted shifts */
    public var shiftIds: [String]?
    /** The dates of any deleted full day time off markers */
    public var fullDayTimeOffMarkerDates: [Date]?
    /** The deleted shifts, full day time off markers, or the entire agent schedule */
    public var deletes: BuAgentScheduleHistoryDeletedChange?

    public init(metadata: BuAgentScheduleHistoryChangeMetadata?, shiftIds: [String]?, fullDayTimeOffMarkerDates: [Date]?, deletes: BuAgentScheduleHistoryDeletedChange?) {
        self.metadata = metadata
        self.shiftIds = shiftIds
        self.fullDayTimeOffMarkerDates = fullDayTimeOffMarkerDates
        self.deletes = deletes
    }


}




public class BuCreateBlankScheduleRequest: Codable {







    /** The description for the schedule */
    public var _description: String?
    /** The forecast to use when generating the schedule.  Note that the forecast must fully encompass the schedule's start week + week count */
    public var shortTermForecast: BuShortTermForecastReference?
    /** The number of weeks in the schedule. One extra day is added at the end */
    public var weekCount: Int?

    public init(_description: String?, shortTermForecast: BuShortTermForecastReference?, weekCount: Int?) {
        self._description = _description
        self.shortTermForecast = shortTermForecast
        self.weekCount = weekCount
    }

    public enum CodingKeys: String, CodingKey { 
        case _description = "description"
        case shortTermForecast
        case weekCount
    }


}




public class BuCurrentAgentScheduleSearchResponse: Codable {













    /** The requested agent schedules */
    public var agentSchedules: [BuAgentScheduleSearchResponse]?
    /** The time zone configured for the business unit to which this schedule applies */
    public var businessUnitTimeZone: String?
    /** References to all published week schedules overlapping the start/end date query parameters */
    public var publishedSchedules: [BuAgentSchedulePublishedScheduleReference]?
    /** The start date of the schedules. Only populated on notifications. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** The end date of the schedules. Only populated on notifications. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endDate: Date?
    /** The list of updates for the schedule. Only used in notifications */
    public var updates: [BuAgentScheduleUpdate]?

    public init(agentSchedules: [BuAgentScheduleSearchResponse]?, businessUnitTimeZone: String?, publishedSchedules: [BuAgentSchedulePublishedScheduleReference]?, startDate: Date?, endDate: Date?, updates: [BuAgentScheduleUpdate]?) {
        self.agentSchedules = agentSchedules
        self.businessUnitTimeZone = businessUnitTimeZone
        self.publishedSchedules = publishedSchedules
        self.startDate = startDate
        self.endDate = endDate
        self.updates = updates
    }


}




public class BuForecastResult: Codable {









    /** The reference start date for interval-based data for this forecast. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var referenceStartDate: Date?
    /** The forecast data broken up by planning group */
    public var planningGroups: [ForecastPlanningGroupData]?
    /** The week number represented by this response */
    public var weekNumber: Int?
    /** The number of weeks in this forecast */
    public var weekCount: Int?

    public init(referenceStartDate: Date?, planningGroups: [ForecastPlanningGroupData]?, weekNumber: Int?, weekCount: Int?) {
        self.referenceStartDate = referenceStartDate
        self.planningGroups = planningGroups
        self.weekNumber = weekNumber
        self.weekCount = weekCount
    }


}




public class BuImportShortTermForecastSchema: Codable {











    /** The description for the forecast */
    public var _description: String?
    /** The number of weeks covered by the forecast */
    public var weekCount: Int?
    /** The short term planning group data */
    public var planningGroups: [ForecastPlanningGroupData]?
    /** The long term planning group data */
    public var longTermPlanningGroups: [LongTermForecastPlanningGroupData]?
    /** Whether this forecast can be used for scheduling */
    public var canUseForScheduling: Bool?

    public init(_description: String?, weekCount: Int?, planningGroups: [ForecastPlanningGroupData]?, longTermPlanningGroups: [LongTermForecastPlanningGroupData]?, canUseForScheduling: Bool?) {
        self._description = _description
        self.weekCount = weekCount
        self.planningGroups = planningGroups
        self.longTermPlanningGroups = longTermPlanningGroups
        self.canUseForScheduling = canUseForScheduling
    }

    public enum CodingKeys: String, CodingKey { 
        case _description = "description"
        case weekCount
        case planningGroups
        case longTermPlanningGroups
        case canUseForScheduling
    }


}




public class BuQueryAgentSchedulesRequest: Codable {







    /** The ID of the management unit to query */
    public var managementUnitId: String?
    /** The IDs of the users to query.  Omit to query all user schedules in the management unit. Note: If teamIds is also specified, only schedules for users in the requested teams will be returned */
    public var userIds: [String]?
    /** The teamIds to request. If null or not set, results will be queried for requested users if applicable or otherwise all users in the management unit */
    public var teamIds: [String]?

    public init(managementUnitId: String?, userIds: [String]?, teamIds: [String]?) {
        self.managementUnitId = managementUnitId
        self.userIds = userIds
        self.teamIds = teamIds
    }


}




public class BuRescheduleResult: Codable {











    /** The generation results.  Note the result will always be delivered via the generationResultsDownloadUrl; however the schema is included for documentation */
    public var generationResults: ScheduleGenerationResult?
    /** The download URL from which to fetch the generation results for the rescheduling run */
    public var generationResultsDownloadUrl: String?
    /** The headcount forecast.  Note the result will always be delivered via the headcountForecastDownloadUrl; however the schema is included for documentation */
    public var headcountForecast: BuHeadcountForecast?
    /** The download URL from which to fetch the headcount forecast for the rescheduling run */
    public var headcountForecastDownloadUrl: String?
    /** List of download links for agent schedules produced by the rescheduling run */
    public var agentSchedules: [BuRescheduleAgentScheduleResult]?

    public init(generationResults: ScheduleGenerationResult?, generationResultsDownloadUrl: String?, headcountForecast: BuHeadcountForecast?, headcountForecastDownloadUrl: String?, agentSchedules: [BuRescheduleAgentScheduleResult]?) {
        self.generationResults = generationResults
        self.generationResultsDownloadUrl = generationResultsDownloadUrl
        self.headcountForecast = headcountForecast
        self.headcountForecastDownloadUrl = headcountForecastDownloadUrl
        self.agentSchedules = agentSchedules
    }


}




public class BuScheduleRun: Codable {







    public enum State: String, Codable { 
        case _none = "None"
        case queued = "Queued"
        case scheduling = "Scheduling"
        case canceled = "Canceled"
        case failed = "Failed"
        case complete = "Complete"
    }





























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The scheduler run ID.  Reference this value for support */
    public var schedulerRunId: String?
    /** Whether this is an intraday rescheduling run */
    public var intradayRescheduling: Bool?
    /** The state of the generation run */
    public var state: State?
    /** The number of weeks spanned by the schedule */
    public var weekCount: Int?
    /** Percent completion of the schedule run */
    public var percentComplete: Double?
    /** The start date of the target week. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var targetWeek: Date?
    /** The generated schedule.  Null unless the schedule run is complete */
    public var schedule: BuScheduleReference?
    /** The description of the generated schedule */
    public var scheduleDescription: String?
    /** When the schedule generation run started. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var schedulingStartTime: Date?
    /** The user who started the scheduling run */
    public var schedulingStartedBy: UserReference?
    /** The user who canceled the scheduling run, if applicable */
    public var schedulingCanceledBy: UserReference?
    /** When the scheduling run was completed, if applicable. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var schedulingCompletedTime: Date?
    /** The number of schedule generation messages for this schedule generation run */
    public var messageCount: Int?
    /** The list of schedule generation message counts by severity for this schedule generation run */
    public var messageSeverityCounts: [SchedulerMessageSeverityCount]?
    /** Rescheduling options for this run.  Null unless intradayRescheduling is true */
    public var reschedulingOptions: ReschedulingOptionsRunResponse?
    /** When the reschedule result will expire.  Null unless intradayRescheduling is true. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var reschedulingResultExpiration: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, schedulerRunId: String?, intradayRescheduling: Bool?, state: State?, weekCount: Int?, percentComplete: Double?, targetWeek: Date?, schedule: BuScheduleReference?, scheduleDescription: String?, schedulingStartTime: Date?, schedulingStartedBy: UserReference?, schedulingCanceledBy: UserReference?, schedulingCompletedTime: Date?, messageCount: Int?, messageSeverityCounts: [SchedulerMessageSeverityCount]?, reschedulingOptions: ReschedulingOptionsRunResponse?, reschedulingResultExpiration: Date?, selfUri: String?) {
        self._id = _id
        self.schedulerRunId = schedulerRunId
        self.intradayRescheduling = intradayRescheduling
        self.state = state
        self.weekCount = weekCount
        self.percentComplete = percentComplete
        self.targetWeek = targetWeek
        self.schedule = schedule
        self.scheduleDescription = scheduleDescription
        self.schedulingStartTime = schedulingStartTime
        self.schedulingStartedBy = schedulingStartedBy
        self.schedulingCanceledBy = schedulingCanceledBy
        self.schedulingCompletedTime = schedulingCompletedTime
        self.messageCount = messageCount
        self.messageSeverityCounts = messageSeverityCounts
        self.reschedulingOptions = reschedulingOptions
        self.reschedulingResultExpiration = reschedulingResultExpiration
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case schedulerRunId
        case intradayRescheduling
        case state
        case weekCount
        case percentComplete
        case targetWeek
        case schedule
        case scheduleDescription
        case schedulingStartTime
        case schedulingStartedBy
        case schedulingCanceledBy
        case schedulingCompletedTime
        case messageCount
        case messageSeverityCounts
        case reschedulingOptions
        case reschedulingResultExpiration
        case selfUri
    }


}




public class BuScheduleRunListing: Codable {



    public var entities: [BuScheduleRun]?

    public init(entities: [BuScheduleRun]?) {
        self.entities = entities
    }


}




public class BulkCallbackPatchRequest: Codable {



    /** The list of requests to update callbacks in bulk */
    public var patchCallbackRequests: [PatchCallbackRequest]?

    public init(patchCallbackRequests: [PatchCallbackRequest]?) {
        self.patchCallbackRequests = patchCallbackRequests
    }


}




public class BulkDeleteResponse: Codable {







    public var results: [BulkResponseResultVoidEntity]?
    public var errorCount: Int?
    public var errorIndexes: [Int]?

    public init(results: [BulkResponseResultVoidEntity]?, errorCount: Int?, errorIndexes: [Int]?) {
        self.results = results
        self.errorCount = errorCount
        self.errorIndexes = errorIndexes
    }


}




public class BulkError: Codable {





    /** Error message of the bulk operation result. */
    public var message: String?
    /** Error code of the bulk operation result. */
    public var code: String?

    public init(message: String?, code: String?) {
        self.message = message
        self.code = code
    }


}




public class BulkErrorDetail: Codable {







    public var fieldName: String?
    public var value: String?
    public var message: String?

    public init(fieldName: String?, value: String?, message: String?) {
        self.fieldName = fieldName
        self.value = value
        self.message = message
    }


}




public class BulkResponse: Codable {







    /** A list of the results from the bulk operation. */
    public var results: [BulkResult]?
    /** The number of errors from the bulk operation. */
    public var errorCount: Int?
    /** An index of where the errors are in the listing. */
    public var errorIndexes: [Int]?

    public init(results: [BulkResult]?, errorCount: Int?, errorIndexes: [Int]?) {
        self.results = results
        self.errorCount = errorCount
        self.errorIndexes = errorIndexes
    }


}




public class BulkResponseResultExternalOrganizationEntity: Codable {









    public var _id: String?
    public var success: Bool?
    public var entity: ExternalOrganization?
    public var error: BulkErrorEntity?

    public init(_id: String?, success: Bool?, entity: ExternalOrganization?, error: BulkErrorEntity?) {
        self._id = _id
        self.success = success
        self.entity = entity
        self.error = error
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case success
        case entity
        case error
    }


}




public class BulkUpdateShiftTradeStateResponse: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }





    /** The status of the operation */
    public var status: Status?
    /** The ID for the operation */
    public var operationId: String?
    /** The result of the operation.  Null unless status == Complete */
    public var result: BulkUpdateShiftTradeStateResult?

    public init(status: Status?, operationId: String?, result: BulkUpdateShiftTradeStateResult?) {
        self.status = status
        self.operationId = operationId
        self.result = result
    }


}




public class BusinessUnitListing: Codable {



    public var entities: [BusinessUnitListItem]?

    public init(entities: [BusinessUnitListItem]?) {
        self.entities = entities
    }


}




public class Call: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case _none = "none"
    }



    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }



    public enum RecordingState: String, Codable { 
        case _none = "none"
        case active = "active"
        case paused = "paused"
    }















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDonotdisturb = "endpoint.donotdisturb"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferDonotdisturb = "transfer.donotdisturb"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }







































    /** The connection state of this communication. */
    public var state: State?
    /** The initial connection state of this communication. */
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The direction of the call */
    public var direction: Direction?
    /** True if this call is being recorded. */
    public var recording: Bool?
    /** State of recording on this call. */
    public var recordingState: RecordingState?
    /** True if this call is muted so that remote participants can't hear any audio from this end. */
    public var muted: Bool?
    /** True if this call is held and the person on this side hears hold music. */
    public var confined: Bool?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** True when the recording of this call is in secure pause status. */
    public var securePause: Bool?
    /** A globally unique identifier for the recording associated with this call. */
    public var recordingId: String?
    /** The time line of the participant's call, divided into activity segments. */
    public var segments: [Segment]?
    public var errorInfo: ErrorInfo?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the call was placed on hold in the cloud clock if the call is currently on hold. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startHoldTime: Date?
    /** If call is an outbound fax of a document from content management, then this is the id in content management. */
    public var documentId: String?
    /** The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAlertingTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var disconnectedTime: Date?
    /** List of reasons that this call was disconnected. This will be set once the call disconnects. */
    public var disconnectReasons: [DisconnectReason]?
    /** Extra information on fax transmission. */
    public var faxStatus: FaxStatus?
    /** The source provider for the call. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** User to User Information (UUI) data managed by SIP session application. */
    public var uuiData: String?
    /** Address and name data for a call endpoint. */
    public var _self: Address?
    /** Address and name data for a call endpoint. */
    public var other: Address?
    /** Call wrap up or disposition data. */
    public var wrapup: Wrapup?
    /** After-call work for the communication. */
    public var afterCallWork: AfterCallWork?
    /** Indicates if after-call work is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** UUID of virtual agent assistant that provide suggestions to the agent participant during the conversation. */
    public var agentAssistantId: String?
    /** Represents the queue settings for this media type. */
    public var queueMediaSettings: ConversationQueueMediaSettings?
    /** Call resolution data for Dialer bulk make calls commands. */
    public var disposition: Disposition?

    public init(state: State?, initialState: InitialState?, _id: String?, direction: Direction?, recording: Bool?, recordingState: RecordingState?, muted: Bool?, confined: Bool?, held: Bool?, securePause: Bool?, recordingId: String?, segments: [Segment]?, errorInfo: ErrorInfo?, disconnectType: DisconnectType?, startHoldTime: Date?, documentId: String?, startAlertingTime: Date?, connectedTime: Date?, disconnectedTime: Date?, disconnectReasons: [DisconnectReason]?, faxStatus: FaxStatus?, provider: String?, scriptId: String?, peerId: String?, uuiData: String?, _self: Address?, other: Address?, wrapup: Wrapup?, afterCallWork: AfterCallWork?, afterCallWorkRequired: Bool?, agentAssistantId: String?, queueMediaSettings: ConversationQueueMediaSettings?, disposition: Disposition?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.direction = direction
        self.recording = recording
        self.recordingState = recordingState
        self.muted = muted
        self.confined = confined
        self.held = held
        self.securePause = securePause
        self.recordingId = recordingId
        self.segments = segments
        self.errorInfo = errorInfo
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.documentId = documentId
        self.startAlertingTime = startAlertingTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.disconnectReasons = disconnectReasons
        self.faxStatus = faxStatus
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.uuiData = uuiData
        self._self = _self
        self.other = other
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.agentAssistantId = agentAssistantId
        self.queueMediaSettings = queueMediaSettings
        self.disposition = disposition
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case direction
        case recording
        case recordingState
        case muted
        case confined
        case held
        case securePause
        case recordingId
        case segments
        case errorInfo
        case disconnectType
        case startHoldTime
        case documentId
        case startAlertingTime
        case connectedTime
        case disconnectedTime
        case disconnectReasons
        case faxStatus
        case provider
        case scriptId
        case peerId
        case uuiData
        case _self = "self"
        case other
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case agentAssistantId
        case queueMediaSettings
        case disposition
    }


}




public class CalibrationEntityListing: Codable {





















    public var entities: [Calibration]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Calibration]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CallConversation: Codable {











    public enum RecordingState: String, Codable { 
        case _none = "none"
        case active = "active"
        case paused = "paused"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The list of participants involved in the conversation. */
    public var participants: [CallMediaParticipant]?
    /** The list of other media channels involved in the conversation. */
    public var otherMediaUris: [String]?
    /** The list of the most recent 20 transfer commands applied to this conversation. */
    public var recentTransfers: [TransferResponse]?
    public var recordingState: RecordingState?
    /** If this is a conference conversation, then this field indicates the maximum number of participants allowed to participant in the conference. */
    public var maxParticipants: Int?
    /** True when the recording of this conversation is in secure pause status. */
    public var securePause: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, participants: [CallMediaParticipant]?, otherMediaUris: [String]?, recentTransfers: [TransferResponse]?, recordingState: RecordingState?, maxParticipants: Int?, securePause: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
        self.recentTransfers = recentTransfers
        self.recordingState = recordingState
        self.maxParticipants = maxParticipants
        self.securePause = securePause
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
        case recentTransfers
        case recordingState
        case maxParticipants
        case securePause
        case selfUri
    }


}




public class CallForwardingEventCallForwarding: Codable {











    public var user: CallForwardingEventUser?
    public var enabled: Bool?
    public var calls: [CallForwardingEventCall]?
    public var voicemail: String?
    public var modifiedDate: Date?

    public init(user: CallForwardingEventUser?, enabled: Bool?, calls: [CallForwardingEventCall]?, voicemail: String?, modifiedDate: Date?) {
        self.user = user
        self.enabled = enabled
        self.calls = calls
        self.voicemail = voicemail
        self.modifiedDate = modifiedDate
    }


}




public class CallHistoryParticipant: Codable {













    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }











    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDonotdisturb = "endpoint.donotdisturb"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferDonotdisturb = "transfer.donotdisturb"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
    }









    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }



    /** The unique participant ID. */
    public var _id: String?
    /** The display friendly name of the participant. */
    public var name: String?
    /** The participant address. */
    public var address: String?
    /** The time when this participant first joined the conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startTime: Date?
    /** The time when this participant went disconnected for this media (eg: video disconnected time). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?
    /** The participant's purpose.  Values can be: 'agent', 'user', 'customer', 'external', 'acd', 'ivr */
    public var purpose: String?
    /** The participant's direction.  Values can be: 'inbound' or 'outbound' */
    public var direction: Direction?
    /** The call ANI. */
    public var ani: String?
    /** The call DNIS. */
    public var dnis: String?
    /** The PureCloud user for this participant. */
    public var user: User?
    /** The PureCloud queue for this participant. */
    public var queue: Queue?
    /** The group involved in the group ring call. */
    public var group: Group?
    /** The reason the participant was disconnected from the conversation. */
    public var disconnectType: DisconnectType?
    /** The PureCloud external contact */
    public var externalContact: ExternalContact?
    /** The PureCloud external organization */
    public var externalOrganization: ExternalOrganization?
    /** Indicates whether the contact ever connected */
    public var didInteract: Bool?
    /** Indicates SIP Response codes associated with the participant */
    public var sipResponseCodes: [Int64]?
    /** The reason specifying why participant flagged the conversation. */
    public var flaggedReason: FlaggedReason?
    /** The outbound campaign associated with the participant */
    public var outboundCampaign: Campaign?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, endTime: Date?, purpose: String?, direction: Direction?, ani: String?, dnis: String?, user: User?, queue: Queue?, group: Group?, disconnectType: DisconnectType?, externalContact: ExternalContact?, externalOrganization: ExternalOrganization?, didInteract: Bool?, sipResponseCodes: [Int64]?, flaggedReason: FlaggedReason?, outboundCampaign: Campaign?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.endTime = endTime
        self.purpose = purpose
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.user = user
        self.queue = queue
        self.group = group
        self.disconnectType = disconnectType
        self.externalContact = externalContact
        self.externalOrganization = externalOrganization
        self.didInteract = didInteract
        self.sipResponseCodes = sipResponseCodes
        self.flaggedReason = flaggedReason
        self.outboundCampaign = outboundCampaign
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case endTime
        case purpose
        case direction
        case ani
        case dnis
        case user
        case queue
        case group
        case disconnectType
        case externalContact
        case externalOrganization
        case didInteract
        case sipResponseCodes
        case flaggedReason
        case outboundCampaign
    }


}




public class CallTarget: Codable {

    public enum ModelType: String, Codable { 
        case station = "STATION"
        case phonenumber = "PHONENUMBER"
    }



    /** The type of call */
    public var type: ModelType?
    /** The id of the station or an E.164 formatted phone number */
    public var value: String?

    public init(type: ModelType?, value: String?) {
        self.type = type
        self.value = value
    }


}




public class CallableTimeSetEntityListing: Codable {





















    public var entities: [CallableTimeSet]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CallableTimeSet]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CallbackMediaSettings: Codable {



















    /** Indicates if auto-answer is enabled for the given media type or subtype (default is false).  Subtype settings take precedence over media type settings. */
    public var enableAutoAnswer: Bool?
    /** The alerting timeout for the media type, in seconds */
    public var alertingTimeoutSeconds: Int?
    /** The targeted service level for the media type */
    public var serviceLevel: ServiceLevel?
    /** How long to play the alerting tone for an auto-answer interaction */
    public var autoAnswerAlertToneSeconds: Double?
    /** How long to play the alerting tone for a manual-answer interaction */
    public var manualAnswerAlertToneSeconds: Double?
    /** Map of media subtype to media subtype specific settings. */
    public var subTypeSettings: [String:BaseMediaSettings]?
    /** Flag to enable Auto-Dial and Auto-End automation for callbacks on this queue. */
    public var enableAutoDialAndEnd: Bool?
    /** Time in seconds after agent connects to callback before outgoing call is auto-dialed. Allowable values in range 0 - 1200 seconds. Defaults to 300 seconds. */
    public var autoDialDelaySeconds: Int?
    /** Time in seconds after agent disconnects from the outgoing call before the encasing callback is auto-ended. Allowable values in range 0 - 1200 seconds. Defaults to 300 seconds. */
    public var autoEndDelaySeconds: Int?

    public init(enableAutoAnswer: Bool?, alertingTimeoutSeconds: Int?, serviceLevel: ServiceLevel?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, subTypeSettings: [String:BaseMediaSettings]?, enableAutoDialAndEnd: Bool?, autoDialDelaySeconds: Int?, autoEndDelaySeconds: Int?) {
        self.enableAutoAnswer = enableAutoAnswer
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.serviceLevel = serviceLevel
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.subTypeSettings = subTypeSettings
        self.enableAutoDialAndEnd = enableAutoDialAndEnd
        self.autoDialDelaySeconds = autoDialDelaySeconds
        self.autoEndDelaySeconds = autoEndDelaySeconds
    }


}




public class Campaign: Codable {















    public enum DialingMode: String, Codable { 
        case agentless = "agentless"
        case preview = "preview"
        case power = "power"
        case predictive = "predictive"
        case progressive = "progressive"
        case external = "external"
    }







    public enum CampaignStatus: String, Codable { 
        case on = "on"
        case stopping = "stopping"
        case off = "off"
        case complete = "complete"
        case invalid = "invalid"
        case forcedOff = "forced_off"
        case forcedStopping = "forced_stopping"
    }















































    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the Campaign. */
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** The ContactList for this Campaign to dial. */
    public var contactList: DomainEntityRef?
    /** The Queue for this Campaign to route calls to. Required for all dialing modes except agentless. */
    public var queue: DomainEntityRef?
    /** The strategy this Campaign will use for dialing. */
    public var dialingMode: DialingMode?
    /** The Script to be displayed to agents that are handling outbound calls. Required for all dialing modes except agentless. */
    public var script: DomainEntityRef?
    /** The EdgeGroup that will place the calls. Required for all dialing modes except preview. */
    public var edgeGroup: DomainEntityRef?
    /** The identifier of the site to be used for dialing; can be set in place of an edge group. */
    public var site: DomainEntityRef?
    /** The current status of the Campaign. A Campaign may be turned 'on' or 'off'. Required for updates. */
    public var campaignStatus: CampaignStatus?
    /** The ContactPhoneNumberColumns on the ContactList that this Campaign should dial. */
    public var phoneColumns: [PhoneColumn]?
    /** The targeted compliance abandon rate percentage. Required for power and predictive campaigns. */
    public var abandonRate: Double?
    /** DncLists for this Campaign to check before placing a call. */
    public var dncLists: [DomainEntityRef]?
    /** The callable time set for this campaign to check before placing a call. */
    public var callableTimeSet: DomainEntityRef?
    /** The call analysis response set to handle call analysis results from the edge. Required for all dialing modes except preview. */
    public var callAnalysisResponseSet: DomainEntityRef?
    /** A list of current error conditions associated with the campaign. */
    public var errors: [RestErrorDetail]?
    /** The caller id name to be displayed on the outbound call. */
    public var callerName: String?
    /** The caller id phone number to be displayed on the outbound call. */
    public var callerAddress: String?
    /** The number of outbound lines to be concurrently dialed. Only applicable to non-preview campaigns; only required for agentless. */
    public var outboundLineCount: Int?
    /** Rule sets to be applied while this campaign is dialing. */
    public var ruleSets: [DomainEntityRef]?
    /** Whether or not agents can skip previews without placing a call. Only applicable for preview campaigns. */
    public var skipPreviewDisabled: Bool?
    /** The number of seconds before a call will be automatically placed on a preview. A value of 0 indicates no automatic placement of calls. Only applicable to preview campaigns. */
    public var previewTimeOutSeconds: Int64?
    /** Indicates (when true) that the campaign will remain on after contacts are depleted, allowing additional contacts to be appended/added to the contact list and processed by the still-running campaign. The campaign can still be turned off manually. */
    public var alwaysRunning: Bool?
    /** The order in which to sort contacts for dialing, based on a column. */
    public var contactSort: ContactSort?
    /** The order in which to sort contacts for dialing, based on up to four columns. */
    public var contactSorts: [ContactSort]?
    /** How long to wait before dispositioning a call as 'no-answer'. Default 30 seconds. Only applicable to non-preview campaigns. */
    public var noAnswerTimeout: Int?
    /** The language the edge will use to analyze the call. */
    public var callAnalysisLanguage: String?
    /** The priority of this campaign relative to other campaigns that are running on the same queue. 5 is the highest priority, 1 the lowest. */
    public var priority: Int?
    /** Filter to apply to the contact list before dialing. Currently a campaign can only have one filter applied. */
    public var contactListFilters: [DomainEntityRef]?
    /** The division this campaign belongs to. */
    public var division: DomainEntityRef?
    /** Settings for dynamic queueing of contacts. */
    public var dynamicContactQueueingSettings: DynamicContactQueueingSettings?
    /** The maximum number of calls that can be placed per agent on this campaign */
    public var maxCallsPerAgent: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, contactList: DomainEntityRef?, queue: DomainEntityRef?, dialingMode: DialingMode?, script: DomainEntityRef?, edgeGroup: DomainEntityRef?, site: DomainEntityRef?, campaignStatus: CampaignStatus?, phoneColumns: [PhoneColumn]?, abandonRate: Double?, dncLists: [DomainEntityRef]?, callableTimeSet: DomainEntityRef?, callAnalysisResponseSet: DomainEntityRef?, errors: [RestErrorDetail]?, callerName: String?, callerAddress: String?, outboundLineCount: Int?, ruleSets: [DomainEntityRef]?, skipPreviewDisabled: Bool?, previewTimeOutSeconds: Int64?, alwaysRunning: Bool?, contactSort: ContactSort?, contactSorts: [ContactSort]?, noAnswerTimeout: Int?, callAnalysisLanguage: String?, priority: Int?, contactListFilters: [DomainEntityRef]?, division: DomainEntityRef?, dynamicContactQueueingSettings: DynamicContactQueueingSettings?, maxCallsPerAgent: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.contactList = contactList
        self.queue = queue
        self.dialingMode = dialingMode
        self.script = script
        self.edgeGroup = edgeGroup
        self.site = site
        self.campaignStatus = campaignStatus
        self.phoneColumns = phoneColumns
        self.abandonRate = abandonRate
        self.dncLists = dncLists
        self.callableTimeSet = callableTimeSet
        self.callAnalysisResponseSet = callAnalysisResponseSet
        self.errors = errors
        self.callerName = callerName
        self.callerAddress = callerAddress
        self.outboundLineCount = outboundLineCount
        self.ruleSets = ruleSets
        self.skipPreviewDisabled = skipPreviewDisabled
        self.previewTimeOutSeconds = previewTimeOutSeconds
        self.alwaysRunning = alwaysRunning
        self.contactSort = contactSort
        self.contactSorts = contactSorts
        self.noAnswerTimeout = noAnswerTimeout
        self.callAnalysisLanguage = callAnalysisLanguage
        self.priority = priority
        self.contactListFilters = contactListFilters
        self.division = division
        self.dynamicContactQueueingSettings = dynamicContactQueueingSettings
        self.maxCallsPerAgent = maxCallsPerAgent
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case contactList
        case queue
        case dialingMode
        case script
        case edgeGroup
        case site
        case campaignStatus
        case phoneColumns
        case abandonRate
        case dncLists
        case callableTimeSet
        case callAnalysisResponseSet
        case errors
        case callerName
        case callerAddress
        case outboundLineCount
        case ruleSets
        case skipPreviewDisabled
        case previewTimeOutSeconds
        case alwaysRunning
        case contactSort
        case contactSorts
        case noAnswerTimeout
        case callAnalysisLanguage
        case priority
        case contactListFilters
        case division
        case dynamicContactQueueingSettings
        case maxCallsPerAgent
        case selfUri
    }


}




public class CampaignRuleEntities: Codable {





    /** The list of campaigns for a CampaignRule to monitor. Required if the CampaignRule has any conditions that run on a campaign. */
    public var campaigns: [DomainEntityRef]?
    /** The list of sequences for a CampaignRule to monitor. Required if the CampaignRule has any conditions that run on a sequence. */
    public var sequences: [DomainEntityRef]?

    public init(campaigns: [DomainEntityRef]?, sequences: [DomainEntityRef]?) {
        self.campaigns = campaigns
        self.sequences = sequences
    }


}




public class CampaignRuleEntityListing: Codable {





















    public var entities: [CampaignRule]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CampaignRule]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CampaignSequence: Codable {















    public enum Status: String, Codable { 
        case on = "on"
        case off = "off"
        case complete = "complete"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** The ordered list of Campaigns that this CampaignSequence will run. */
    public var campaigns: [DomainEntityRef]?
    /** A zero-based index indicating which Campaign this CampaignSequence is currently on. */
    public var currentCampaign: Int?
    /** The current status of the CampaignSequence. A CampaignSequence can be turned 'on' or 'off'. */
    public var status: Status?
    /** A message indicating if and why a CampaignSequence has stopped unexpectedly. */
    public var stopMessage: String?
    /** Indicates if a sequence should repeat from the beginning after the last campaign completes. Default is false. */
    public var _repeat: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, campaigns: [DomainEntityRef]?, currentCampaign: Int?, status: Status?, stopMessage: String?, _repeat: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.campaigns = campaigns
        self.currentCampaign = currentCampaign
        self.status = status
        self.stopMessage = stopMessage
        self._repeat = _repeat
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case campaigns
        case currentCampaign
        case status
        case stopMessage
        case _repeat = "repeat"
        case selfUri
    }


}



/** List of available Action categories. */

public class Category: Codable {



    /** Category name */
    public var name: String?

    public init(name: String?) {
        self.name = name
    }


}




public class CategoryListing: Codable {









    public var entities: [KnowledgeCategory]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [KnowledgeCategory]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class ChannelTopicEntityListing: Codable {



    public var entities: [ChannelTopic]?

    public init(entities: [ChannelTopic]?) {
        self.entities = entities
    }


}




public class ChatMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case parked = "parked"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDonotdisturb = "endpoint.donotdisturb"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferDonotdisturb = "transfer.donotdisturb"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
    }





































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }













    /** The unique participant ID. */
    public var _id: String?
    /** The display friendly name of the participant. */
    public var name: String?
    /** The participant address. */
    public var address: String?
    /** The time when this participant first joined the conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startTime: Date?
    /** The time when this participant went connected for this media (eg: video connected time). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** The time when this participant went disconnected for this media (eg: video disconnected time). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?
    /** The time when this participant's hold started. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startHoldTime: Date?
    /** The participant's purpose.  Values can be: 'agent', 'user', 'customer', 'external', 'acd', 'ivr */
    public var purpose: String?
    /** The participant's state.  Values can be: 'alerting', 'connected', 'disconnected', 'dialing', 'contacting */
    public var state: State?
    /** The participant's direction.  Values can be: 'inbound' or 'outbound' */
    public var direction: Direction?
    /** The reason the participant was disconnected from the conversation. */
    public var disconnectType: DisconnectType?
    /** Value is true when the participant is on hold. */
    public var held: Bool?
    /** Value is true when the participant requires wrap-up. */
    public var wrapupRequired: Bool?
    /** The wrap-up prompt indicating the type of wrap-up to be performed. */
    public var wrapupPrompt: String?
    /** List of roles this participant's media has had on the conversation, ie monitor, coach, etc */
    public var mediaRoles: [String]?
    /** The PureCloud user for this participant. */
    public var user: DomainEntityRef?
    /** The PureCloud queue for this participant. */
    public var queue: DomainEntityRef?
    /** The PureCloud team for this participant. */
    public var team: DomainEntityRef?
    /** A list of ad-hoc attributes for the participant. */
    public var attributes: [String:String]?
    /** If the conversation ends in error, contains additional error details. */
    public var errorInfo: ErrorInfo?
    /** The Engage script that should be used by this participant. */
    public var script: DomainEntityRef?
    /** The amount of time the participant has to complete wrap-up. */
    public var wrapupTimeoutMs: Int?
    /** Value is true when the participant has skipped wrap-up. */
    public var wrapupSkipped: Bool?
    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutMs: Int?
    /** The source provider for the communication. */
    public var provider: String?
    /** If this participant represents an external contact, then this will be the reference for the external contact. */
    public var externalContact: DomainEntityRef?
    /** If this participant represents an external org, then this will be the reference for the external org. */
    public var externalOrganization: DomainEntityRef?
    /** Wrapup for this participant, if it has been applied. */
    public var wrapup: Wrapup?
    /** The peer communication corresponding to a matching leg for this communication. */
    public var peer: String?
    /** The reason specifying why participant flagged the conversation. */
    public var flaggedReason: FlaggedReason?
    /** Journey System data/context that is applicable to this communication.  When used for historical purposes, the context should be immutable.  When null, there is no applicable Journey System context. */
    public var journeyContext: JourneyContext?
    /** Information on how a communication should be routed to an agent. */
    public var conversationRoutingData: ConversationRoutingData?
    /** The timestamp when this participant started after-call work. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAcwTime: Date?
    /** The timestamp when this participant ended after-call work. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endAcwTime: Date?
    /** The ID of the chat room. */
    public var roomId: String?
    /** If available, the URI to the avatar image of this communication. */
    public var avatarImageUrl: String?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, mediaRoles: [String]?, user: DomainEntityRef?, queue: DomainEntityRef?, team: DomainEntityRef?, attributes: [String:String]?, errorInfo: ErrorInfo?, script: DomainEntityRef?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, alertingTimeoutMs: Int?, provider: String?, externalContact: DomainEntityRef?, externalOrganization: DomainEntityRef?, wrapup: Wrapup?, peer: String?, flaggedReason: FlaggedReason?, journeyContext: JourneyContext?, conversationRoutingData: ConversationRoutingData?, startAcwTime: Date?, endAcwTime: Date?, roomId: String?, avatarImageUrl: String?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.mediaRoles = mediaRoles
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.peer = peer
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.conversationRoutingData = conversationRoutingData
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.roomId = roomId
        self.avatarImageUrl = avatarImageUrl
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case mediaRoles
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalOrganization
        case wrapup
        case peer
        case flaggedReason
        case journeyContext
        case conversationRoutingData
        case startAcwTime
        case endAcwTime
        case roomId
        case avatarImageUrl
    }


}



/** Configuration information for the integration */

public class ClientAppConfigurationInfo: Codable {





    /** The current, active configuration for the integration. */
    public var current: IntegrationConfiguration?
    /** The effective configuration for the app, containing the integration specific configuration along with overrides specified in the integration type. */
    public var effective: EffectiveConfiguration?

    public init(current: IntegrationConfiguration?, effective: EffectiveConfiguration?) {
        self.current = current
        self.effective = effective
    }


}



/** Coaching appointment response */

public class CoachingAppointmentResponse: Codable {











    public enum Status: String, Codable { 
        case scheduled = "Scheduled"
        case inProgress = "InProgress"
        case completed = "Completed"
        case invalidSchedule = "InvalidSchedule"
    }



























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of coaching appointment */
    public var name: String?
    /** The description of coaching appointment */
    public var _description: String?
    /** The date/time the coaching appointment starts. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?
    /** The duration of coaching appointment in minutes */
    public var lengthInMinutes: Int?
    /** The status of coaching appointment */
    public var status: Status?
    /** The facilitator of coaching appointment */
    public var facilitator: UserReference?
    /** The list of attendees attending the coaching */
    public var attendees: [UserReference]?
    /** The user who created the coaching appointment */
    public var createdBy: UserReference?
    /** The date/time the coaching appointment was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The last user to modify the coaching appointment */
    public var modifiedBy: UserReference?
    /** The date/time the coaching appointment was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The list of conversations associated with coaching appointment. */
    public var conversations: [ConversationReference]?
    /** The list of documents associated with coaching appointment. */
    public var documents: [DocumentReference]?
    /** Whether the appointment is overdue. */
    public var isOverdue: Bool?
    /** The Workforce Management schedule the appointment is associated with. */
    public var wfmSchedule: WfmScheduleReference?
    /** The date/time the coaching appointment was set to completed status. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCompleted: Date?
    /** The list of external links related to the appointment */
    public var externalLinks: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, dateStart: Date?, lengthInMinutes: Int?, status: Status?, facilitator: UserReference?, attendees: [UserReference]?, createdBy: UserReference?, dateCreated: Date?, modifiedBy: UserReference?, dateModified: Date?, conversations: [ConversationReference]?, documents: [DocumentReference]?, isOverdue: Bool?, wfmSchedule: WfmScheduleReference?, dateCompleted: Date?, externalLinks: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.dateStart = dateStart
        self.lengthInMinutes = lengthInMinutes
        self.status = status
        self.facilitator = facilitator
        self.attendees = attendees
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
        self.conversations = conversations
        self.documents = documents
        self.isOverdue = isOverdue
        self.wfmSchedule = wfmSchedule
        self.dateCompleted = dateCompleted
        self.externalLinks = externalLinks
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case dateStart
        case lengthInMinutes
        case status
        case facilitator
        case attendees
        case createdBy
        case dateCreated
        case modifiedBy
        case dateModified
        case conversations
        case documents
        case isOverdue
        case wfmSchedule
        case dateCompleted
        case externalLinks
        case selfUri
    }


}



/** Settings concerning cobrowse */

public class CobrowseSettings: Codable {







    public enum Channels: String, Codable { 
        case webmessaging = "Webmessaging"
        case voice = "Voice"
    }



    /** Whether or not cobrowse is enabled */
    public var enabled: Bool?
    /** Whether the viewer should have option to request control */
    public var allowAgentControl: Bool?
    /** Mask patterns that will apply to pages being shared */
    public var maskSelectors: [String]?
    /** Cobrowse channels for web messenger */
    public var channels: [Channels]?
    /** Readonly patterns that will apply to pages being shared */
    public var readonlySelectors: [String]?

    public init(enabled: Bool?, allowAgentControl: Bool?, maskSelectors: [String]?, channels: [Channels]?, readonlySelectors: [String]?) {
        self.enabled = enabled
        self.allowAgentControl = allowAgentControl
        self.maskSelectors = maskSelectors
        self.channels = channels
        self.readonlySelectors = readonlySelectors
    }


}




public class CommonAlertBulkUpdateRequest: Codable {

    public enum ModelType: String, Codable { 
        case mute = "Mute"
        case snooze = "Snooze"
        case unread = "Unread"
    }







    /** The action to take */
    public var type: ModelType?
    /** The user supplied alert ids to be muted */
    public var alertIds: [String]?
    /** The fields need for a mute or snooze requests */
    public var muteSnooze: MuteSnoozeFields?
    /** The fields need for an unread update requests */
    public var unread: UnreadFields?

    public init(type: ModelType?, alertIds: [String]?, muteSnooze: MuteSnoozeFields?, unread: UnreadFields?) {
        self.type = type
        self.alertIds = alertIds
        self.muteSnooze = muteSnooze
        self.unread = unread
    }


}




public class CommonCampaignDivisionView: Codable {







    public enum MediaType: String, Codable { 
        case email = "email"
        case sms = "sms"
        case voice = "voice"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the Campaign. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The media type used for this campaign. */
    public var mediaType: MediaType?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, mediaType: MediaType?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.mediaType = mediaType
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case mediaType
        case selfUri
    }


}




public class CommonRule: Codable {

















    public enum ModelType: String, Codable { 
        case conversationMetrics = "ConversationMetrics"
        case userPresence = "UserPresence"
        case workforceManagement = "WorkforceManagement"
        case unknown = "Unknown"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Name of the rule */
    public var name: String?
    /** The description of the rule. */
    public var _description: String?
    /** Indicates if the rule is enabled. */
    public var enabled: Bool?
    /** The alert notification types to trigger when alarm state changes as well as the users they will be sent to. */
    public var notifications: [AlertNotification]?
    /** Indicates if the alert will send a notification when it is closed. */
    public var sendExitingAlarmNotifications: Bool?
    /** The amount of time in milliseconds to wait between notification. */
    public var waitBetweenNotificationMs: Int64?
    /** The set of metric conditions that would trigger an alert. */
    public var conditions: CommonRuleConditions?
    /** The type of the rule. */
    public var type: ModelType?
    /** Indicates if the rule is in alarm state. */
    public var inAlarm: Bool?
    /** The entity that created the rule. */
    public var user: UserReference?
    /** The current version number of the rule. */
    public var version: Int?
    /** The creation date of the rule when the rule was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The timestamp of the last update to the rule. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateLastModified: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, enabled: Bool?, notifications: [AlertNotification]?, sendExitingAlarmNotifications: Bool?, waitBetweenNotificationMs: Int64?, conditions: CommonRuleConditions?, type: ModelType?, inAlarm: Bool?, user: UserReference?, version: Int?, dateCreated: Date?, dateLastModified: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.enabled = enabled
        self.notifications = notifications
        self.sendExitingAlarmNotifications = sendExitingAlarmNotifications
        self.waitBetweenNotificationMs = waitBetweenNotificationMs
        self.conditions = conditions
        self.type = type
        self.inAlarm = inAlarm
        self.user = user
        self.version = version
        self.dateCreated = dateCreated
        self.dateLastModified = dateLastModified
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case enabled
        case notifications
        case sendExitingAlarmNotifications
        case waitBetweenNotificationMs
        case conditions
        case type
        case inAlarm
        case user
        case version
        case dateCreated
        case dateLastModified
        case selfUri
    }


}




public class CommonRuleConditions: Codable {





    public enum ModelType: String, Codable { 
        case and = "And"
        case or = "Or"
        case not = "Not"
    }



    /** The list of predicates groups to be evaluated */
    public var clauses: [CommonRuleConditions]?
    /** The list of rule metric predicates to be evaluated. */
    public var predicates: [CommonRulePredicate]?
    /** the logic operator performed. */
    public var type: ModelType?
    /** The id. */
    public var _id: String?

    public init(clauses: [CommonRuleConditions]?, predicates: [CommonRulePredicate]?, type: ModelType?, _id: String?) {
        self.clauses = clauses
        self.predicates = predicates
        self.type = type
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case clauses
        case predicates
        case type
        case _id = "id"
    }


}




public class CommonRulePredicateEntity: Codable {

    public enum EntityType: String, Codable { 
        case user = "User"
        case group = "Group"
        case queue = "Queue"
        case team = "Team"
        case teamMembers = "TeamMembers"
    }









    /** Specifies the type of entity being evaluated */
    public var entityType: EntityType?
    /** User id of the entity being monitored */
    public var user: AddressableEntityRef?
    /** Group id of the entity being monitored */
    public var group: AddressableEntityRef?
    /** Queue id of the entity being monitored */
    public var queue: AddressableEntityRef?
    /** Team id of the entity being monitored */
    public var team: AddressableEntityRef?

    public init(entityType: EntityType?, user: AddressableEntityRef?, group: AddressableEntityRef?, queue: AddressableEntityRef?, team: AddressableEntityRef?) {
        self.entityType = entityType
        self.user = user
        self.group = group
        self.queue = queue
        self.team = team
    }


}




public class CommunicationAnsweredEvent: Codable {









    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication */
    public var communicationId: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
    }


}




public class CommunicationEndedEvent: Codable {









    public enum DisconnectType: String, Codable { 
        case error = "Error"
        case peer = "Peer"
        case _self = "Self"
        case system = "System"
        case transfer = "Transfer"
        case transferACD = "TransferACD"
        case transferConference = "TransferConference"
        case transferConsult = "TransferConsult"
        case transferUser = "TransferUser"
    }



    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication */
    public var communicationId: String?
    /** Indicates how this communication was ended. */
    public var disconnectType: DisconnectType?
    /** The id (V4 UUID) of the conversation that the communication is being moved to when conversations are merged. */
    public var destinationConversationId: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, disconnectType: DisconnectType?, destinationConversationId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.disconnectType = disconnectType
        self.destinationConversationId = destinationConversationId
    }


}



/** Variable type information about a complex type from the bot's definition */

public class ComplexVariableInfo: Codable {





    /** The variable type ID */
    public var _id: String?
    /** The variable type display name */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class Condition: Codable {

    public enum ModelType: String, Codable { 
        case wrapupcondition = "wrapupCondition"
        case systemdispositioncondition = "systemDispositionCondition"
        case contactattributecondition = "contactAttributeCondition"
        case phonenumbercondition = "phoneNumberCondition"
        case phonenumbertypecondition = "phoneNumberTypeCondition"
        case callanalysiscondition = "callAnalysisCondition"
        case contactpropertycondition = "contactPropertyCondition"
        case dataactioncondition = "dataActionCondition"
    }







    public enum ValueType: String, Codable { 
        case string = "STRING"
        case numeric = "NUMERIC"
        case datetime = "DATETIME"
        case period = "PERIOD"
    }

    public enum Operator: String, Codable { 
        case equals = "EQUALS"
        case lessThan = "LESS_THAN"
        case lessThanEquals = "LESS_THAN_EQUALS"
        case greaterThan = "GREATER_THAN"
        case greaterThanEquals = "GREATER_THAN_EQUALS"
        case contains = "CONTAINS"
        case beginsWith = "BEGINS_WITH"
        case endsWith = "ENDS_WITH"
        case before = "BEFORE"
        case after = "AFTER"
        case _in = "IN"
    }





    public enum PropertyType: String, Codable { 
        case lastAttemptByColumn = "LAST_ATTEMPT_BY_COLUMN"
        case lastAttemptOverall = "LAST_ATTEMPT_OVERALL"
        case lastWrapupByColumn = "LAST_WRAPUP_BY_COLUMN"
        case lastWrapupOverall = "LAST_WRAPUP_OVERALL"
    }















    /** The type of the condition. */
    public var type: ModelType?
    /** If true, inverts the result of evaluating this Condition. Default is false. */
    public var inverted: Bool?
    /** An attribute name associated with this Condition. Required for a contactAttributeCondition. */
    public var attributeName: String?
    /** A value associated with this Condition. This could be text, a number, or a relative time. Not used for a DataActionCondition. */
    public var value: String?
    /** The type of the value associated with this Condition. Not used for a DataActionCondition. */
    public var valueType: ValueType?
    /** An operation with which to evaluate the Condition. Not used for a DataActionCondition. */
    public var _operator: Operator?
    /** List of wrap-up code identifiers. Required for a wrapupCondition. */
    public var codes: [String]?
    /** A value associated with the property type of this Condition. Required for a contactPropertyCondition. */
    public var property: String?
    /** The type of the property associated with this Condition. Required for a contactPropertyCondition. */
    public var propertyType: PropertyType?
    /** The Data Action to use for this condition. Required for a dataActionCondition. */
    public var dataAction: DomainEntityRef?
    /** The result of this condition if the data action returns a result indicating there was no data. Required for a DataActionCondition. */
    public var dataNotFoundResolution: Bool?
    /** The input field from the data action that the contactId will be passed to for this condition. Valid for a dataActionCondition. */
    public var contactIdField: String?
    /** The input field from the data action that the callAnalysisResult will be passed to for this condition. Valid for a wrapup dataActionCondition. */
    public var callAnalysisResultField: String?
    /** The input field from the data action that the agentWrapup will be passed to for this condition. Valid for a wrapup dataActionCondition. */
    public var agentWrapupField: String?
    /** A list of mappings defining which contact data fields will be passed to which data action input fields for this condition. Valid for a dataActionCondition. */
    public var contactColumnToDataActionFieldMappings: [ContactColumnToDataActionFieldMapping]?
    /** A list of predicates defining the comparisons to use for this condition. Required for a dataActionCondition. */
    public var predicates: [DataActionConditionPredicate]?

    public init(type: ModelType?, inverted: Bool?, attributeName: String?, value: String?, valueType: ValueType?, _operator: Operator?, codes: [String]?, property: String?, propertyType: PropertyType?, dataAction: DomainEntityRef?, dataNotFoundResolution: Bool?, contactIdField: String?, callAnalysisResultField: String?, agentWrapupField: String?, contactColumnToDataActionFieldMappings: [ContactColumnToDataActionFieldMapping]?, predicates: [DataActionConditionPredicate]?) {
        self.type = type
        self.inverted = inverted
        self.attributeName = attributeName
        self.value = value
        self.valueType = valueType
        self._operator = _operator
        self.codes = codes
        self.property = property
        self.propertyType = propertyType
        self.dataAction = dataAction
        self.dataNotFoundResolution = dataNotFoundResolution
        self.contactIdField = contactIdField
        self.callAnalysisResultField = callAnalysisResultField
        self.agentWrapupField = agentWrapupField
        self.contactColumnToDataActionFieldMappings = contactColumnToDataActionFieldMappings
        self.predicates = predicates
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case inverted
        case attributeName
        case value
        case valueType
        case _operator = "operator"
        case codes
        case property
        case propertyType
        case dataAction
        case dataNotFoundResolution
        case contactIdField
        case callAnalysisResultField
        case agentWrapupField
        case contactColumnToDataActionFieldMappings
        case predicates
    }


}




public class ConfigurationOverrides: Codable {



    /** Indicates whether or not the contact will be placed in front of the queue or at the end of the queue. */
    public var priority: Bool?

    public init(priority: Bool?) {
        self.priority = priority
    }


}




public class ConfusionIntentInfo: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the object. */
    public var name: String?
    /** Number of utterances in this intent which are similar to parent utterance. */
    public var utteranceCount: Int?

    public init(_id: String?, name: String?, utteranceCount: Int?) {
        self._id = _id
        self.name = name
        self.utteranceCount = utteranceCount
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case utteranceCount
    }


}




public class ConnectRate: Codable {







    /** Number of call attempts made */
    public var attempts: Int64?
    /** Number of calls with a live voice detected */
    public var connects: Int64?
    /** Ratio of connects to attempts */
    public var connectRatio: Double?

    public init(attempts: Int64?, connects: Int64?, connectRatio: Double?) {
        self.attempts = attempts
        self.connects = connects
        self.connectRatio = connectRatio
    }


}




public class ConnectedUser: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class ConsultTransferEvent: Codable {













    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** The id (V4 UUID) of the communication representing the participant that is initiating the transfer. */
    public var initiatingCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred to. */
    public var destinationCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred. */
    public var objectCommunicationId: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, initiatingCommunicationId: String?, destinationCommunicationId: String?, objectCommunicationId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.initiatingCommunicationId = initiatingCommunicationId
        self.destinationCommunicationId = destinationCommunicationId
        self.objectCommunicationId = objectCommunicationId
    }


}




public class ContactAddressConditionSettings: Codable {

    public enum Operator: String, Codable { 
        case equals = "Equals"
        case contains = "Contains"
        case beginsWith = "BeginsWith"
        case endsWith = "EndsWith"
    }



    /** The operator to use when comparing address values. */
    public var _operator: Operator?
    /** The value to compare against the contact's address. */
    public var value: String?

    public init(_operator: Operator?, value: String?) {
        self._operator = _operator
        self.value = value
    }

    public enum CodingKeys: String, CodingKey { 
        case _operator = "operator"
        case value
    }


}




public class ContactListEntityListing: Codable {





















    public var entities: [ContactList]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ContactList]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ContactListFilterPredicate: Codable {



    public enum ColumnType: String, Codable { 
        case numeric = "numeric"
        case alphabetic = "alphabetic"
    }

    public enum Operator: String, Codable { 
        case equals = "EQUALS"
        case lessThan = "LESS_THAN"
        case lessThanEquals = "LESS_THAN_EQUALS"
        case greaterThan = "GREATER_THAN"
        case greaterThanEquals = "GREATER_THAN_EQUALS"
        case contains = "CONTAINS"
        case beginsWith = "BEGINS_WITH"
        case endsWith = "ENDS_WITH"
        case before = "BEFORE"
        case after = "AFTER"
        case between = "BETWEEN"
        case _in = "IN"
    }







    /** Contact list column from the ContactListFilter's contactList. */
    public var column: String?
    /** The type of data in the contact column. */
    public var columnType: ColumnType?
    /** The operator for this ContactListFilterPredicate. */
    public var _operator: Operator?
    /** Value with which to compare the contact's data. This could be text, a number, or a relative time. A value for relative time should follow the format PxxDTyyHzzM, where xx, yy, and zz specify the days, hours and minutes. For example, a value of P01DT08H30M corresponds to 1 day, 8 hours, and 30 minutes from now. To specify a time in the past, include a negative sign before each numeric value. For example, a value of P-01DT-08H-30M corresponds to 1 day, 8 hours, and 30 minutes in the past. You can also do things like P01DT00H-30M, which would correspond to 23 hours and 30 minutes from now (1 day - 30 minutes). */
    public var value: String?
    /** A range of values. Required for operators BETWEEN and IN. */
    public var range: ContactListFilterRange?
    /** Inverts the result of the predicate (i.e., if the predicate returns true, inverting it will return false). */
    public var inverted: Bool?

    public init(column: String?, columnType: ColumnType?, _operator: Operator?, value: String?, range: ContactListFilterRange?, inverted: Bool?) {
        self.column = column
        self.columnType = columnType
        self._operator = _operator
        self.value = value
        self.range = range
        self.inverted = inverted
    }

    public enum CodingKeys: String, CodingKey { 
        case column
        case columnType
        case _operator = "operator"
        case value
        case range
        case inverted
    }


}




public class ContactListFilterRange: Codable {











    /** The minimum value of the range. Required for the operator BETWEEN. */
    public var min: String?
    /** The maximum value of the range. Required for the operator BETWEEN. */
    public var max: String?
    /** Whether or not to include the minimum in the range. */
    public var minInclusive: Bool?
    /** Whether or not to include the maximum in the range. */
    public var maxInclusive: Bool?
    /** A set of values that the contact data should be in. Required for the IN operator. */
    public var inSet: [String]?

    public init(min: String?, max: String?, minInclusive: Bool?, maxInclusive: Bool?, inSet: [String]?) {
        self.min = min
        self.max = max
        self.minInclusive = minInclusive
        self.maxInclusive = maxInclusive
        self.inSet = inSet
    }


}




public class ContactListTemplateBulkRetrieveBody: Codable {



    /** The IDs of the Contact List Templates to retrieve. */
    public var ids: [String]?

    public init(ids: [String]?) {
        self.ids = ids
    }


}




public class ContactSort: Codable {



    public enum Direction: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
    }



    public var fieldName: String?
    /** The direction in which to sort contacts. */
    public var direction: Direction?
    /** Whether or not the column contains numeric data. */
    public var numeric: Bool?

    public init(fieldName: String?, direction: Direction?, numeric: Bool?) {
        self.fieldName = fieldName
        self.direction = direction
        self.numeric = numeric
    }


}



/** A card action that a user can take. */

public class ContentCardAction: Codable {

    public enum ModelType: String, Codable { 
        case link = "Link"
        case postback = "Postback"
    }







    /** Describes the type of action. */
    public var type: ModelType?
    /** The response text from the button click. */
    public var text: String?
    /** Text to be returned as the payload from a ButtonResponse when a button is clicked. The payload and text are a combination which will have to be unique across each card and carousel in order to determine which button was clicked in that card or carousel. */
    public var payload: String?
    /** A URL of a web page to direct the user to. */
    public var url: String?

    public init(type: ModelType?, text: String?, payload: String?, url: String?) {
        self.type = type
        self.text = text
        self.payload = payload
        self.url = url
    }


}




public class ContentManagementSingleDocumentTopicLockData: Codable {







    public var lockedBy: ContentManagementSingleDocumentTopicUserData?
    public var dateCreated: Date?
    public var dateExpires: Date?

    public init(lockedBy: ContentManagementSingleDocumentTopicUserData?, dateCreated: Date?, dateExpires: Date?) {
        self.lockedBy = lockedBy
        self.dateCreated = dateCreated
        self.dateExpires = dateExpires
    }


}




public class ContentManagementSingleDocumentTopicWorkspaceData: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class ContentManagementWorkspaceDocumentsTopicUserData: Codable {





    public var _id: String?
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}



/** Quick reply object V2. */

public class ContentQuickReplyV2: Codable {





    /** Text to show as the title of the quick reply. */
    public var title: String?
    /** An array of quick reply objects. */
    public var actions: [ContentQuickReply]?

    public init(title: String?, actions: [ContentQuickReply]?) {
        self.title = title
        self.actions = actions
    }


}




public class ContentSetting: Codable {



    /** Settings relating to facebook and instagram stories feature */
    public var story: StorySetting?

    public init(story: StorySetting?) {
        self.story = story
    }


}




public class ContextPattern: Codable {



    /** A list of one or more criteria to satisfy. */
    public var criteria: [EntityTypeCriteria]?

    public init(criteria: [EntityTypeCriteria]?) {
        self.criteria = criteria
    }


}




public class Conversation: Codable {



















    public enum RecordingState: String, Codable { 
        case active = "ACTIVE"
        case paused = "PAUSED"
        case _none = "NONE"
    }

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case parked = "parked"
        case _none = "none"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The external tag associated with the conversation. */
    public var externalTag: String?
    /** The time when the conversation started. This will be the time when the first participant joined the conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startTime: Date?
    /** The time when the conversation ended. This will be the time when the last participant left the conversation, or null when the conversation is still active. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?
    /** The address of the conversation as seen from an external participant. For phone calls this will be the DNIS for inbound calls and the ANI for outbound calls. For other media types this will be the address of the destination participant for inbound and the address of the initiating participant for outbound. */
    public var address: String?
    /** The list of all participants in the conversation. */
    public var participants: [Participant]?
    /** A list of conversations to merge into this conversation to create a conference. This field is null except when being used to create a conference. */
    public var conversationIds: [String]?
    /** If this is a conference conversation, then this field indicates the maximum number of participants allowed to participant in the conference. */
    public var maxParticipants: Int?
    /** On update, 'paused' initiates a secure pause, 'active' resumes any paused recordings; otherwise indicates state of conversation recording. */
    public var recordingState: RecordingState?
    /** The conversation's state */
    public var state: State?
    /** Identifiers of divisions associated with this conversation */
    public var divisions: [ConversationDivisionMembership]?
    /** The list of the most recent 20 transfer commands applied to this conversation. */
    public var recentTransfers: [TransferResponse]?
    /** True when the recording of this conversation is in secure pause status. */
    public var securePause: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, externalTag: String?, startTime: Date?, endTime: Date?, address: String?, participants: [Participant]?, conversationIds: [String]?, maxParticipants: Int?, recordingState: RecordingState?, state: State?, divisions: [ConversationDivisionMembership]?, recentTransfers: [TransferResponse]?, securePause: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.externalTag = externalTag
        self.startTime = startTime
        self.endTime = endTime
        self.address = address
        self.participants = participants
        self.conversationIds = conversationIds
        self.maxParticipants = maxParticipants
        self.recordingState = recordingState
        self.state = state
        self.divisions = divisions
        self.recentTransfers = recentTransfers
        self.securePause = securePause
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case externalTag
        case startTime
        case endTime
        case address
        case participants
        case conversationIds
        case maxParticipants
        case recordingState
        case state
        case divisions
        case recentTransfers
        case securePause
        case selfUri
    }


}




public class ConversationAggregateQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case activerouting = "activeRouting"
        case activeskillid = "activeSkillId"
        case addressfrom = "addressFrom"
        case addressto = "addressTo"
        case agentassistantid = "agentAssistantId"
        case agentbullseyering = "agentBullseyeRing"
        case agentowned = "agentOwned"
        case agentrank = "agentRank"
        case agentscore = "agentScore"
        case ani = "ani"
        case assignerid = "assignerId"
        case authenticated = "authenticated"
        case canonicalexternalcontactid = "canonicalExternalContactId"
        case conversationid = "conversationId"
        case conversationinitiator = "conversationInitiator"
        case convertedfrom = "convertedFrom"
        case convertedto = "convertedTo"
        case customerparticipation = "customerParticipation"
        case deliverystatus = "deliveryStatus"
        case destinationaddress = "destinationAddress"
        case direction = "direction"
        case disconnecttype = "disconnectType"
        case divisionid = "divisionId"
        case dnis = "dnis"
        case edgeid = "edgeId"
        case eligibleagentcount = "eligibleAgentCount"
        case errorcode = "errorCode"
        case extendeddeliverystatus = "extendedDeliveryStatus"
        case externalcontactid = "externalContactId"
        case externalmediacount = "externalMediaCount"
        case externalorganizationid = "externalOrganizationId"
        case externaltag = "externalTag"
        case firstqueue = "firstQueue"
        case flaggedreason = "flaggedReason"
        case flowintype = "flowInType"
        case flowouttype = "flowOutType"
        case groupid = "groupId"
        case interactiontype = "interactionType"
        case journeyactionid = "journeyActionId"
        case journeyactionmapid = "journeyActionMapId"
        case journeyactionmapversion = "journeyActionMapVersion"
        case journeycustomerid = "journeyCustomerId"
        case journeycustomeridtype = "journeyCustomerIdType"
        case journeycustomersessionid = "journeyCustomerSessionId"
        case journeycustomersessionidtype = "journeyCustomerSessionIdType"
        case knowledgebaseid = "knowledgeBaseId"
        case mediacount = "mediaCount"
        case mediatype = "mediaType"
        case messagetype = "messageType"
        case originatingdirection = "originatingDirection"
        case outboundcampaignid = "outboundCampaignId"
        case outboundcontactid = "outboundContactId"
        case outboundcontactlistid = "outboundContactListId"
        case participantname = "participantName"
        case peerid = "peerId"
        case proposedagentid = "proposedAgentId"
        case provider = "provider"
        case purpose = "purpose"
        case queueid = "queueId"
        case remote = "remote"
        case removedskillid = "removedSkillId"
        case requestedlanguageid = "requestedLanguageId"
        case requestedrouting = "requestedRouting"
        case requestedroutingskillid = "requestedRoutingSkillId"
        case roomid = "roomId"
        case routingpriority = "routingPriority"
        case routingring = "routingRing"
        case routingrule = "routingRule"
        case routingruletype = "routingRuleType"
        case scoredagentid = "scoredAgentId"
        case selectedagentid = "selectedAgentId"
        case selectedagentrank = "selectedAgentRank"
        case selfserved = "selfServed"
        case sessiondnis = "sessionDnis"
        case sessionid = "sessionId"
        case stationid = "stationId"
        case teamid = "teamId"
        case usedrouting = "usedRouting"
        case userid = "userId"
        case waitinginteractioncount = "waitingInteractionCount"
        case wrapupcode = "wrapUpCode"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension predicates */
    public var value: String?
    /** Right hand side for dimension predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case _operator = "operator"
        case value
        case range
    }


}




public class ConversationCallEventTopicCallConversation: Codable {









    public enum RecordingState: String, Codable { 
        case _none = "none"
        case active = "active"
        case paused = "paused"
    }





    public var _id: String?
    public var name: String?
    public var participants: [ConversationCallEventTopicCallMediaParticipant]?
    public var otherMediaUris: [String]?
    public var recordingState: RecordingState?
    public var securePause: Bool?
    public var maxParticipants: Int?

    public init(_id: String?, name: String?, participants: [ConversationCallEventTopicCallMediaParticipant]?, otherMediaUris: [String]?, recordingState: RecordingState?, securePause: Bool?, maxParticipants: Int?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
        self.recordingState = recordingState
        self.securePause = securePause
        self.maxParticipants = maxParticipants
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
        case recordingState
        case securePause
        case maxParticipants
    }


}




public class ConversationCallEventTopicDetail: Codable {









    public var errorCode: String?
    public var fieldName: String?
    public var entityId: String?
    public var entityName: String?

    public init(errorCode: String?, fieldName: String?, entityId: String?, entityName: String?) {
        self.errorCode = errorCode
        self.fieldName = fieldName
        self.entityId = entityId
        self.entityName = entityName
    }


}




public class ConversationCallEventTopicErrorBody: Codable {





















    public var message: String?
    public var code: String?
    public var status: Int?
    public var entityId: String?
    public var entityName: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var contextId: String?
    public var details: [ConversationCallEventTopicDetail]?
    public var errors: [ConversationCallEventTopicErrorBody]?

    public init(message: String?, code: String?, status: Int?, entityId: String?, entityName: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, details: [ConversationCallEventTopicDetail]?, errors: [ConversationCallEventTopicErrorBody]?) {
        self.message = message
        self.code = code
        self.status = status
        self.entityId = entityId
        self.entityName = entityName
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.details = details
        self.errors = errors
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class ConversationCallEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int?

    public init(_id: String?, version: Int?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}




public class ConversationCallEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class ConversationCallbackEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: ConversationCallbackEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: ConversationCallbackEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}




public class ConversationCallbackEventTopicJourneyContext: Codable {







    public var customer: ConversationCallbackEventTopicJourneyCustomer?
    public var customerSession: ConversationCallbackEventTopicJourneyCustomerSession?
    public var triggeringAction: ConversationCallbackEventTopicJourneyAction?

    public init(customer: ConversationCallbackEventTopicJourneyCustomer?, customerSession: ConversationCallbackEventTopicJourneyCustomerSession?, triggeringAction: ConversationCallbackEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class ConversationCallbackEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}




public class ConversationChatEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class ConversationCobrowseEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: ConversationCobrowseEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: ConversationCobrowseEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}




public class ConversationCobrowseEventTopicJourneyContext: Codable {







    public var customer: ConversationCobrowseEventTopicJourneyCustomer?
    public var customerSession: ConversationCobrowseEventTopicJourneyCustomerSession?
    public var triggeringAction: ConversationCobrowseEventTopicJourneyAction?

    public init(customer: ConversationCobrowseEventTopicJourneyCustomer?, customerSession: ConversationCobrowseEventTopicJourneyCustomerSession?, triggeringAction: ConversationCobrowseEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class ConversationCobrowseEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}



/** A card action that a user can take. */

public class ConversationContentCardAction: Codable {

    public enum ModelType: String, Codable { 
        case link = "Link"
        case postback = "Postback"
        case unknown = "Unknown"
    }







    /** Describes the type of action. */
    public var type: ModelType?
    /** The response text from the button click. */
    public var text: String?
    /** Text to be returned as the payload from a ButtonResponse when a button is clicked. The payload and text are a combination which will have to be unique across each card and carousel in order to determine which button was clicked in that card or carousel. */
    public var payload: String?
    /** A URL of a web page to direct the user to. */
    public var url: String?

    public init(type: ModelType?, text: String?, payload: String?, url: String?) {
        self.type = type
        self.text = text
        self.payload = payload
        self.url = url
    }


}



/** Quick reply object V2. */

public class ConversationContentQuickReplyV2: Codable {





    /** Text to show as the title of the quick reply. */
    public var title: String?
    /** An array of quick reply objects. */
    public var actions: [ConversationContentQuickReply]?

    public init(title: String?, actions: [ConversationContentQuickReply]?) {
        self.title = title
        self.actions = actions
    }


}




public class ConversationEmailEventTopicConversationRoutingData: Codable {











    /** A UriReference for a resource */
    public var queue: ConversationEmailEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: ConversationEmailEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int?
    /** The skills to use for routing decisions */
    public var skills: [ConversationEmailEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [ConversationEmailEventTopicScoredAgent]?

    public init(queue: ConversationEmailEventTopicUriReference?, language: ConversationEmailEventTopicUriReference?, priority: Int?, skills: [ConversationEmailEventTopicUriReference]?, scoredAgents: [ConversationEmailEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}




public class ConversationEncryptionConfiguration: Codable {





    public enum KeyConfigurationType: String, Codable { 
        case kmsSymmetric = "KmsSymmetric"
        case localKeyManager = "LocalKeyManager"
        case native = "Native"
        case _none = "None"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** keyConfigurationType is always KmsSymmetric, and should be the arn to the key alias for the master key */
    public var url: String?
    /** Type should be 'KmsSymmetric' when create or update Key configurations, 'None' to disable configuration. */
    public var keyConfigurationType: KeyConfigurationType?
    /** The error message related to the configuration */
    public var lastError: ErrorBody?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, url: String?, keyConfigurationType: KeyConfigurationType?, lastError: ErrorBody?, selfUri: String?) {
        self._id = _id
        self.url = url
        self.keyConfigurationType = keyConfigurationType
        self.lastError = lastError
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case url
        case keyConfigurationType
        case lastError
        case selfUri
    }


}




public class ConversationEncryptionConfigurationListing: Codable {







    public var total: Int64?
    public var entities: [ConversationEncryptionConfiguration]?
    public var selfUri: String?

    public init(total: Int64?, entities: [ConversationEncryptionConfiguration]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}



/** A Presence event. */

public class ConversationEventPresence: Codable {

    public enum ModelType: String, Codable { 
        case join = "Join"
        case disconnect = "Disconnect"
        case clear = "Clear"
        case signIn = "SignIn"
    }

    /** Describes the type of Presence event. */
    public var type: ModelType?

    public init(type: ModelType?) {
        self.type = type
    }


}



/** Address and name data for a call endpoint. */

public class ConversationEventTopicAddress: Codable {











    /** This will be nameRaw if present, or a locality lookup of the address field otherwise. */
    public var name: String?
    /** The name as close to the bits on the wire as possible. */
    public var nameRaw: String?
    /** The normalized address. This field is acquired from the Address Normalization Table.  The addressRaw could have gone through some transformations, such as only using the numeric portion, before being run through the Address Normalization Table. */
    public var addressNormalized: String?
    /** The address as close to the bits on the wire as possible. */
    public var addressRaw: String?
    /** The displayable address. This field is acquired from the Address Normalization Table.  The addressRaw could have gone through some transformations, such as only using the numeric portion, before being run through the Address Normalization Table. */
    public var addressDisplayable: String?

    public init(name: String?, nameRaw: String?, addressNormalized: String?, addressRaw: String?, addressDisplayable: String?) {
        self.name = name
        self.nameRaw = nameRaw
        self.addressNormalized = addressNormalized
        self.addressRaw = addressRaw
        self.addressDisplayable = addressDisplayable
    }


}




public class ConversationEventTopicCall: Codable {



    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case uploading = "uploading"
        case converting = "converting"
        case transmitting = "transmitting"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case uploading = "uploading"
        case converting = "converting"
        case transmitting = "transmitting"
        case _none = "none"
    }



    public enum RecordingState: String, Codable { 
        case _none = "none"
        case active = "active"
        case paused = "paused"
    }











    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }



    public enum Direction: String, Codable { 
        case outbound = "outbound"
        case inbound = "inbound"
    }



































    /** A globally unique identifier for this communication. */
    public var _id: String?
    public var state: State?
    public var initialState: InitialState?
    /** True if this call is being recorded. */
    public var recording: Bool?
    /** State of recording on this call. */
    public var recordingState: RecordingState?
    /** True if this call is muted so that remote participants can't hear any audio from this end. */
    public var muted: Bool?
    /** True if this call is held and the person on this side hears hold music. */
    public var confined: Bool?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** True when the recording of this call is in secure pause status. */
    public var securePause: Bool?
    public var errorInfo: ConversationEventTopicErrorDetails?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the call was placed on hold in the cloud clock if the call is currently on hold. */
    public var startHoldTime: Date?
    /** Whether a call is inbound or outbound. */
    public var direction: Direction?
    /** If call is a fax of a document in content management, the id of the document in content management. */
    public var documentId: String?
    public var _self: ConversationEventTopicAddress?
    /** Address and name data for a call endpoint. */
    public var other: ConversationEventTopicAddress?
    /** The source provider of the call. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** List of reasons that this call was disconnected. This will be set once the call disconnects. */
    public var disconnectReasons: [ConversationEventTopicDisconnectReason]?
    public var faxStatus: ConversationEventTopicFaxStatus?
    /** User to User Information (UUI) data managed by SIP session application. */
    public var uuiData: String?
    /** The timestamp when this participant was connected to the barge conference in the provider clock. */
    public var bargedTime: Date?
    /** Call wrap up or disposition data. */
    public var wrapup: ConversationEventTopicWrapup?
    public var afterCallWork: ConversationEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** UUID of virtual agent assistant that provide suggestions to the agent participant during the conversation. */
    public var agentAssistantId: String?
    public var queueMediaSettings: ConversationEventTopicQueueMediaSettings?

    public init(_id: String?, state: State?, initialState: InitialState?, recording: Bool?, recordingState: RecordingState?, muted: Bool?, confined: Bool?, held: Bool?, securePause: Bool?, errorInfo: ConversationEventTopicErrorDetails?, disconnectType: DisconnectType?, startHoldTime: Date?, direction: Direction?, documentId: String?, _self: ConversationEventTopicAddress?, other: ConversationEventTopicAddress?, provider: String?, scriptId: String?, peerId: String?, connectedTime: Date?, disconnectedTime: Date?, disconnectReasons: [ConversationEventTopicDisconnectReason]?, faxStatus: ConversationEventTopicFaxStatus?, uuiData: String?, bargedTime: Date?, wrapup: ConversationEventTopicWrapup?, afterCallWork: ConversationEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, agentAssistantId: String?, queueMediaSettings: ConversationEventTopicQueueMediaSettings?) {
        self._id = _id
        self.state = state
        self.initialState = initialState
        self.recording = recording
        self.recordingState = recordingState
        self.muted = muted
        self.confined = confined
        self.held = held
        self.securePause = securePause
        self.errorInfo = errorInfo
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.direction = direction
        self.documentId = documentId
        self._self = _self
        self.other = other
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.disconnectReasons = disconnectReasons
        self.faxStatus = faxStatus
        self.uuiData = uuiData
        self.bargedTime = bargedTime
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.agentAssistantId = agentAssistantId
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case initialState
        case recording
        case recordingState
        case muted
        case confined
        case held
        case securePause
        case errorInfo
        case disconnectType
        case startHoldTime
        case direction
        case documentId
        case _self = "self"
        case other
        case provider
        case scriptId
        case peerId
        case connectedTime
        case disconnectedTime
        case disconnectReasons
        case faxStatus
        case uuiData
        case bargedTime
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case agentAssistantId
        case queueMediaSettings
    }


}




public class ConversationEventTopicConversation: Codable {

















    public var _id: String?
    public var maxParticipants: Int?
    public var participants: [ConversationEventTopicParticipant]?
    public var recentTransfers: [ConversationEventTopicRecentTransfer]?
    public var recordingState: String?
    public var address: String?
    public var externalTag: String?
    public var securePause: Bool?

    public init(_id: String?, maxParticipants: Int?, participants: [ConversationEventTopicParticipant]?, recentTransfers: [ConversationEventTopicRecentTransfer]?, recordingState: String?, address: String?, externalTag: String?, securePause: Bool?) {
        self._id = _id
        self.maxParticipants = maxParticipants
        self.participants = participants
        self.recentTransfers = recentTransfers
        self.recordingState = recordingState
        self.address = address
        self.externalTag = externalTag
        self.securePause = securePause
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case maxParticipants
        case participants
        case recentTransfers
        case recordingState
        case address
        case externalTag
        case securePause
    }


}




public class ConversationEventTopicDisconnectReason: Codable {

    public enum ModelType: String, Codable { 
        case q850 = "q850"
        case sip = "sip"
    }





    /** Disconnect reason protocol type. */
    public var type: ModelType?
    /** Protocol specific reason code. See the Q.850 and SIP specs. */
    public var code: Int?
    /** Human readable English description of the disconnect reason. */
    public var phrase: String?

    public init(type: ModelType?, code: Int?, phrase: String?) {
        self.type = type
        self.code = code
        self.phrase = phrase
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class ConversationEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int?

    public init(_id: String?, version: Int?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}



/** Metadata information about a message. */

public class ConversationEventTopicMessageMetadata: Codable {







    /** Message type. */
    public var type: String?
    /** List of message events, if any */
    public var events: [ConversationEventTopicMessageMetadataEvent]?
    /** List of message content, if any */
    public var content: [ConversationEventTopicMessageMetadataContent]?

    public init(type: String?, events: [ConversationEventTopicMessageMetadataEvent]?, content: [ConversationEventTopicMessageMetadataContent]?) {
        self.type = type
        self.events = events
        self.content = content
    }


}




public class ConversationEventTopicPhoneNumberColumn: Codable {





    public var columnName: String?
    public var type: String?

    public init(columnName: String?, type: String?) {
        self.columnName = columnName
        self.type = type
    }


}




public class ConversationEventTopicSocialExpression: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }





















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }













    public var state: State?
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** A globally unique identifier for the social media. */
    public var socialMediaId: String?
    /** The social network of the communication */
    public var socialMediaHub: String?
    /** The social media user name of the communication */
    public var socialUserName: String?
    /** The text preview of the communication contents */
    public var previewText: String?
    /** A globally unique identifier for the recording associated with this chat. */
    public var recordingId: String?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** The source provider of the social expression. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the chat was placed on hold in the cloud clock if the chat is currently on hold. */
    public var startHoldTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** Call wrap up or disposition data. */
    public var wrapup: ConversationEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: ConversationEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?

    public init(state: State?, initialState: InitialState?, _id: String?, socialMediaId: String?, socialMediaHub: String?, socialUserName: String?, previewText: String?, recordingId: String?, held: Bool?, provider: String?, scriptId: String?, peerId: String?, disconnectType: DisconnectType?, startHoldTime: Date?, connectedTime: Date?, disconnectedTime: Date?, wrapup: ConversationEventTopicWrapup?, afterCallWork: ConversationEventTopicAfterCallWork?, afterCallWorkRequired: Bool?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.socialMediaId = socialMediaId
        self.socialMediaHub = socialMediaHub
        self.socialUserName = socialUserName
        self.previewText = previewText
        self.recordingId = recordingId
        self.held = held
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case socialMediaId
        case socialMediaHub
        case socialUserName
        case previewText
        case recordingId
        case held
        case provider
        case scriptId
        case peerId
        case disconnectType
        case startHoldTime
        case connectedTime
        case disconnectedTime
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
    }


}



/** A UriReference for a resource */

public class ConversationEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}



/** Message content element. If contentType = \"Attachment\" only one item is allowed. */

public class ConversationMessageContent: Codable {

    public enum ContentType: String, Codable { 
        case attachment = "Attachment"
        case location = "Location"
        case quickReply = "QuickReply"
        case notification = "Notification"
        case buttonResponse = "ButtonResponse"
        case story = "Story"
        case mention = "Mention"
        case card = "Card"
        case carousel = "Carousel"
        case text = "Text"
        case quickReplyV2 = "QuickReplyV2"
        case unknown = "Unknown"
    }





















    /** Type of this content element. */
    public var contentType: ContentType?
    /** Location content. */
    public var location: ConversationContentLocation?
    /** Attachment content. */
    public var attachment: ConversationContentAttachment?
    /** Quick reply content. */
    public var quickReply: ConversationContentQuickReply?
    /** Button response content. */
    public var buttonResponse: ConversationContentButtonResponse?
    /** Template notification content. */
    public var template: ConversationContentNotificationTemplate?
    /** Ephemeral story content. */
    public var story: ConversationContentStory?
    /** Card content */
    public var card: ConversationContentCard?
    /** Carousel content */
    public var carousel: ConversationContentCarousel?
    /** Text content. */
    public var text: ConversationContentText?
    /** Quick reply V2 content. */
    public var quickReplyV2: ConversationContentQuickReplyV2?

    public init(contentType: ContentType?, location: ConversationContentLocation?, attachment: ConversationContentAttachment?, quickReply: ConversationContentQuickReply?, buttonResponse: ConversationContentButtonResponse?, template: ConversationContentNotificationTemplate?, story: ConversationContentStory?, card: ConversationContentCard?, carousel: ConversationContentCarousel?, text: ConversationContentText?, quickReplyV2: ConversationContentQuickReplyV2?) {
        self.contentType = contentType
        self.location = location
        self.attachment = attachment
        self.quickReply = quickReply
        self.buttonResponse = buttonResponse
        self.template = template
        self.story = story
        self.card = card
        self.carousel = carousel
        self.text = text
        self.quickReplyV2 = quickReplyV2
    }


}




public class ConversationMessageEventTopicMessageMetadataContent: Codable {





    /** Type of this content element. */
    public var contentType: String?
    /** Content subtype, if any */
    public var subType: String?

    public init(contentType: String?, subType: String?) {
        self.contentType = contentType
        self.subType = subType
    }


}




public class ConversationMessageEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}



/** Metadata information about a message. */

public class ConversationMessageMetadata: Codable {

    public enum ModelType: String, Codable { 
        case text = "Text"
        case structured = "Structured"
        case receipt = "Receipt"
        case event = "Event"
        case message = "Message"
        case unknown = "Unknown"
    }





    /** Message type. */
    public var type: ModelType?
    /** List of events metadata */
    public var events: [ConversationMessageMetadataEvent]?
    /** List of message content */
    public var content: [ConversationMessageMetadataContent]?

    public init(type: ModelType?, events: [ConversationMessageMetadataEvent]?, content: [ConversationMessageMetadataContent]?) {
        self.type = type
        self.events = events
        self.content = content
    }


}



/** Additional identifiers for describing messaging recipient. */

public class ConversationRecipientAdditionalIdentifier: Codable {

    public enum ModelType: String, Codable { 
        case deployment = "Deployment"
        case subject = "Subject"
        case unknown = "Unknown"
    }



    /** Type of the Identifier */
    public var type: ModelType?
    /** The Identifier value. */
    public var value: String?

    public init(type: ModelType?, value: String?) {
        self.type = type
        self.value = value
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationScreenShareEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationScreenShareEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}




public class ConversationScreenShareEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: ConversationScreenShareEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int?

    public init(agent: ConversationScreenShareEventTopicUriReference?, score: Int?) {
        self.agent = agent
        self.score = score
    }


}




public class ConversationScreenShareEventTopicScreenShareMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case timeout = "timeout"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }







































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }

















    public var _id: String?
    public var name: String?
    public var address: String?
    public var startTime: Date?
    public var connectedTime: Date?
    public var endTime: Date?
    public var startHoldTime: Date?
    public var purpose: String?
    public var state: State?
    public var initialState: InitialState?
    public var direction: Direction?
    public var disconnectType: DisconnectType?
    public var held: Bool?
    public var wrapupRequired: Bool?
    public var wrapupPrompt: String?
    public var user: ConversationScreenShareEventTopicUriReference?
    public var queue: ConversationScreenShareEventTopicUriReference?
    public var team: ConversationScreenShareEventTopicUriReference?
    public var attributes: [String:String]?
    public var errorInfo: ConversationScreenShareEventTopicErrorBody?
    public var script: ConversationScreenShareEventTopicUriReference?
    public var wrapupTimeoutMs: Int?
    public var wrapupSkipped: Bool?
    public var alertingTimeoutMs: Int?
    public var provider: String?
    public var externalContact: ConversationScreenShareEventTopicUriReference?
    public var externalOrganization: ConversationScreenShareEventTopicUriReference?
    public var wrapup: ConversationScreenShareEventTopicWrapup?
    public var conversationRoutingData: ConversationScreenShareEventTopicConversationRoutingData?
    public var peer: String?
    public var screenRecordingState: String?
    public var flaggedReason: FlaggedReason?
    public var journeyContext: ConversationScreenShareEventTopicJourneyContext?
    public var startAcwTime: Date?
    public var endAcwTime: Date?
    public var mediaRoles: [String]?
    public var queueMediaSettings: ConversationScreenShareEventTopicQueueMediaSettings?
    public var context: String?
    public var peerCount: Int?
    public var sharing: Bool?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, initialState: InitialState?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, user: ConversationScreenShareEventTopicUriReference?, queue: ConversationScreenShareEventTopicUriReference?, team: ConversationScreenShareEventTopicUriReference?, attributes: [String:String]?, errorInfo: ConversationScreenShareEventTopicErrorBody?, script: ConversationScreenShareEventTopicUriReference?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, alertingTimeoutMs: Int?, provider: String?, externalContact: ConversationScreenShareEventTopicUriReference?, externalOrganization: ConversationScreenShareEventTopicUriReference?, wrapup: ConversationScreenShareEventTopicWrapup?, conversationRoutingData: ConversationScreenShareEventTopicConversationRoutingData?, peer: String?, screenRecordingState: String?, flaggedReason: FlaggedReason?, journeyContext: ConversationScreenShareEventTopicJourneyContext?, startAcwTime: Date?, endAcwTime: Date?, mediaRoles: [String]?, queueMediaSettings: ConversationScreenShareEventTopicQueueMediaSettings?, context: String?, peerCount: Int?, sharing: Bool?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.conversationRoutingData = conversationRoutingData
        self.peer = peer
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.mediaRoles = mediaRoles
        self.queueMediaSettings = queueMediaSettings
        self.context = context
        self.peerCount = peerCount
        self.sharing = sharing
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case initialState
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalOrganization
        case wrapup
        case conversationRoutingData
        case peer
        case screenRecordingState
        case flaggedReason
        case journeyContext
        case startAcwTime
        case endAcwTime
        case mediaRoles
        case queueMediaSettings
        case context
        case peerCount
        case sharing
    }


}




public class ConversationSocialExpressionEventTopicDetail: Codable {









    public var errorCode: String?
    public var fieldName: String?
    public var entityId: String?
    public var entityName: String?

    public init(errorCode: String?, fieldName: String?, entityId: String?, entityName: String?) {
        self.errorCode = errorCode
        self.fieldName = fieldName
        self.entityId = entityId
        self.entityName = entityName
    }


}




public class ConversationSocialExpressionEventTopicErrorBody: Codable {





















    public var message: String?
    public var code: String?
    public var status: Int?
    public var entityId: String?
    public var entityName: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var contextId: String?
    public var details: [ConversationSocialExpressionEventTopicDetail]?
    public var errors: [ConversationSocialExpressionEventTopicErrorBody]?

    public init(message: String?, code: String?, status: Int?, entityId: String?, entityName: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, details: [ConversationSocialExpressionEventTopicDetail]?, errors: [ConversationSocialExpressionEventTopicErrorBody]?) {
        self.message = message
        self.code = code
        self.status = status
        self.entityId = entityId
        self.entityName = entityName
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.details = details
        self.errors = errors
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class ConversationSocialExpressionEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int?

    public init(_id: String?, version: Int?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}




public class ConversationTagsUpdate: Codable {



    /** The external tag associated with the conversation. */
    public var externalTag: String?

    public init(externalTag: String?) {
        self.externalTag = externalTag
    }


}




public class ConversationSocialExpressionEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class ConversationThreadingWindow: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The conversation threading window timeout (Minutes) for each messaging type */
    public var settings: [ConversationThreadingWindowSetting]?
    /** The default conversation threading window timeout (Minutes) */
    public var defaultTimeoutMinutes: Int64?

    public init(_id: String?, settings: [ConversationThreadingWindowSetting]?, defaultTimeoutMinutes: Int64?) {
        self._id = _id
        self.settings = settings
        self.defaultTimeoutMinutes = defaultTimeoutMinutes
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case settings
        case defaultTimeoutMinutes
    }


}




public class ConversationUser: Codable {



    /** The globally unique identifier for this user. */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class ConversationVideoEventTopicConversationRoutingData: Codable {











    /** A UriReference for a resource */
    public var queue: ConversationVideoEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: ConversationVideoEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int?
    /** The skills to use for routing decisions */
    public var skills: [ConversationVideoEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [ConversationVideoEventTopicScoredAgent]?

    public init(queue: ConversationVideoEventTopicUriReference?, language: ConversationVideoEventTopicUriReference?, priority: Int?, skills: [ConversationVideoEventTopicUriReference]?, scoredAgents: [ConversationVideoEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}




public class CopyWorkPlan: Codable {



    /** Name of the copied work plan */
    public var name: String?

    public init(name: String?) {
        self.name = name
    }


}




public class CreateActivityCodeRequest: Codable {



    public enum Category: String, Codable { 
        case onQueueWork = "OnQueueWork"
        case _break = "Break"
        case meal = "Meal"
        case meeting = "Meeting"
        case offQueueWork = "OffQueueWork"
        case timeOff = "TimeOff"
        case training = "Training"
        case unavailable = "Unavailable"
        case unscheduled = "Unscheduled"
    }

















    /** The name of the activity code */
    public var name: String?
    /** The activity code's category */
    public var category: Category?
    /** The default length of the activity in minutes */
    public var lengthInMinutes: Int?
    /** Whether an agent is paid while performing this activity */
    public var countsAsPaidTime: Bool?
    /** Indicates whether or not the activity should be counted as work time */
    public var countsAsWorkTime: Bool?
    /** Whether an agent can select this activity code when creating or editing a time off request */
    public var agentTimeOffSelectable: Bool?
    /** Whether or not this activity code counts toward shrinkage calculations */
    public var countsTowardShrinkage: Bool?
    /** Whether this activity code is considered planned or unplanned shrinkage */
    public var plannedShrinkage: Bool?
    /** Whether this activity code is considered interruptible */
    public var interruptible: Bool?
    /** The secondary presences of this activity code */
    public var secondaryPresences: [SecondaryPresence]?

    public init(name: String?, category: Category?, lengthInMinutes: Int?, countsAsPaidTime: Bool?, countsAsWorkTime: Bool?, agentTimeOffSelectable: Bool?, countsTowardShrinkage: Bool?, plannedShrinkage: Bool?, interruptible: Bool?, secondaryPresences: [SecondaryPresence]?) {
        self.name = name
        self.category = category
        self.lengthInMinutes = lengthInMinutes
        self.countsAsPaidTime = countsAsPaidTime
        self.countsAsWorkTime = countsAsWorkTime
        self.agentTimeOffSelectable = agentTimeOffSelectable
        self.countsTowardShrinkage = countsTowardShrinkage
        self.plannedShrinkage = plannedShrinkage
        self.interruptible = interruptible
        self.secondaryPresences = secondaryPresences
    }


}




public class CreateBusinessUnitSettingsRequest: Codable {

    public enum StartDayOfWeek: String, Codable { 
        case sunday = "Sunday"
        case monday = "Monday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
        case thursday = "Thursday"
        case friday = "Friday"
        case saturday = "Saturday"
    }







    /** The start day of week for this business unit */
    public var startDayOfWeek: StartDayOfWeek?
    /** The time zone for this business unit, using the Olsen tz database format */
    public var timeZone: String?
    /** Short term forecasting settings */
    public var shortTermForecasting: BuShortTermForecastingSettings?
    /** Scheduling settings */
    public var scheduling: BuSchedulingSettingsRequest?

    public init(startDayOfWeek: StartDayOfWeek?, timeZone: String?, shortTermForecasting: BuShortTermForecastingSettings?, scheduling: BuSchedulingSettingsRequest?) {
        self.startDayOfWeek = startDayOfWeek
        self.timeZone = timeZone
        self.shortTermForecasting = shortTermForecasting
        self.scheduling = scheduling
    }


}




public class CreateCallbackCommand: Codable {























    /** The identifier of the script to be used for the callback */
    public var scriptId: String?
    /** The identifier of the queue to be used for the callback. Either queueId or routingData is required. */
    public var queueId: String?
    /** The routing data to be used for the callback. Either queueId or routingData is required. */
    public var routingData: RoutingData?
    /** The name of the party to be called back. */
    public var callbackUserName: String?
    /** A list of phone numbers for the callback. */
    public var callbackNumbers: [String]?
    /** The scheduled date-time for the callback as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss.SSSZ */
    public var callbackScheduledTime: Date?
    /** The country code to be associated with the callback numbers. */
    public var countryCode: String?
    /** Whether or not to validate the callback numbers for phone number format. */
    public var validateCallbackNumbers: Bool?
    /** A map of key-value pairs containing additional data that can be associated to the callback. These values will appear in the attributes property on the conversation participant. Example: { \"notes\": \"ready to close the deal!\", \"customerPreferredName\": \"Doc\" } */
    public var data: [String:String]?
    /** The phone number displayed to recipients when a phone call is placed as part of the callback. Must conform to the E.164 format. May be overridden by other settings in the system such as external trunk settings. Telco support for \"callerId\" varies. */
    public var callerId: String?
    /** The name displayed to recipients when a phone call is placed as part of the callback. May be overridden by other settings in the system such as external trunk settings. Telco support for \"callerIdName\" varies. */
    public var callerIdName: String?

    public init(scriptId: String?, queueId: String?, routingData: RoutingData?, callbackUserName: String?, callbackNumbers: [String]?, callbackScheduledTime: Date?, countryCode: String?, validateCallbackNumbers: Bool?, data: [String:String]?, callerId: String?, callerIdName: String?) {
        self.scriptId = scriptId
        self.queueId = queueId
        self.routingData = routingData
        self.callbackUserName = callbackUserName
        self.callbackNumbers = callbackNumbers
        self.callbackScheduledTime = callbackScheduledTime
        self.countryCode = countryCode
        self.validateCallbackNumbers = validateCallbackNumbers
        self.data = data
        self.callerId = callerId
        self.callerIdName = callerIdName
    }


}




public class CreateManagementUnitApiRequest: Codable {





    public enum StartDayOfWeek: String, Codable { 
        case sunday = "Sunday"
        case monday = "Monday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
        case thursday = "Thursday"
        case friday = "Friday"
        case saturday = "Saturday"
    }







    /** The name of the management unit */
    public var name: String?
    /** The default time zone to use for this management unit.  Moving to Business Unit */
    public var timeZone: String?
    /** The configured first day of the week for scheduling and forecasting purposes. Moving to Business Unit */
    public var startDayOfWeek: StartDayOfWeek?
    /** The configuration for the management unit.  If omitted, reasonable defaults will be assigned */
    public var settings: CreateManagementUnitSettingsRequest?
    /** The id of the division to which this management unit belongs.  Defaults to home division ID */
    public var divisionId: String?
    /** The id of the business unit to which this management unit belongs */
    public var businessUnitId: String?

    public init(name: String?, timeZone: String?, startDayOfWeek: StartDayOfWeek?, settings: CreateManagementUnitSettingsRequest?, divisionId: String?, businessUnitId: String?) {
        self.name = name
        self.timeZone = timeZone
        self.startDayOfWeek = startDayOfWeek
        self.settings = settings
        self.divisionId = divisionId
        self.businessUnitId = businessUnitId
    }


}




public class CreateOutboundMessagingConversationRequest: Codable {





    public enum ToAddressMessengerType: String, Codable { 
        case sms = "sms"
        case _open = "open"
        case whatsapp = "whatsapp"
    }





    /** The ID of the queue to be associated with the message. This will determine the fromAddress of the message. */
    public var queueId: String?
    /** The messaging address of the recipient of the message. For an SMS messenger type, the phone number address must be in E.164 format. E.g. +13175555555 or +34234234234.  For open messenger type, any string within the outbound.open.messaging.to.address.characters.max limit can be used. For whatsapp messenger type, use a Whatsapp ID of a phone number. E.g for a E.164 formatted phone number `+13175555555`, a Whatsapp ID would be 13175555555 */
    public var toAddress: String?
    /** The messaging address messenger type. */
    public var toAddressMessengerType: ToAddressMessengerType?
    /** An override to use an existing conversation.  If set to true, an existing conversation will be used if there is one within the conversation window.  If set to false, create request fails if there is a conversation within the conversation window. */
    public var useExistingConversation: Bool?
    /** The external contact with which the message will be associated. */
    public var externalContactId: String?

    public init(queueId: String?, toAddress: String?, toAddressMessengerType: ToAddressMessengerType?, useExistingConversation: Bool?, externalContactId: String?) {
        self.queueId = queueId
        self.toAddress = toAddress
        self.toAddressMessengerType = toAddressMessengerType
        self.useExistingConversation = useExistingConversation
        self.externalContactId = externalContactId
    }


}




public class CreatePerformanceProfile: Codable {























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** A name for this performance profile */
    public var name: String?
    /** The associated division for this Performance Profile */
    public var division: WritableDivision?
    /** A description about this performance profile */
    public var _description: String?
    /** Order of the associated metrics. The list should contain valid ids for metrics */
    public var metricOrders: [String]?
    /** Creation date for this performance profile. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The reporting interval periods for this performance profile */
    public var reportingIntervals: [ReportingInterval]?
    /** The flag for active profiles */
    public var active: Bool?
    /** The number of members in this performance profile */
    public var memberCount: Int?
    /** The maximum rank size for the leaderboard. This counts the number of ranks can be retrieved in a leaderboard queries */
    public var maxLeaderboardRankSize: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, _description: String?, metricOrders: [String]?, dateCreated: Date?, reportingIntervals: [ReportingInterval]?, active: Bool?, memberCount: Int?, maxLeaderboardRankSize: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.metricOrders = metricOrders
        self.dateCreated = dateCreated
        self.reportingIntervals = reportingIntervals
        self.active = active
        self.memberCount = memberCount
        self.maxLeaderboardRankSize = maxLeaderboardRankSize
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case metricOrders
        case dateCreated
        case reportingIntervals
        case active
        case memberCount
        case maxLeaderboardRankSize
        case selfUri
    }


}




public class CreateResponseAssetRequest: Codable {







    /** Name of the file to upload. It must not start with a dot and not end with a forward slash. Whitespace and the following characters are not allowed: \\{^}%`]\">[~<#| */
    public var name: String?
    /** Division to associate to this asset. Can only be used with this division. */
    public var divisionId: String?
    /** Content MD-5 of the file to upload */
    public var contentMd5: String?

    public init(name: String?, divisionId: String?, contentMd5: String?) {
        self.name = name
        self.divisionId = divisionId
        self.contentMd5 = contentMd5
    }


}




public class CreateShareRequest: Codable {

    public enum SharedEntityType: String, Codable { 
        case document = "DOCUMENT"
    }



    public enum MemberType: String, Codable { 
        case user = "USER"
        case group = "GROUP"
        case _public = "PUBLIC"
    }





    /** The share entity type */
    public var sharedEntityType: SharedEntityType?
    /** The entity that will be shared */
    public var sharedEntity: SharedEntity?
    public var memberType: MemberType?
    /** The member that will have access to this share. Only required if a list of members is not provided. */
    public var member: SharedEntity?
    public var members: [CreateShareRequestMember]?

    public init(sharedEntityType: SharedEntityType?, sharedEntity: SharedEntity?, memberType: MemberType?, member: SharedEntity?, members: [CreateShareRequestMember]?) {
        self.sharedEntityType = sharedEntityType
        self.sharedEntity = sharedEntity
        self.memberType = memberType
        self.member = member
        self.members = members
    }


}




public class CreateShareRequestMember: Codable {

    public enum MemberType: String, Codable { 
        case user = "USER"
        case group = "GROUP"
        case _public = "PUBLIC"
    }



    public var memberType: MemberType?
    public var member: MemberEntity?

    public init(memberType: MemberType?, member: MemberEntity?) {
        self.memberType = memberType
        self.member = member
    }


}




public class CreateTriggerRequest: Codable {

















    /** The target to invoke when a matching event is received */
    public var target: TriggerTarget?
    /** Boolean indicating if Trigger is enabled */
    public var enabled: Bool?
    /** The configuration for when a trigger is considered to be a match for an event. When not provided, all events will fire the trigger */
    public var matchCriteria: [MatchCriteria]?
    /** The name of the trigger */
    public var name: String?
    /** The topic that will cause the trigger to be invoked. Cannot be updated after creation. Valid topics can be found at /processautomation/triggers/topics  */
    public var topicName: String?
    /** Optional length of time that events are meaningful after origination. Events older than this threshold may be dropped if the platform is delayed in processing events. Unset means events are valid indefinitely, otherwise must be set to at least 10 seconds. Only one of eventTTLSeconds or delayBySeconds can be set. */
    public var eventTTLSeconds: Int?
    /** Optional delay invoking target after trigger fires. Must be in the range of 60 to 900 seconds. Only one of eventTTLSeconds or delayBySeconds can be set. */
    public var delayBySeconds: Int?
    /** Description of the trigger. Can be up to 512 characters in length. */
    public var _description: String?

    public init(target: TriggerTarget?, enabled: Bool?, matchCriteria: [MatchCriteria]?, name: String?, topicName: String?, eventTTLSeconds: Int?, delayBySeconds: Int?, _description: String?) {
        self.target = target
        self.enabled = enabled
        self.matchCriteria = matchCriteria
        self.name = name
        self.topicName = topicName
        self.eventTTLSeconds = eventTTLSeconds
        self.delayBySeconds = delayBySeconds
        self._description = _description
    }

    public enum CodingKeys: String, CodingKey { 
        case target
        case enabled
        case matchCriteria
        case name
        case topicName
        case eventTTLSeconds
        case delayBySeconds
        case _description = "description"
    }


}




public class CreateWebChatMessageRequest: Codable {



    public enum BodyType: String, Codable { 
        case standard = "standard"
        case notice = "notice"
        case memberJoin = "member-join"
        case memberLeave = "member-leave"
        case mediaRequest = "media-request"
    }

    /** The message body. Note that message bodies are limited to 4,000 characters. */
    public var body: String?
    /** The purpose of the message within the conversation, such as a standard text entry versus a greeting. */
    public var bodyType: BodyType?

    public init(body: String?, bodyType: BodyType?) {
        self.body = body
        self.bodyType = bodyType
    }


}




public class CreateWorkPlan: Codable {

















































    public enum ShiftStartVarianceType: String, Codable { 
        case shiftStart = "ShiftStart"
        case shiftStartAndPaidDuration = "ShiftStartAndPaidDuration"
    }







    /** Name of this work plan */
    public var name: String?
    /** Whether the work plan is enabled for scheduling */
    public var enabled: Bool?
    /** Whether the weekly paid time constraint is enabled for this work plan */
    public var constrainWeeklyPaidTime: Bool?
    /** Whether the weekly paid time constraint is flexible for this work plan */
    public var flexibleWeeklyPaidTime: Bool?
    /** Exact weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == false */
    public var weeklyExactPaidMinutes: Int?
    /** Minimum weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == true */
    public var weeklyMinimumPaidMinutes: Int?
    /** Maximum weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == true */
    public var weeklyMaximumPaidMinutes: Int?
    /** Whether paid time granularity should be constrained for this workplan */
    public var constrainPaidTimeGranularity: Bool?
    /** Granularity in minutes allowed for shift paid time in this work plan. Used if constrainPaidTimeGranularity == true */
    public var paidTimeGranularityMinutes: Int?
    /** Whether the minimum time between shifts constraint is enabled for this work plan */
    public var constrainMinimumTimeBetweenShifts: Bool?
    /** Minimum time between shifts in minutes defined in this work plan. Used if constrainMinimumTimeBetweenShifts == true */
    public var minimumTimeBetweenShiftsMinutes: Int?
    /** Maximum number days in a week allowed to be scheduled for this work plan */
    public var maximumDays: Int?
    /** Minimum amount of consecutive non working minutes per week that agents who are assigned this work plan are allowed to have off */
    public var minimumConsecutiveNonWorkingMinutesPerWeek: Int?
    /** Whether to constrain the maximum consecutive working weekends */
    public var constrainMaximumConsecutiveWorkingWeekends: Bool?
    /** The maximum number of consecutive weekends that agents who are assigned to this work plan are allowed to work */
    public var maximumConsecutiveWorkingWeekends: Int?
    /** The minimum number of days that agents assigned to a work plan must work per week */
    public var minimumWorkingDaysPerWeek: Int?
    /** Whether to constrain the maximum consecutive working days */
    public var constrainMaximumConsecutiveWorkingDays: Bool?
    /** The maximum number of consecutive days that agents assigned to this work plan are allowed to work. Used if constrainMaximumConsecutiveWorkingDays == true */
    public var maximumConsecutiveWorkingDays: Int?
    /** The time period in minutes for the duration between the start times of two consecutive working days */
    public var minimumShiftStartDistanceMinutes: Int?
    /** Minimum days off in the planning period */
    public var minimumDaysOffPerPlanningPeriod: Int?
    /** Maximum days off in the planning period */
    public var maximumDaysOffPerPlanningPeriod: Int?
    /** Minimum paid minutes in the planning period */
    public var minimumPaidMinutesPerPlanningPeriod: Int?
    /** Maximum paid minutes in the planning period */
    public var maximumPaidMinutesPerPlanningPeriod: Int?
    /** Optional days to schedule for this work plan */
    public var optionalDays: SetWrapperDayOfWeek?
    /** This constraint ensures that an agent starts each workday within a user-defined time threshold */
    public var shiftStartVarianceType: ShiftStartVarianceType?
    /** Variance in minutes among start times of shifts in this work plan */
    public var shiftStartVariances: ListWrapperShiftStartVariance?
    /** Shifts in this work plan */
    public var shifts: [CreateWorkPlanShift]?
    /** Agents in this work plan */
    public var agents: [UserReference]?

    public init(name: String?, enabled: Bool?, constrainWeeklyPaidTime: Bool?, flexibleWeeklyPaidTime: Bool?, weeklyExactPaidMinutes: Int?, weeklyMinimumPaidMinutes: Int?, weeklyMaximumPaidMinutes: Int?, constrainPaidTimeGranularity: Bool?, paidTimeGranularityMinutes: Int?, constrainMinimumTimeBetweenShifts: Bool?, minimumTimeBetweenShiftsMinutes: Int?, maximumDays: Int?, minimumConsecutiveNonWorkingMinutesPerWeek: Int?, constrainMaximumConsecutiveWorkingWeekends: Bool?, maximumConsecutiveWorkingWeekends: Int?, minimumWorkingDaysPerWeek: Int?, constrainMaximumConsecutiveWorkingDays: Bool?, maximumConsecutiveWorkingDays: Int?, minimumShiftStartDistanceMinutes: Int?, minimumDaysOffPerPlanningPeriod: Int?, maximumDaysOffPerPlanningPeriod: Int?, minimumPaidMinutesPerPlanningPeriod: Int?, maximumPaidMinutesPerPlanningPeriod: Int?, optionalDays: SetWrapperDayOfWeek?, shiftStartVarianceType: ShiftStartVarianceType?, shiftStartVariances: ListWrapperShiftStartVariance?, shifts: [CreateWorkPlanShift]?, agents: [UserReference]?) {
        self.name = name
        self.enabled = enabled
        self.constrainWeeklyPaidTime = constrainWeeklyPaidTime
        self.flexibleWeeklyPaidTime = flexibleWeeklyPaidTime
        self.weeklyExactPaidMinutes = weeklyExactPaidMinutes
        self.weeklyMinimumPaidMinutes = weeklyMinimumPaidMinutes
        self.weeklyMaximumPaidMinutes = weeklyMaximumPaidMinutes
        self.constrainPaidTimeGranularity = constrainPaidTimeGranularity
        self.paidTimeGranularityMinutes = paidTimeGranularityMinutes
        self.constrainMinimumTimeBetweenShifts = constrainMinimumTimeBetweenShifts
        self.minimumTimeBetweenShiftsMinutes = minimumTimeBetweenShiftsMinutes
        self.maximumDays = maximumDays
        self.minimumConsecutiveNonWorkingMinutesPerWeek = minimumConsecutiveNonWorkingMinutesPerWeek
        self.constrainMaximumConsecutiveWorkingWeekends = constrainMaximumConsecutiveWorkingWeekends
        self.maximumConsecutiveWorkingWeekends = maximumConsecutiveWorkingWeekends
        self.minimumWorkingDaysPerWeek = minimumWorkingDaysPerWeek
        self.constrainMaximumConsecutiveWorkingDays = constrainMaximumConsecutiveWorkingDays
        self.maximumConsecutiveWorkingDays = maximumConsecutiveWorkingDays
        self.minimumShiftStartDistanceMinutes = minimumShiftStartDistanceMinutes
        self.minimumDaysOffPerPlanningPeriod = minimumDaysOffPerPlanningPeriod
        self.maximumDaysOffPerPlanningPeriod = maximumDaysOffPerPlanningPeriod
        self.minimumPaidMinutesPerPlanningPeriod = minimumPaidMinutesPerPlanningPeriod
        self.maximumPaidMinutesPerPlanningPeriod = maximumPaidMinutesPerPlanningPeriod
        self.optionalDays = optionalDays
        self.shiftStartVarianceType = shiftStartVarianceType
        self.shiftStartVariances = shiftStartVariances
        self.shifts = shifts
        self.agents = agents
    }


}




public class CreateWorkPlanActivity: Codable {



























    /** ID of the activity code associated with this activity */
    public var activityCodeId: String?
    /** Description of the activity */
    public var _description: String?
    /** Length of the activity in minutes */
    public var lengthMinutes: Int?
    /** Whether the start time of the activity is relative to the start time of the shift it belongs to */
    public var startTimeIsRelativeToShiftStart: Bool?
    /** Whether the start time of the activity is flexible */
    public var flexibleStartTime: Bool?
    /** Earliest activity start in offset minutes relative to shift start time if startTimeIsRelativeToShiftStart == true else its based on midnight. Used if flexibleStartTime == true */
    public var earliestStartTimeMinutes: Int?
    /** Latest activity start in offset minutes relative to shift start time if startTimeIsRelativeToShiftStart == true else its based on midnight. Used if flexibleStartTime == true */
    public var latestStartTimeMinutes: Int?
    /** Exact activity start in offset minutes relative to shift start time if startTimeIsRelativeToShiftStart == true else its based on midnight. Used if flexibleStartTime == false */
    public var exactStartTimeMinutes: Int?
    /** Increment in offset minutes that would contribute to different possible start times for the activity */
    public var startTimeIncrementMinutes: Int?
    /** Whether the activity is paid */
    public var countsAsPaidTime: Bool?
    /** Whether the activity duration is counted towards contiguous work time */
    public var countsAsContiguousWorkTime: Bool?
    /** The minimum duration between shift start and shift item (e.g., break or meal) start in minutes */
    public var minimumLengthFromShiftStartMinutes: Int?
    /** The minimum duration between shift item (e.g., break or meal) end and shift end in minutes */
    public var minimumLengthFromShiftEndMinutes: Int?

    public init(activityCodeId: String?, _description: String?, lengthMinutes: Int?, startTimeIsRelativeToShiftStart: Bool?, flexibleStartTime: Bool?, earliestStartTimeMinutes: Int?, latestStartTimeMinutes: Int?, exactStartTimeMinutes: Int?, startTimeIncrementMinutes: Int?, countsAsPaidTime: Bool?, countsAsContiguousWorkTime: Bool?, minimumLengthFromShiftStartMinutes: Int?, minimumLengthFromShiftEndMinutes: Int?) {
        self.activityCodeId = activityCodeId
        self._description = _description
        self.lengthMinutes = lengthMinutes
        self.startTimeIsRelativeToShiftStart = startTimeIsRelativeToShiftStart
        self.flexibleStartTime = flexibleStartTime
        self.earliestStartTimeMinutes = earliestStartTimeMinutes
        self.latestStartTimeMinutes = latestStartTimeMinutes
        self.exactStartTimeMinutes = exactStartTimeMinutes
        self.startTimeIncrementMinutes = startTimeIncrementMinutes
        self.countsAsPaidTime = countsAsPaidTime
        self.countsAsContiguousWorkTime = countsAsContiguousWorkTime
        self.minimumLengthFromShiftStartMinutes = minimumLengthFromShiftStartMinutes
        self.minimumLengthFromShiftEndMinutes = minimumLengthFromShiftEndMinutes
    }

    public enum CodingKeys: String, CodingKey { 
        case activityCodeId
        case _description = "description"
        case lengthMinutes
        case startTimeIsRelativeToShiftStart
        case flexibleStartTime
        case earliestStartTimeMinutes
        case latestStartTimeMinutes
        case exactStartTimeMinutes
        case startTimeIncrementMinutes
        case countsAsPaidTime
        case countsAsContiguousWorkTime
        case minimumLengthFromShiftStartMinutes
        case minimumLengthFromShiftEndMinutes
    }


}




public class CreateWorkPlanShift: Codable {









































    public enum DayOffRule: String, Codable { 
        case nextDayOff = "NextDayOff"
        case previousDayOff = "PreviousDayOff"
    }



    /** Name of the shift */
    public var name: String?
    /** Days of the week applicable for this shift */
    public var days: SetWrapperDayOfWeek?
    /** Whether the start time of the shift is flexible */
    public var flexibleStartTime: Bool?
    /** Exact start time of the shift defined as offset minutes from midnight. Used if flexibleStartTime == false */
    public var exactStartTimeMinutesFromMidnight: Int?
    /** Earliest start time of the shift defined as offset minutes from midnight. Used if flexibleStartTime == true */
    public var earliestStartTimeMinutesFromMidnight: Int?
    /** Latest start time of the shift defined as offset minutes from midnight. Used if flexibleStartTime == true */
    public var latestStartTimeMinutesFromMidnight: Int?
    /** Whether the latest stop time constraint for the shift is enabled.  Deprecated, use constrainLatestStopTime instead */
    public var constrainStopTime: Bool?
    /** Whether the latest stop time constraint for the shift is enabled */
    public var constrainLatestStopTime: Bool?
    /** Latest stop time of the shift defined as offset minutes from midnight. Used if constrainStopTime == true */
    public var latestStopTimeMinutesFromMidnight: Int?
    /** Whether the earliest stop time constraint for the shift is enabled */
    public var constrainEarliestStopTime: Bool?
    /** This is the earliest time a shift can end */
    public var earliestStopTimeMinutesFromMidnight: Int?
    /** Increment in offset minutes that would contribute to different possible start times for the shift. Used if flexibleStartTime == true */
    public var startIncrementMinutes: Int?
    /** Whether the paid time setting for the shift is flexible */
    public var flexiblePaidTime: Bool?
    /** Exact paid time in minutes configured for the shift. Used if flexiblePaidTime == false */
    public var exactPaidTimeMinutes: Int?
    /** Minimum paid time in minutes configured for the shift. Used if flexiblePaidTime == true */
    public var minimumPaidTimeMinutes: Int?
    /** Maximum paid time in minutes configured for the shift. Used if flexiblePaidTime == true */
    public var maximumPaidTimeMinutes: Int?
    /** Whether the contiguous time constraint for the shift is enabled */
    public var constrainContiguousWorkTime: Bool?
    /** Minimum contiguous time in minutes configured for the shift. Used if constrainContiguousWorkTime == true */
    public var minimumContiguousWorkTimeMinutes: Int?
    /** Maximum contiguous time in minutes configured for the shift. Used if constrainContiguousWorkTime == true */
    public var maximumContiguousWorkTimeMinutes: Int?
    /** Whether day off rule is enabled */
    public var constrainDayOff: Bool?
    /** The day off rule for agents to have next day off or previous day off. used if constrainDayOff = true */
    public var dayOffRule: DayOffRule?
    /** Activities configured for this shift */
    public var activities: [CreateWorkPlanActivity]?

    public init(name: String?, days: SetWrapperDayOfWeek?, flexibleStartTime: Bool?, exactStartTimeMinutesFromMidnight: Int?, earliestStartTimeMinutesFromMidnight: Int?, latestStartTimeMinutesFromMidnight: Int?, constrainStopTime: Bool?, constrainLatestStopTime: Bool?, latestStopTimeMinutesFromMidnight: Int?, constrainEarliestStopTime: Bool?, earliestStopTimeMinutesFromMidnight: Int?, startIncrementMinutes: Int?, flexiblePaidTime: Bool?, exactPaidTimeMinutes: Int?, minimumPaidTimeMinutes: Int?, maximumPaidTimeMinutes: Int?, constrainContiguousWorkTime: Bool?, minimumContiguousWorkTimeMinutes: Int?, maximumContiguousWorkTimeMinutes: Int?, constrainDayOff: Bool?, dayOffRule: DayOffRule?, activities: [CreateWorkPlanActivity]?) {
        self.name = name
        self.days = days
        self.flexibleStartTime = flexibleStartTime
        self.exactStartTimeMinutesFromMidnight = exactStartTimeMinutesFromMidnight
        self.earliestStartTimeMinutesFromMidnight = earliestStartTimeMinutesFromMidnight
        self.latestStartTimeMinutesFromMidnight = latestStartTimeMinutesFromMidnight
        self.constrainStopTime = constrainStopTime
        self.constrainLatestStopTime = constrainLatestStopTime
        self.latestStopTimeMinutesFromMidnight = latestStopTimeMinutesFromMidnight
        self.constrainEarliestStopTime = constrainEarliestStopTime
        self.earliestStopTimeMinutesFromMidnight = earliestStopTimeMinutesFromMidnight
        self.startIncrementMinutes = startIncrementMinutes
        self.flexiblePaidTime = flexiblePaidTime
        self.exactPaidTimeMinutes = exactPaidTimeMinutes
        self.minimumPaidTimeMinutes = minimumPaidTimeMinutes
        self.maximumPaidTimeMinutes = maximumPaidTimeMinutes
        self.constrainContiguousWorkTime = constrainContiguousWorkTime
        self.minimumContiguousWorkTimeMinutes = minimumContiguousWorkTimeMinutes
        self.maximumContiguousWorkTimeMinutes = maximumContiguousWorkTimeMinutes
        self.constrainDayOff = constrainDayOff
        self.dayOffRule = dayOffRule
        self.activities = activities
    }


}




public class CredentialInfo: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Date the credentials were created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    /** Date credentials were last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    /** Type of the credentials. */
    public var type: CredentialType?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, createdDate: Date?, modifiedDate: Date?, type: CredentialType?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.createdDate = createdDate
        self.modifiedDate = modifiedDate
        self.type = type
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case createdDate
        case modifiedDate
        case type
        case selfUri
    }


}




public class CredentialInfoListing: Codable {





















    public var entities: [CredentialInfo]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CredentialInfo]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CriteriaCategoryInfo: Codable {





    public var categoryId: String?
    public var displayOrder: Int?

    public init(categoryId: String?, displayOrder: Int?) {
        self.categoryId = categoryId
        self.displayOrder = displayOrder
    }


}




public class CurrentUserScheduleRequestBody: Codable {







    /** Beginning of the range of schedules to fetch, in ISO-8601 format */
    public var startDate: Date?
    /** End of the range of schedules to fetch, in ISO-8601 format */
    public var endDate: Date?
    /** Whether to load the full week's schedule (for the current user) of any week overlapping the start/end date query parameters, defaults to false */
    public var loadFullWeeks: Bool?

    public init(startDate: Date?, endDate: Date?, loadFullWeeks: Bool?) {
        self.startDate = startDate
        self.endDate = endDate
        self.loadFullWeeks = loadFullWeeks
    }


}




public class CustomerStartDetailEventTopicJourneyContext: Codable {









    public var sessionId: String?
    public var sessionIdType: String?
    public var actionId: String?
    public var actionMapId: String?

    public init(sessionId: String?, sessionIdType: String?, actionId: String?, actionMapId: String?) {
        self.sessionId = sessionId
        self.sessionIdType = sessionIdType
        self.actionId = actionId
        self.actionMapId = actionMapId
    }


}




public class DataTableRowEntityListing: Codable {





















    public var entities: [[String:JSON]]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [[String:JSON]]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DateRange: Codable {





    /** The inclusive start of a date range in yyyy-MM-dd format. Should be interpreted in the management unit's configured time zone. */
    public var startDate: String?
    /** The inclusive end of a date range in yyyy-MM-dd format. Should be interpreted in the management unit's configured time zone. */
    public var endDate: String?

    public init(startDate: String?, endDate: String?) {
        self.startDate = startDate
        self.endDate = endDate
    }


}




public class DeploymentPing: Codable {





    /** Collection of actions to be offered or displayed to the visitor. */
    public var actions: [DeploymentWebAction]?
    /** Custom poll interval in milliseconds; when the return value is -1, disable pings. */
    public var pollIntervalMilliseconds: Int?

    public init(actions: [DeploymentWebAction]?, pollIntervalMilliseconds: Int?) {
        self.actions = actions
        self.pollIntervalMilliseconds = pollIntervalMilliseconds
    }


}




public class Detail: Codable {









    public var errorCode: String?
    public var fieldName: String?
    public var entityId: String?
    public var entityName: String?

    public init(errorCode: String?, fieldName: String?, entityId: String?, entityName: String?) {
        self.errorCode = errorCode
        self.fieldName = fieldName
        self.entityId = entityId
        self.entityName = entityName
    }


}



/** Development Activity object */

public class DevelopmentActivity: Codable {

















    public enum ArchivalMode: String, Codable { 
        case graceful = "Graceful"
        case immediate = "Immediate"
    }





    public enum ModelType: String, Codable { 
        case informational = "Informational"
        case coaching = "Coaching"
        case assessedContent = "AssessedContent"
        case assessment = "Assessment"
        case external = "External"
    }

    public enum Status: String, Codable { 
        case planned = "Planned"
        case inProgress = "InProgress"
        case completed = "Completed"
        case invalidSchedule = "InvalidSchedule"
        case notCompleted = "NotCompleted"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Date that activity was completed. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCompleted: Date?
    /** User that created activity */
    public var createdBy: UserReference?
    /** Date activity was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The user's percentage score for this activity */
    public var percentageScore: Float?
    /** True if the activity was passed */
    public var isPassed: Bool?
    /** True if this is the latest version of assignment assigned to the user */
    public var isLatest: Bool?
    /** True if the associated module is archived */
    public var isModuleArchived: Bool?
    /** Module archive type */
    public var archivalMode: ArchivalMode?
    /** The URI for this object */
    public var selfUri: String?
    /** The name of the activity */
    public var name: String?
    /** The type of activity */
    public var type: ModelType?
    /** The status of the activity */
    public var status: Status?
    /** Due date for completion of the activity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateDue: Date?
    /** Facilitator of the activity */
    public var facilitator: UserReference?
    /** List of users attending the activity */
    public var attendees: [UserReference]?
    /** Indicates if the activity is overdue */
    public var isOverdue: Bool?

    public init(_id: String?, dateCompleted: Date?, createdBy: UserReference?, dateCreated: Date?, percentageScore: Float?, isPassed: Bool?, isLatest: Bool?, isModuleArchived: Bool?, archivalMode: ArchivalMode?, selfUri: String?, name: String?, type: ModelType?, status: Status?, dateDue: Date?, facilitator: UserReference?, attendees: [UserReference]?, isOverdue: Bool?) {
        self._id = _id
        self.dateCompleted = dateCompleted
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.percentageScore = percentageScore
        self.isPassed = isPassed
        self.isLatest = isLatest
        self.isModuleArchived = isModuleArchived
        self.archivalMode = archivalMode
        self.selfUri = selfUri
        self.name = name
        self.type = type
        self.status = status
        self.dateDue = dateDue
        self.facilitator = facilitator
        self.attendees = attendees
        self.isOverdue = isOverdue
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case dateCompleted
        case createdBy
        case dateCreated
        case percentageScore
        case isPassed
        case isLatest
        case isModuleArchived
        case archivalMode
        case selfUri
        case name
        case type
        case status
        case dateDue
        case facilitator
        case attendees
        case isOverdue
    }


}




public class DevelopmentActivityAggregateParam: Codable {



    public enum Metrics: String, Codable { 
        case nactivities = "nActivities"
        case nplannedactivities = "nPlannedActivities"
        case ninprogressactivities = "nInProgressActivities"
        case ncompleteactivities = "nCompleteActivities"
        case noverdueactivities = "nOverdueActivities"
        case ninvalidscheduleactivities = "nInvalidScheduleActivities"
        case npassedactivities = "nPassedActivities"
        case nfailedactivities = "nFailedActivities"
        case oactivityscore = "oActivityScore"
        case nnotcompletedactivities = "nNotCompletedActivities"
    }

    public enum GroupBy: String, Codable { 
        case attendeeid = "attendeeId"
    }



    /** Specifies the range of due dates to be used for filtering. Milliseconds will be truncated. A maximum of 1 year can be specified in the range. End date is not inclusive. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** The list of metrics to be returned. If omitted, all metrics are returned. */
    public var metrics: [Metrics]?
    /** Specifies if the aggregated data is combined into a single set of metrics (groupBy is empty or not specified), or contains an element per attendeeId (groupBy is \"attendeeId\") */
    public var groupBy: [GroupBy]?
    /** The filter applied to the data. This is ANDed with the interval parameter. */
    public var filter: DevelopmentActivityAggregateQueryRequestFilter?

    public init(interval: String?, metrics: [Metrics]?, groupBy: [GroupBy]?, filter: DevelopmentActivityAggregateQueryRequestFilter?) {
        self.interval = interval
        self.metrics = metrics
        self.groupBy = groupBy
        self.filter = filter
    }


}




public class DevelopmentActivityAggregateQueryRequestPredicate: Codable {

    public enum Dimension: String, Codable { 
        case attendeeid = "attendeeId"
        case type = "type"
        case moduleid = "moduleId"
        case ispassed = "isPassed"
    }



    /** Each predicates specifies a dimension. */
    public var dimension: Dimension?
    /** Corresponding value for dimensions in predicates. If the dimension is type, Valid Values: Informational, AssessedContent, Assessment, Coaching */
    public var value: String?

    public init(dimension: Dimension?, value: String?) {
        self.dimension = dimension
        self.value = value
    }


}




public class DevelopmentActivityAggregateResponse: Codable {



    /** The results of the query */
    public var results: [DevelopmentActivityAggregateQueryResponseGroupedData]?

    public init(results: [DevelopmentActivityAggregateQueryResponseGroupedData]?) {
        self.results = results
    }


}




public class DevelopmentActivityListing: Codable {





















    public var entities: [DevelopmentActivity]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DevelopmentActivity]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DialerAttemptLimitsConfigChangeAttemptLimits: Codable {







    public enum ResetPeriod: String, Codable { 
        case never = "NEVER"
        case today = "TODAY"
    }

















    public var maxAttemptsPerContact: Int?
    public var maxAttemptsPerNumber: Int?
    /** The timezone is necessary to define when \"today\" starts and ends */
    public var timeZoneId: String?
    /** After how long the number of attempts will be set back to 0 */
    public var resetPeriod: ResetPeriod?
    /** Configuration for recall attempts */
    public var recallEntries: [String:DialerAttemptLimitsConfigChangeRecallEntry]?
    /** Whether recalls are performed before considering other numbers (true) or after (false) */
    public var breadthFirstRecalls: Bool?
    public var additionalProperties: [String:JSON]?
    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The UI-visible name of the object */
    public var name: String?
    /** Creation time of the entity */
    public var dateCreated: Date?
    /** Last modified time of the entity */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?

    public init(maxAttemptsPerContact: Int?, maxAttemptsPerNumber: Int?, timeZoneId: String?, resetPeriod: ResetPeriod?, recallEntries: [String:DialerAttemptLimitsConfigChangeRecallEntry]?, breadthFirstRecalls: Bool?, additionalProperties: [String:JSON]?, _id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?) {
        self.maxAttemptsPerContact = maxAttemptsPerContact
        self.maxAttemptsPerNumber = maxAttemptsPerNumber
        self.timeZoneId = timeZoneId
        self.resetPeriod = resetPeriod
        self.recallEntries = recallEntries
        self.breadthFirstRecalls = breadthFirstRecalls
        self.additionalProperties = additionalProperties
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case maxAttemptsPerContact
        case maxAttemptsPerNumber
        case timeZoneId
        case resetPeriod
        case recallEntries
        case breadthFirstRecalls
        case additionalProperties
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
    }


}



/** A UriReference for a resource */

public class DialerCampaignProgressEventUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class DialerCampaignRuleConfigChangeCampaignRuleAction: Codable {





    public enum ActionType: String, Codable { 
        case turnoncampaign = "turnOnCampaign"
        case turnoffcampaign = "turnOffCampaign"
        case turnonsequence = "turnOnSequence"
        case turnoffsequence = "turnOffSequence"
        case setcampaignpriority = "setCampaignPriority"
        case recyclecampaign = "recycleCampaign"
    }





    /** The globally unique identifier for the action */
    public var _id: String?
    /** The parameters to match this action */
    public var parameters: [String:String]?
    /** The type of this action */
    public var actionType: ActionType?
    public var campaignRuleActionEntities: DialerCampaignRuleConfigChangeCampaignRuleActionEntities?
    public var additionalProperties: [String:JSON]?

    public init(_id: String?, parameters: [String:String]?, actionType: ActionType?, campaignRuleActionEntities: DialerCampaignRuleConfigChangeCampaignRuleActionEntities?, additionalProperties: [String:JSON]?) {
        self._id = _id
        self.parameters = parameters
        self.actionType = actionType
        self.campaignRuleActionEntities = campaignRuleActionEntities
        self.additionalProperties = additionalProperties
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case parameters
        case actionType
        case campaignRuleActionEntities
        case additionalProperties
    }


}




public class DialerRulesetConfigChangeContactColumnToDataActionFieldMapping: Codable {







    /** The name of a contact column whose data will be passed to the data action */
    public var contactColumnName: String?
    /** The name of an output field from the data action that the contact column data will be passed to */
    public var dataActionField: String?
    public var additionalProperties: [String:JSON]?

    public init(contactColumnName: String?, dataActionField: String?, additionalProperties: [String:JSON]?) {
        self.contactColumnName = contactColumnName
        self.dataActionField = dataActionField
        self.additionalProperties = additionalProperties
    }


}




public class DialerRulesetConfigChangeDataActionConditionPredicate: Codable {



    public enum OutputOperator: String, Codable { 
        case equals = "EQUALS"
        case lessThan = "LESS_THAN"
        case lessThanEquals = "LESS_THAN_EQUALS"
        case greaterThan = "GREATER_THAN"
        case greaterThanEquals = "GREATER_THAN_EQUALS"
        case contains = "CONTAINS"
        case beginsWith = "BEGINS_WITH"
        case endsWith = "ENDS_WITH"
        case before = "BEFORE"
        case after = "AFTER"
    }









    /** The name of an output field from the data action's output to use for this condition */
    public var outputField: String?
    /** The operation with which to evaluate this condition */
    public var outputOperator: OutputOperator?
    /** The value to compare against for this condition */
    public var comparisonValue: String?
    /** The result of this predicate if the requested output field is missing from the data action's result */
    public var outputFieldMissingResolution: Bool?
    /** If true, inverts the result of evaluating this Predicate. Default is false. */
    public var inverted: Bool?
    public var additionalProperties: [String:JSON]?

    public init(outputField: String?, outputOperator: OutputOperator?, comparisonValue: String?, outputFieldMissingResolution: Bool?, inverted: Bool?, additionalProperties: [String:JSON]?) {
        self.outputField = outputField
        self.outputOperator = outputOperator
        self.comparisonValue = comparisonValue
        self.outputFieldMissingResolution = outputFieldMissingResolution
        self.inverted = inverted
        self.additionalProperties = additionalProperties
    }


}




public class DialogflowCXEnvironment: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}




public class DigitalRule: Codable {







    public enum Category: String, Codable { 
        case preContact = "PreContact"
        case postContact = "PostContact"
    }





    /** The identifier of the rule. */
    public var _id: String?
    /** The name of the rule. */
    public var name: String?
    /** The ranked order of the rule. Rules are processed from lowest number to highest. */
    public var order: Int?
    /** The category of the rule. */
    public var category: Category?
    /** A list of conditions to evaluate. All of the Conditions must evaluate to true to trigger the actions. */
    public var conditions: [DigitalCondition]?
    /** The list of actions to be taken if all conditions are true. */
    public var actions: [DigitalAction]?

    public init(_id: String?, name: String?, order: Int?, category: Category?, conditions: [DigitalCondition]?, actions: [DigitalAction]?) {
        self._id = _id
        self.name = name
        self.order = order
        self.category = category
        self.conditions = conditions
        self.actions = actions
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case order
        case category
        case conditions
        case actions
    }


}




public class DigitalRuleSet: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** A ContactList to provide suggestions for contact columns on relevant conditions and actions. */
    public var contactList: DomainEntityRef?
    /** The list of rules. */
    public var rules: [DigitalRule]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, contactList: DomainEntityRef?, rules: [DigitalRule]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.contactList = contactList
        self.rules = rules
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case contactList
        case rules
        case selfUri
    }


}




public class DisallowedEntityLearningAssignmentReference: Codable {





    /** The error code associated with this disallowed entity */
    public var errorCode: String?
    /** The entity that was disallowed */
    public var entity: LearningAssignmentReference?

    public init(errorCode: String?, entity: LearningAssignmentReference?) {
        self.errorCode = errorCode
        self.entity = entity
    }


}




public class DisconnectReason: Codable {

    public enum ModelType: String, Codable { 
        case q850 = "q850"
        case sip = "sip"
    }





    /** Disconnect reason protocol type. */
    public var type: ModelType?
    /** Protocol specific reason code. See the Q.850 and SIP specs. */
    public var code: Int?
    /** Human readable English description of the disconnect reason. */
    public var phrase: String?

    public init(type: ModelType?, code: Int?, phrase: String?) {
        self.type = type
        self.code = code
        self.phrase = phrase
    }


}




public class DivsPermittedEntityListing: Codable {























    public var entities: [AuthzDivision]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var allDivsPermitted: Bool?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [AuthzDivision]?, pageSize: Int?, pageNumber: Int?, total: Int64?, allDivsPermitted: Bool?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.allDivsPermitted = allDivsPermitted
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DncListCreate: Codable {















    public enum DncSourceType: String, Codable { 
        case rds = "rds"
        case rdsCustom = "rds_custom"
        case dncCom = "dnc.com"
        case gryphon = "gryphon"
    }

    public enum ContactMethod: String, Codable { 
        case email = "Email"
        case phone = "Phone"
        case any = "Any"
    }















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the DncList. */
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** The status of the import process */
    public var importStatus: ImportStatus?
    /** The total number of phone numbers in the DncList. */
    public var size: Int64?
    /** The type of the DncList. */
    public var dncSourceType: DncSourceType?
    /** The contact method. Required if dncSourceType is rds. */
    public var contactMethod: ContactMethod?
    /** A dnc.com loginId. Required if the dncSourceType is dnc.com. */
    public var loginId: String?
    /** A dnc.com campaignId. Optional if the dncSourceType is dnc.com. */
    public var campaignId: String?
    /** The list of dnc.com codes to be treated as DNC. Required if the dncSourceType is dnc.com. */
    public var dncCodes: [String]?
    /** A gryphon license number. Required if the dncSourceType is gryphon. */
    public var licenseId: String?
    /** The division this DncList belongs to. */
    public var division: DomainEntityRef?
    /** The column to evaluate exclusion against. Required if the dncSourceType is rds_custom. */
    public var customExclusionColumn: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, importStatus: ImportStatus?, size: Int64?, dncSourceType: DncSourceType?, contactMethod: ContactMethod?, loginId: String?, campaignId: String?, dncCodes: [String]?, licenseId: String?, division: DomainEntityRef?, customExclusionColumn: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.importStatus = importStatus
        self.size = size
        self.dncSourceType = dncSourceType
        self.contactMethod = contactMethod
        self.loginId = loginId
        self.campaignId = campaignId
        self.dncCodes = dncCodes
        self.licenseId = licenseId
        self.division = division
        self.customExclusionColumn = customExclusionColumn
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case importStatus
        case size
        case dncSourceType
        case contactMethod
        case loginId
        case campaignId
        case dncCodes
        case licenseId
        case division
        case customExclusionColumn
        case selfUri
    }


}




public class DnsRecordEntry: Codable {





    public enum VerificationStatus: String, Codable { 
        case pending = "Pending"
        case verified = "Verified"
        case failed = "Failed"
        case unknown = "Unknown"
    }

    /** the hostname of the DNS entry */
    public var host: String?
    /** the payload of the DNS entry */
    public var recordContents: String?
    /** the current status of the related verification process */
    public var verificationStatus: VerificationStatus?

    public init(host: String?, recordContents: String?, verificationStatus: VerificationStatus?) {
        self.host = host
        self.recordContents = recordContents
        self.verificationStatus = verificationStatus
    }


}




public class DocumentBodyBlock: Codable {

    public enum ModelType: String, Codable { 
        case paragraph = "Paragraph"
        case image = "Image"
        case video = "Video"
        case orderedList = "OrderedList"
        case unorderedList = "UnorderedList"
        case table = "Table"
    }











    /** The type of the block for the body. This determines which body block object (paragraph, list, video, image or table) would have a value. */
    public var type: ModelType?
    /** Paragraph. It must contain a value if the type of the block is Paragraph. */
    public var paragraph: DocumentBodyParagraph?
    /** Image. It must contain a value if the type of the block is Image. */
    public var image: DocumentBodyImage?
    /** Video. It must contain a value if the type of the block is Video. */
    public var video: DocumentBodyVideo?
    /** List. It must contain a value if the type of the block is UnorderedList or OrderedList. */
    public var list: DocumentBodyList?
    /** Table. It must contain a value if type of the block is Table. */
    public var table: DocumentBodyTable?

    public init(type: ModelType?, paragraph: DocumentBodyParagraph?, image: DocumentBodyImage?, video: DocumentBodyVideo?, list: DocumentBodyList?, table: DocumentBodyTable?) {
        self.type = type
        self.paragraph = paragraph
        self.image = image
        self.video = video
        self.list = list
        self.table = table
    }


}




public class DocumentBodyTableRowBlock: Codable {





    /** The list of cells for the table. */
    public var cells: [DocumentBodyTableCellBlock]?
    /** The properties for the table rows. */
    public var properties: DocumentBodyTableRowBlockProperties?

    public init(cells: [DocumentBodyTableCellBlock]?, properties: DocumentBodyTableRowBlockProperties?) {
        self.cells = cells
        self.properties = properties
    }


}




public class DocumentListContentBlock: Codable {

    public enum ModelType: String, Codable { 
        case text = "Text"
        case image = "Image"
        case orderedList = "OrderedList"
        case unorderedList = "UnorderedList"
        case video = "Video"
    }









    /** The type of the list block. */
    public var type: ModelType?
    /** Text. It must contain a value if the type of the block is Text. */
    public var text: DocumentText?
    /** Image. It must contain a value if the type of the block is Image. */
    public var image: DocumentBodyImage?
    /** List. It must contain a value if the type of the block is UnorderedList or OrderedList. */
    public var list: DocumentBodyList?
    /** Video. It must contain a value if the type of the block is Video. */
    public var video: DocumentBodyVideo?

    public init(type: ModelType?, text: DocumentText?, image: DocumentBodyImage?, list: DocumentBodyList?, video: DocumentBodyVideo?) {
        self.type = type
        self.text = text
        self.image = image
        self.list = list
        self.video = video
    }


}




public class DocumentQuery: Codable {



    public enum Operator: String, Codable { 
        case or = "Or"
        case and = "And"
    }

    /** Documents filter clauses/criteria. Limit of 20 clauses. */
    public var clauses: [DocumentQueryClause]?
    /** Specifies how the filter clauses will be applied together. */
    public var _operator: Operator?

    public init(clauses: [DocumentQueryClause]?, _operator: Operator?) {
        self.clauses = clauses
        self._operator = _operator
    }

    public enum CodingKeys: String, CodingKey { 
        case clauses
        case _operator = "operator"
    }


}




public class DocumentQueryClause: Codable {

    public enum Operator: String, Codable { 
        case or = "Or"
        case and = "And"
    }



    /** Specifies how the predicates will be applied together. */
    public var _operator: Operator?
    /** To apply multiple conditions. Limit of 10 predicates across all clauses. */
    public var predicates: [DocumentQueryPredicate]?

    public init(_operator: Operator?, predicates: [DocumentQueryPredicate]?) {
        self._operator = _operator
        self.predicates = predicates
    }

    public enum CodingKeys: String, CodingKey { 
        case _operator = "operator"
        case predicates
    }


}




public class DocumentationSearchResponse: Codable {



















    /** The total number of results found */
    public var total: Int64?
    /** The total number of pages */
    public var pageCount: Int?
    /** The current page size */
    public var pageSize: Int?
    /** The current page number */
    public var pageNumber: Int?
    /** Q64 value for the previous page of results */
    public var previousPage: String?
    /** Q64 value for the current page of results */
    public var currentPage: String?
    /** Q64 value for the next page of results */
    public var nextPage: String?
    /** Resource types the search was performed against */
    public var types: [String]?
    /** Search results */
    public var results: [DocumentationResult]?

    public init(total: Int64?, pageCount: Int?, pageSize: Int?, pageNumber: Int?, previousPage: String?, currentPage: String?, nextPage: String?, types: [String]?, results: [DocumentationResult]?) {
        self.total = total
        self.pageCount = pageCount
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.previousPage = previousPage
        self.currentPage = currentPage
        self.nextPage = nextPage
        self.types = types
        self.results = results
    }


}




public class DomainEdgeSoftwareVersionDtoEntityListing: Codable {





















    public var entities: [DomainEdgeSoftwareVersionDto]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DomainEdgeSoftwareVersionDto]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DomainEntityListingQueryResult: Codable {





















    public var entities: [QueryResult]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [QueryResult]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DomainEntityListingSurveyForm: Codable {





















    public var entities: [SurveyForm]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [SurveyForm]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DomainPermission: Codable {













    public var domain: String?
    public var entityType: String?
    public var action: String?
    public var label: String?
    public var allowsConditions: Bool?
    public var divisionAware: Bool?

    public init(domain: String?, entityType: String?, action: String?, label: String?, allowsConditions: Bool?, divisionAware: Bool?) {
        self.domain = domain
        self.entityType = entityType
        self.action = action
        self.label = label
        self.allowsConditions = allowsConditions
        self.divisionAware = divisionAware
    }


}




public class DomainPhysicalCapabilities: Codable {





    public var vlan: Bool?
    public var team: Bool?

    public init(vlan: Bool?, team: Bool?) {
        self.vlan = vlan
        self.team = team
    }


}




public class DomainResourceConditionNode: Codable {



    public enum Operator: String, Codable { 
        case eq = "EQ"
        case _in = "IN"
        case ge = "GE"
        case gt = "GT"
        case le = "LE"
        case lt = "LT"
    }



    public enum Conjunction: String, Codable { 
        case and = "AND"
        case or = "OR"
    }



    public var variableName: String?
    public var _operator: Operator?
    public var operands: [DomainResourceConditionValue]?
    public var conjunction: Conjunction?
    public var terms: [DomainResourceConditionNode]?

    public init(variableName: String?, _operator: Operator?, operands: [DomainResourceConditionValue]?, conjunction: Conjunction?, terms: [DomainResourceConditionNode]?) {
        self.variableName = variableName
        self._operator = _operator
        self.operands = operands
        self.conjunction = conjunction
        self.terms = terms
    }

    public enum CodingKeys: String, CodingKey { 
        case variableName
        case _operator = "operator"
        case operands
        case conjunction
        case terms
    }


}




public class EdgeEntityListing: Codable {





















    public var entities: [Edge]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Edge]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class EdgeGroupEntityListing: Codable {





















    public var entities: [EdgeGroup]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [EdgeGroup]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class EdgeLogsJobFile: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }











    public enum UploadStatus: String, Codable { 
        case uploading = "UPLOADING"
        case notUploaded = "NOT_UPLOADED"
        case uploaded = "UPLOADED"
        case errorOnUpload = "ERROR_ON_UPLOAD"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var timeCreated: Date?
    /** The time this log file was last modified on the Edge. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var timeModified: Date?
    /** The size of this file in bytes. */
    public var sizeBytes: Double?
    /** The status of the upload of this file from the Edge to the cloud.  Use /upload to start an upload. */
    public var uploadStatus: UploadStatus?
    /** The path of this file on the Edge. */
    public var edgePath: String?
    /** The download ID to use with the downloads API. */
    public var downloadId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, timeCreated: Date?, timeModified: Date?, sizeBytes: Double?, uploadStatus: UploadStatus?, edgePath: String?, downloadId: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.timeCreated = timeCreated
        self.timeModified = timeModified
        self.sizeBytes = sizeBytes
        self.uploadStatus = uploadStatus
        self.edgePath = edgePath
        self.downloadId = downloadId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case timeCreated
        case timeModified
        case sizeBytes
        case uploadStatus
        case edgePath
        case downloadId
        case selfUri
    }


}




public class EdgeMetrics: Codable {

















    public var edge: DomainEntityRef?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventTime: Date?
    public var upTimeMsec: Int64?
    public var processors: [EdgeMetricsProcessor]?
    public var memory: [EdgeMetricsMemory]?
    public var disks: [EdgeMetricsDisk]?
    public var subsystems: [EdgeMetricsSubsystem]?
    public var networks: [EdgeMetricsNetwork]?

    public init(edge: DomainEntityRef?, eventTime: Date?, upTimeMsec: Int64?, processors: [EdgeMetricsProcessor]?, memory: [EdgeMetricsMemory]?, disks: [EdgeMetricsDisk]?, subsystems: [EdgeMetricsSubsystem]?, networks: [EdgeMetricsNetwork]?) {
        self.edge = edge
        self.eventTime = eventTime
        self.upTimeMsec = upTimeMsec
        self.processors = processors
        self.memory = memory
        self.disks = disks
        self.subsystems = subsystems
        self.networks = networks
    }


}




public class EdgeMetricsDisk: Codable {







    /** Available memory in bytes. */
    public var availableBytes: Double?
    /** Disk partition name. */
    public var partitionName: String?
    /** Total memory in bytes. */
    public var totalBytes: Double?

    public init(availableBytes: Double?, partitionName: String?, totalBytes: Double?) {
        self.availableBytes = availableBytes
        self.partitionName = partitionName
        self.totalBytes = totalBytes
    }


}




public class EdgeMetricsProcessor: Codable {











    /** Percent time processor was active. */
    public var activeTimePct: Double?
    /** Machine CPU identifier. 'total' will always be included in the array and is the total of all CPU resources. */
    public var cpuId: String?
    /** Percent time processor was idle. */
    public var idleTimePct: Double?
    /** Percent time processor spent in privileged mode. */
    public var privilegedTimePct: Double?
    /** Percent time processor spent in user mode. */
    public var userTimePct: Double?

    public init(activeTimePct: Double?, cpuId: String?, idleTimePct: Double?, privilegedTimePct: Double?, userTimePct: Double?) {
        self.activeTimePct = activeTimePct
        self.cpuId = cpuId
        self.idleTimePct = idleTimePct
        self.privilegedTimePct = privilegedTimePct
        self.userTimePct = userTimePct
    }


}




public class EdgeMetricsSubsystem: Codable {







    /** Delay in milliseconds. */
    public var delayMs: Int?
    /** Name of the Edge process. */
    public var processName: String?
    /** Subsystem for an Edge device. */
    public var mediaSubsystem: EdgeMetricsSubsystem?

    public init(delayMs: Int?, processName: String?, mediaSubsystem: EdgeMetricsSubsystem?) {
        self.delayMs = delayMs
        self.processName = processName
        self.mediaSubsystem = mediaSubsystem
    }


}




public class EdgeNetworkDiagnosticResponse: Codable {





    /** UUID of each executed command on edge */
    public var commandCorrelationId: String?
    /** Response string of executed command from edge */
    public var diagnostics: String?

    public init(commandCorrelationId: String?, diagnostics: String?) {
        self.commandCorrelationId = commandCorrelationId
        self.diagnostics = diagnostics
    }


}




public class EdgeSoftwareUpdateTopicDomainEdgeSoftwareUpdate: Codable {



    public enum Status: String, Codable { 
        case _none = "NONE"
        case _init = "INIT"
        case inProgress = "IN_PROGRESS"
        case expired = "EXPIRED"
        case exception = "EXCEPTION"
        case aborted = "ABORTED"
        case failed = "FAILED"
        case succeeded = "SUCCEEDED"
        case delete = "DELETE"
    }







    public var _id: String?
    public var status: Status?
    public var downloadStartTime: Date?
    public var executeStartTime: Date?
    public var executeStopTime: Date?

    public init(_id: String?, status: Status?, downloadStartTime: Date?, executeStartTime: Date?, executeStopTime: Date?) {
        self._id = _id
        self.status = status
        self.downloadStartTime = downloadStartTime
        self.executeStartTime = executeStartTime
        self.executeStopTime = executeStopTime
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case status
        case downloadStartTime
        case executeStartTime
        case executeStopTime
    }


}




public class EmailColumn: Codable {







    /** The name of the email column. */
    public var columnName: String?
    /** Indicates the type of the email column. For example, 'work' or 'personal'. */
    public var type: String?
    /** A column that indicates the timezone to use for a given contact when checking contactable times. */
    public var contactableTimeColumn: String?

    public init(columnName: String?, type: String?, contactableTimeColumn: String?) {
        self.columnName = columnName
        self.type = type
        self.contactableTimeColumn = contactableTimeColumn
    }


}




public class EmailConversationEntityListing: Codable {





















    public var entities: [EmailConversation]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [EmailConversation]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class EmailExternalEstablishedEvent: Codable {

















    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication. */
    public var communicationId: String?
    /** A name for the participant if it is available for this conversation. */
    public var displayName: String?
    /** Indicates that established communication has an initial email. If true, the initial messagesSent value will be initialized to 1. */
    public var includeMessage: Bool?
    /** Metadata about this communication. */
    public var initialConfiguration: EmailInitialConfiguration?
    /** Metadata about the source of this communication's interaction. */
    public var sourceConfiguration: SourceConfiguration?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, displayName: String?, includeMessage: Bool?, initialConfiguration: EmailInitialConfiguration?, sourceConfiguration: SourceConfiguration?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.displayName = displayName
        self.includeMessage = includeMessage
        self.initialConfiguration = initialConfiguration
        self.sourceConfiguration = sourceConfiguration
    }


}




public class EmailInitialConfiguration: Codable {























    /** An email address that this email is to. */
    public var to: String?
    /** An email address that this email is from. */
    public var from: String?
    /** An email addresses that this email is carbon copied to. */
    public var cc: [String]?
    /** An email addresses that this email is blind carbon copied to. */
    public var bcc: [String]?
    /** The subject for this email. */
    public var subject: String?
    /** UUID identifying the most recent previous email communication ID from the same participant on this email conversation. Will be null if this is a new participant. */
    public var previousEmailId: String?
    /** Indicates that this communication's initial state is held. */
    public var held: Bool?
    /** Indicates that this communication's initial state is alerting. If false, the communication started in a connected state. */
    public var alerting: Bool?
    /** Indicates the direction of this communication with respect to the contact center. `true` means the communication is INBOUND. `false` means the communication is OUTBOUND. */
    public var inbound: Bool?
    /** The id of the communication (the \"peer\") that \"invited\" this communication, if this occurred. */
    public var invitedBy: String?
    /** Additional metadata about this session which should be recorded by the platform but which will not be indexed or searchable. Primarily for diagnostic value. Any information that needs to be accessible through other components like Analytics should be moved to dedicated fields. */
    public var additionalInfo: [String:String]?

    public init(to: String?, from: String?, cc: [String]?, bcc: [String]?, subject: String?, previousEmailId: String?, held: Bool?, alerting: Bool?, inbound: Bool?, invitedBy: String?, additionalInfo: [String:String]?) {
        self.to = to
        self.from = from
        self.cc = cc
        self.bcc = bcc
        self.subject = subject
        self.previousEmailId = previousEmailId
        self.held = held
        self.alerting = alerting
        self.inbound = inbound
        self.invitedBy = invitedBy
        self.additionalInfo = additionalInfo
    }


}




public class EmailMessagePreview: Codable {

























    public enum State: String, Codable { 
        case created = "Created"
        case ready = "Ready"
        case edited = "Edited"
    }

    public enum DraftType: String, Codable { 
        case reply = "Reply"
        case replyAll = "ReplyAll"
        case forward = "Forward"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The recipients of the email message. */
    public var to: [EmailAddress]?
    /** The recipients that were copied on the email message. */
    public var cc: [EmailAddress]?
    /** The recipients that were blind copied on the email message. */
    public var bcc: [EmailAddress]?
    /** The sender of the email message. */
    public var from: EmailAddress?
    /** The receiver of the reply email message. */
    public var replyTo: EmailAddress?
    /** The subject of the email message. */
    public var subject: String?
    /** The attachments of the email message. */
    public var attachments: [Attachment]?
    /** A truncated version of the textBody */
    public var textBodyPreview: String?
    /** The time when the message was received or sent. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var time: Date?
    /** Indicates whether the history of previous emails of the conversation is included within the email bodies of this message. */
    public var historyIncluded: Bool?
    /** The state of the current draft. */
    public var state: State?
    /** The type of draft that need to be treated. */
    public var draftType: DraftType?
    /** Indicates an estimation of the size of the current email as a whole, in its final, ready to be sent form. */
    public var emailSizeBytes: Int?
    /** Indicates the maximum allowed size for an email to be send via SMTP server, based on the email domain configuration */
    public var maxEmailSizeBytes: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, to: [EmailAddress]?, cc: [EmailAddress]?, bcc: [EmailAddress]?, from: EmailAddress?, replyTo: EmailAddress?, subject: String?, attachments: [Attachment]?, textBodyPreview: String?, time: Date?, historyIncluded: Bool?, state: State?, draftType: DraftType?, emailSizeBytes: Int?, maxEmailSizeBytes: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.to = to
        self.cc = cc
        self.bcc = bcc
        self.from = from
        self.replyTo = replyTo
        self.subject = subject
        self.attachments = attachments
        self.textBodyPreview = textBodyPreview
        self.time = time
        self.historyIncluded = historyIncluded
        self.state = state
        self.draftType = draftType
        self.emailSizeBytes = emailSizeBytes
        self.maxEmailSizeBytes = maxEmailSizeBytes
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case to
        case cc
        case bcc
        case from
        case replyTo
        case subject
        case attachments
        case textBodyPreview
        case time
        case historyIncluded
        case state
        case draftType
        case emailSizeBytes
        case maxEmailSizeBytes
        case selfUri
    }


}




public class EmailMessagePreviewListing: Codable {





















    public var entities: [EmailMessagePreview]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [EmailMessagePreview]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class EmailOutboundDomainResult: Codable {







    public enum SenderStatus: String, Codable { 
        case requestReceived = "RequestReceived"
        case provisionRequestSentVendor = "ProvisionRequestSentVendor"
        case provisioned = "Provisioned"
        case error = "Error"
        case deprovisioned = "Deprovisioned"
    }

    public enum SenderType: String, Codable { 
        case unknown = "Unknown"
        case emailDomain = "EmailDomain"
        case mockEmailDomain = "MockEmailDomain"
    }

    public var dnsCnameBounceRecord: DnsRecordEntry?
    public var dnsTxtSendingRecord: DnsRecordEntry?
    public var domainName: String?
    public var senderStatus: SenderStatus?
    public var senderType: SenderType?

    public init(dnsCnameBounceRecord: DnsRecordEntry?, dnsTxtSendingRecord: DnsRecordEntry?, domainName: String?, senderStatus: SenderStatus?, senderType: SenderType?) {
        self.dnsCnameBounceRecord = dnsCnameBounceRecord
        self.dnsTxtSendingRecord = dnsTxtSendingRecord
        self.domainName = domainName
        self.senderStatus = senderStatus
        self.senderType = senderType
    }


}




public class EmailUserEstablishedEvent: Codable {



















    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication. */
    public var communicationId: String?
    /** A unique Id (V4 UUID) identifying this userId this communication belongs to. */
    public var userId: String?
    /** A unique Id (V4 UUID) identifying the queue that the user is emailing on behalf of. Applies to outbound emails only. */
    public var queueId: String?
    /** Indicates whether or not this user will be required to complete after call work. */
    public var afterCallWorkRequired: Bool?
    /** Metadata about this communication. */
    public var initialConfiguration: EmailInitialConfiguration?
    /** Metadata about the source of this communication's interaction. */
    public var sourceConfiguration: SourceConfiguration?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, userId: String?, queueId: String?, afterCallWorkRequired: Bool?, initialConfiguration: EmailInitialConfiguration?, sourceConfiguration: SourceConfiguration?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.userId = userId
        self.queueId = queueId
        self.afterCallWorkRequired = afterCallWorkRequired
        self.initialConfiguration = initialConfiguration
        self.sourceConfiguration = sourceConfiguration
    }


}



/** An emergency flow associates a call flow to use in an emergency with the ivr(s) to route to it. */

public class EmergencyCallFlow: Codable {





    /** The call flow to execute in an emergency. */
    public var emergencyFlow: DomainEntityRef?
    /** The IVR(s) to route to the call flow during an emergency. */
    public var ivrs: [DomainEntityRef]?

    public init(emergencyFlow: DomainEntityRef?, ivrs: [DomainEntityRef]?) {
        self.emergencyFlow = emergencyFlow
        self.ivrs = ivrs
    }


}



/** A group of call flows. */

public class EmergencyGroupDivisionView: Codable {









    /** The emergency group identifier */
    public var _id: String?
    /** The emergency group name */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case selfUri
    }


}




public class EndTransferEvent: Codable {









    public enum FinalState: String, Codable { 
        case completed = "Completed"
        case canceled = "Canceled"
        case failed = "Failed"
    }



    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** The id (V4 UUID) used to identify the transfer already started by the external platform. */
    public var commandId: String?
    /** Indicates whether the transfer completed successfully, was cancelled, or failed for some reason. */
    public var finalState: FinalState?
    /** The id (V4 UUID) of the communication that was being transferred. */
    public var objectCommunicationId: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, commandId: String?, finalState: FinalState?, objectCommunicationId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.commandId = commandId
        self.finalState = finalState
        self.objectCommunicationId = objectCommunicationId
    }


}




public class Entry: Codable {





    /** A value included in this facet. */
    public var value: String?
    /** The number of results with this value. */
    public var count: Int?

    public init(value: String?, count: Int?) {
        self.value = value
        self.count = count
    }


}




public class ErrorBody: Codable {























    public var message: String?
    public var code: String?
    public var status: Int?
    public var entityId: String?
    public var entityName: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var contextId: String?
    public var details: [Detail]?
    public var errors: [ErrorBody]?
    public var limit: Limit?

    public init(message: String?, code: String?, status: Int?, entityId: String?, entityName: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, details: [Detail]?, errors: [ErrorBody]?, limit: Limit?) {
        self.message = message
        self.code = code
        self.status = status
        self.entityId = entityId
        self.entityName = entityName
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.details = details
        self.errors = errors
        self.limit = limit
    }


}




public class EstimateAvailablePartialDayTimeOffRequest: Codable {





    /** Start date-time in ISO-8601 format for partial day request */
    public var date: Date?
    /** A requested length of time off request in minutes. If the value is null, then the system will use activity code length setting */
    public var requestedDurationMinutes: Int?

    public init(date: Date?, requestedDurationMinutes: Int?) {
        self.date = date
        self.requestedDurationMinutes = requestedDurationMinutes
    }


}




public class EvaluationAggregateDataContainer: Codable {





    /** A mapping from dimension to value */
    public var group: [String:String]?
    public var data: [StatisticalResponse]?

    public init(group: [String:String]?, data: [StatisticalResponse]?) {
        self.group = group
        self.data = data
    }


}




public class EvaluationAggregateQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [EvaluationAggregateQueryPredicate]?

    public init(type: ModelType?, predicates: [EvaluationAggregateQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class EvaluationAggregationQuery: Codable {







    public enum GroupBy: String, Codable { 
        case assigneeapplicable = "assigneeApplicable"
        case assigneeid = "assigneeId"
        case calibrationid = "calibrationId"
        case contextid = "contextId"
        case conversationid = "conversationId"
        case divisionid = "divisionId"
        case evaluationcontextid = "evaluationContextId"
        case evaluationid = "evaluationId"
        case evaluatorid = "evaluatorId"
        case formid = "formId"
        case queueid = "queueId"
        case released = "released"
        case rescored = "rescored"
        case teamid = "teamId"
        case userid = "userId"
    }



    public enum Metrics: String, Codable { 
        case nevaluations = "nEvaluations"
        case nevaluationsdeleted = "nEvaluationsDeleted"
        case nevaluationsrescored = "nEvaluationsRescored"
        case ototalcriticalscore = "oTotalCriticalScore"
        case ototalscore = "oTotalScore"
    }





    public enum AlternateTimeDimension: String, Codable { 
        case conversationstart = "conversationStart"
        case evaluationcreateddate = "evaluationCreatedDate"
        case evaluationreleasedate = "evaluationReleaseDate"
        case eventtime = "eventTime"
    }

    /** Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H */
    public var granularity: String?
    /** Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var timeZone: String?
    /** Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group. */
    public var groupBy: [GroupBy]?
    /** Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters */
    public var filter: EvaluationAggregateQueryFilter?
    /** Behaves like a SQL SELECT clause. Only named metrics will be retrieved. */
    public var metrics: [Metrics]?
    /** Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c') */
    public var flattenMultivaluedDimensions: Bool?
    /** Custom derived metric views */
    public var views: [EvaluationAggregationView]?
    /** Dimension to use as the alternative timestamp for data in the aggregate.  Choosing \"eventTime\" uses the actual time of the data event. */
    public var alternateTimeDimension: AlternateTimeDimension?

    public init(interval: String?, granularity: String?, timeZone: String?, groupBy: [GroupBy]?, filter: EvaluationAggregateQueryFilter?, metrics: [Metrics]?, flattenMultivaluedDimensions: Bool?, views: [EvaluationAggregationView]?, alternateTimeDimension: AlternateTimeDimension?) {
        self.interval = interval
        self.granularity = granularity
        self.timeZone = timeZone
        self.groupBy = groupBy
        self.filter = filter
        self.metrics = metrics
        self.flattenMultivaluedDimensions = flattenMultivaluedDimensions
        self.views = views
        self.alternateTimeDimension = alternateTimeDimension
    }


}




public class EvaluationCreateEvalForm: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class EvaluationDetailQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case assigneeapplicable = "assigneeApplicable"
        case assigneeid = "assigneeId"
        case calibrationid = "calibrationId"
        case contextid = "contextId"
        case deleted = "deleted"
        case evaluationid = "evaluationId"
        case evaluationstatus = "evaluationStatus"
        case evaluatorid = "evaluatorId"
        case eventtime = "eventTime"
        case formid = "formId"
        case formname = "formName"
        case queueid = "queueId"
        case released = "released"
        case rescored = "rescored"
        case userid = "userId"
    }

    public enum Metric: String, Codable { 
        case ototalcriticalscore = "oTotalCriticalScore"
        case ototalscore = "oTotalScore"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Left hand side for metric predicates */
    public var metric: Metric?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension or metric predicates */
    public var value: String?
    /** Right hand side for dimension or metric predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, metric: Metric?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self.metric = metric
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case metric
        case _operator = "operator"
        case value
        case range
    }


}




public class EvaluationEntityListing: Codable {





















    public var entities: [Evaluation]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Evaluation]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class EvaluationQualityV2TopicUser: Codable {





    public var _id: String?
    public var displayName: String?

    public init(_id: String?, displayName: String?) {
        self._id = _id
        self.displayName = displayName
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case displayName
    }


}




public class EvaluationResponse: Codable {















    public enum Status: String, Codable { 
        case pending = "PENDING"
        case inprogress = "INPROGRESS"
        case finished = "FINISHED"
        case inreview = "INREVIEW"
        case retracted = "RETRACTED"
    }

















    public enum MediaType: String, Codable { 
        case call = "CALL"
        case callback = "CALLBACK"
        case chat = "CHAT"
        case cobrowse = "COBROWSE"
        case email = "EMAIL"
        case message = "MESSAGE"
        case socialExpression = "SOCIAL_EXPRESSION"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
    }















    public enum ResourceType: String, Codable { 
        case email = "EMAIL"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var conversation: ConversationReference?
    /** Evaluation form used for evaluation. */
    public var evaluationForm: EvaluationFormResponse?
    public var evaluator: User?
    public var agent: User?
    public var calibration: Calibration?
    public var status: Status?
    public var answers: EvaluationScoringSet?
    public var agentHasRead: Bool?
    public var assignee: User?
    /** Indicates whether an assignee is applicable for the evaluation. Set to false when assignee is not applicable. */
    public var assigneeApplicable: Bool?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var releaseDate: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var assignedDate: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var changedDate: Date?
    public var queue: Queue?
    /** List of different communication types used in conversation. */
    public var mediaType: [MediaType]?
    /** Is only true when evaluation is re-scored. */
    public var rescore: Bool?
    /** Date of conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var conversationDate: Date?
    /** End date of conversation if it had completed before evaluation creation. Null if created before the conversation ended. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var conversationEndDate: Date?
    /** Signifies if the evaluation is never to be released. This cannot be set true if release date is also set. */
    public var neverRelease: Bool?
    /** Set to false to unassign the evaluation. This cannot be set to false when assignee is also set. */
    public var assigned: Bool?
    /** Date when the assignee was last changed. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateAssigneeChanged: Date?
    /** Only used for email evaluations. Will be null for all other evaluations. */
    public var resourceId: String?
    /** The type of resource. Only used for email evaluations. Will be null for evaluations on all other resources. */
    public var resourceType: ResourceType?
    /** Is only true when the user making the request does not have sufficient permissions to see evaluation */
    public var redacted: Bool?
    public var isScoringIndex: Bool?
    /** List of user authorized actions on evaluation. Possible values: assign, edit, editScore, editAgentSignoff, delete, release, viewAudit */
    public var authorizedActions: [String]?
    /** Is true when evaluation assistance didn't execute successfully */
    public var hasAssistanceFailed: Bool?
    /** The source that created the evaluation. */
    public var evaluationSource: EvaluationSource?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, conversation: ConversationReference?, evaluationForm: EvaluationFormResponse?, evaluator: User?, agent: User?, calibration: Calibration?, status: Status?, answers: EvaluationScoringSet?, agentHasRead: Bool?, assignee: User?, assigneeApplicable: Bool?, releaseDate: Date?, assignedDate: Date?, changedDate: Date?, queue: Queue?, mediaType: [MediaType]?, rescore: Bool?, conversationDate: Date?, conversationEndDate: Date?, neverRelease: Bool?, assigned: Bool?, dateAssigneeChanged: Date?, resourceId: String?, resourceType: ResourceType?, redacted: Bool?, isScoringIndex: Bool?, authorizedActions: [String]?, hasAssistanceFailed: Bool?, evaluationSource: EvaluationSource?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.conversation = conversation
        self.evaluationForm = evaluationForm
        self.evaluator = evaluator
        self.agent = agent
        self.calibration = calibration
        self.status = status
        self.answers = answers
        self.agentHasRead = agentHasRead
        self.assignee = assignee
        self.assigneeApplicable = assigneeApplicable
        self.releaseDate = releaseDate
        self.assignedDate = assignedDate
        self.changedDate = changedDate
        self.queue = queue
        self.mediaType = mediaType
        self.rescore = rescore
        self.conversationDate = conversationDate
        self.conversationEndDate = conversationEndDate
        self.neverRelease = neverRelease
        self.assigned = assigned
        self.dateAssigneeChanged = dateAssigneeChanged
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.redacted = redacted
        self.isScoringIndex = isScoringIndex
        self.authorizedActions = authorizedActions
        self.hasAssistanceFailed = hasAssistanceFailed
        self.evaluationSource = evaluationSource
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case conversation
        case evaluationForm
        case evaluator
        case agent
        case calibration
        case status
        case answers
        case agentHasRead
        case assignee
        case assigneeApplicable
        case releaseDate
        case assignedDate
        case changedDate
        case queue
        case mediaType
        case rescore
        case conversationDate
        case conversationEndDate
        case neverRelease
        case assigned
        case dateAssigneeChanged
        case resourceId
        case resourceType
        case redacted
        case isScoringIndex
        case authorizedActions
        case hasAssistanceFailed
        case evaluationSource
        case selfUri
    }


}




public class EvaluationVersion: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}




public class ExecuteRecordingJobsQuery: Codable {

    public enum State: String, Codable { 
        case processing = "PROCESSING"
    }

    /** The desired state for the job to be set to. */
    public var state: State?

    public init(state: State?) {
        self.state = state
    }


}



/** Details about a Web Deployment */

public class ExpandableWebDeployment: Codable {























    public enum Status: String, Codable { 
        case pending = "Pending"
        case active = "Active"
        case inactive = "Inactive"
        case error = "Error"
        case deleting = "Deleting"
    }





    /** The deployment ID */
    public var _id: String?
    /** The deployment name */
    public var name: String?
    /** The description of the config */
    public var _description: String?
    /** Property indicates whether all domains are allowed or not. allowedDomains must be empty when this is set as true. */
    public var allowAllDomains: Bool?
    /** The list of domains that are approved to use this deployment; the list will be added to CORS headers for ease of web use. */
    public var allowedDomains: [String]?
    /** The supported content profile for a deployment */
    public var supportedContent: SupportedContentReference?
    /** Javascript snippet used to load the config */
    public var snippet: String?
    /** The date the deployment was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date the deployment was most recently modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** A reference to the user who most recently modified the deployment */
    public var lastModifiedUser: AddressableEntityRef?
    /** A reference to the inboundshortmessage flow used by this deployment */
    public var flow: DomainEntityRef?
    /** The current status of the deployment */
    public var status: Status?
    /** The config version this deployment uses */
    public var configuration: WebDeploymentConfigurationVersionResponse?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, allowAllDomains: Bool?, allowedDomains: [String]?, supportedContent: SupportedContentReference?, snippet: String?, dateCreated: Date?, dateModified: Date?, lastModifiedUser: AddressableEntityRef?, flow: DomainEntityRef?, status: Status?, configuration: WebDeploymentConfigurationVersionResponse?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.allowAllDomains = allowAllDomains
        self.allowedDomains = allowedDomains
        self.supportedContent = supportedContent
        self.snippet = snippet
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.lastModifiedUser = lastModifiedUser
        self.flow = flow
        self.status = status
        self.configuration = configuration
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case allowAllDomains
        case allowedDomains
        case supportedContent
        case snippet
        case dateCreated
        case dateModified
        case lastModifiedUser
        case flow
        case status
        case configuration
        case selfUri
    }


}




public class ExtensionPoolDivisionView: Codable {









    /** The extension pool identifier */
    public var _id: String?
    /** The start number of the extension pool. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case selfUri
    }


}




public class ExternalContactsContactChangedTopicLineId: Codable {





    public var ids: [ExternalContactsContactChangedTopicLineUserId]?
    public var displayName: String?

    public init(ids: [ExternalContactsContactChangedTopicLineUserId]?, displayName: String?) {
        self.ids = ids
        self.displayName = displayName
    }


}




public class ExternalContactsContactChangedTopicLineUserId: Codable {



    public var userId: String?

    public init(userId: String?) {
        self.userId = userId
    }


}




public class ExternalContactsUnresolvedContactChangedTopicDivision: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class ExternalContactsUnresolvedContactChangedTopicFacebookId: Codable {





    public var ids: [ExternalContactsUnresolvedContactChangedTopicFacebookScopedId]?
    public var displayName: String?

    public init(ids: [ExternalContactsUnresolvedContactChangedTopicFacebookScopedId]?, displayName: String?) {
        self.ids = ids
        self.displayName = displayName
    }


}




public class ExternalContactsUnresolvedContactChangedTopicInstagramId: Codable {





    public var ids: [ExternalContactsUnresolvedContactChangedTopicInstagramScopedId]?
    public var displayName: String?

    public init(ids: [ExternalContactsUnresolvedContactChangedTopicInstagramScopedId]?, displayName: String?) {
        self.ids = ids
        self.displayName = displayName
    }


}




public class ExternalMetricDataProcessedItem: Codable {













    public enum ModelType: String, Codable { 
        case total = "Total"
        case cumulative = "Cumulative"
    }





    /** The user ID. Must provide either userId or userEmail, but not both. */
    public var userId: String?
    /** The user main email used in user's GenesysCloud account. Must provide either userId or userEmail, but not both. */
    public var userEmail: String?
    /** The ID of the external metric definition */
    public var metricId: String?
    /** The date of the metric data. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateOccurred: Date?
    /** The value of the metric data. When value is null, the metric data will be deleted. */
    public var value: Double?
    /** The number of data points. The default value is 0 when type is Cumulative and the metric data already exists, otherwise 1. When total count reaches 0, the metric data will be deleted. */
    public var count: Int?
    /** The type of the metric data. The default value is Total. */
    public var type: ModelType?
    /** The total value of the metric data. */
    public var totalValue: Double?
    /** The total number of data points. */
    public var totalCount: Int?

    public init(userId: String?, userEmail: String?, metricId: String?, dateOccurred: Date?, value: Double?, count: Int?, type: ModelType?, totalValue: Double?, totalCount: Int?) {
        self.userId = userId
        self.userEmail = userEmail
        self.metricId = metricId
        self.dateOccurred = dateOccurred
        self.value = value
        self.count = count
        self.type = type
        self.totalValue = totalValue
        self.totalCount = totalCount
    }


}



/** External metric data write response */

public class ExternalMetricDataWriteResponse: Codable {





    /** The list of processed entities */
    public var processedEntities: [ExternalMetricDataProcessedItem]?
    /** The list of unprocessed entities */
    public var unprocessedEntities: [ExternalMetricDataUnprocessedItem]?

    public init(processedEntities: [ExternalMetricDataProcessedItem]?, unprocessedEntities: [ExternalMetricDataUnprocessedItem]?) {
        self.processedEntities = processedEntities
        self.unprocessedEntities = unprocessedEntities
    }


}




public class ExternalMetricDefinition: Codable {





    public enum Unit: String, Codable { 
        case seconds = "Seconds"
        case percent = "Percent"
        case number = "Number"
        case currency = "Currency"
    }





    public enum DefaultObjectiveType: String, Codable { 
        case higherIsBetter = "HigherIsBetter"
        case lowerIsBetter = "LowerIsBetter"
        case targetArea = "TargetArea"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the External Metric Definition */
    public var name: String?
    /** The unit of the External Metric Definition */
    public var unit: Unit?
    /** The unit definition of the External Metric Definition */
    public var unitDefinition: String?
    /** The decimal precision of the External Metric Definition */
    public var precision: Int?
    /** The default objective type of the External Metric Definition */
    public var defaultObjectiveType: DefaultObjectiveType?
    /** The retention in months of the External Metric Definition */
    public var retentionMonths: Int?
    /** True if the External Metric Definition is enabled */
    public var enabled: Bool?
    /** True if the External Metric Definition is in use */
    public var inUse: Bool?
    /** The last date and time that the metric data was refreshed. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateLastRefreshed: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, unit: Unit?, unitDefinition: String?, precision: Int?, defaultObjectiveType: DefaultObjectiveType?, retentionMonths: Int?, enabled: Bool?, inUse: Bool?, dateLastRefreshed: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.unit = unit
        self.unitDefinition = unitDefinition
        self.precision = precision
        self.defaultObjectiveType = defaultObjectiveType
        self.retentionMonths = retentionMonths
        self.enabled = enabled
        self.inUse = inUse
        self.dateLastRefreshed = dateLastRefreshed
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case unit
        case unitDefinition
        case precision
        case defaultObjectiveType
        case retentionMonths
        case enabled
        case inUse
        case dateLastRefreshed
        case selfUri
    }


}




public class ExternalMetricDefinitionListing: Codable {





















    public var entities: [ExternalMetricDefinition]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ExternalMetricDefinition]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class FacebookIntegration: Codable {































    public enum CreateStatus: String, Codable { 
        case initiated = "Initiated"
        case completed = "Completed"
        case error = "Error"
    }





    /** A unique Integration Id. */
    public var _id: String?
    /** The name of the Facebook Integration */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    public var messagingSetting: MessagingSettingReference?
    /** The App Id from Facebook messenger */
    public var appId: String?
    /** The Page Id from Facebook messenger */
    public var pageId: String?
    /** The name of the Facebook page */
    public var pageName: String?
    /** The url of the profile image of the Facebook page */
    public var pageProfileImageUrl: String?
    /** The status of the Facebook Integration */
    public var status: String?
    /** The recipient reference associated to the Facebook Integration. This recipient is used to associate a flow to an integration */
    public var recipient: DomainEntityRef?
    /** Date this Integration was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date this Integration was modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** User reference that created this Integration */
    public var createdBy: DomainEntityRef?
    /** User reference that last modified this Integration */
    public var modifiedBy: DomainEntityRef?
    /** Version number required for updates. */
    public var version: Int?
    /** Status of asynchronous create operation */
    public var createStatus: CreateStatus?
    /** Error information returned, if createStatus is set to Error */
    public var createError: ErrorBody?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingReference?, appId: String?, pageId: String?, pageName: String?, pageProfileImageUrl: String?, status: String?, recipient: DomainEntityRef?, dateCreated: Date?, dateModified: Date?, createdBy: DomainEntityRef?, modifiedBy: DomainEntityRef?, version: Int?, createStatus: CreateStatus?, createError: ErrorBody?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.appId = appId
        self.pageId = pageId
        self.pageName = pageName
        self.pageProfileImageUrl = pageProfileImageUrl
        self.status = status
        self.recipient = recipient
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.version = version
        self.createStatus = createStatus
        self.createError = createError
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case appId
        case pageId
        case pageName
        case pageProfileImageUrl
        case status
        case recipient
        case dateCreated
        case dateModified
        case createdBy
        case modifiedBy
        case version
        case createStatus
        case createError
        case selfUri
    }


}




public class FacebookIntegrationRequest: Codable {





















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the Facebook Integration */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    /** Defines the message settings to be applied for this integration */
    public var messagingSetting: MessagingSettingRequestReference?
    /** The long-lived Page Access Token of Facebook page.  See https://developers.facebook.com/docs/facebook-login/access-tokens.  When a pageAccessToken is provided, pageId and userAccessToken are not required. */
    public var pageAccessToken: String?
    /** The short-lived User Access Token of the Facebook user logged into the Facebook app.  See https://developers.facebook.com/docs/facebook-login/access-tokens.  When userAccessToken is provided, pageId is mandatory.  When userAccessToken/pageId combination is provided, pageAccessToken is not required. */
    public var userAccessToken: String?
    /** The page Id of Facebook page. The pageId is required when userAccessToken is provided. */
    public var pageId: String?
    /** The app Id of Facebook app. The appId is required when a customer wants to use their own approved Facebook app. */
    public var appId: String?
    /** The app Secret of Facebook app. The appSecret is required when appId is provided. */
    public var appSecret: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingRequestReference?, pageAccessToken: String?, userAccessToken: String?, pageId: String?, appId: String?, appSecret: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.pageAccessToken = pageAccessToken
        self.userAccessToken = userAccessToken
        self.pageId = pageId
        self.appId = appId
        self.appSecret = appSecret
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case pageAccessToken
        case userAccessToken
        case pageId
        case appId
        case appSecret
        case selfUri
    }


}




public class FacetStatistics: Codable {















    public var count: Int64?
    public var min: Double?
    public var max: Double?
    public var mean: Double?
    public var stdDeviation: Double?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateMin: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateMax: Date?

    public init(count: Int64?, min: Double?, max: Double?, mean: Double?, stdDeviation: Double?, dateMin: Date?, dateMax: Date?) {
        self.count = count
        self.min = min
        self.max = max
        self.mean = mean
        self.stdDeviation = stdDeviation
        self.dateMin = dateMin
        self.dateMax = dateMax
    }


}




public class FailedObject: Codable {









    public var _id: String?
    public var version: String?
    public var name: String?
    public var errorCode: String?

    public init(_id: String?, version: String?, name: String?, errorCode: String?) {
        self._id = _id
        self.version = version
        self.name = name
        self.errorCode = errorCode
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
        case name
        case errorCode
    }


}




public class FaxDocumentEntityListing: Codable {





















    public var entities: [FaxDocument]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [FaxDocument]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class FlowAggregateDataContainer: Codable {





    /** A mapping from dimension to value */
    public var group: [String:String]?
    public var data: [StatisticalResponse]?

    public init(group: [String:String]?, data: [StatisticalResponse]?) {
        self.group = group
        self.data = data
    }


}




public class FlowAggregateQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [FlowAggregateQueryPredicate]?

    public init(type: ModelType?, predicates: [FlowAggregateQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class FlowAggregationQuery: Codable {







    public enum GroupBy: String, Codable { 
        case activerouting = "activeRouting"
        case activeskillid = "activeSkillId"
        case addressfrom = "addressFrom"
        case addressto = "addressTo"
        case agentassistantid = "agentAssistantId"
        case agentbullseyering = "agentBullseyeRing"
        case agentowned = "agentOwned"
        case agentrank = "agentRank"
        case agentscore = "agentScore"
        case ani = "ani"
        case assignerid = "assignerId"
        case authenticated = "authenticated"
        case conversationid = "conversationId"
        case conversationinitiator = "conversationInitiator"
        case convertedfrom = "convertedFrom"
        case convertedto = "convertedTo"
        case customerparticipation = "customerParticipation"
        case deliverystatus = "deliveryStatus"
        case destinationaddress = "destinationAddress"
        case direction = "direction"
        case disconnecttype = "disconnectType"
        case divisionid = "divisionId"
        case dnis = "dnis"
        case edgeid = "edgeId"
        case eligibleagentcount = "eligibleAgentCount"
        case endinglanguage = "endingLanguage"
        case entryreason = "entryReason"
        case entrytype = "entryType"
        case errorcode = "errorCode"
        case exitreason = "exitReason"
        case extendeddeliverystatus = "extendedDeliveryStatus"
        case externalcontactid = "externalContactId"
        case externalmediacount = "externalMediaCount"
        case externalorganizationid = "externalOrganizationId"
        case externaltag = "externalTag"
        case firstqueue = "firstQueue"
        case flaggedreason = "flaggedReason"
        case flowid = "flowId"
        case flowintype = "flowInType"
        case flowmilestoneid = "flowMilestoneId"
        case flowname = "flowName"
        case flowouttype = "flowOutType"
        case flowoutcome = "flowOutcome"
        case flowoutcomeid = "flowOutcomeId"
        case flowoutcomevalue = "flowOutcomeValue"
        case flowtype = "flowType"
        case flowversion = "flowVersion"
        case groupid = "groupId"
        case interactiontype = "interactionType"
        case journeyactionid = "journeyActionId"
        case journeyactionmapid = "journeyActionMapId"
        case journeyactionmapversion = "journeyActionMapVersion"
        case journeycustomerid = "journeyCustomerId"
        case journeycustomeridtype = "journeyCustomerIdType"
        case journeycustomersessionid = "journeyCustomerSessionId"
        case journeycustomersessionidtype = "journeyCustomerSessionIdType"
        case knowledgebaseid = "knowledgeBaseId"
        case mediacount = "mediaCount"
        case mediatype = "mediaType"
        case messagetype = "messageType"
        case originatingdirection = "originatingDirection"
        case outboundcampaignid = "outboundCampaignId"
        case outboundcontactid = "outboundContactId"
        case outboundcontactlistid = "outboundContactListId"
        case participantname = "participantName"
        case peerid = "peerId"
        case proposedagentid = "proposedAgentId"
        case provider = "provider"
        case purpose = "purpose"
        case queueid = "queueId"
        case recognitionfailurereason = "recognitionFailureReason"
        case remote = "remote"
        case removedskillid = "removedSkillId"
        case requestedlanguageid = "requestedLanguageId"
        case requestedrouting = "requestedRouting"
        case requestedroutingskillid = "requestedRoutingSkillId"
        case roomid = "roomId"
        case routingpriority = "routingPriority"
        case routingring = "routingRing"
        case routingrule = "routingRule"
        case routingruletype = "routingRuleType"
        case scoredagentid = "scoredAgentId"
        case selectedagentid = "selectedAgentId"
        case selectedagentrank = "selectedAgentRank"
        case selfserved = "selfServed"
        case sessiondnis = "sessionDnis"
        case sessionid = "sessionId"
        case startinglanguage = "startingLanguage"
        case stationid = "stationId"
        case teamid = "teamId"
        case transfertargetaddress = "transferTargetAddress"
        case transfertargetname = "transferTargetName"
        case transfertype = "transferType"
        case usedrouting = "usedRouting"
        case userid = "userId"
        case waitinginteractioncount = "waitingInteractionCount"
        case wrapupcode = "wrapUpCode"
    }



    public enum Metrics: String, Codable { 
        case nflow = "nFlow"
        case nflowmilestone = "nFlowMilestone"
        case nflowoutcome = "nFlowOutcome"
        case nflowoutcomefailed = "nFlowOutcomeFailed"
        case oflowmilestone = "oFlowMilestone"
        case tflow = "tFlow"
        case tflowdisconnect = "tFlowDisconnect"
        case tflowexit = "tFlowExit"
        case tflowoutcome = "tFlowOutcome"
    }





    public enum AlternateTimeDimension: String, Codable { 
        case eventtime = "eventTime"
    }

    /** Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H */
    public var granularity: String?
    /** Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var timeZone: String?
    /** Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group. */
    public var groupBy: [GroupBy]?
    /** Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters */
    public var filter: FlowAggregateQueryFilter?
    /** Behaves like a SQL SELECT clause. Only named metrics will be retrieved. */
    public var metrics: [Metrics]?
    /** Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c') */
    public var flattenMultivaluedDimensions: Bool?
    /** Custom derived metric views */
    public var views: [FlowAggregationView]?
    /** Dimension to use as the alternative timestamp for data in the aggregate.  Choosing \"eventTime\" uses the actual time of the data event. */
    public var alternateTimeDimension: AlternateTimeDimension?

    public init(interval: String?, granularity: String?, timeZone: String?, groupBy: [GroupBy]?, filter: FlowAggregateQueryFilter?, metrics: [Metrics]?, flattenMultivaluedDimensions: Bool?, views: [FlowAggregationView]?, alternateTimeDimension: AlternateTimeDimension?) {
        self.interval = interval
        self.granularity = granularity
        self.timeZone = timeZone
        self.groupBy = groupBy
        self.filter = filter
        self.metrics = metrics
        self.flattenMultivaluedDimensions = flattenMultivaluedDimensions
        self.views = views
        self.alternateTimeDimension = alternateTimeDimension
    }


}




public class FlowEntityListing: Codable {





















    public var entities: [Flow]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Flow]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class FlowExecutionAggregateQueryResponse: Codable {



    public var results: [FlowExecutionAggregateDataContainer]?

    public init(results: [FlowExecutionAggregateDataContainer]?) {
        self.results = results
    }


}




public class FlowExecutionAggregationView: Codable {

    public enum Target: String, Codable { 
        case nflowexecutions = "nFlowExecutions"
    }



    public enum Function: String, Codable { 
        case rangebound = "rangeBound"
    }



    /** Target metric name */
    public var target: Target?
    /** A unique name for this view. Must be distinct from other views and built-in metric names. */
    public var name: String?
    /** Type of view you wish to create */
    public var function: Function?
    /** Range of numbers for slicing up data */
    public var range: AggregationRange?

    public init(target: Target?, name: String?, function: Function?, range: AggregationRange?) {
        self.target = target
        self.name = name
        self.function = function
        self.range = range
    }


}




public class FlowHealthIntentVersionInfo: Codable {







    /** NLU Version Info for this flow version. */
    public var nluVersion: AddressableEntityRef?
    /** Given flow's Version Info. */
    public var flowVersion: AddressableEntityRef?
    /** NLU Domain Info for this flow version. */
    public var nluDomain: AddressableEntityRef?

    public init(nluVersion: AddressableEntityRef?, flowVersion: AddressableEntityRef?, nluDomain: AddressableEntityRef?) {
        self.nluVersion = nluVersion
        self.flowVersion = flowVersion
        self.nluDomain = nluDomain
    }


}




public class FlowHealthUtterance: Codable {







    public enum Language: String, Codable { 
        case enUs = "en-us"
        case enGb = "en-gb"
        case enAu = "en-au"
        case enZa = "en-za"
        case enNz = "en-nz"
        case enIe = "en-ie"
        case frCa = "fr-ca"
        case frFr = "fr-fr"
        case esUs = "es-us"
        case esEs = "es-es"
        case esMx = "es-mx"
        case deDe = "de-de"
        case itIt = "it-it"
        case ptBr = "pt-br"
        case ptPt = "pt-pt"
        case nlNl = "nl-nl"
    }

    public enum StaticValidationResults: String, Codable { 
        case tooFewUtterances = "TooFewUtterances"
        case tooManyUtterances = "TooManyUtterances"
        case utteranceTooShort = "UtteranceTooShort"
        case utteranceTooLong = "UtteranceTooLong"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Utterance Text. */
    public var text: String?
    /** Number of issues found for this utterance. */
    public var issueCount: Int64?
    /** Language provided for this utterance's health. */
    public var language: Language?
    /** Validation results for the utterance. */
    public var staticValidationResults: [StaticValidationResults]?
    /** Details about this utterance being an outlier or not. */
    public var outlierInfo: OutlierInfo?
    /** Confusion details with other utterances. */
    public var confusionInfo: ConfusionDetails?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, text: String?, issueCount: Int64?, language: Language?, staticValidationResults: [StaticValidationResults]?, outlierInfo: OutlierInfo?, confusionInfo: ConfusionDetails?, selfUri: String?) {
        self._id = _id
        self.text = text
        self.issueCount = issueCount
        self.language = language
        self.staticValidationResults = staticValidationResults
        self.outlierInfo = outlierInfo
        self.confusionInfo = confusionInfo
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case text
        case issueCount
        case language
        case staticValidationResults
        case outlierInfo
        case confusionInfo
        case selfUri
    }


}




public class FlowMilestoneDivisionView: Codable {









    /** The flow milestone identifier */
    public var _id: String?
    /** The flow milestone name */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case selfUri
    }


}




public class FlowObservationQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [FlowObservationQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [FlowObservationQueryPredicate]?

    public init(type: ModelType?, clauses: [FlowObservationQueryClause]?, predicates: [FlowObservationQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class FlowOutcome: Codable {













    /** The flow outcome identifier */
    public var _id: String?
    /** The flow outcome name. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    public var _description: String?
    public var currentOperation: Operation?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, _description: String?, currentOperation: Operation?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.currentOperation = currentOperation
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case currentOperation
        case selfUri
    }


}




public class FlowOutcomeDivisionViewEntityListing: Codable {





















    public var entities: [FlowOutcomeDivisionView]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [FlowOutcomeDivisionView]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class FlowOutcomeListing: Codable {





















    public var entities: [FlowOutcome]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [FlowOutcome]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class FlowVersion: Codable {









    public enum ModelType: String, Codable { 
        case publish = "PUBLISH"
        case checkin = "CHECKIN"
        case save = "SAVE"
    }

































    public enum CompatibleFlowTypes: String, Codable { 
        case bot = "BOT"
        case commonmodule = "COMMONMODULE"
        case digitalbot = "DIGITALBOT"
        case inboundcall = "INBOUNDCALL"
        case inboundchat = "INBOUNDCHAT"
        case inboundemail = "INBOUNDEMAIL"
        case inboundshortmessage = "INBOUNDSHORTMESSAGE"
        case inqueuecall = "INQUEUECALL"
        case inqueueemail = "INQUEUEEMAIL"
        case inqueueshortmessage = "INQUEUESHORTMESSAGE"
        case outboundcall = "OUTBOUNDCALL"
        case securecall = "SECURECALL"
        case speech = "SPEECH"
        case surveyinvite = "SURVEYINVITE"
        case voice = "VOICE"
        case voicemail = "VOICEMAIL"
        case voicesurvey = "VOICESURVEY"
        case workflow = "WORKFLOW"
        case workitem = "WORKITEM"
    }



    /** The flow version identifier */
    public var _id: String?
    public var name: String?
    public var commitVersion: String?
    public var configurationVersion: String?
    public var type: ModelType?
    public var secure: Bool?
    public var debug: Bool?
    public var createdBy: User?
    public var createdByClient: DomainEntityRef?
    public var configurationUri: String?
    public var dateCreated: Int64?
    public var dateCheckedIn: Int64?
    public var dateSaved: Int64?
    public var generationId: String?
    public var publishResultUri: String?
    public var inputSchema: JsonSchemaDocument?
    public var outputSchema: JsonSchemaDocument?
    /** The date this version became the published version of the flow. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var datePublished: Date?
    /** The date this version was no longer the published version of the flow. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var datePublishedEnd: Date?
    /** Information about the natural language understanding configuration for the flow version */
    public var nluInfo: NluInfo?
    /** List of supported languages for this version of the flow */
    public var supportedLanguages: [SupportedLanguage]?
    /** Compatible flow types designate which flow types are allowed to embed a flow’s configuration within their own flow configuration.  Currently the only flows that can be embedded are Common Module flows and the embedding flow can invoke them using the Call Common Module action. */
    public var compatibleFlowTypes: [CompatibleFlowTypes]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, commitVersion: String?, configurationVersion: String?, type: ModelType?, secure: Bool?, debug: Bool?, createdBy: User?, createdByClient: DomainEntityRef?, configurationUri: String?, dateCreated: Int64?, dateCheckedIn: Int64?, dateSaved: Int64?, generationId: String?, publishResultUri: String?, inputSchema: JsonSchemaDocument?, outputSchema: JsonSchemaDocument?, datePublished: Date?, datePublishedEnd: Date?, nluInfo: NluInfo?, supportedLanguages: [SupportedLanguage]?, compatibleFlowTypes: [CompatibleFlowTypes]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.commitVersion = commitVersion
        self.configurationVersion = configurationVersion
        self.type = type
        self.secure = secure
        self.debug = debug
        self.createdBy = createdBy
        self.createdByClient = createdByClient
        self.configurationUri = configurationUri
        self.dateCreated = dateCreated
        self.dateCheckedIn = dateCheckedIn
        self.dateSaved = dateSaved
        self.generationId = generationId
        self.publishResultUri = publishResultUri
        self.inputSchema = inputSchema
        self.outputSchema = outputSchema
        self.datePublished = datePublished
        self.datePublishedEnd = datePublishedEnd
        self.nluInfo = nluInfo
        self.supportedLanguages = supportedLanguages
        self.compatibleFlowTypes = compatibleFlowTypes
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case commitVersion
        case configurationVersion
        case type
        case secure
        case debug
        case createdBy
        case createdByClient
        case configurationUri
        case dateCreated
        case dateCheckedIn
        case dateSaved
        case generationId
        case publishResultUri
        case inputSchema
        case outputSchema
        case datePublished
        case datePublishedEnd
        case nluInfo
        case supportedLanguages
        case compatibleFlowTypes
        case selfUri
    }


}




public class ForecastServiceLevelResponse: Codable {





    /** The percent of calls to answer in the number of seconds defined */
    public var percent: Int?
    /** The number of seconds to define for the percent of calls to be answered */
    public var seconds: Int?

    public init(percent: Int?, seconds: Int?) {
        self.percent = percent
        self.seconds = seconds
    }


}




public class GamificationScorecardChangeTopicMetric: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class GeneralTopicsEntityListing: Codable {



    public var entities: [GeneralTopic]?

    public init(entities: [GeneralTopic]?) {
        self.entities = entities
    }


}




public class Geolocation: Codable {























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** A string used to describe the type of client the geolocation is being updated from e.g. ios, android, web, etc. */
    public var type: String?
    /** A boolean used to tell whether or not to set this geolocation client as the primary on a PATCH */
    public var primary: Bool?
    public var latitude: Double?
    public var longitude: Double?
    public var country: String?
    public var region: String?
    public var city: String?
    public var locations: [LocationDefinition]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, type: String?, primary: Bool?, latitude: Double?, longitude: Double?, country: String?, region: String?, city: String?, locations: [LocationDefinition]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.type = type
        self.primary = primary
        self.latitude = latitude
        self.longitude = longitude
        self.country = country
        self.region = region
        self.city = city
        self.locations = locations
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case type
        case primary
        case latitude
        case longitude
        case country
        case region
        case city
        case locations
        case selfUri
    }


}




public class GetMetricDefinitionsResponse: Codable {







    public var total: Int64?
    public var entities: [MetricDefinition]?
    public var selfUri: String?

    public init(total: Int64?, entities: [MetricDefinition]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class GetRulesQuery: Codable {

    public enum RuleType: String, Codable { 
        case conversation = "Conversation"
        case presence = "Presence"
        case all = "All"
    }

    public enum QueryType: String, Codable { 
        case info = "Info"
        case count = "Count"
    }

    public enum EnabledType: String, Codable { 
        case enabled = "Enabled"
        case disabled = "Disabled"
        case all = "All"
    }





    public enum SortBy: String, Codable { 
        case name = "Name"
        case dateCreated = "DateCreated"
    }

    public enum SortOrder: String, Codable { 
        case asc = "Asc"
        case desc = "Desc"
    }



    public enum NameSearchType: String, Codable { 
        case exact = "Exact"
        case contains = "Contains"
        case unknown = "Unknown"
    }

    /** The rule type of the alerts the query will return */
    public var ruleType: RuleType?
    /** The type of query being performed. */
    public var queryType: QueryType?
    /** The state of the rule the query will return.  The accepted choices are Enabled, Disabled, or All */
    public var enabledType: EnabledType?
    /** The page number of the queried response */
    public var pageNumber: Int?
    /** The number of entities to return of the queried response.  The max is 25 */
    public var pageSize: Int?
    /** The field to sort responses by.  The accepted choices are Name and DateStart */
    public var sortBy: SortBy?
    /** The order in which response will be sorted.  The accepted choices are Asc and Desc */
    public var sortOrder: SortOrder?
    /** The name of the rule being queries. */
    public var ruleName: String?
    /** Specifies how strict the name search needs to be. Expected values are Exact and Contains if querying by name. */
    public var nameSearchType: NameSearchType?

    public init(ruleType: RuleType?, queryType: QueryType?, enabledType: EnabledType?, pageNumber: Int?, pageSize: Int?, sortBy: SortBy?, sortOrder: SortOrder?, ruleName: String?, nameSearchType: NameSearchType?) {
        self.ruleType = ruleType
        self.queryType = queryType
        self.enabledType = enabledType
        self.pageNumber = pageNumber
        self.pageSize = pageSize
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.ruleName = ruleName
        self.nameSearchType = nameSearchType
    }


}




public class Group: Codable {











    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }



    public enum ModelType: String, Codable { 
        case official = "official"
        case social = "social"
    }







    public enum Visibility: String, Codable { 
        case _public = "public"
        case owners = "owners"
        case members = "members"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The group name. */
    public var name: String?
    public var _description: String?
    /** Last modified date/time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Number of members. */
    public var memberCount: Int64?
    /** Active, inactive, or deleted state. */
    public var state: State?
    /** Current version for this resource. */
    public var version: Int?
    /** Type of group. */
    public var type: ModelType?
    public var images: [UserImage]?
    public var addresses: [GroupContact]?
    /** Are membership rules visible to the person requesting to view the group */
    public var rulesVisible: Bool?
    /** Who can view this group */
    public var visibility: Visibility?
    /** Allow roles to be assigned to this group */
    public var rolesEnabled: Bool?
    /** Owners of the group */
    public var owners: [User]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, dateModified: Date?, memberCount: Int64?, state: State?, version: Int?, type: ModelType?, images: [UserImage]?, addresses: [GroupContact]?, rulesVisible: Bool?, visibility: Visibility?, rolesEnabled: Bool?, owners: [User]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.dateModified = dateModified
        self.memberCount = memberCount
        self.state = state
        self.version = version
        self.type = type
        self.images = images
        self.addresses = addresses
        self.rulesVisible = rulesVisible
        self.visibility = visibility
        self.rolesEnabled = rolesEnabled
        self.owners = owners
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case dateModified
        case memberCount
        case state
        case version
        case type
        case images
        case addresses
        case rulesVisible
        case visibility
        case rolesEnabled
        case owners
        case selfUri
    }


}




public class GroupsSearchResponse: Codable {



















    /** The total number of results found */
    public var total: Int64?
    /** The total number of pages */
    public var pageCount: Int?
    /** The current page size */
    public var pageSize: Int?
    /** The current page number */
    public var pageNumber: Int?
    /** Q64 value for the previous page of results */
    public var previousPage: String?
    /** Q64 value for the current page of results */
    public var currentPage: String?
    /** Q64 value for the next page of results */
    public var nextPage: String?
    /** Resource types the search was performed against */
    public var types: [String]?
    /** Search results */
    public var results: [Group]?

    public init(total: Int64?, pageCount: Int?, pageSize: Int?, pageNumber: Int?, previousPage: String?, currentPage: String?, nextPage: String?, types: [String]?, results: [Group]?) {
        self.total = total
        self.pageCount = pageCount
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.previousPage = previousPage
        self.currentPage = currentPage
        self.nextPage = nextPage
        self.types = types
        self.results = results
    }


}




public class HeadcountInterval: Codable {





    /** The start date-time for this headcount interval in ISO-8601 format, must be within the 8 day schedule */
    public var interval: Date?
    /** Headcount value for this interval */
    public var value: Double?

    public init(interval: Date?, value: Double?) {
        self.interval = interval
        self.value = value
    }


}




public class HistoricalAdherenceDayMetrics: Codable {























    /** Start of day offset in seconds relative to query start time */
    public var dayStartOffsetSecs: Int?
    /** Duration of schedule in seconds included for adherence percentage calculation */
    public var adherenceScheduleSecs: Int?
    /** Total scheduled duration in seconds for OnQueue activities */
    public var conformanceScheduleSecs: Int?
    /** Total actually worked duration in seconds for OnQueue activities */
    public var conformanceActualSecs: Int?
    /** Total number of adherence exceptions for this user */
    public var exceptionCount: Int?
    /** Total duration in seconds of adherence exceptions for this user */
    public var exceptionDurationSecs: Int?
    /** The impact duration in seconds of current adherence state for this user */
    public var impactSeconds: Int?
    /** Total duration in seconds for all scheduled activities */
    public var scheduleLengthSecs: Int?
    /** Total duration in seconds for all actually worked activities */
    public var actualLengthSecs: Int?
    /** Total adherence percentage for this user, in the scale of 0 - 100 */
    public var adherencePercentage: Double?
    /** Total conformance percentage for this user, in the scale of 0 - 100. Conformance percentage can be greater than 100 when the actual on queue time is greater than the scheduled on queue time for the same period. */
    public var conformancePercentage: Double?

    public init(dayStartOffsetSecs: Int?, adherenceScheduleSecs: Int?, conformanceScheduleSecs: Int?, conformanceActualSecs: Int?, exceptionCount: Int?, exceptionDurationSecs: Int?, impactSeconds: Int?, scheduleLengthSecs: Int?, actualLengthSecs: Int?, adherencePercentage: Double?, conformancePercentage: Double?) {
        self.dayStartOffsetSecs = dayStartOffsetSecs
        self.adherenceScheduleSecs = adherenceScheduleSecs
        self.conformanceScheduleSecs = conformanceScheduleSecs
        self.conformanceActualSecs = conformanceActualSecs
        self.exceptionCount = exceptionCount
        self.exceptionDurationSecs = exceptionDurationSecs
        self.impactSeconds = impactSeconds
        self.scheduleLengthSecs = scheduleLengthSecs
        self.actualLengthSecs = actualLengthSecs
        self.adherencePercentage = adherencePercentage
        self.conformancePercentage = conformancePercentage
    }


}




public class HistoricalAdherenceQueryResult: Codable {













    public enum Impact: String, Codable { 
        case positive = "Positive"
        case negative = "Negative"
        case neutral = "Neutral"
        case unknown = "Unknown"
    }









    /** The ID of the user for whom the adherence is queried */
    public var userId: String?
    /** The ID of the management unit of the user for whom the adherence is queried */
    public var managementUnitId: String?
    /** Beginning of the date range that was queried, in ISO-8601 format */
    public var startDate: Date?
    /** End of the date range that was queried, in ISO-8601 format. If it was not set, end date will be set to the queried time */
    public var endDate: Date?
    /** Adherence percentage for this user, in the scale of 0 - 100 */
    public var adherencePercentage: Double?
    /** Conformance percentage for this user, in the scale of 0 - 100. Conformance percentage can be greater than 100 when the actual on queue time is greater than the scheduled on queue time for the same period. */
    public var conformancePercentage: Double?
    /** The impact of the current adherence state for this user */
    public var impact: Impact?
    /** List of adherence exceptions for this user */
    public var exceptionInfo: [HistoricalAdherenceExceptionInfo]?
    /** Adherence and conformance metrics for days in query range */
    public var dayMetrics: [HistoricalAdherenceDayMetrics]?
    /** The end date of the actual activities in ISO-8601 format. */
    public var actualsEndDate: Date?
    /** List of actual activity with offset for this user */
    public var actuals: [HistoricalAdherenceActuals]?

    public init(userId: String?, managementUnitId: String?, startDate: Date?, endDate: Date?, adherencePercentage: Double?, conformancePercentage: Double?, impact: Impact?, exceptionInfo: [HistoricalAdherenceExceptionInfo]?, dayMetrics: [HistoricalAdherenceDayMetrics]?, actualsEndDate: Date?, actuals: [HistoricalAdherenceActuals]?) {
        self.userId = userId
        self.managementUnitId = managementUnitId
        self.startDate = startDate
        self.endDate = endDate
        self.adherencePercentage = adherencePercentage
        self.conformancePercentage = conformancePercentage
        self.impact = impact
        self.exceptionInfo = exceptionInfo
        self.dayMetrics = dayMetrics
        self.actualsEndDate = actualsEndDate
        self.actuals = actuals
    }


}




public class HistoricalShrinkageResult: Codable {















    /** Beginning of the date range that was queried, in ISO-8601 format */
    public var startDate: Date?
    /** End of the date range that was queried, in ISO-8601 format. If it was not set, end date will be set to the queried time */
    public var endDate: Date?
    /** Total duration in seconds for which agents in the management unit are scheduled */
    public var totalScheduledDurationSeconds: Int?
    /** Total duration in seconds for which agents in the management unit are actually logged-in */
    public var totalLoggedInDurationSeconds: Int?
    /** Aggregated shrinkage data for all the activity categories */
    public var aggregatedShrinkage: HistoricalShrinkageAggregateResponse?
    /** Shrinkage for activity categories */
    public var shrinkageForActivityCategories: [HistoricalShrinkageActivityCategoryResponse]?
    /** List of all business units of all the agents in response */
    public var businessUnitIds: [String]?

    public init(startDate: Date?, endDate: Date?, totalScheduledDurationSeconds: Int?, totalLoggedInDurationSeconds: Int?, aggregatedShrinkage: HistoricalShrinkageAggregateResponse?, shrinkageForActivityCategories: [HistoricalShrinkageActivityCategoryResponse]?, businessUnitIds: [String]?) {
        self.startDate = startDate
        self.endDate = endDate
        self.totalScheduledDurationSeconds = totalScheduledDurationSeconds
        self.totalLoggedInDurationSeconds = totalLoggedInDurationSeconds
        self.aggregatedShrinkage = aggregatedShrinkage
        self.shrinkageForActivityCategories = shrinkageForActivityCategories
        self.businessUnitIds = businessUnitIds
    }


}




public class HistoricalShrinkageResultListing: Codable {



    public var entities: [HistoricalShrinkageResult]?

    public init(entities: [HistoricalShrinkageResult]?) {
        self.entities = entities
    }


}




public class HrisTimeOffTypesJobReference: Codable {



    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case error = "Error"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The status of the job */
    public var status: Status?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, status: Status?, selfUri: String?) {
        self._id = _id
        self.status = status
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case status
        case selfUri
    }


}




public class IdentityNow: Codable {























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var disabled: Bool?
    public var issuerURI: String?
    public var ssoTargetURI: String?
    public var sloURI: String?
    public var sloBinding: String?
    public var relyingPartyIdentifier: String?
    public var certificate: String?
    public var certificates: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, disabled: Bool?, issuerURI: String?, ssoTargetURI: String?, sloURI: String?, sloBinding: String?, relyingPartyIdentifier: String?, certificate: String?, certificates: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.disabled = disabled
        self.issuerURI = issuerURI
        self.ssoTargetURI = ssoTargetURI
        self.sloURI = sloURI
        self.sloBinding = sloBinding
        self.relyingPartyIdentifier = relyingPartyIdentifier
        self.certificate = certificate
        self.certificates = certificates
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case disabled
        case issuerURI
        case ssoTargetURI
        case sloURI
        case sloBinding
        case relyingPartyIdentifier
        case certificate
        case certificates
        case selfUri
    }


}




public class IdentityProvider: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var disabled: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, disabled: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.disabled = disabled
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case disabled
        case selfUri
    }


}



/** Details about an idle event trigger */

public class IdleEventTrigger: Codable {





    /** Name of event triggered after period of inactivity. */
    public var eventName: String?
    /** Number of seconds of inactivity before an event is triggered. */
    public var idleAfterSeconds: Int64?

    public init(eventName: String?, idleAfterSeconds: Int64?) {
        self.eventName = eventName
        self.idleAfterSeconds = idleAfterSeconds
    }


}




public class ImportForecastResponse: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }





    /** The status of the operation */
    public var status: Status?
    /** The ID for the operation */
    public var operationId: String?
    /** The result of the operation. Always null, result will come via notification */
    public var result: BuShortTermForecast?

    public init(status: Status?, operationId: String?, result: BuShortTermForecast?) {
        self.status = status
        self.operationId = operationId
        self.result = result
    }


}




public class ImportScriptStatusResponse: Codable {







    public var url: String?
    public var succeeded: Bool?
    public var message: String?

    public init(url: String?, succeeded: Bool?, message: String?) {
        self.url = url
        self.succeeded = succeeded
        self.message = message
    }


}




public class ImportTemplateEntityListing: Codable {





















    public var entities: [ImportTemplate]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ImportTemplate]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class InboundDomainPatchRequest: Codable {





    /** The DNS settings if the inbound domain is using a custom Mail From. These settings can only be used on InboundDomains where subDomain is false. */
    public var mailFromSettings: MailFromResult?
    /** The custom SMTP server integration to use when sending outbound emails from this domain. */
    public var customSMTPServer: DomainEntityRef?

    public init(mailFromSettings: MailFromResult?, customSMTPServer: DomainEntityRef?) {
        self.mailFromSettings = mailFromSettings
        self.customSMTPServer = customSMTPServer
    }


}




public class InsightsAgentItem: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** This user's manager. */
    public var manager: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, manager: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.manager = manager
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case manager
        case selfUri
    }


}




public class InsightsDetailsOverallItem: Codable {







    /** Insights data in the comparative period */
    public var comparativePeriod: InsightsDetailsOverallPeriodPoints?
    /** Insights data in the primary period */
    public var primaryPeriod: InsightsDetailsOverallPeriodPoints?
    /** Percent of goal change */
    public var percentOfGoalChange: Double?

    public init(comparativePeriod: InsightsDetailsOverallPeriodPoints?, primaryPeriod: InsightsDetailsOverallPeriodPoints?, percentOfGoalChange: Double?) {
        self.comparativePeriod = comparativePeriod
        self.primaryPeriod = primaryPeriod
        self.percentOfGoalChange = percentOfGoalChange
    }


}




public class InsightsSummaryOverallItem: Codable {







    /** Insights data in the comparative period */
    public var comparativePeriod: InsightsSummaryOverallPeriodPoints?
    /** Insights data in the primary period */
    public var primaryPeriod: InsightsSummaryOverallPeriodPoints?
    /** Percent of goal change */
    public var percentOfGoalChange: Double?

    public init(comparativePeriod: InsightsSummaryOverallPeriodPoints?, primaryPeriod: InsightsSummaryOverallPeriodPoints?, percentOfGoalChange: Double?) {
        self.comparativePeriod = comparativePeriod
        self.primaryPeriod = primaryPeriod
        self.percentOfGoalChange = percentOfGoalChange
    }


}




public class InsightsSummaryUserItem: Codable {









    /** Queried user */
    public var user: UserReference?
    /** The list of insights data for each metric of the user */
    public var metricData: [InsightsSummaryMetricItem]?
    /** Overall insights data of the user */
    public var overallData: InsightsSummaryOverallItem?
    /** Ranking of the user */
    public var ranking: Int?

    public init(user: UserReference?, metricData: [InsightsSummaryMetricItem]?, overallData: InsightsSummaryOverallItem?, ranking: Int?) {
        self.user = user
        self.metricData = metricData
        self.overallData = overallData
        self.ranking = ranking
    }


}




public class InsightsTrend: Codable {





    public enum Granularity: String, Codable { 
        case daily = "Daily"
        case weekly = "Weekly"
        case monthly = "Monthly"
    }









    /** The performance profile */
    public var performanceProfile: AddressableEntityRef?
    /** The division */
    public var division: DivisionReference?
    /** Granularity */
    public var granularity: Granularity?
    /** The comparative period work day date range */
    public var comparativePeriod: WorkdayPeriod?
    /** The primary period work day date range */
    public var primaryPeriod: WorkdayPeriod?
    /** The list of insights trend for each metric */
    public var entities: [InsightsTrendMetricItem]?
    /** The insights trend in total */
    public var total: InsightsTrendTotalItem?

    public init(performanceProfile: AddressableEntityRef?, division: DivisionReference?, granularity: Granularity?, comparativePeriod: WorkdayPeriod?, primaryPeriod: WorkdayPeriod?, entities: [InsightsTrendMetricItem]?, total: InsightsTrendTotalItem?) {
        self.performanceProfile = performanceProfile
        self.division = division
        self.granularity = granularity
        self.comparativePeriod = comparativePeriod
        self.primaryPeriod = primaryPeriod
        self.entities = entities
        self.total = total
    }


}




public class InsightsTrendTotalItem: Codable {



    /** Trends for the metric */
    public var trends: InsightsTrends?

    public init(trends: InsightsTrends?) {
        self.trends = trends
    }


}




public class InsightsTrends: Codable {





    /** List of trend data in the comparative period */
    public var comparativePeriod: [TrendData]?
    /** List of trend data in the primary period */
    public var primaryPeriod: [TrendData]?

    public init(comparativePeriod: [TrendData]?, primaryPeriod: [TrendData]?) {
        self.comparativePeriod = comparativePeriod
        self.primaryPeriod = primaryPeriod
    }


}




public class InstagramIntegration: Codable {



































    public enum CreateStatus: String, Codable { 
        case initiated = "Initiated"
        case completed = "Completed"
        case error = "Error"
    }





    /** A unique Integration ID. */
    public var _id: String?
    /** The name of the Instagram Integration */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    public var messagingSetting: MessagingSettingReference?
    /** The App ID from Facebook */
    public var appId: String?
    /** The Page ID from Instagram messenger */
    public var pageId: String?
    /** The ID from Instagram messenger */
    public var instagramId: String?
    /** The Username from Instagram messenger */
    public var instagramUsername: String?
    /** The name from Instagram messenger */
    public var instagramName: String?
    /** The url of the profile image from Instagram messenger */
    public var instagramProfileImageUrl: String?
    /** The status of the Instagram Integration */
    public var status: String?
    /** The recipient reference associated to the Instagram Integration. This recipient is used to associate a flow to an integration */
    public var recipient: DomainEntityRef?
    /** Date this Integration was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date this Integration was modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** User reference that created this Integration */
    public var createdBy: DomainEntityRef?
    /** User reference that last modified this Integration */
    public var modifiedBy: DomainEntityRef?
    /** Version number required for updates. */
    public var version: Int?
    /** Status of asynchronous create operation */
    public var createStatus: CreateStatus?
    /** Error information returned, if createStatus is set to Error */
    public var createError: ErrorBody?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingReference?, appId: String?, pageId: String?, instagramId: String?, instagramUsername: String?, instagramName: String?, instagramProfileImageUrl: String?, status: String?, recipient: DomainEntityRef?, dateCreated: Date?, dateModified: Date?, createdBy: DomainEntityRef?, modifiedBy: DomainEntityRef?, version: Int?, createStatus: CreateStatus?, createError: ErrorBody?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.appId = appId
        self.pageId = pageId
        self.instagramId = instagramId
        self.instagramUsername = instagramUsername
        self.instagramName = instagramName
        self.instagramProfileImageUrl = instagramProfileImageUrl
        self.status = status
        self.recipient = recipient
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.version = version
        self.createStatus = createStatus
        self.createError = createError
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case appId
        case pageId
        case instagramId
        case instagramUsername
        case instagramName
        case instagramProfileImageUrl
        case status
        case recipient
        case dateCreated
        case dateModified
        case createdBy
        case modifiedBy
        case version
        case createStatus
        case createError
        case selfUri
    }


}




public class InstagramIntegrationRequest: Codable {





















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the Instagram Integration */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    /** Defines the message settings to be applied for this integration */
    public var messagingSetting: MessagingSettingRequestReference?
    /** The long-lived Page Access Token of Instagram page.  See https://developers.facebook.com/docs/facebook-login/access-tokens.  When a pageAccessToken is provided, pageId and userAccessToken are not required. */
    public var pageAccessToken: String?
    /** The short-lived User Access Token of Instagram user logged into Facebook app.  See https://developers.facebook.com/docs/facebook-login/access-tokens.  When userAccessToken is provided, pageId is mandatory.  When userAccessToken/pageId combination is provided, pageAccessToken is not required. */
    public var userAccessToken: String?
    /** The page ID of Instagram page. The pageId is required when userAccessToken is provided. */
    public var pageId: String?
    /** The app ID of Facebook app. The appId is required when a customer wants to use their own approved Facebook app. */
    public var appId: String?
    /** The app Secret of Facebook app. The appSecret is required when appId is provided. */
    public var appSecret: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingRequestReference?, pageAccessToken: String?, userAccessToken: String?, pageId: String?, appId: String?, appSecret: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.pageAccessToken = pageAccessToken
        self.userAccessToken = userAccessToken
        self.pageId = pageId
        self.appId = appId
        self.appSecret = appSecret
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case pageAccessToken
        case userAccessToken
        case pageId
        case appId
        case appSecret
        case selfUri
    }


}



/** Configuration information for the integration */

public class IntegrationConfigurationInfo: Codable {



    /** The current, active configuration for the integration. */
    public var current: IntegrationConfiguration?

    public init(current: IntegrationConfiguration?) {
        self.current = current
    }


}




public class IntradayPerformancePredictionData: Codable {







    /** Percentage of interactions that meets service level target as defined in the matching service goal templates */
    public var serviceLevelPercent: Double?
    /** Predicted average time in seconds it takes to answer an interaction once the interaction becomes available to be routed */
    public var averageSpeedOfAnswerSeconds: Double?
    /** Percentage of on-queue time for all agents in this group that are occupied handling interactions */
    public var occupancyPercent: Double?

    public init(serviceLevelPercent: Double?, averageSpeedOfAnswerSeconds: Double?, occupancyPercent: Double?) {
        self.serviceLevelPercent = serviceLevelPercent
        self.averageSpeedOfAnswerSeconds = averageSpeedOfAnswerSeconds
        self.occupancyPercent = occupancyPercent
    }


}




public class InvalidAssignment: Codable {





    /** Invalid user for validation */
    public var user: UserReference?
    /** The reason for the invalid input for validation */
    public var message: String?

    public init(user: UserReference?, message: String?) {
        self.user = user
        self.message = message
    }


}




public class ItemValidationLimits: Codable {





    /** A structure denoting the system-imposed minimum string length (for text-based core types) or numeric values (for number-based) core types.  For example, the validationLimits for a text-based core type specify the min/max values for a minimum string length (minLength) constraint supplied by a schemaauthor on a text field.  Similarly, the maxLength's min/max specifies maximum string length constraint supplied by a schema author for the same field. */
    public var minLength: MinLength?
    /** A structure denoting the system-imposed minimum and maximum string length (for text-based core types) or numeric values (for number-based) core types.  For example, the validationLimits for a text-based core type specify the min/max values for a minimum string length (minLength) constraint supplied by a schemaauthor on a text field.  Similarly, the maxLength's min/max specifies maximum string length constraint supplied by a schema author for the same field. */
    public var maxLength: MaxLength?

    public init(minLength: MinLength?, maxLength: MaxLength?) {
        self.minLength = minLength
        self.maxLength = maxLength
    }


}




public class JourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int?

    public init(_id: String?, version: Int?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}




public class JourneyAggregateDataContainer: Codable {





    /** A mapping from dimension to value */
    public var group: [String:String]?
    public var data: [StatisticalResponse]?

    public init(group: [String:String]?, data: [StatisticalResponse]?) {
        self.group = group
        self.data = data
    }


}




public class JourneyAggregateQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [JourneyAggregateQueryPredicate]?

    public init(type: ModelType?, predicates: [JourneyAggregateQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class JourneyAggregationQuery: Codable {







    public enum GroupBy: String, Codable { 
        case containsallcondition = "containsAllCondition"
        case containsanycondition = "containsAnyCondition"
        case endswithcondition = "endsWithCondition"
        case equalcondition = "equalCondition"
        case journeyactionid = "journeyActionId"
        case journeyactionmapid = "journeyActionMapId"
        case journeyactionmapversion = "journeyActionMapVersion"
        case journeyactionmediatype = "journeyActionMediaType"
        case journeyactiontargetid = "journeyActionTargetId"
        case journeyactiontemplateid = "journeyActionTemplateId"
        case journeyblockingactionmapid = "journeyBlockingActionMapId"
        case journeyblockingemergencyschedulegroupid = "journeyBlockingEmergencyScheduleGroupId"
        case journeyblockingreason = "journeyBlockingReason"
        case journeyblockingschedulegroupid = "journeyBlockingScheduleGroupId"
        case journeydevicecategory = "journeyDeviceCategory"
        case journeydevicetype = "journeyDeviceType"
        case journeyfrequencycapreason = "journeyFrequencyCapReason"
        case journeyipgeolocationcountry = "journeyIpGeolocationCountry"
        case journeyoutcomeid = "journeyOutcomeId"
        case journeysegmentid = "journeySegmentId"
        case journeysegmentscope = "journeySegmentScope"
        case journeysessionid = "journeySessionId"
        case journeysessionsegmentid = "journeySessionSegmentId"
        case journeysessiontype = "journeySessionType"
        case notcontainsallcondition = "notContainsAllCondition"
        case notcontainsanycondition = "notContainsAnyCondition"
        case notequalcondition = "notEqualCondition"
        case startswithcondition = "startsWithCondition"
        case touchpointactionmapid = "touchpointActionMapId"
        case touchpointagentid = "touchpointAgentId"
        case touchpointattributionscope = "touchpointAttributionScope"
        case touchpointchannelmessagetype = "touchpointChannelMessageType"
        case touchpointchannelplatform = "touchpointChannelPlatform"
        case touchpointchanneltype = "touchpointChannelType"
        case touchpointconversationid = "touchpointConversationId"
        case touchpointinteractiontype = "touchpointInteractionType"
        case touchpointqueueid = "touchpointQueueId"
        case touchpointrequestedrouting = "touchpointRequestedRouting"
        case touchpointusedrouting = "touchpointUsedRouting"
        case touchpointwrapupcode = "touchpointWrapupCode"
    }



    public enum Metrics: String, Codable { 
        case ndistinctjourneyactions = "nDistinctJourneyActions"
        case ndistinctjourneysessions = "nDistinctJourneySessions"
        case njourneyactionsblocked = "nJourneyActionsBlocked"
        case njourneyoutcomesachieved = "nJourneyOutcomesAchieved"
        case njourneyoutcomesattributed = "nJourneyOutcomesAttributed"
        case njourneysegmentsassigned = "nJourneySegmentsAssigned"
        case njourneysessions = "nJourneySessions"
        case nwebactionsabandoned = "nWebActionsAbandoned"
        case nwebactionsaccepted = "nWebActionsAccepted"
        case nwebactionsengaged = "nWebActionsEngaged"
        case nwebactionserrored = "nWebActionsErrored"
        case nwebactionsfrequencycapreached = "nWebActionsFrequencyCapReached"
        case nwebactionsignored = "nWebActionsIgnored"
        case nwebactionsoffered = "nWebActionsOffered"
        case nwebactionsofferedoutsideschedule = "nWebActionsOfferedOutsideSchedule"
        case nwebactionsqualified = "nWebActionsQualified"
        case nwebactionsqualifiedoutsideschedule = "nWebActionsQualifiedOutsideSchedule"
        case nwebactionsrejected = "nWebActionsRejected"
        case nwebactionsstarted = "nWebActionsStarted"
        case nwebactionstimedout = "nWebActionsTimedout"
        case ojourneyoutcometouchpointvalue = "oJourneyOutcomeTouchpointValue"
        case ojourneyoutcomevalue = "oJourneyOutcomeValue"
    }





    public enum AlternateTimeDimension: String, Codable { 
        case eventtime = "eventTime"
    }

    /** Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H */
    public var granularity: String?
    /** Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var timeZone: String?
    /** Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group. */
    public var groupBy: [GroupBy]?
    /** Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters */
    public var filter: JourneyAggregateQueryFilter?
    /** Behaves like a SQL SELECT clause. Only named metrics will be retrieved. */
    public var metrics: [Metrics]?
    /** Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c') */
    public var flattenMultivaluedDimensions: Bool?
    /** Custom derived metric views */
    public var views: [JourneyAggregationView]?
    /** Dimension to use as the alternative timestamp for data in the aggregate.  Choosing \"eventTime\" uses the actual time of the data event. */
    public var alternateTimeDimension: AlternateTimeDimension?

    public init(interval: String?, granularity: String?, timeZone: String?, groupBy: [GroupBy]?, filter: JourneyAggregateQueryFilter?, metrics: [Metrics]?, flattenMultivaluedDimensions: Bool?, views: [JourneyAggregationView]?, alternateTimeDimension: AlternateTimeDimension?) {
        self.interval = interval
        self.granularity = granularity
        self.timeZone = timeZone
        self.groupBy = groupBy
        self.filter = filter
        self.metrics = metrics
        self.flattenMultivaluedDimensions = flattenMultivaluedDimensions
        self.views = views
        self.alternateTimeDimension = alternateTimeDimension
    }


}




public class JourneyAppEventsNotificationApp: Codable {









    public var name: String?
    public var namespace: String?
    public var version: String?
    public var buildNumber: String?

    public init(name: String?, namespace: String?, version: String?, buildNumber: String?) {
        self.name = name
        self.namespace = namespace
        self.version = version
        self.buildNumber = buildNumber
    }


}




public class JourneyAppEventsNotificationOutcomeAchievedMessage: Codable {























    public var outcome: JourneyAppEventsNotificationOutcome?
    public var browser: JourneyAppEventsNotificationBrowser?
    public var visitCreatedDate: Date?
    public var ipAddress: String?
    public var ipOrganization: String?
    public var userAgentString: String?
    public var device: JourneyAppEventsNotificationDevice?
    public var geolocation: JourneyAppEventsNotificationGeoLocation?
    public var mktCampaign: JourneyAppEventsNotificationMktCampaign?
    public var visitReferrer: JourneyAppEventsNotificationReferrer?
    public var associatedValue: JourneyAppEventsNotificationAssociatedValue?

    public init(outcome: JourneyAppEventsNotificationOutcome?, browser: JourneyAppEventsNotificationBrowser?, visitCreatedDate: Date?, ipAddress: String?, ipOrganization: String?, userAgentString: String?, device: JourneyAppEventsNotificationDevice?, geolocation: JourneyAppEventsNotificationGeoLocation?, mktCampaign: JourneyAppEventsNotificationMktCampaign?, visitReferrer: JourneyAppEventsNotificationReferrer?, associatedValue: JourneyAppEventsNotificationAssociatedValue?) {
        self.outcome = outcome
        self.browser = browser
        self.visitCreatedDate = visitCreatedDate
        self.ipAddress = ipAddress
        self.ipOrganization = ipOrganization
        self.userAgentString = userAgentString
        self.device = device
        self.geolocation = geolocation
        self.mktCampaign = mktCampaign
        self.visitReferrer = visitReferrer
        self.associatedValue = associatedValue
    }


}




public class JourneyAppEventsNotificationReferrer: Codable {

















    public enum Medium: String, Codable { 
        case _internal = "internal"
        case search = "search"
        case social = "social"
        case email = "email"
        case unknown = "unknown"
        case paid = "paid"
    }

    public var url: String?
    public var domain: String?
    public var hostname: String?
    public var keywords: String?
    public var pathname: String?
    public var queryString: String?
    public var fragment: String?
    public var name: String?
    public var medium: Medium?

    public init(url: String?, domain: String?, hostname: String?, keywords: String?, pathname: String?, queryString: String?, fragment: String?, name: String?, medium: Medium?) {
        self.url = url
        self.domain = domain
        self.hostname = hostname
        self.keywords = keywords
        self.pathname = pathname
        self.queryString = queryString
        self.fragment = fragment
        self.name = name
        self.medium = medium
    }


}




public class JourneyOutcomeEventsNotificationExternalContact: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneyOutcomeEventsNotificationOutcomeEventsNotification: Codable {















    public enum EventType: String, Codable { 
        case outcomeAchievedEvent = "OutcomeAchievedEvent"
        case outcomeAttributionEvent = "OutcomeAttributionEvent"
    }





    public var _id: String?
    public var correlationId: String?
    public var externalContact: JourneyOutcomeEventsNotificationExternalContact?
    public var createdDate: Date?
    public var customerId: String?
    public var customerIdType: String?
    public var session: JourneyOutcomeEventsNotificationSession?
    public var eventType: EventType?
    public var outcomeAchievedEvent: JourneyOutcomeEventsNotificationOutcomeAchievedMessage?
    public var outcomeAttributionEventMessage: JourneyOutcomeEventsNotificationOutcomeAttributionMessage?

    public init(_id: String?, correlationId: String?, externalContact: JourneyOutcomeEventsNotificationExternalContact?, createdDate: Date?, customerId: String?, customerIdType: String?, session: JourneyOutcomeEventsNotificationSession?, eventType: EventType?, outcomeAchievedEvent: JourneyOutcomeEventsNotificationOutcomeAchievedMessage?, outcomeAttributionEventMessage: JourneyOutcomeEventsNotificationOutcomeAttributionMessage?) {
        self._id = _id
        self.correlationId = correlationId
        self.externalContact = externalContact
        self.createdDate = createdDate
        self.customerId = customerId
        self.customerIdType = customerIdType
        self.session = session
        self.eventType = eventType
        self.outcomeAchievedEvent = outcomeAchievedEvent
        self.outcomeAttributionEventMessage = outcomeAttributionEventMessage
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case correlationId
        case externalContact
        case createdDate
        case customerId
        case customerIdType
        case session
        case eventType
        case outcomeAchievedEvent
        case outcomeAttributionEventMessage
    }


}




public class JourneyOutcomeEventsNotificationOutcomeTouchpoint: Codable {









    public var _id: String?
    public var channels: [JourneyOutcomeEventsNotificationOutcomeTouchpointChannel]?
    public var createdDate: Date?
    public var actionMap: JourneyOutcomeEventsNotificationActionMap?

    public init(_id: String?, channels: [JourneyOutcomeEventsNotificationOutcomeTouchpointChannel]?, createdDate: Date?, actionMap: JourneyOutcomeEventsNotificationActionMap?) {
        self._id = _id
        self.channels = channels
        self.createdDate = createdDate
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case channels
        case createdDate
        case actionMap
    }


}




public class JourneySessionEventsNotificationConversationUserDisposition: Codable {







    public var code: String?
    public var notes: String?
    public var user: JourneySessionEventsNotificationUser?

    public init(code: String?, notes: String?, user: JourneySessionEventsNotificationUser?) {
        self.code = code
        self.notes = notes
        self.user = user
    }


}




public class JourneySessionEventsNotificationGeoLocation: Codable {





















    public var country: String?
    public var countryName: String?
    public var latitude: Double?
    public var longitude: Double?
    public var locality: String?
    public var postalCode: String?
    public var region: String?
    public var regionName: String?
    public var timezone: String?
    public var source: String?

    public init(country: String?, countryName: String?, latitude: Double?, longitude: Double?, locality: String?, postalCode: String?, region: String?, regionName: String?, timezone: String?, source: String?) {
        self.country = country
        self.countryName = countryName
        self.latitude = latitude
        self.longitude = longitude
        self.locality = locality
        self.postalCode = postalCode
        self.region = region
        self.regionName = regionName
        self.timezone = timezone
        self.source = source
    }


}




public class JourneySessionEventsNotificationSegment: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneySessionEventsNotificationSessionLastEvent: Codable {







    public var _id: String?
    public var eventName: String?
    public var createdDate: Date?

    public init(_id: String?, eventName: String?, createdDate: Date?) {
        self._id = _id
        self.eventName = eventName
        self.createdDate = createdDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case eventName
        case createdDate
    }


}




public class JourneyWebActionEventsNotificationActionTarget: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneyWebActionEventsNotificationBlockedWebActionOfferMessage: Codable {







    public enum BlockingReason: String, Codable { 
        case unknown = "Unknown"
        case pageUrlConditionsNotMatching = "PageUrlConditionsNotMatching"
        case serviceLevelThrottling = "ServiceLevelThrottling"
        case alreadyExistingOffer = "AlreadyExistingOffer"
        case triggerDateInFuture = "TriggerDateInFuture"
        case multipleSimultaneousOffers = "MultipleSimultaneousOffers"
        case noAvailableAgents = "NoAvailableAgents"
        case frequencyCapping = "FrequencyCapping"
        case offeredOutsideSchedule = "OfferedOutsideSchedule"
    }





    public enum BlockingFrequencyCapBehaviour: String, Codable { 
        case unknown = "Unknown"
        case capOnceFinalized = "CapOnceFinalized"
        case capOnceRejected = "CapOnceRejected"
        case capForPeriod = "CapForPeriod"
    }







    public var action: JourneyWebActionEventsNotificationEventAction?
    public var actionMap: JourneyWebActionEventsNotificationActionMap?
    public var actionTarget: JourneyWebActionEventsNotificationActionTarget?
    public var blockingReason: BlockingReason?
    public var blockingActionMap: JourneyWebActionEventsNotificationActionMap?
    public var blockingAction: JourneyWebActionEventsNotificationEventAction?
    public var blockingFrequencyCapBehaviour: BlockingFrequencyCapBehaviour?
    public var blockingPageUrlConditions: [JourneyWebActionEventsNotificationActionMapPageUrlCondition]?
    public var blockingScheduleGroup: JourneyWebActionEventsNotificationScheduleGroup?
    public var blockingEmergencyScheduleGroup: JourneyWebActionEventsNotificationEmergencyGroup?

    public init(action: JourneyWebActionEventsNotificationEventAction?, actionMap: JourneyWebActionEventsNotificationActionMap?, actionTarget: JourneyWebActionEventsNotificationActionTarget?, blockingReason: BlockingReason?, blockingActionMap: JourneyWebActionEventsNotificationActionMap?, blockingAction: JourneyWebActionEventsNotificationEventAction?, blockingFrequencyCapBehaviour: BlockingFrequencyCapBehaviour?, blockingPageUrlConditions: [JourneyWebActionEventsNotificationActionMapPageUrlCondition]?, blockingScheduleGroup: JourneyWebActionEventsNotificationScheduleGroup?, blockingEmergencyScheduleGroup: JourneyWebActionEventsNotificationEmergencyGroup?) {
        self.action = action
        self.actionMap = actionMap
        self.actionTarget = actionTarget
        self.blockingReason = blockingReason
        self.blockingActionMap = blockingActionMap
        self.blockingAction = blockingAction
        self.blockingFrequencyCapBehaviour = blockingFrequencyCapBehaviour
        self.blockingPageUrlConditions = blockingPageUrlConditions
        self.blockingScheduleGroup = blockingScheduleGroup
        self.blockingEmergencyScheduleGroup = blockingEmergencyScheduleGroup
    }


}




public class JourneyWebActionEventsNotificationExternalContact: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneyWebActionEventsNotificationWebActionEventsNotification: Codable {















    public enum EventType: String, Codable { 
        case webActionEvent = "WebActionEvent"
        case blockedWebActionOfferEvent = "BlockedWebActionOfferEvent"
    }





    public var _id: String?
    public var correlationId: String?
    public var externalContact: JourneyWebActionEventsNotificationExternalContact?
    public var createdDate: Date?
    public var customerId: String?
    public var customerIdType: String?
    public var session: JourneyWebActionEventsNotificationSession?
    public var eventType: EventType?
    public var webActionEvent: JourneyWebActionEventsNotificationWebActionMessage?
    public var blockedWebActionOfferEvent: JourneyWebActionEventsNotificationBlockedWebActionOfferMessage?

    public init(_id: String?, correlationId: String?, externalContact: JourneyWebActionEventsNotificationExternalContact?, createdDate: Date?, customerId: String?, customerIdType: String?, session: JourneyWebActionEventsNotificationSession?, eventType: EventType?, webActionEvent: JourneyWebActionEventsNotificationWebActionMessage?, blockedWebActionOfferEvent: JourneyWebActionEventsNotificationBlockedWebActionOfferMessage?) {
        self._id = _id
        self.correlationId = correlationId
        self.externalContact = externalContact
        self.createdDate = createdDate
        self.customerId = customerId
        self.customerIdType = customerIdType
        self.session = session
        self.eventType = eventType
        self.webActionEvent = webActionEvent
        self.blockedWebActionOfferEvent = blockedWebActionOfferEvent
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case correlationId
        case externalContact
        case createdDate
        case customerId
        case customerIdType
        case session
        case eventType
        case webActionEvent
        case blockedWebActionOfferEvent
    }


}




public class JourneyWebActionEventsNotificationWebActionMessage: Codable {





























    public var action: JourneyWebActionEventsNotificationEventAction?
    public var actionTarget: JourneyWebActionEventsNotificationActionTarget?
    public var actionMap: JourneyWebActionEventsNotificationActionMap?
    public var errorCode: String?
    public var errorMessage: String?
    public var userAgentString: String?
    public var ipAddress: String?
    public var ipOrganization: String?
    public var browser: JourneyWebActionEventsNotificationBrowser?
    public var device: JourneyWebActionEventsNotificationDevice?
    public var geolocation: JourneyWebActionEventsNotificationGeoLocation?
    public var mktCampaign: JourneyWebActionEventsNotificationMktCampaign?
    public var visitReferrer: JourneyWebActionEventsNotificationReferrer?
    public var timeToDisposition: Int?

    public init(action: JourneyWebActionEventsNotificationEventAction?, actionTarget: JourneyWebActionEventsNotificationActionTarget?, actionMap: JourneyWebActionEventsNotificationActionMap?, errorCode: String?, errorMessage: String?, userAgentString: String?, ipAddress: String?, ipOrganization: String?, browser: JourneyWebActionEventsNotificationBrowser?, device: JourneyWebActionEventsNotificationDevice?, geolocation: JourneyWebActionEventsNotificationGeoLocation?, mktCampaign: JourneyWebActionEventsNotificationMktCampaign?, visitReferrer: JourneyWebActionEventsNotificationReferrer?, timeToDisposition: Int?) {
        self.action = action
        self.actionTarget = actionTarget
        self.actionMap = actionMap
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.userAgentString = userAgentString
        self.ipAddress = ipAddress
        self.ipOrganization = ipOrganization
        self.browser = browser
        self.device = device
        self.geolocation = geolocation
        self.mktCampaign = mktCampaign
        self.visitReferrer = visitReferrer
        self.timeToDisposition = timeToDisposition
    }


}




public class JourneyWebEventsNotificationActionMap: Codable {









    public var _id: String?
    public var selfUri: String?
    public var displayName: String?
    public var version: Int?

    public init(_id: String?, selfUri: String?, displayName: String?, version: Int?) {
        self._id = _id
        self.selfUri = selfUri
        self.displayName = displayName
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case displayName
        case version
    }


}




public class JourneyWebEventsNotificationCustomEventAttribute: Codable {



    public enum DataType: String, Codable { 
        case string = "STRING"
        case boolean = "BOOLEAN"
        case number = "NUMBER"
    }

    public var value: String?
    public var dataType: DataType?

    public init(value: String?, dataType: DataType?) {
        self.value = value
        self.dataType = dataType
    }


}




public class JourneyWebEventsNotificationDevice: Codable {

















    public enum Category: String, Codable { 
        case desktop = "desktop"
        case mobile = "mobile"
        case tablet = "tablet"
        case other = "other"
    }



    public var type: String?
    public var isMobile: Bool?
    public var screenHeight: Int?
    public var screenWidth: Int?
    public var screenDensity: Int?
    public var fingerprint: String?
    public var osFamily: String?
    public var osVersion: String?
    public var category: Category?
    public var manufacturer: String?

    public init(type: String?, isMobile: Bool?, screenHeight: Int?, screenWidth: Int?, screenDensity: Int?, fingerprint: String?, osFamily: String?, osVersion: String?, category: Category?, manufacturer: String?) {
        self.type = type
        self.isMobile = isMobile
        self.screenHeight = screenHeight
        self.screenWidth = screenWidth
        self.screenDensity = screenDensity
        self.fingerprint = fingerprint
        self.osFamily = osFamily
        self.osVersion = osVersion
        self.category = category
        self.manufacturer = manufacturer
    }


}




public class JourneyWebEventsNotificationOutcome: Codable {









    public var _id: String?
    public var selfUri: String?
    public var displayName: String?
    public var version: String?

    public init(_id: String?, selfUri: String?, displayName: String?, version: String?) {
        self._id = _id
        self.selfUri = selfUri
        self.displayName = displayName
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case displayName
        case version
    }


}




public class JsonNodeSearchResponse: Codable {





















    /** The total number of results found */
    public var total: Int64?
    /** The total number of pages */
    public var pageCount: Int?
    /** The current page size */
    public var pageSize: Int?
    /** The current page number */
    public var pageNumber: Int?
    /** Q64 value for the previous page of results */
    public var previousPage: String?
    /** Q64 value for the current page of results */
    public var currentPage: String?
    /** Q64 value for the next page of results */
    public var nextPage: String?
    /** Resource types the search was performed against */
    public var types: [String]?
    /** Search results */
    public var results: JSON?
    public var aggregations: JSON?

    public init(total: Int64?, pageCount: Int?, pageSize: Int?, pageNumber: Int?, previousPage: String?, currentPage: String?, nextPage: String?, types: [String]?, results: JSON?, aggregations: JSON?) {
        self.total = total
        self.pageCount = pageCount
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.previousPage = previousPage
        self.currentPage = currentPage
        self.nextPage = nextPage
        self.types = types
        self.results = results
        self.aggregations = aggregations
    }


}




public class JsonSearchResponse: Codable {















    /** The total number of results found */
    public var total: Int64?
    /** The total number of pages */
    public var pageCount: Int?
    /** The current page size */
    public var pageSize: Int?
    /** The current page number */
    public var pageNumber: Int?
    /** Resource types the search was performed against */
    public var types: [String]?
    /** Search results */
    public var results: JSON?
    public var aggregations: JSON?

    public init(total: Int64?, pageCount: Int?, pageSize: Int?, pageNumber: Int?, types: [String]?, results: JSON?, aggregations: JSON?) {
        self.total = total
        self.pageCount = pageCount
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.types = types
        self.results = results
        self.aggregations = aggregations
    }


}




public class KeyPerformanceIndicator: Codable {





    public enum OptimizationType: String, Codable { 
        case maximization = "Maximization"
        case minimization = "Minimization"
    }

    public enum ProblemType: String, Codable { 
        case classification = "Classification"
        case regression = "Regression"
    }







    public enum KpiType: String, Codable { 
        case salesConversion = "SalesConversion"
        case churn = "Churn"
        case retention = "Retention"
        case salesValue = "SalesValue"
        case handleTime = "HandleTime"
        case numberOfTransfers = "NumberOfTransfers"
    }

    public enum Source: String, Codable { 
        case wrapUpCode = "WrapUpCode"
        case outcome = "Outcome"
        case _none = "None"
    }





    public enum Status: String, Codable { 
        case enabled = "Enabled"
        case disabled = "Disabled"
    }

    public enum KpiGroup: String, Codable { 
        case standard = "Standard"
        case custom = "Custom"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the Key Performance Indicator. */
    public var name: String?
    /** The optimization type of the Key Performance Indicator. */
    public var optimizationType: OptimizationType?
    /** The problem type of the Key Performance Indicator. */
    public var problemType: ProblemType?
    /** DateTime indicating when the Key Performance Indicator was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** DateTime indicating when the Key Performance Indicator was modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The description of the Key Performance Indicator. */
    public var _description: String?
    /** The type of Key Performance Indicator. */
    public var kpiType: KpiType?
    /** Source of values for Key Performance Indicator. */
    public var source: Source?
    /** Defines what wrap up codes are mapped to Key Performance Indicator. */
    public var wrapUpCodeConfig: WrapUpCodeConfig?
    /** Defines what outcome ids are mapped to Key Performance Indicator. */
    public var outcomeConfig: OutcomeConfig?
    /** The status of the Key Performance Indicator. */
    public var status: Status?
    /** The group the Key Performance Indicator belongs to. */
    public var kpiGroup: KpiGroup?
    /** Queue IDs on which KPI specification is used. */
    public var queues: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, optimizationType: OptimizationType?, problemType: ProblemType?, dateCreated: Date?, dateModified: Date?, _description: String?, kpiType: KpiType?, source: Source?, wrapUpCodeConfig: WrapUpCodeConfig?, outcomeConfig: OutcomeConfig?, status: Status?, kpiGroup: KpiGroup?, queues: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.optimizationType = optimizationType
        self.problemType = problemType
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self._description = _description
        self.kpiType = kpiType
        self.source = source
        self.wrapUpCodeConfig = wrapUpCodeConfig
        self.outcomeConfig = outcomeConfig
        self.status = status
        self.kpiGroup = kpiGroup
        self.queues = queues
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case optimizationType
        case problemType
        case dateCreated
        case dateModified
        case _description = "description"
        case kpiType
        case source
        case wrapUpCodeConfig
        case outcomeConfig
        case status
        case kpiGroup
        case queues
        case selfUri
    }


}




public class KlaxonHeartBeatAlertsTopicHeartBeatAlert: Codable {

















    public enum AlertTypes: String, Codable { 
        case sms = "SMS"
        case device = "DEVICE"
        case email = "EMAIL"
    }

    public enum RuleType: String, Codable { 
        case edge = "EDGE"
    }

    public var _id: String?
    public var name: String?
    public var senderId: String?
    public var heartBeatTimeoutInMinutes: Double?
    public var ruleId: String?
    public var startDate: Date?
    public var endDate: Date?
    public var notificationUsers: [KlaxonHeartBeatAlertsTopicNotificationUser]?
    public var alertTypes: [AlertTypes]?
    public var ruleType: RuleType?

    public init(_id: String?, name: String?, senderId: String?, heartBeatTimeoutInMinutes: Double?, ruleId: String?, startDate: Date?, endDate: Date?, notificationUsers: [KlaxonHeartBeatAlertsTopicNotificationUser]?, alertTypes: [AlertTypes]?, ruleType: RuleType?) {
        self._id = _id
        self.name = name
        self.senderId = senderId
        self.heartBeatTimeoutInMinutes = heartBeatTimeoutInMinutes
        self.ruleId = ruleId
        self.startDate = startDate
        self.endDate = endDate
        self.notificationUsers = notificationUsers
        self.alertTypes = alertTypes
        self.ruleType = ruleType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case senderId
        case heartBeatTimeoutInMinutes
        case ruleId
        case startDate
        case endDate
        case notificationUsers
        case alertTypes
        case ruleType
    }


}




public class KlaxonHeartBeatRulesTopicNotificationUser: Codable {





    public var _id: String?
    public var displayName: String?

    public init(_id: String?, displayName: String?) {
        self._id = _id
        self.displayName = displayName
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case displayName
    }


}




public class KlaxonInteractionStatsAlertsTopicNotificationUser: Codable {





    public var _id: String?
    public var displayName: String?

    public init(_id: String?, displayName: String?) {
        self._id = _id
        self.displayName = displayName
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case displayName
    }


}




public class KnowledgeAggregateDataContainer: Codable {





    /** A mapping from dimension to value */
    public var group: [String:String]?
    public var data: [StatisticalResponse]?

    public init(group: [String:String]?, data: [StatisticalResponse]?) {
        self.group = group
        self.data = data
    }


}




public class KnowledgeAggregateQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [KnowledgeAggregateQueryPredicate]?

    public init(type: ModelType?, predicates: [KnowledgeAggregateQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class KnowledgeAggregationQuery: Codable {







    public enum GroupBy: String, Codable { 
        case agentassistantid = "agentAssistantId"
        case appdeploymentid = "appDeploymentId"
        case apptype = "appType"
        case conversationchanneltype = "conversationChannelType"
        case conversationid = "conversationId"
        case documentengagementtype = "documentEngagementType"
        case externalcontactid = "externalContactId"
        case feedbackcategory = "feedbackCategory"
        case feedbackid = "feedbackId"
        case feedbackrating = "feedbackRating"
        case feedbackratingtype = "feedbackRatingType"
        case feedbackratingvalue = "feedbackRatingValue"
        case feedbackreason = "feedbackReason"
        case feedbacktype = "feedbackType"
        case hascomment = "hasComment"
        case hassearch = "hasSearch"
        case knowledgebasedocumentid = "knowledgeBaseDocumentId"
        case knowledgebasedocumentvariationid = "knowledgeBaseDocumentVariationId"
        case knowledgebasedocumentversionid = "knowledgeBaseDocumentVersionId"
        case knowledgebaseid = "knowledgeBaseId"
        case languagecode = "languageCode"
        case mediatype = "mediaType"
        case presenteddocumentscount = "presentedDocumentsCount"
        case querytype = "queryType"
        case queueid = "queueId"
        case searchid = "searchId"
        case searchquery = "searchQuery"
        case selfserved = "selfServed"
        case sessionid = "sessionId"
        case surfacingmethod = "surfacingMethod"
        case userid = "userId"
    }



    public enum Metrics: String, Codable { 
        case ndistinctknowledgesessions = "nDistinctKnowledgeSessions"
        case nknowledgedocumentcopied = "nKnowledgeDocumentCopied"
        case nknowledgedocumentfeedback = "nKnowledgeDocumentFeedback"
        case nknowledgedocumentpresented = "nKnowledgeDocumentPresented"
        case nknowledgedocumentsurfaced = "nKnowledgeDocumentSurfaced"
        case nknowledgedocumentviewed = "nKnowledgeDocumentViewed"
        case nknowledgesearch = "nKnowledgeSearch"
        case nknowledgesearchanswered = "nKnowledgeSearchAnswered"
        case nknowledgesearchfeedback = "nKnowledgeSearchFeedback"
        case nknowledgesearchunanswered = "nKnowledgeSearchUnanswered"
        case nknowledgesessions = "nKnowledgeSessions"
        case oknowledgedocumentquery = "oKnowledgeDocumentQuery"
        case oknowledgedocumentqueryselfserved = "oKnowledgeDocumentQuerySelfServed"
        case oknowledgesearch = "oKnowledgeSearch"
    }





    public enum AlternateTimeDimension: String, Codable { 
        case eventtime = "eventTime"
    }

    public enum QueryType: String, Codable { 
        case groupby = "groupBy"
        case topn = "topN"
    }



    /** Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H */
    public var granularity: String?
    /** Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var timeZone: String?
    /** Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group. */
    public var groupBy: [GroupBy]?
    /** Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters */
    public var filter: KnowledgeAggregateQueryFilter?
    /** Behaves like a SQL SELECT clause. Only named metrics will be retrieved. */
    public var metrics: [Metrics]?
    /** Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c') */
    public var flattenMultivaluedDimensions: Bool?
    /** Custom derived metric views */
    public var views: [KnowledgeAggregationView]?
    /** Dimension to use as the alternative timestamp for data in the aggregate.  Choosing \"eventTime\" uses the actual time of the data event. */
    public var alternateTimeDimension: AlternateTimeDimension?
    /** Query type to use. Use groupBy for all matching results, and topN for just top N results for the requested metric (group by exactly 1 dimension) */
    public var queryType: QueryType?
    /** How many results you want in the topN list. Only applicable for topN query type. */
    public var limit: Int?

    public init(interval: String?, granularity: String?, timeZone: String?, groupBy: [GroupBy]?, filter: KnowledgeAggregateQueryFilter?, metrics: [Metrics]?, flattenMultivaluedDimensions: Bool?, views: [KnowledgeAggregationView]?, alternateTimeDimension: AlternateTimeDimension?, queryType: QueryType?, limit: Int?) {
        self.interval = interval
        self.granularity = granularity
        self.timeZone = timeZone
        self.groupBy = groupBy
        self.filter = filter
        self.metrics = metrics
        self.flattenMultivaluedDimensions = flattenMultivaluedDimensions
        self.views = views
        self.alternateTimeDimension = alternateTimeDimension
        self.queryType = queryType
        self.limit = limit
    }


}




public class KnowledgeContextReference: Codable {





    /** The globally unique identifier for the knowledge context. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class KnowledgeDocumentAlternative: Codable {





    /** Alternate phrasing to the document title, having a limit of 500 words. */
    public var phrase: String?
    /** Autocomplete enabled for the alternate phrase. */
    public var autocomplete: Bool?

    public init(phrase: String?, autocomplete: Bool?) {
        self.phrase = phrase
        self.autocomplete = autocomplete
    }


}




public class KnowledgeDocumentCopy: Codable {







    public enum QueryType: String, Codable { 
        case unknown = "Unknown"
        case article = "Article"
        case autoSearch = "AutoSearch"
        case category = "Category"
        case manualSearch = "ManualSearch"
        case recommendation = "Recommendation"
        case suggestion = "Suggestion"
    }







    /** The variation of the document whose content was copied. */
    public var documentVariationId: String?
    /** The version of the document whose content was copied. */
    public var documentVersionId: String?
    /** The search that surfaced the document whose content was copied. */
    public var searchId: String?
    /** The type of the query that surfaced the document. */
    public var queryType: QueryType?
    /** Knowledge session ID. */
    public var sessionId: String?
    /** Conversation context information, if the document content is copied in the context of a conversation. */
    public var conversationContext: KnowledgeConversationContext?
    /** The client application in which the document content was copied. */
    public var application: KnowledgeSearchClientApplication?

    public init(documentVariationId: String?, documentVersionId: String?, searchId: String?, queryType: QueryType?, sessionId: String?, conversationContext: KnowledgeConversationContext?, application: KnowledgeSearchClientApplication?) {
        self.documentVariationId = documentVariationId
        self.documentVersionId = documentVersionId
        self.searchId = searchId
        self.queryType = queryType
        self.sessionId = sessionId
        self.conversationContext = conversationContext
        self.application = application
    }


}




public class KnowledgeDocumentPresentation: Codable {





    public enum QueryType: String, Codable { 
        case unknown = "Unknown"
        case article = "Article"
        case autoSearch = "AutoSearch"
        case category = "Category"
        case manualSearch = "ManualSearch"
        case recommendation = "Recommendation"
        case suggestion = "Suggestion"
    }







    /** The presented documents */
    public var documents: [KnowledgeDocumentVersionVariationReference]?
    /** The search that surfaced the documents that were presented. */
    public var searchId: String?
    /** The type of the query that surfaced the documents. */
    public var queryType: QueryType?
    /** Knowledge session ID. */
    public var sessionId: String?
    /** Conversation context information if the documents were presented in the context of a conversation. */
    public var conversationContext: KnowledgeConversationContext?
    /** The client application in which the documents were presented. */
    public var application: KnowledgeSearchClientApplication?

    public init(documents: [KnowledgeDocumentVersionVariationReference]?, searchId: String?, queryType: QueryType?, sessionId: String?, conversationContext: KnowledgeConversationContext?, application: KnowledgeSearchClientApplication?) {
        self.documents = documents
        self.searchId = searchId
        self.queryType = queryType
        self.sessionId = sessionId
        self.conversationContext = conversationContext
        self.application = application
    }


}




public class KnowledgeDocumentReference: Codable {







    /** The globally unique identifier for the document. */
    public var _id: String?
    /** The knowledge base that the document belongs to. */
    public var knowledgeBase: KnowledgeBaseReference?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, knowledgeBase: KnowledgeBaseReference?, selfUri: String?) {
        self._id = _id
        self.knowledgeBase = knowledgeBase
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case knowledgeBase
        case selfUri
    }


}




public class KnowledgeDocumentReq: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Document title. */
    public var title: String?
    /** Indicates if the knowledge document should be included in search results. */
    public var visible: Bool?
    /** List of alternate phrases related to the title which improves search results. */
    public var alternatives: [KnowledgeDocumentAlternative]?
    /** The category associated with the document. */
    public var categoryId: String?
    /** The ids of labels associated with the document. */
    public var labelIds: [String]?
    /** The external id associated with the document. */
    public var externalId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, title: String?, visible: Bool?, alternatives: [KnowledgeDocumentAlternative]?, categoryId: String?, labelIds: [String]?, externalId: String?, selfUri: String?) {
        self._id = _id
        self.title = title
        self.visible = visible
        self.alternatives = alternatives
        self.categoryId = categoryId
        self.labelIds = labelIds
        self.externalId = externalId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case title
        case visible
        case alternatives
        case categoryId
        case labelIds
        case externalId
        case selfUri
    }


}




public class KnowledgeDocumentView: Codable {







    public enum QueryType: String, Codable { 
        case unknown = "Unknown"
        case article = "Article"
        case autoSearch = "AutoSearch"
        case category = "Category"
        case manualSearch = "ManualSearch"
        case recommendation = "Recommendation"
        case suggestion = "Suggestion"
    }







    /** The variation of the viewed document. */
    public var documentVariationId: String?
    /** The version of the viewed document. */
    public var documentVersionId: String?
    /** The search that surfaced the viewed document. */
    public var searchId: String?
    /** The type of the query that surfaced the document. */
    public var queryType: QueryType?
    /** The client application from which the document was viewed. */
    public var application: KnowledgeSearchClientApplication?
    /** The unique identifier of the knowledge session in which the document was viewed. */
    public var sessionId: String?
    /** Conversation context information if the document was viewed in the context of a conversation. */
    public var conversationContext: KnowledgeConversationContext?

    public init(documentVariationId: String?, documentVersionId: String?, searchId: String?, queryType: QueryType?, application: KnowledgeSearchClientApplication?, sessionId: String?, conversationContext: KnowledgeConversationContext?) {
        self.documentVariationId = documentVariationId
        self.documentVersionId = documentVersionId
        self.searchId = searchId
        self.queryType = queryType
        self.application = application
        self.sessionId = sessionId
        self.conversationContext = conversationContext
    }


}




public class KnowledgeExportJobResponse: Codable {





    public enum FileType: String, Codable { 
        case json = "Json"
        case csv = "Csv"
        case xlsx = "Xlsx"
    }







    public enum Status: String, Codable { 
        case created = "Created"
        case validationInProgress = "ValidationInProgress"
        case validationCompleted = "ValidationCompleted"
        case validationFailed = "ValidationFailed"
        case started = "Started"
        case inProgress = "InProgress"
        case completed = "Completed"
        case partialCompleted = "PartialCompleted"
        case failed = "Failed"
        case abortRequested = "AbortRequested"
        case aborted = "Aborted"
    }













    /** Id of the export job. */
    public var _id: String?
    /** The URL of the location at which the caller can download the export file, when available. */
    public var downloadURL: String?
    /** File type of the document */
    public var fileType: FileType?
    /** Requested version of the exported json file. */
    public var jsonFileVersion: Int?
    /** The current count of the number of records processed. */
    public var countDocumentProcessed: Int?
    /** Filters to narrow down what to export. */
    public var exportFilter: KnowledgeExportJobFilter?
    /** The status of the export job. */
    public var status: Status?
    /** Knowledge base which document export belongs to. */
    public var knowledgeBase: KnowledgeBase?
    /** The user who created the operation */
    public var createdBy: UserReference?
    /** The timestamp of when the export began. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The timestamp of when the export stopped. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Any error information, or null of the processing is not in failed state. */
    public var errorInformation: ErrorBody?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, downloadURL: String?, fileType: FileType?, jsonFileVersion: Int?, countDocumentProcessed: Int?, exportFilter: KnowledgeExportJobFilter?, status: Status?, knowledgeBase: KnowledgeBase?, createdBy: UserReference?, dateCreated: Date?, dateModified: Date?, errorInformation: ErrorBody?, selfUri: String?) {
        self._id = _id
        self.downloadURL = downloadURL
        self.fileType = fileType
        self.jsonFileVersion = jsonFileVersion
        self.countDocumentProcessed = countDocumentProcessed
        self.exportFilter = exportFilter
        self.status = status
        self.knowledgeBase = knowledgeBase
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.errorInformation = errorInformation
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case downloadURL
        case fileType
        case jsonFileVersion
        case countDocumentProcessed
        case exportFilter
        case status
        case knowledgeBase
        case createdBy
        case dateCreated
        case dateModified
        case errorInformation
        case selfUri
    }


}




public class KnowledgeExtendedCategory: Codable {









    public enum LanguageCode: String, Codable { 
        case enUs = "en-US"
        case enUk = "en-UK"
        case enAu = "en-AU"
        case enCa = "en-CA"
        case enHk = "en-HK"
        case enIn = "en-IN"
        case enIe = "en-IE"
        case enNz = "en-NZ"
        case enPh = "en-PH"
        case enSg = "en-SG"
        case enZa = "en-ZA"
        case deDe = "de-DE"
        case deAt = "de-AT"
        case deCh = "de-CH"
        case esAr = "es-AR"
        case esCo = "es-CO"
        case esMx = "es-MX"
        case esUs = "es-US"
        case esEs = "es-ES"
        case frFr = "fr-FR"
        case frBe = "fr-BE"
        case frCa = "fr-CA"
        case frCh = "fr-CH"
        case ptBr = "pt-BR"
        case ptPt = "pt-PT"
        case nlNl = "nl-NL"
        case nlBe = "nl-BE"
        case itIt = "it-IT"
        case caEs = "ca-ES"
        case trTr = "tr-TR"
        case svSe = "sv-SE"
        case fiFi = "fi-FI"
        case nbNo = "nb-NO"
        case daDk = "da-DK"
        case jaJp = "ja-JP"
        case arAe = "ar-AE"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Category name */
    public var name: String?
    /** Category description */
    public var _description: String?
    /** Knowledge base which category does belong to */
    public var knowledgeBase: KnowledgeBase?
    /** Actual language of the category */
    public var languageCode: LanguageCode?
    /** Category creation date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Category last modification date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Category parent */
    public var parent: KnowledgeCategory?
    /** Category children */
    public var children: [KnowledgeCategory]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, knowledgeBase: KnowledgeBase?, languageCode: LanguageCode?, dateCreated: Date?, dateModified: Date?, parent: KnowledgeCategory?, children: [KnowledgeCategory]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.knowledgeBase = knowledgeBase
        self.languageCode = languageCode
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.parent = parent
        self.children = children
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case knowledgeBase
        case languageCode
        case dateCreated
        case dateModified
        case parent
        case children
        case selfUri
    }


}




public class KnowledgeGroupStatistics: Codable {







    /** Knowledge Group unique phrase count */
    public var unlinkedPhraseCount: Int?
    /** Knowledge Group unlinked phrases hit count */
    public var unlinkedPhraseHitCount: Int?
    /** Total number of phrase hit counts of an unanswered group */
    public var totalPhraseHitCount: Int?

    public init(unlinkedPhraseCount: Int?, unlinkedPhraseHitCount: Int?, totalPhraseHitCount: Int?) {
        self.unlinkedPhraseCount = unlinkedPhraseCount
        self.unlinkedPhraseHitCount = unlinkedPhraseHitCount
        self.totalPhraseHitCount = totalPhraseHitCount
    }


}




public class KnowledgeGuestDocumentCopy: Codable {







    public enum QueryType: String, Codable { 
        case unknown = "Unknown"
        case article = "Article"
        case autoSearch = "AutoSearch"
        case category = "Category"
        case manualSearch = "ManualSearch"
        case recommendation = "Recommendation"
        case suggestion = "Suggestion"
    }





    /** The variation of the document whose content was copied. */
    public var documentVariationId: String?
    /** The version of the document whose content was copied. */
    public var documentVersionId: String?
    /** The search that surfaced the document whose content was copied. */
    public var searchId: String?
    /** The type of the query that surfaced the document. */
    public var queryType: QueryType?
    /** Knowledge session ID. */
    public var sessionId: String?
    /** The client application in which the document content was copied. */
    public var application: KnowledgeGuestSearchClientApplication?

    public init(documentVariationId: String?, documentVersionId: String?, searchId: String?, queryType: QueryType?, sessionId: String?, application: KnowledgeGuestSearchClientApplication?) {
        self.documentVariationId = documentVariationId
        self.documentVersionId = documentVersionId
        self.searchId = searchId
        self.queryType = queryType
        self.sessionId = sessionId
        self.application = application
    }


}




public class KnowledgeGuestDocumentPresentation: Codable {





    public enum QueryType: String, Codable { 
        case unknown = "Unknown"
        case article = "Article"
        case autoSearch = "AutoSearch"
        case category = "Category"
        case manualSearch = "ManualSearch"
        case recommendation = "Recommendation"
        case suggestion = "Suggestion"
    }





    /** The presented documents */
    public var documents: [KnowledgeDocumentVersionVariationReference]?
    /** The search that surfaced the documents that were presented. */
    public var searchId: String?
    /** The type of the query that surfaced the documents. */
    public var queryType: QueryType?
    /** Knowledge session ID. */
    public var sessionId: String?
    /** The client application in which the documents were presented. */
    public var application: KnowledgeGuestSearchClientApplication?

    public init(documents: [KnowledgeDocumentVersionVariationReference]?, searchId: String?, queryType: QueryType?, sessionId: String?, application: KnowledgeGuestSearchClientApplication?) {
        self.documents = documents
        self.searchId = searchId
        self.queryType = queryType
        self.sessionId = sessionId
        self.application = application
    }


}




public class KnowledgeGuestDocumentVariation: Codable {

















    /** The globally unique identifier for the variation. */
    public var _id: String?
    /** The content for the variation. */
    public var body: DocumentBody?
    /** The creation date-time for the document variation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The last modification date-time for the document variation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The version of the document. */
    public var documentVersion: AddressableEntityRef?
    /** The context values associated with the variation. */
    public var contexts: [KnowledgeGuestDocumentVariationContext]?
    /** The reference to document to which the variation is associated. */
    public var document: AddressableEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, body: DocumentBody?, dateCreated: Date?, dateModified: Date?, documentVersion: AddressableEntityRef?, contexts: [KnowledgeGuestDocumentVariationContext]?, document: AddressableEntityRef?, selfUri: String?) {
        self._id = _id
        self.body = body
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.documentVersion = documentVersion
        self.contexts = contexts
        self.document = document
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case body
        case dateCreated
        case dateModified
        case documentVersion
        case contexts
        case document
        case selfUri
    }


}




public class KnowledgeGuestDocumentView: Codable {







    public enum QueryType: String, Codable { 
        case unknown = "Unknown"
        case article = "Article"
        case autoSearch = "AutoSearch"
        case category = "Category"
        case manualSearch = "ManualSearch"
        case recommendation = "Recommendation"
        case suggestion = "Suggestion"
    }

    /** The variation of the viewed document. */
    public var documentVariationId: String?
    /** The version of the viewed document. */
    public var documentVersionId: String?
    /** The search that surfaced the viewed document. */
    public var searchId: String?
    /** The type of the query that surfaced the document. */
    public var queryType: QueryType?

    public init(documentVariationId: String?, documentVersionId: String?, searchId: String?, queryType: QueryType?) {
        self.documentVariationId = documentVariationId
        self.documentVersionId = documentVersionId
        self.searchId = searchId
        self.queryType = queryType
    }


}




public class KnowledgeImportJobSettings: Codable {









    /** If enabled import creates a new document even if update is available. */
    public var importAsNew: Bool?
    /** If specified, import will override the visibility of the imported documents. */
    public var visible: Bool?
    /** If specified, import will override the category of the imported documents. */
    public var categoryId: String?
    /** If specified, import will add this labels to the imported documents. */
    public var labelIds: [String]?

    public init(importAsNew: Bool?, visible: Bool?, categoryId: String?, labelIds: [String]?) {
        self.importAsNew = importAsNew
        self.visible = visible
        self.categoryId = categoryId
        self.labelIds = labelIds
    }


}




public class LabelListing: Codable {









    public var entities: [LabelResponse]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [LabelResponse]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class LabelUtilizationRequest: Codable {





    /** Defines the maximum number of interactions with this label that an agent can handle at one time. */
    public var maximumCapacity: Int?
    /** Defines other labels that can interrupt an interaction with this label. */
    public var interruptingLabelIds: [String]?

    public init(maximumCapacity: Int?, interruptingLabelIds: [String]?) {
        self.maximumCapacity = maximumCapacity
        self.interruptingLabelIds = interruptingLabelIds
    }


}




public class LanguageReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}



/** Learning module assignment with user information */

public class LearningAssignment: Codable {



























    public enum State: String, Codable { 
        case assigned = "Assigned"
        case inProgress = "InProgress"
        case completed = "Completed"
        case deleted = "Deleted"
        case notCompleted = "NotCompleted"
        case invalidSchedule = "InvalidSchedule"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The assessment associated with this assignment */
    public var assessment: LearningAssessment?
    /** The user who created the assignment */
    public var createdBy: UserReference?
    /** The date when the assignment was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The user who modified the assignment */
    public var modifiedBy: UserReference?
    /** The date when the assignment was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** True if the assignment is overdue */
    public var isOverdue: Bool?
    /** The user's percentage score for this assignment */
    public var percentageScore: Float?
    /** True if this assignment was created by a Rule */
    public var isRule: Bool?
    /** True if this assignment was created manually */
    public var isManual: Bool?
    /** True if the assessment was passed */
    public var isPassed: Bool?
    /** True if the assignment is based on latest module */
    public var isLatest: Bool?
    /** The URI for this object */
    public var selfUri: String?
    /** The Learning Assignment state */
    public var state: State?
    /** The recommended completion date of the assignment. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateRecommendedForCompletion: Date?
    /** The version of Learning module assigned */
    public var version: Int?
    /** The Learning module object associated with this assignment */
    public var module: LearningModule?
    /** The user to whom the assignment is assigned */
    public var user: UserReference?
    /** The assessment form associated with this assignment */
    public var assessmentForm: AssessmentForm?
    /** The length in minutes of the assignment */
    public var lengthInMinutes: Int?

    public init(_id: String?, assessment: LearningAssessment?, createdBy: UserReference?, dateCreated: Date?, modifiedBy: UserReference?, dateModified: Date?, isOverdue: Bool?, percentageScore: Float?, isRule: Bool?, isManual: Bool?, isPassed: Bool?, isLatest: Bool?, selfUri: String?, state: State?, dateRecommendedForCompletion: Date?, version: Int?, module: LearningModule?, user: UserReference?, assessmentForm: AssessmentForm?, lengthInMinutes: Int?) {
        self._id = _id
        self.assessment = assessment
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
        self.isOverdue = isOverdue
        self.percentageScore = percentageScore
        self.isRule = isRule
        self.isManual = isManual
        self.isPassed = isPassed
        self.isLatest = isLatest
        self.selfUri = selfUri
        self.state = state
        self.dateRecommendedForCompletion = dateRecommendedForCompletion
        self.version = version
        self.module = module
        self.user = user
        self.assessmentForm = assessmentForm
        self.lengthInMinutes = lengthInMinutes
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case assessment
        case createdBy
        case dateCreated
        case modifiedBy
        case dateModified
        case isOverdue
        case percentageScore
        case isRule
        case isManual
        case isPassed
        case isLatest
        case selfUri
        case state
        case dateRecommendedForCompletion
        case version
        case module
        case user
        case assessmentForm
        case lengthInMinutes
    }


}




public class LearningAssignmentAggregateParam: Codable {



    public enum Metrics: String, Codable { 
        case nactivities = "nActivities"
        case nplannedactivities = "nPlannedActivities"
        case ninprogressactivities = "nInProgressActivities"
        case ncompleteactivities = "nCompleteActivities"
        case noverdueactivities = "nOverdueActivities"
        case ninvalidscheduleactivities = "nInvalidScheduleActivities"
        case npassedactivities = "nPassedActivities"
        case nfailedactivities = "nFailedActivities"
        case oactivityscore = "oActivityScore"
        case nnotcompletedactivities = "nNotCompletedActivities"
    }

    public enum GroupBy: String, Codable { 
        case attendeeid = "attendeeId"
    }



    /** Specifies the range of due dates to be used for filtering. Milliseconds will be truncated. A maximum of 1 year can be specified in the range. End date is not inclusive. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** The list of metrics to be returned. If omitted, all metrics are returned. */
    public var metrics: [Metrics]?
    /** Specifies if the aggregated data is combined into a single set of metrics (groupBy is empty or not specified), or contains an element per attendeeId (groupBy is \"attendeeId\") */
    public var groupBy: [GroupBy]?
    /** The filter applied to the data.  This is ANDed with the interval parameter.  */
    public var filter: LearningAssignmentAggregateQueryRequestFilter?

    public init(interval: String?, metrics: [Metrics]?, groupBy: [GroupBy]?, filter: LearningAssignmentAggregateQueryRequestFilter?) {
        self.interval = interval
        self.metrics = metrics
        self.groupBy = groupBy
        self.filter = filter
    }


}




public class LearningAssignmentAggregateQueryRequestPredicate: Codable {

    public enum Dimension: String, Codable { 
        case attendeeid = "attendeeId"
        case type = "type"
        case moduleid = "moduleId"
        case ispassed = "isPassed"
    }



    /** Each predicates specifies a dimension. */
    public var dimension: Dimension?
    /** Corresponding value for dimensions in predicates. If the dimension is type, Valid Values: Informational, AssessedContent, Assessment */
    public var value: String?

    public init(dimension: Dimension?, value: String?) {
        self.dimension = dimension
        self.value = value
    }


}




public class LearningAssignmentAggregateResponse: Codable {



    /** The results of the query */
    public var results: [LearningAssignmentAggregateQueryResponseGroupedData]?

    public init(results: [LearningAssignmentAggregateQueryResponseGroupedData]?) {
        self.results = results
    }


}




public class LearningAssignmentBulkAddResponse: Codable {





    /** The learning assignments that were assigned correctly */
    public var entities: [LearningAssignment]?
    /** The items that were not allowed to be assigned */
    public var disallowedEntities: [DisallowedEntityLearningAssignmentItem]?

    public init(entities: [LearningAssignment]?, disallowedEntities: [DisallowedEntityLearningAssignmentItem]?) {
        self.entities = entities
        self.disallowedEntities = disallowedEntities
    }


}




public class LearningAssignmentRuleRunTopicLearningAssignmentRuleRunNotification: Codable {





    public var entities: [LearningAssignmentRuleRunTopicLearningAssignmentsCreated]?
    public var total: Int?

    public init(entities: [LearningAssignmentRuleRunTopicLearningAssignmentsCreated]?, total: Int?) {
        self.entities = entities
        self.total = total
    }


}




public class LearningAssignmentUser: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}



/** List of users matching the learning module rule */

public class LearningAssignmentUserListing: Codable {























    public var entities: [LearningAssignmentUser]?
    public var pageSize: Int?
    public var pageNumber: Int?
    /** The number of users matching search term */
    public var total: Int64?
    /** The total number of users */
    public var unfilteredTotal: Int?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [LearningAssignmentUser]?, pageSize: Int?, pageNumber: Int?, total: Int64?, unfilteredTotal: Int?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.unfilteredTotal = unfilteredTotal
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** Learning module response */

public class LearningModule: Codable {



















    public enum Source: String, Codable { 
        case userCreated = "UserCreated"
        case genesysBeyond = "GenesysBeyond"
    }













    public enum ModelType: String, Codable { 
        case informational = "Informational"
        case assessedContent = "AssessedContent"
        case assessment = "Assessment"
        case external = "External"
    }













    public enum ArchivalMode: String, Codable { 
        case graceful = "Graceful"
        case immediate = "Immediate"
    }

    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of learning module */
    public var name: String?
    /** If true, learning module is excluded when retrieving modules for manual assignment */
    public var excludedFromCatalog: Bool?
    /** The user who created learning module */
    public var createdBy: UserReference?
    /** The date/time learning module was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The user who modified learning module */
    public var modifiedBy: UserReference?
    /** The date/time learning module was modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The version of published learning module */
    public var version: Int?
    /** The external ID of the learning module */
    public var externalId: String?
    /** The source of the learning module */
    public var source: Source?
    /** The rule for learning module; read-only, and only populated when requested via expand param. */
    public var rule: LearningModuleRule?
    /** The URI for this object */
    public var selfUri: String?
    /** If true, learning module is archived */
    public var isArchived: Bool?
    /** If true, learning module is published */
    public var isPublished: Bool?
    /** The description of learning module */
    public var _description: String?
    /** The completion time of learning module in days */
    public var completionTimeInDays: Int?
    /** The type for the learning module */
    public var type: ModelType?
    /** The list of inform steps in a learning module */
    public var informSteps: [LearningModuleInformStep]?
    /** The assessment form for learning module */
    public var assessmentForm: AssessmentForm?
    /** The learning module summary data */
    public var summaryData: LearningModuleSummary?
    /** The learning module reassign summary data */
    public var reassignSummaryData: LearningModuleReassignSummary?
    /** The cover art for the learning module */
    public var coverArt: LearningModuleCoverArtResponse?
    /** The recommended time in minutes to complete the module */
    public var lengthInMinutes: Int?
    /** The mode of archival for learning module */
    public var archivalMode: ArchivalMode?

    public init(_id: String?, name: String?, excludedFromCatalog: Bool?, createdBy: UserReference?, dateCreated: Date?, modifiedBy: UserReference?, dateModified: Date?, version: Int?, externalId: String?, source: Source?, rule: LearningModuleRule?, selfUri: String?, isArchived: Bool?, isPublished: Bool?, _description: String?, completionTimeInDays: Int?, type: ModelType?, informSteps: [LearningModuleInformStep]?, assessmentForm: AssessmentForm?, summaryData: LearningModuleSummary?, reassignSummaryData: LearningModuleReassignSummary?, coverArt: LearningModuleCoverArtResponse?, lengthInMinutes: Int?, archivalMode: ArchivalMode?) {
        self._id = _id
        self.name = name
        self.excludedFromCatalog = excludedFromCatalog
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
        self.version = version
        self.externalId = externalId
        self.source = source
        self.rule = rule
        self.selfUri = selfUri
        self.isArchived = isArchived
        self.isPublished = isPublished
        self._description = _description
        self.completionTimeInDays = completionTimeInDays
        self.type = type
        self.informSteps = informSteps
        self.assessmentForm = assessmentForm
        self.summaryData = summaryData
        self.reassignSummaryData = reassignSummaryData
        self.coverArt = coverArt
        self.lengthInMinutes = lengthInMinutes
        self.archivalMode = archivalMode
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case excludedFromCatalog
        case createdBy
        case dateCreated
        case modifiedBy
        case dateModified
        case version
        case externalId
        case source
        case rule
        case selfUri
        case isArchived
        case isPublished
        case _description = "description"
        case completionTimeInDays
        case type
        case informSteps
        case assessmentForm
        case summaryData
        case reassignSummaryData
        case coverArt
        case lengthInMinutes
        case archivalMode
    }


}



/** Learning module job response */

public class LearningModuleJobResponse: Codable {



    public enum Status: String, Codable { 
        case accepted = "Accepted"
        case running = "Running"
        case completed = "Completed"
        case failed = "Failed"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The status of learning module job */
    public var status: Status?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, status: Status?, selfUri: String?) {
        self._id = _id
        self.status = status
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case status
        case selfUri
    }


}



/** Learning module request */

public class LearningModuleRequest: Codable {









    public enum ModelType: String, Codable { 
        case informational = "Informational"
        case assessedContent = "AssessedContent"
        case assessment = "Assessment"
        case external = "External"
    }











    /** The name of learning module */
    public var name: String?
    /** The description of learning module */
    public var _description: String?
    /** The completion time of learning module in days */
    public var completionTimeInDays: Int?
    /** The list of inform steps in a learning module */
    public var informSteps: [LearningModuleInformStepRequest]?
    /** The type for the learning module */
    public var type: ModelType?
    /** The assessment form for learning module */
    public var assessmentForm: AssessmentForm?
    /** The cover art for the learning module */
    public var coverArt: LearningModuleCoverArtRequest?
    /** The recommended time in minutes to complete the module */
    public var lengthInMinutes: Int?
    /** If true, learning module is excluded when retrieving modules for manual assignment */
    public var excludedFromCatalog: Bool?
    /** The external ID of the learning module. Maximum length: 50 characters. */
    public var externalId: String?

    public init(name: String?, _description: String?, completionTimeInDays: Int?, informSteps: [LearningModuleInformStepRequest]?, type: ModelType?, assessmentForm: AssessmentForm?, coverArt: LearningModuleCoverArtRequest?, lengthInMinutes: Int?, excludedFromCatalog: Bool?, externalId: String?) {
        self.name = name
        self._description = _description
        self.completionTimeInDays = completionTimeInDays
        self.informSteps = informSteps
        self.type = type
        self.assessmentForm = assessmentForm
        self.coverArt = coverArt
        self.lengthInMinutes = lengthInMinutes
        self.excludedFromCatalog = excludedFromCatalog
        self.externalId = externalId
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _description = "description"
        case completionTimeInDays
        case informSteps
        case type
        case assessmentForm
        case coverArt
        case lengthInMinutes
        case excludedFromCatalog
        case externalId
    }


}




public class LearningModuleRuleParts: Codable {

    public enum Operation: String, Codable { 
        case include = "Include"
        case exclude = "Exclude"
    }

    public enum Selector: String, Codable { 
        case acdSkills = "AcdSkills"
        case agentName = "AgentName"
        case division = "Division"
        case group = "Group"
        case location = "Location"
        case queue = "Queue"
        case role = "Role"
        case team = "Team"
    }





    /** The learning module rule operation */
    public var operation: Operation?
    /** The learning module rule selector */
    public var selector: Selector?
    /** The value of rules */
    public var value: [String]?
    /** The order of rules in learning module rule */
    public var order: Int?

    public init(operation: Operation?, selector: Selector?, value: [String]?, order: Int?) {
        self.operation = operation
        self.selector = selector
        self.value = value
        self.order = order
    }


}



/** Learning module summary data */

public class LearningModuleSummary: Codable {









    /** The total number of assignments assigned for a learning module */
    public var assignedCount: Int?
    /** The number of assignments completed for a learning module */
    public var completedCount: Int?
    /** The number of assignments passed for a learning module */
    public var passedCount: Int?
    /** The sum of assignment scores for a learning module */
    public var completedSum: Float?

    public init(assignedCount: Int?, completedCount: Int?, passedCount: Int?, completedSum: Float?) {
        self.assignedCount = assignedCount
        self.completedCount = completedCount
        self.passedCount = passedCount
        self.completedSum = completedSum
    }


}




public class LearningSlotFullDayTimeOffMarker: Codable {













    /** The date of the time off marker, interpreted in the business unit's time zone. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var businessUnitDate: Date?
    /** The length of the time off marker in minutes */
    public var lengthMinutes: Int?
    /** The description of the time off marker */
    public var _description: String?
    /** The ID of the activity code associated with the time off marker */
    public var activityCodeId: String?
    /** Whether the time off marker is paid */
    public var paid: Bool?
    /** The ID of the time off request */
    public var timeOffRequestId: String?

    public init(businessUnitDate: Date?, lengthMinutes: Int?, _description: String?, activityCodeId: String?, paid: Bool?, timeOffRequestId: String?) {
        self.businessUnitDate = businessUnitDate
        self.lengthMinutes = lengthMinutes
        self._description = _description
        self.activityCodeId = activityCodeId
        self.paid = paid
        self.timeOffRequestId = timeOffRequestId
    }

    public enum CodingKeys: String, CodingKey { 
        case businessUnitDate
        case lengthMinutes
        case _description = "description"
        case activityCodeId
        case paid
        case timeOffRequestId
    }


}




public class LearningSlotWfmScheduleActivity: Codable {







    /** User that the schedule is for */
    public var user: UserReference?
    /** List of user's scheduled activities */
    public var activities: [LearningSlotScheduleActivity]?
    /** List of user's days off */
    public var fullDayTimeOffMarkers: [LearningSlotFullDayTimeOffMarker]?

    public init(user: UserReference?, activities: [LearningSlotScheduleActivity]?, fullDayTimeOffMarkers: [LearningSlotFullDayTimeOffMarker]?) {
        self.user = user
        self.activities = activities
        self.fullDayTimeOffMarkers = fullDayTimeOffMarkers
    }


}




public class LexBot: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** A description of the Lex bot */
    public var _description: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case selfUri
    }


}




public class LexBotAlias: Codable {









    public enum Status: String, Codable { 
        case building = "BUILDING"
        case ready = "READY"
        case failed = "FAILED"
        case notBuilt = "NOT_BUILT"
    }



    public enum Language: String, Codable { 
        case enUs = "en-US"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The Lex bot this is an alias for */
    public var bot: LexBot?
    /** The version of the Lex bot this alias points at */
    public var botVersion: String?
    /** The status of the Lex bot alias */
    public var status: Status?
    /** If the status is FAILED, Amazon Lex explains why it failed to build the bot */
    public var failureReason: String?
    /** The target language of the Lex bot */
    public var language: Language?
    /** An array of Intents associated with this bot alias */
    public var intents: [LexIntent]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, bot: LexBot?, botVersion: String?, status: Status?, failureReason: String?, language: Language?, intents: [LexIntent]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.bot = bot
        self.botVersion = botVersion
        self.status = status
        self.failureReason = failureReason
        self.language = language
        self.intents = intents
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case bot
        case botVersion
        case status
        case failureReason
        case language
        case intents
        case selfUri
    }


}




public class LexSlot: Codable {









    /** The slot name */
    public var name: String?
    /** The slot description */
    public var _description: String?
    /** The slot type */
    public var type: String?
    /** The priority of the slot */
    public var priority: Int?

    public init(name: String?, _description: String?, type: String?, priority: Int?) {
        self.name = name
        self._description = _description
        self.type = type
        self.priority = priority
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _description = "description"
        case type
        case priority
    }


}




public class Library: Codable {











    public enum ResponseType: String, Codable { 
        case messagingTemplate = "MessagingTemplate"
        case campaignSmsTemplate = "CampaignSmsTemplate"
        case campaignEmailTemplate = "CampaignEmailTemplate"
        case footer = "Footer"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The library name. */
    public var name: String?
    /** Current version for this resource. */
    public var version: Int?
    /** User that created the library. */
    public var createdBy: User?
    /** The date and time the response was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** This value is deprecated. Responses representing message templates may be added to any library. */
    public var responseType: ResponseType?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, version: Int?, createdBy: User?, dateCreated: Date?, responseType: ResponseType?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.version = version
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.responseType = responseType
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case version
        case createdBy
        case dateCreated
        case responseType
        case selfUri
    }


}




public class LicenseDefinition: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var _description: String?
    public var permissions: Permissions?
    public var prerequisites: [AddressableLicenseDefinition]?
    public var comprises: [LicenseDefinition]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, _description: String?, permissions: Permissions?, prerequisites: [AddressableLicenseDefinition]?, comprises: [LicenseDefinition]?, selfUri: String?) {
        self._id = _id
        self._description = _description
        self.permissions = permissions
        self.prerequisites = prerequisites
        self.comprises = comprises
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case _description = "description"
        case permissions
        case prerequisites
        case comprises
        case selfUri
    }


}




public class LimitChangeRequestsEntityListing: Codable {









    public var entities: [LimitChangeRequestDetails]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [LimitChangeRequestDetails]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}



/** User information for a Line account */

public class LineId: Codable {





    /** The set of Line userIds that this person has. Each userId is specific to the Line channel that the user interacts with. */
    public var ids: [LineUserId]?
    /** The displayName of this person's account in Line */
    public var displayName: String?

    public init(ids: [LineUserId]?, displayName: String?) {
        self.ids = ids
        self.displayName = displayName
    }


}




public class LineIntegrationEntityListing: Codable {





















    public var entities: [LineIntegration]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [LineIntegration]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** Channel-specific User ID for Line accounts */

public class LineUserId: Codable {



    /** The unique channel-specific userId for the user */
    public var userId: String?

    public init(userId: String?) {
        self.userId = userId
    }


}




public class ListWrapperString: Codable {



    public var values: [String]?

    public init(values: [String]?) {
        self.values = values
    }


}




public class LocalEncryptionKeyRequest: Codable {







    /** The local configuration id that contains metadata on private local service */
    public var configId: String?
    /** Base 64 encoded public key, generated by the local service. */
    public var publicKey: String?
    /** The key pair id from the local service. */
    public var keypairId: String?

    public init(configId: String?, publicKey: String?, keypairId: String?) {
        self.configId = configId
        self.publicKey = publicKey
        self.keypairId = keypairId
    }


}




public class LocaleHealth: Codable {





    public enum StaticValidationResults: String, Codable { 
        case tooFewUtterances = "TooFewUtterances"
        case tooManyUtterances = "TooManyUtterances"
        case utteranceTooShort = "UtteranceTooShort"
        case utteranceTooLong = "UtteranceTooLong"
    }

    /** Overall health score for the intent. */
    public var overallScore: Float?
    /** Number of issues found in the intent. */
    public var issueCount: Int64?
    /** Validation results for the intent. */
    public var staticValidationResults: [StaticValidationResults]?

    public init(overallScore: Float?, issueCount: Int64?, staticValidationResults: [StaticValidationResults]?) {
        self.overallScore = overallScore
        self.issueCount = issueCount
        self.staticValidationResults = staticValidationResults
    }


}




public class Location: Codable {











    /** Unique identifier for the location */
    public var _id: String?
    /** Unique identifier for the location floorplan image */
    public var floorplanId: String?
    /** Users coordinates on the floorplan. Only used when floorplanImage is set */
    public var coordinates: [String:Double]?
    /** Optional description on the users location */
    public var notes: String?
    public var locationDefinition: LocationDefinition?

    public init(_id: String?, floorplanId: String?, coordinates: [String:Double]?, notes: String?, locationDefinition: LocationDefinition?) {
        self._id = _id
        self.floorplanId = floorplanId
        self.coordinates = coordinates
        self.notes = notes
        self.locationDefinition = locationDefinition
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case floorplanId
        case coordinates
        case notes
        case locationDefinition
    }


}




public class LocationAddress: Codable {















    public var city: String?
    public var country: String?
    public var countryName: String?
    public var state: String?
    public var street1: String?
    public var street2: String?
    public var zipcode: String?

    public init(city: String?, country: String?, countryName: String?, state: String?, street1: String?, street2: String?, zipcode: String?) {
        self.city = city
        self.country = country
        self.countryName = countryName
        self.state = state
        self.street1 = street1
        self.street2 = street2
        self.zipcode = zipcode
    }


}




public class LocationsSearchResponse: Codable {



















    /** The total number of results found */
    public var total: Int64?
    /** The total number of pages */
    public var pageCount: Int?
    /** The current page size */
    public var pageSize: Int?
    /** The current page number */
    public var pageNumber: Int?
    /** Q64 value for the previous page of results */
    public var previousPage: String?
    /** Q64 value for the current page of results */
    public var currentPage: String?
    /** Q64 value for the next page of results */
    public var nextPage: String?
    /** Resource types the search was performed against */
    public var types: [String]?
    /** Search results */
    public var results: [LocationDefinition]?

    public init(total: Int64?, pageCount: Int?, pageSize: Int?, pageNumber: Int?, previousPage: String?, currentPage: String?, nextPage: String?, types: [String]?, results: [LocationDefinition]?) {
        self.total = total
        self.pageCount = pageCount
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.previousPage = previousPage
        self.currentPage = currentPage
        self.nextPage = nextPage
        self.types = types
        self.results = results
    }


}




public class LogCaptureQueryResponse: Codable {









    public var entities: [LogEntry]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [LogEntry]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class LogEntry: Codable {







    /** Level of log entry */
    public var level: String?
    /** Log message */
    public var message: String?
    /** Timestamp of log entry */
    public var timestamp: Int64?

    public init(level: String?, message: String?, timestamp: Int64?) {
        self.level = level
        self.message = message
        self.timestamp = timestamp
    }


}




public class LongTermForecastResult: Codable {







    /** The forecast data broken up by planning group */
    public var planningGroups: [LongTermForecastPlanningGroupData]?
    /** The reference start date relative to the business unit time zone in this forecast. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var referenceStartDate: Date?
    /** The number of weeks in this forecast */
    public var weekCount: Int?

    public init(planningGroups: [LongTermForecastPlanningGroupData]?, referenceStartDate: Date?, weekCount: Int?) {
        self.planningGroups = planningGroups
        self.referenceStartDate = referenceStartDate
        self.weekCount = weekCount
    }


}




public class MailFromResult: Codable {

    public enum Status: String, Codable { 
        case failed = "FAILED"
        case pending = "PENDING"
        case verified = "VERIFIED"
        case unknown = "UNKNOWN"
    }





    /** The verification status. */
    public var status: Status?
    /** The list of DNS records that pertain that need to exist for verification. */
    public var records: [Record]?
    /** The custom MAIL FROM domain. */
    public var mailFromDomain: String?

    public init(status: Status?, records: [Record]?, mailFromDomain: String?) {
        self.status = status
        self.records = records
        self.mailFromDomain = mailFromDomain
    }


}




public class Markdown: Codable {



    /** whether or not markdown is enabled */
    public var enabled: Bool?

    public init(enabled: Bool?) {
        self.enabled = enabled
    }


}




public class MaxParticipants: Codable {



    /** The maximum number of participants that are allowed on a conversation. */
    public var maxParticipants: Int?

    public init(maxParticipants: Int?) {
        self.maxParticipants = maxParticipants
    }


}




public class MediaSummary: Codable {





    public var contactCenter: MediaSummaryDetail?
    public var enterprise: MediaSummaryDetail?

    public init(contactCenter: MediaSummaryDetail?, enterprise: MediaSummaryDetail?) {
        self.contactCenter = contactCenter
        self.enterprise = enterprise
    }


}




public class MediaSummaryDetail: Codable {





    public var active: Int?
    public var acw: Int?

    public init(active: Int?, acw: Int?) {
        self.active = active
        self.acw = acw
    }


}




public class MediaUtilization: Codable {







    /** Defines the maximum number of conversations of this type that an agent can handle at one time. */
    public var maximumCapacity: Int?
    /** Defines the list of other media types that can interrupt a conversation of this media type.  Values include call, chat, email, callback, and message. */
    public var interruptableMediaTypes: [String]?
    /** If true, then track non-ACD conversations against utilization */
    public var includeNonAcd: Bool?

    public init(maximumCapacity: Int?, interruptableMediaTypes: [String]?, includeNonAcd: Bool?) {
        self.maximumCapacity = maximumCapacity
        self.interruptableMediaTypes = interruptableMediaTypes
        self.includeNonAcd = includeNonAcd
    }


}



/** The associated user reference as a member of a performance profile */

public class Member: Codable {





    /** The user's id */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class MemberGroup: Codable {







    public enum ModelType: String, Codable { 
        case team = "TEAM"
        case group = "GROUP"
        case skillgroup = "SKILLGROUP"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    /** The group type */
    public var type: ModelType?
    /** The number of members in this group */
    public var memberCount: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, type: ModelType?, memberCount: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.type = type
        self.memberCount = memberCount
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case type
        case memberCount
        case selfUri
    }


}




public class MemberListing: Codable {



    public var entities: [Member]?

    public init(entities: [Member]?) {
        self.entities = entities
    }


}



/** Message content element. If contentType = \"Attachment\" only one item is allowed. */

public class MessageContent: Codable {

    public enum ContentType: String, Codable { 
        case attachment = "Attachment"
        case location = "Location"
        case quickReply = "QuickReply"
        case notification = "Notification"
        case genericTemplate = "GenericTemplate"
        case listTemplate = "ListTemplate"
        case postback = "Postback"
        case reactions = "Reactions"
        case mention = "Mention"
        case buttonResponse = "ButtonResponse"
        case story = "Story"
        case card = "Card"
        case carousel = "Carousel"
        case text = "Text"
        case quickReplyV2 = "QuickReplyV2"
    }































    /** Type of this content element. */
    public var contentType: ContentType?
    /** Location content. */
    public var location: ContentLocation?
    /** Attachment content. */
    public var attachment: ContentAttachment?
    /** Quick reply content. */
    public var quickReply: ContentQuickReply?
    /** Button response content. */
    public var buttonResponse: ContentButtonResponse?
    /** Generic content (Deprecated). */
    public var generic: ContentGeneric?
    /** List content (Deprecated). */
    public var list: ContentList?
    /** Template notification content. */
    public var template: ContentNotificationTemplate?
    /** A set of reactions to a message. */
    public var reactions: [ContentReaction]?
    /** Mention content. */
    public var mention: MessagingRecipient?
    /** Structured message postback (Deprecated). */
    public var postback: ContentPostback?
    /** Ephemeral story content. */
    public var story: ContentStory?
    /** Card content */
    public var card: ContentCard?
    /** Carousel content */
    public var carousel: ContentCarousel?
    /** Text content. */
    public var text: ContentText?
    /** Quick reply V2 content. */
    public var quickReplyV2: ContentQuickReplyV2?

    public init(contentType: ContentType?, location: ContentLocation?, attachment: ContentAttachment?, quickReply: ContentQuickReply?, buttonResponse: ContentButtonResponse?, generic: ContentGeneric?, list: ContentList?, template: ContentNotificationTemplate?, reactions: [ContentReaction]?, mention: MessagingRecipient?, postback: ContentPostback?, story: ContentStory?, card: ContentCard?, carousel: ContentCarousel?, text: ContentText?, quickReplyV2: ContentQuickReplyV2?) {
        self.contentType = contentType
        self.location = location
        self.attachment = attachment
        self.quickReply = quickReply
        self.buttonResponse = buttonResponse
        self.generic = generic
        self.list = list
        self.template = template
        self.reactions = reactions
        self.mention = mention
        self.postback = postback
        self.story = story
        self.card = card
        self.carousel = carousel
        self.text = text
        self.quickReplyV2 = quickReplyV2
    }


}




public class MessageInfo: Codable {









    /** Key that can be used to localize the message. */
    public var localizableMessageCode: String?
    /** Description of the message. */
    public var message: String?
    /** Message with template fields for variable replacement. */
    public var messageWithParams: String?
    /** Map with fields for variable replacement. */
    public var messageParams: [String:String]?

    public init(localizableMessageCode: String?, message: String?, messageWithParams: String?, messageParams: [String:String]?) {
        self.localizableMessageCode = localizableMessageCode
        self.message = message
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
    }


}




public class MessageMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case parked = "parked"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDonotdisturb = "endpoint.donotdisturb"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferDonotdisturb = "transfer.donotdisturb"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
    }





































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }















    public enum ModelType: String, Codable { 
        case unknown = "unknown"
        case sms = "sms"
        case twitter = "twitter"
        case facebook = "facebook"
        case line = "line"
        case whatsapp = "whatsapp"
        case telegram = "telegram"
        case kakao = "kakao"
        case webmessaging = "webmessaging"
        case _open = "open"
        case instagram = "instagram"
    }











    /** The unique participant ID. */
    public var _id: String?
    /** The display friendly name of the participant. */
    public var name: String?
    /** The participant address. */
    public var address: String?
    /** The time when this participant first joined the conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startTime: Date?
    /** The time when this participant went connected for this media (eg: video connected time). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** The time when this participant went disconnected for this media (eg: video disconnected time). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?
    /** The time when this participant's hold started. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startHoldTime: Date?
    /** The participant's purpose.  Values can be: 'agent', 'user', 'customer', 'external', 'acd', 'ivr */
    public var purpose: String?
    /** The participant's state.  Values can be: 'alerting', 'connected', 'disconnected', 'dialing', 'contacting */
    public var state: State?
    /** The participant's direction.  Values can be: 'inbound' or 'outbound' */
    public var direction: Direction?
    /** The reason the participant was disconnected from the conversation. */
    public var disconnectType: DisconnectType?
    /** Value is true when the participant is on hold. */
    public var held: Bool?
    /** Value is true when the participant requires wrap-up. */
    public var wrapupRequired: Bool?
    /** The wrap-up prompt indicating the type of wrap-up to be performed. */
    public var wrapupPrompt: String?
    /** List of roles this participant's media has had on the conversation, ie monitor, coach, etc */
    public var mediaRoles: [String]?
    /** The PureCloud user for this participant. */
    public var user: DomainEntityRef?
    /** The PureCloud queue for this participant. */
    public var queue: DomainEntityRef?
    /** The PureCloud team for this participant. */
    public var team: DomainEntityRef?
    /** A list of ad-hoc attributes for the participant. */
    public var attributes: [String:String]?
    /** If the conversation ends in error, contains additional error details. */
    public var errorInfo: ErrorInfo?
    /** The Engage script that should be used by this participant. */
    public var script: DomainEntityRef?
    /** The amount of time the participant has to complete wrap-up. */
    public var wrapupTimeoutMs: Int?
    /** Value is true when the participant has skipped wrap-up. */
    public var wrapupSkipped: Bool?
    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutMs: Int?
    /** The source provider for the communication. */
    public var provider: String?
    /** If this participant represents an external contact, then this will be the reference for the external contact. */
    public var externalContact: DomainEntityRef?
    /** If this participant represents an external org, then this will be the reference for the external org. */
    public var externalOrganization: DomainEntityRef?
    /** Wrapup for this participant, if it has been applied. */
    public var wrapup: Wrapup?
    /** The peer communication corresponding to a matching leg for this communication. */
    public var peer: String?
    /** The reason specifying why participant flagged the conversation. */
    public var flaggedReason: FlaggedReason?
    /** Journey System data/context that is applicable to this communication.  When used for historical purposes, the context should be immutable.  When null, there is no applicable Journey System context. */
    public var journeyContext: JourneyContext?
    /** Information on how a communication should be routed to an agent. */
    public var conversationRoutingData: ConversationRoutingData?
    /** The timestamp when this participant started after-call work. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAcwTime: Date?
    /** The timestamp when this participant ended after-call work. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endAcwTime: Date?
    /** Address for the participant on receiving side of the message conversation. If the address is a phone number, E.164 format is recommended. */
    public var toAddress: Address?
    /** Address for the participant on the sending side of the message conversation. If the address is a phone number, E.164 format is recommended. */
    public var fromAddress: Address?
    /** Message instance details on the communication. */
    public var messages: [MessageDetails]?
    /** Indicates the type of message platform from which the message originated. */
    public var type: ModelType?
    /** Indicates the country where the recipient is associated in ISO 3166-1 alpha-2 format. */
    public var recipientCountry: String?
    /** The type of the recipient. Eg: Provisioned phoneNumber is the recipient for sms message type. */
    public var recipientType: String?
    /** If true, the participant member is authenticated. */
    public var authenticated: Bool?
    /** The ID of the participant being monitored when performing a message monitor. */
    public var monitoredParticipantId: String?
    /** The participant being monitored when performing a message monitor. */
    public var monitoredParticipant: AddressableEntityRef?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, mediaRoles: [String]?, user: DomainEntityRef?, queue: DomainEntityRef?, team: DomainEntityRef?, attributes: [String:String]?, errorInfo: ErrorInfo?, script: DomainEntityRef?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, alertingTimeoutMs: Int?, provider: String?, externalContact: DomainEntityRef?, externalOrganization: DomainEntityRef?, wrapup: Wrapup?, peer: String?, flaggedReason: FlaggedReason?, journeyContext: JourneyContext?, conversationRoutingData: ConversationRoutingData?, startAcwTime: Date?, endAcwTime: Date?, toAddress: Address?, fromAddress: Address?, messages: [MessageDetails]?, type: ModelType?, recipientCountry: String?, recipientType: String?, authenticated: Bool?, monitoredParticipantId: String?, monitoredParticipant: AddressableEntityRef?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.mediaRoles = mediaRoles
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.peer = peer
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.conversationRoutingData = conversationRoutingData
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.toAddress = toAddress
        self.fromAddress = fromAddress
        self.messages = messages
        self.type = type
        self.recipientCountry = recipientCountry
        self.recipientType = recipientType
        self.authenticated = authenticated
        self.monitoredParticipantId = monitoredParticipantId
        self.monitoredParticipant = monitoredParticipant
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case mediaRoles
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalOrganization
        case wrapup
        case peer
        case flaggedReason
        case journeyContext
        case conversationRoutingData
        case startAcwTime
        case endAcwTime
        case toAddress
        case fromAddress
        case messages
        case type
        case recipientCountry
        case recipientType
        case authenticated
        case monitoredParticipantId
        case monitoredParticipant
    }


}




public class MessagingCampaignDiagnostics: Codable {



    /** Current number of time zone rescheduled messages on the campaign */
    public var timeZoneRescheduledContactsCount: Int?

    public init(timeZoneRescheduledContactsCount: Int?) {
        self.timeZoneRescheduledContactsCount = timeZoneRescheduledContactsCount
    }


}




public class MessagingProgressTransferEvent: Codable {













    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** The id (V4 UUID) used to identify the transfer already started by the external platform. */
    public var commandId: String?
    /** The id (V4 UUID) of the communication that is being transferred. */
    public var objectCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred to. */
    public var destinationCommunicationId: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, commandId: String?, objectCommunicationId: String?, destinationCommunicationId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.commandId = commandId
        self.objectCommunicationId = objectCommunicationId
        self.destinationCommunicationId = destinationCommunicationId
    }


}



/** Messaging setting for messaging platform integrations */

public class MessagingSetting: Codable {





















    /** The messaging Setting unique identifier associated with this integration */
    public var _id: String?
    /** The messaging Setting profile name */
    public var name: String?
    /** Date this messaging setting was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date this messaging setting was modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Version number */
    public var version: String?
    /** User reference that created this Setting */
    public var createdBy: DomainEntityRef?
    /** User reference that modified this Setting */
    public var updatedBy: DomainEntityRef?
    /** Configuration relating to message contents */
    public var content: ContentSetting?
    /** Configuration relating to events which may occur */
    public var event: EventSetting?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: String?, createdBy: DomainEntityRef?, updatedBy: DomainEntityRef?, content: ContentSetting?, event: EventSetting?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.createdBy = createdBy
        self.updatedBy = updatedBy
        self.content = content
        self.event = event
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case createdBy
        case updatedBy
        case content
        case event
        case selfUri
    }


}



/** Messaging setting for messaging platform integrations */

public class MessagingSettingRequest: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The messaging Setting profile name */
    public var name: String?
    /** Settings relating to message contents */
    public var content: ContentSetting?
    /** Settings relating to events which may occur */
    public var event: EventSetting?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, content: ContentSetting?, event: EventSetting?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.content = content
        self.event = event
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case content
        case event
        case selfUri
    }


}



/** Data property required as input for installing an accelerator */

public class MetadataProperty: Codable {















    /** the data type of the input property */
    public var type: String?
    /** user-friendly name of the input property */
    public var displayname: String?
    /** brief description of the input property */
    public var _description: String?
    /** whether the property's value should be hidden from display */
    public var sensitive: String?
    /** optional URL with addition information about the input property */
    public var help: String?
    /** optional default value of the input property */
    public var _default: String?
    /** set of possible values if the input property is an enumeration */
    public var _enum: [String]?

    public init(type: String?, displayname: String?, _description: String?, sensitive: String?, help: String?, _default: String?, _enum: [String]?) {
        self.type = type
        self.displayname = displayname
        self._description = _description
        self.sensitive = sensitive
        self.help = help
        self._default = _default
        self._enum = _enum
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case displayname
        case _description = "description"
        case sensitive
        case help
        case _default = "default"
        case _enum = "enum"
    }


}



/** List of resources created or modified as a result of running an accelerator */

public class MetadataResults: Codable {



    /** list of resources */
    public var entities: [MetadataResultEntity]?

    public init(entities: [MetadataResultEntity]?) {
        self.entities = entities
    }


}




public class MetricDefinition: Codable {





    public enum UnitType: String, Codable { 
        case _none = "None"
        case percent = "Percent"
        case currency = "Currency"
        case seconds = "Seconds"
        case number = "Number"
        case attendanceStatus = "AttendanceStatus"
        case unit = "Unit"
    }



















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The type of associated metric unit */
    public var unitType: UnitType?
    /** An alternate name for this metric definition, often abbreviation */
    public var shortName: String?
    /** Metric names used as dividend */
    public var dividendMetrics: [String]?
    /** Metric names used as divisor */
    public var divisorMetrics: [String]?
    /** A predefined default objective for this metric */
    public var defaultObjective: DefaultObjective?
    /** An optional field to specify if this metric definition is locked to certain template. e.g. punctuality */
    public var lockTemplateId: String?
    /** Flag to indicate if this metricDefinition allows filter based on media types */
    public var mediaTypeFilteringAllowed: Bool?
    /** Flag to indicate if this metricDefinition allows filter based on initial direction */
    public var initialDirectionFilteringAllowed: Bool?
    /** Flag to indicate if this metricDefinition allows filter based on queues */
    public var queueFilteringAllowed: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, unitType: UnitType?, shortName: String?, dividendMetrics: [String]?, divisorMetrics: [String]?, defaultObjective: DefaultObjective?, lockTemplateId: String?, mediaTypeFilteringAllowed: Bool?, initialDirectionFilteringAllowed: Bool?, queueFilteringAllowed: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.unitType = unitType
        self.shortName = shortName
        self.dividendMetrics = dividendMetrics
        self.divisorMetrics = divisorMetrics
        self.defaultObjective = defaultObjective
        self.lockTemplateId = lockTemplateId
        self.mediaTypeFilteringAllowed = mediaTypeFilteringAllowed
        self.initialDirectionFilteringAllowed = initialDirectionFilteringAllowed
        self.queueFilteringAllowed = queueFilteringAllowed
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case unitType
        case shortName
        case dividendMetrics
        case divisorMetrics
        case defaultObjective
        case lockTemplateId
        case mediaTypeFilteringAllowed
        case initialDirectionFilteringAllowed
        case queueFilteringAllowed
        case selfUri
    }


}




public class MinerErrorInfo: Codable {









    public var message: String?
    public var code: String?
    /** Error message with params included. */
    public var messageWithParams: String?
    /** Map of variables and params for the error message. */
    public var messageParams: [String:JSON]?

    public init(message: String?, code: String?, messageWithParams: String?, messageParams: [String:JSON]?) {
        self.message = message
        self.code = code
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
    }


}




public class MinerExecuteRequest: Codable {







    public enum MediaType: String, Codable { 
        case chat = "Chat"
        case call = "Call"
        case message = "Message"
        case email = "Email"
    }

    public enum ParticipantType: String, Codable { 
        case customer = "Customer"
        case agent = "Agent"
        case both = "Both"
    }



    /** Start date for the date range to mine. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStart: Date?
    /** End date for the date range to mine. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEnd: Date?
    /** Location of input conversations. */
    public var uploadKey: String?
    /** Media type for filtering conversations. */
    public var mediaType: MediaType?
    /** Type of the participant, either agent, customer or both. */
    public var participantType: ParticipantType?
    /** List of queue IDs for filtering conversations. */
    public var queueIds: [String]?

    public init(dateStart: Date?, dateEnd: Date?, uploadKey: String?, mediaType: MediaType?, participantType: ParticipantType?, queueIds: [String]?) {
        self.dateStart = dateStart
        self.dateEnd = dateEnd
        self.uploadKey = uploadKey
        self.mediaType = mediaType
        self.participantType = participantType
        self.queueIds = queueIds
    }


}




public class ModelingProcessingError: Codable {

    public enum InternalErrorCode: String, Codable { 
        case modelInputMissing = "ModelInputMissing"
        case modelInputInvalid = "ModelInputInvalid"
        case modelFailed = "ModelFailed"
    }



    /** An internal code representing the type of error. ModelInputMissing for 'Model Builder inputs not found.' ModelInputInvalid for 'Model Builder inputs are invalid. Ensure the input data format is correct.' ModelFailed for 'An error occured while building the model with the given input.' */
    public var internalErrorCode: InternalErrorCode?
    /** A text description of the error */
    public var _description: String?

    public init(internalErrorCode: InternalErrorCode?, _description: String?) {
        self.internalErrorCode = internalErrorCode
        self._description = _description
    }

    public enum CodingKeys: String, CodingKey { 
        case internalErrorCode
        case _description = "description"
    }


}




public class MuAgentQueueTimeRequest: Codable {





    /** ID of the management unit */
    public var managementUnitId: String?
    /** List of Agent queue times within the management unit */
    public var agentOnQueueTimes: [AgentQueueTimeRequest]?

    public init(managementUnitId: String?, agentOnQueueTimes: [AgentQueueTimeRequest]?) {
        self.managementUnitId = managementUnitId
        self.agentOnQueueTimes = agentOnQueueTimes
    }


}




public class MutableUserPresence: Codable {



















    /** The user's id */
    public var _id: String?
    public var name: String?
    /** Deprecated - The sourceID field should be used as a replacement. */
    public var source: String?
    /** Represents the ID of a registered source */
    public var sourceId: String?
    /** A boolean used to tell whether or not to set this presence source as the primary on a PATCH */
    public var primary: Bool?
    public var presenceDefinition: PresenceDefinition?
    public var message: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, source: String?, sourceId: String?, primary: Bool?, presenceDefinition: PresenceDefinition?, message: String?, modifiedDate: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.source = source
        self.sourceId = sourceId
        self.primary = primary
        self.presenceDefinition = presenceDefinition
        self.message = message
        self.modifiedDate = modifiedDate
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case source
        case sourceId
        case primary
        case presenceDefinition
        case message
        case modifiedDate
        case selfUri
    }


}




public class NamedEntityDefinition: Codable {





    /** The name of the entity. */
    public var name: String?
    /** The name of the entity type. */
    public var type: String?

    public init(name: String?, type: String?) {
        self.name = name
        self.type = type
    }


}




public class NetworkConnectivity: Codable {









    /** The name of the network carrier. */
    public var carrier: String?
    /** Whether Bluetooth is enabled. */
    public var bluetoothEnabled: Bool?
    /** Whether Cellular is enabled. */
    public var cellularEnabled: Bool?
    /** Whether Wi-Fi is enabled. */
    public var wifiEnabled: Bool?

    public init(carrier: String?, bluetoothEnabled: Bool?, cellularEnabled: Bool?, wifiEnabled: Bool?) {
        self.carrier = carrier
        self.bluetoothEnabled = bluetoothEnabled
        self.cellularEnabled = cellularEnabled
        self.wifiEnabled = wifiEnabled
    }


}




public class NluDetectionRequest: Codable {





    /** The input subject to NLU detection. */
    public var input: NluDetectionInput?
    /** The context for the input to NLU detection. */
    public var context: NluDetectionContext?

    public init(input: NluDetectionInput?, context: NluDetectionContext?) {
        self.input = input
        self.context = context
    }


}




public class NluDomainVersion: Codable {



















    public enum TrainingStatus: String, Codable { 
        case untrained = "Untrained"
        case training = "Training"
        case trained = "Trained"
        case error = "Error"
        case unknown = "Unknown"
    }

    public enum EvaluationStatus: String, Codable { 
        case unevaluated = "Unevaluated"
        case evaluating = "Evaluating"
        case evaluated = "Evaluated"
        case error = "Error"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The NLU domain of the version. */
    public var domain: NluDomain?
    /** The description of the NLU domain version. */
    public var _description: String?
    /** The language that the NLU domain version supports. */
    public var language: String?
    /** Whether this NLU domain version has been published. */
    public var published: Bool?
    /** The date when the NLU domain version was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date when the NLU domain version was updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The date when the NLU domain version was trained. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateTrained: Date?
    /** The date when the NLU domain version was published. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var datePublished: Date?
    /** The training status of the NLU domain version. */
    public var trainingStatus: TrainingStatus?
    /** The evaluation status of the NLU domain version. */
    public var evaluationStatus: EvaluationStatus?
    /** The intents defined for this NLU domain version. */
    public var intents: [IntentDefinition]?
    /** The entity types defined for this NLU domain version. */
    public var entityTypes: [NamedEntityTypeDefinition]?
    /** The entities defined for this NLU domain version.This field is mutually exclusive with entityTypeBindings */
    public var entities: [NamedEntityDefinition]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, domain: NluDomain?, _description: String?, language: String?, published: Bool?, dateCreated: Date?, dateModified: Date?, dateTrained: Date?, datePublished: Date?, trainingStatus: TrainingStatus?, evaluationStatus: EvaluationStatus?, intents: [IntentDefinition]?, entityTypes: [NamedEntityTypeDefinition]?, entities: [NamedEntityDefinition]?, selfUri: String?) {
        self._id = _id
        self.domain = domain
        self._description = _description
        self.language = language
        self.published = published
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.dateTrained = dateTrained
        self.datePublished = datePublished
        self.trainingStatus = trainingStatus
        self.evaluationStatus = evaluationStatus
        self.intents = intents
        self.entityTypes = entityTypes
        self.entities = entities
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case domain
        case _description = "description"
        case language
        case published
        case dateCreated
        case dateModified
        case dateTrained
        case datePublished
        case trainingStatus
        case evaluationStatus
        case intents
        case entityTypes
        case entities
        case selfUri
    }


}




public class NluDomainVersionListing: Codable {





















    public var entities: [NluDomainVersion]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [NluDomainVersion]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class NluDomainVersionTrainingResponse: Codable {





    /** A message indicating result of the action. */
    public var message: String?
    public var version: NluDomainVersion?

    public init(message: String?, version: NluDomainVersion?) {
        self.message = message
        self.version = version
    }


}




public class NluUtteranceSegment: Codable {





    /** The text of the segment. */
    public var text: String?
    /** The entity annotation of the segment. */
    public var entity: NamedEntityAnnotation?

    public init(text: String?, entity: NamedEntityAnnotation?) {
        self.text = text
        self.entity = entity
    }


}



/** Model for a Nuance bot */

public class NuanceBot: Codable {



























    /** Nuance bot Id */
    public var _id: String?
    /** Nuance bot name */
    public var name: String?
    /** The Integration Id for this bot */
    public var integrationId: String?
    /** The Nuance Organization for this bot */
    public var nuanceOrganization: NuanceOrganization?
    /** The Application for this bot */
    public var application: NuanceApplication?
    /** The environment of the Nuance bot */
    public var nuanceEnvironment: NuanceEnvironment?
    /** The Geography of the Nuance bot */
    public var geography: NuanceGeography?
    /** client ID/Secret objects for the credentials that execute this Nuance bot */
    public var credentials: [NuanceBotCredentials]?
    /** List of available variables in this Nuance bot.  When querying, use the 'expand=variables' query param to populate this value */
    public var variables: [NuanceBotVariable]?
    /** List of transferNodes in this Nuance bot.  When querying, use the 'expand=transferNodes' query param to populate this value */
    public var transferNodes: [NuanceBotTransferNode]?
    /** List of locales associated with this Nuance bot.  Generally in the ISO format such as 'en-US' */
    public var locales: [String]?
    /** List of channels associated with this Nuance bot. */
    public var channels: [NuanceChannel]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, integrationId: String?, nuanceOrganization: NuanceOrganization?, application: NuanceApplication?, nuanceEnvironment: NuanceEnvironment?, geography: NuanceGeography?, credentials: [NuanceBotCredentials]?, variables: [NuanceBotVariable]?, transferNodes: [NuanceBotTransferNode]?, locales: [String]?, channels: [NuanceChannel]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.integrationId = integrationId
        self.nuanceOrganization = nuanceOrganization
        self.application = application
        self.nuanceEnvironment = nuanceEnvironment
        self.geography = geography
        self.credentials = credentials
        self.variables = variables
        self.transferNodes = transferNodes
        self.locales = locales
        self.channels = channels
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case integrationId
        case nuanceOrganization
        case application
        case nuanceEnvironment
        case geography
        case credentials
        case variables
        case transferNodes
        case locales
        case channels
        case selfUri
    }


}



/** Model for a Nuance bot environment */

public class NuanceEnvironment: Codable {









    /** The environment ID */
    public var _id: String?
    /** The environment name */
    public var name: String?
    /** The environment type, usually a value like SANDBOX or PRODUCTION */
    public var environmentDesignation: String?
    /** The host used to execute this bot, similar to 'api.nuance.com:443' */
    public var executionHost: String?

    public init(_id: String?, name: String?, environmentDesignation: String?, executionHost: String?) {
        self._id = _id
        self.name = name
        self.environmentDesignation = environmentDesignation
        self.executionHost = executionHost
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case environmentDesignation
        case executionHost
    }


}




public class OAuthClientEntityListing: Codable {





















    public var entities: [OAuthClientListing]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [OAuthClientListing]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ObjectiveZone: Codable {



    public enum DirectionType: String, Codable { 
        case up = "Up"
        case down = "Down"
        case flat = "Flat"
    }

    public enum ZoneType: String, Codable { 
        case good = "Good"
        case target = "Target"
        case great = "Great"
        case out = "Out"
    }









    /** label */
    public var label: String?
    /** direction type */
    public var directionType: DirectionType?
    /** zone type */
    public var zoneType: ZoneType?
    /** upper limit points */
    public var upperLimitPoints: Int?
    /** lower limit points */
    public var lowerLimitPoints: Int?
    /** upper limit value */
    public var upperLimitValue: Int?
    /** lower limit value */
    public var lowerLimitValue: Int?

    public init(label: String?, directionType: DirectionType?, zoneType: ZoneType?, upperLimitPoints: Int?, lowerLimitPoints: Int?, upperLimitValue: Int?, lowerLimitValue: Int?) {
        self.label = label
        self.directionType = directionType
        self.zoneType = zoneType
        self.upperLimitPoints = upperLimitPoints
        self.lowerLimitPoints = lowerLimitPoints
        self.upperLimitValue = upperLimitValue
        self.lowerLimitValue = lowerLimitValue
    }


}




public class OneLogin: Codable {























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var disabled: Bool?
    public var issuerURI: String?
    public var ssoTargetURI: String?
    public var sloURI: String?
    public var sloBinding: String?
    public var relyingPartyIdentifier: String?
    public var certificate: String?
    public var certificates: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, disabled: Bool?, issuerURI: String?, ssoTargetURI: String?, sloURI: String?, sloBinding: String?, relyingPartyIdentifier: String?, certificate: String?, certificates: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.disabled = disabled
        self.issuerURI = issuerURI
        self.ssoTargetURI = ssoTargetURI
        self.sloURI = sloURI
        self.sloBinding = sloBinding
        self.relyingPartyIdentifier = relyingPartyIdentifier
        self.certificate = certificate
        self.certificates = certificates
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case disabled
        case issuerURI
        case ssoTargetURI
        case sloURI
        case sloBinding
        case relyingPartyIdentifier
        case certificate
        case certificates
        case selfUri
    }


}



/** Open Messaging rich media message structure */

public class OpenEventNormalizedMessage: Codable {





    public enum ModelType: String, Codable { 
        case event = "Event"
    }



    /** Unique ID of the message generated by Messaging Platform. */
    public var _id: String?
    /** Channel-specific information that describes the message and the message channel/provider. */
    public var channel: OpenMessagingChannel?
    /** Message type. */
    public var type: ModelType?
    /** List of event elements. */
    public var events: [OpenMessageEvent]?

    public init(_id: String?, channel: OpenMessagingChannel?, type: ModelType?, events: [OpenMessageEvent]?) {
        self._id = _id
        self.channel = channel
        self.type = type
        self.events = events
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case channel
        case type
        case events
    }


}



/** Open Channel-specific information that describes the message and the message channel/provider. */

public class OpenInboundMessagingReceiptChannel: Codable {





    /** Information about the recipient the message is intended for. */
    public var to: OpenMessagingToRecipient?
    /** Original time of the event. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var time: Date?

    public init(to: OpenMessagingToRecipient?, time: Date?) {
        self.to = to
        self.time = time
    }


}



/** Open Event Messaging rich media message structure */

public class OpenInboundNormalizedEvent: Codable {





    /** Channel-specific information that describes the message and the message channel/provider. */
    public var channel: OpenInboundMessagingChannel?
    /** List of event elements. */
    public var events: [OpenEvent]?

    public init(channel: OpenInboundMessagingChannel?, events: [OpenEvent]?) {
        self.channel = channel
        self.events = events
    }


}



/** Open Messaging rich media message structure */

public class OpenInboundNormalizedMessage: Codable {









    /** Channel-specific information that describes the message and the message channel/provider. */
    public var channel: OpenInboundMessageMessagingChannel?
    /** Message text. */
    public var text: String?
    /** List of content elements. */
    public var content: [OpenInboundMessageContent]?
    /** Additional metadata about this message to capture non-channel specific data. */
    public var metadata: [String:String]?

    public init(channel: OpenInboundMessageMessagingChannel?, text: String?, content: [OpenInboundMessageContent]?, metadata: [String:String]?) {
        self.channel = channel
        self.text = text
        self.content = content
        self.metadata = metadata
    }


}




public class OpenIntegrationEntityListing: Codable {





















    public var entities: [OpenIntegration]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [OpenIntegration]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** Message event element. */

public class OpenMessageEvent: Codable {

    public enum EventType: String, Codable { 
        case typing = "Typing"
    }



    /** Type of this event element */
    public var eventType: EventType?
    /** Typing event. */
    public var typing: ConversationEventTyping?

    public init(eventType: EventType?, typing: ConversationEventTyping?) {
        self.eventType = eventType
        self.typing = typing
    }


}



/** Open Messaging rich media message structure */

public class OpenMessageNormalizedMessage: Codable {





    public enum ModelType: String, Codable { 
        case text = "Text"
    }







    /** Unique ID of the message generated by Messaging Platform. */
    public var _id: String?
    /** Channel-specific information that describes the message and the message channel/provider. */
    public var channel: OpenMessagingChannel?
    /** Message type. */
    public var type: ModelType?
    /** Message text. */
    public var text: String?
    /** List of content elements. */
    public var content: [OpenMessageContent]?
    /** Additional metadata about this message. */
    public var metadata: [String:String]?

    public init(_id: String?, channel: OpenMessagingChannel?, type: ModelType?, text: String?, content: [OpenMessageContent]?, metadata: [String:String]?) {
        self._id = _id
        self.channel = channel
        self.type = type
        self.text = text
        self.content = content
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case channel
        case type
        case text
        case content
        case metadata
    }


}



/** Channel-specific information that describes the message and the message channel/provider. */

public class OpenMessagingChannel: Codable {



    public enum Platform: String, Codable { 
        case _open = "Open"
    }

    public enum ModelType: String, Codable { 
        case _private = "Private"
    }











    /** The Messaging Platform integration ID. */
    public var _id: String?
    /** The provider type. */
    public var platform: Platform?
    /** Specifies if this message is part of a private or public conversation. */
    public var type: ModelType?
    /** Unique provider ID of the message such as a Facebook message ID. */
    public var messageId: String?
    /** Information about the recipient the message is sent to. */
    public var to: OpenMessagingToRecipient?
    /** Information about the recipient the message is received from. */
    public var from: OpenMessagingFromRecipient?
    /** Original time of the event. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var time: Date?
    /** Information about the channel. */
    public var metadata: JSON?

    public init(_id: String?, platform: Platform?, type: ModelType?, messageId: String?, to: OpenMessagingToRecipient?, from: OpenMessagingFromRecipient?, time: Date?, metadata: JSON?) {
        self._id = _id
        self.platform = platform
        self.type = type
        self.messageId = messageId
        self.to = to
        self.from = from
        self.time = time
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case platform
        case type
        case messageId
        case to
        case from
        case time
        case metadata
    }


}




public class Operation: Codable {

















    public enum ActionName: String, Codable { 
        case create = "CREATE"
        case checkin = "CHECKIN"
        case checkout = "CHECKOUT"
        case debug = "DEBUG"
        case delete = "DELETE"
        case history = "HISTORY"
        case publish = "PUBLISH"
        case revert = "REVERT"
        case save = "SAVE"
        case stateChange = "STATE_CHANGE"
        case update = "UPDATE"
        case validate = "VALIDATE"
    }

    public enum ActionStatus: String, Codable { 
        case locked = "LOCKED"
        case unlocked = "UNLOCKED"
        case started = "STARTED"
        case pendingGeneration = "PENDING_GENERATION"
        case pendingBackendNotification = "PENDING_BACKEND_NOTIFICATION"
        case success = "SUCCESS"
        case failure = "FAILURE"
    }

    public var _id: String?
    public var complete: Bool?
    public var user: User?
    public var client: DomainEntityRef?
    public var errorMessage: String?
    public var errorCode: String?
    public var errorDetails: [Detail]?
    public var errorMessageParams: [String:String]?
    /** Action name */
    public var actionName: ActionName?
    /** Action status */
    public var actionStatus: ActionStatus?

    public init(_id: String?, complete: Bool?, user: User?, client: DomainEntityRef?, errorMessage: String?, errorCode: String?, errorDetails: [Detail]?, errorMessageParams: [String:String]?, actionName: ActionName?, actionStatus: ActionStatus?) {
        self._id = _id
        self.complete = complete
        self.user = user
        self.client = client
        self.errorMessage = errorMessage
        self.errorCode = errorCode
        self.errorDetails = errorDetails
        self.errorMessageParams = errorMessageParams
        self.actionName = actionName
        self.actionStatus = actionStatus
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case complete
        case user
        case client
        case errorMessage
        case errorCode
        case errorDetails
        case errorMessageParams
        case actionName
        case actionStatus
    }


}




public class OrganizationFeatures: Codable {



























    public var realtimeCIC: Bool?
    public var purecloud: Bool?
    public var hipaa: Bool?
    public var ucEnabled: Bool?
    public var pci: Bool?
    public var purecloudVoice: Bool?
    public var xmppFederation: Bool?
    public var chat: Bool?
    public var informalPhotos: Bool?
    public var directory: Bool?
    public var contactCenter: Bool?
    public var unifiedCommunications: Bool?
    public var custserv: Bool?

    public init(realtimeCIC: Bool?, purecloud: Bool?, hipaa: Bool?, ucEnabled: Bool?, pci: Bool?, purecloudVoice: Bool?, xmppFederation: Bool?, chat: Bool?, informalPhotos: Bool?, directory: Bool?, contactCenter: Bool?, unifiedCommunications: Bool?, custserv: Bool?) {
        self.realtimeCIC = realtimeCIC
        self.purecloud = purecloud
        self.hipaa = hipaa
        self.ucEnabled = ucEnabled
        self.pci = pci
        self.purecloudVoice = purecloudVoice
        self.xmppFederation = xmppFederation
        self.chat = chat
        self.informalPhotos = informalPhotos
        self.directory = directory
        self.contactCenter = contactCenter
        self.unifiedCommunications = unifiedCommunications
        self.custserv = custserv
    }


}




public class OrganizationPresence: Codable {























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The label used for the system presence in each specified language */
    public var languageLabels: [String:String]?
    public var systemPresence: String?
    public var deactivated: Bool?
    public var primary: Bool?
    public var createdBy: User?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    public var modifiedBy: User?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, languageLabels: [String:String]?, systemPresence: String?, deactivated: Bool?, primary: Bool?, createdBy: User?, createdDate: Date?, modifiedBy: User?, modifiedDate: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.languageLabels = languageLabels
        self.systemPresence = systemPresence
        self.deactivated = deactivated
        self.primary = primary
        self.createdBy = createdBy
        self.createdDate = createdDate
        self.modifiedBy = modifiedBy
        self.modifiedDate = modifiedDate
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case languageLabels
        case systemPresence
        case deactivated
        case primary
        case createdBy
        case createdDate
        case modifiedBy
        case modifiedDate
        case selfUri
    }


}




public class OrganizationPresenceDefinitionEntityListing: Codable {







    public var total: Int64?
    public var entities: [OrganizationPresenceDefinition]?
    public var selfUri: String?

    public init(total: Int64?, entities: [OrganizationPresenceDefinition]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class OutOfOfficeEventUser: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class OutboundDomainEntityListing: Codable {





















    public var entities: [OutboundDomain]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [OutboundDomain]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class OutboundMessagingCampaignPostContactSmsEventTopicSMSAttributes: Codable {









    public var contactPhoneNumber: String?
    public var contactPhoneNumberColumnName: String?
    public var configuredSenderPhoneNumber: String?
    public var senderPhoneNumber: String?

    public init(contactPhoneNumber: String?, contactPhoneNumberColumnName: String?, configuredSenderPhoneNumber: String?, senderPhoneNumber: String?) {
        self.contactPhoneNumber = contactPhoneNumber
        self.contactPhoneNumberColumnName = contactPhoneNumberColumnName
        self.configuredSenderPhoneNumber = configuredSenderPhoneNumber
        self.senderPhoneNumber = senderPhoneNumber
    }


}




public class OutboundMessagingCampaignPreContactEmailEventTopicOutboundMessagingCampaignPreContactEmailEvent: Codable {



    public enum OutboundCampaignType: String, Codable { 
        case unknown = "UNKNOWN"
        case email = "EMAIL"
        case sms = "SMS"
    }



    public enum WrapupCode: String, Codable { 
        case unknown = "UNKNOWN"
        case outboundEmailsInvalidSkipped = "OUTBOUND_EMAILS_INVALID_SKIPPED"
        case outboundInvalidEmailAddress = "OUTBOUND_INVALID_EMAIL_ADDRESS"
        case outboundMaxEmailSubjectLengthExceeded = "OUTBOUND_MAX_EMAIL_SUBJECT_LENGTH_EXCEEDED"
        case outboundMaxEmailBodyLengthExceeded = "OUTBOUND_MAX_EMAIL_BODY_LENGTH_EXCEEDED"
        case outboundRuleErrorSkipped = "OUTBOUND_RULE_ERROR_SKIPPED"
        case outboundRuleSkipped = "OUTBOUND_RULE_SKIPPED"
        case outboundContactUncontactableSkipped = "OUTBOUND_CONTACT_UNCONTACTABLE_SKIPPED"
        case outboundNumberUncontactableSkipped = "OUTBOUND_NUMBER_UNCONTACTABLE_SKIPPED"
        case outboundContactAddressUncontactableSkipped = "OUTBOUND_CONTACT_ADDRESS_UNCONTACTABLE_SKIPPED"
        case ininOutboundZoneBlockedSkipped = "ININ_OUTBOUND_ZONE_BLOCKED_SKIPPED"
        case ininOutboundDncSkipped = "ININ_OUTBOUND_DNC_SKIPPED"
        case ininOutboundInternalErrorSkipped = "ININ_OUTBOUND_INTERNAL_ERROR_SKIPPED"
        case ininOutboundOnDoNotCallList = "ININ_OUTBOUND_ON_DO_NOT_CALL_LIST"
        case ininOutboundNotCallableTime = "ININ_OUTBOUND_NOT_CALLABLE_TIME"
    }













    public var eventTime: Date?
    public var outboundCampaignType: OutboundCampaignType?
    public var emailAttributes: OutboundMessagingCampaignPreContactEmailEventTopicEmailAttributes?
    public var wrapupCode: WrapupCode?
    public var outboundCampaignId: String?
    public var divisionId: String?
    public var contentTemplateId: String?
    public var outboundContactListId: String?
    public var outboundContactId: String?
    public var isCampaignAlwaysRunning: Bool?

    public init(eventTime: Date?, outboundCampaignType: OutboundCampaignType?, emailAttributes: OutboundMessagingCampaignPreContactEmailEventTopicEmailAttributes?, wrapupCode: WrapupCode?, outboundCampaignId: String?, divisionId: String?, contentTemplateId: String?, outboundContactListId: String?, outboundContactId: String?, isCampaignAlwaysRunning: Bool?) {
        self.eventTime = eventTime
        self.outboundCampaignType = outboundCampaignType
        self.emailAttributes = emailAttributes
        self.wrapupCode = wrapupCode
        self.outboundCampaignId = outboundCampaignId
        self.divisionId = divisionId
        self.contentTemplateId = contentTemplateId
        self.outboundContactListId = outboundContactListId
        self.outboundContactId = outboundContactId
        self.isCampaignAlwaysRunning = isCampaignAlwaysRunning
    }


}




public class OutboundMessagingMessagingCampaignConfigChangeContactSort: Codable {



    public enum Direction: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
    }





    public var fieldName: String?
    public var direction: Direction?
    /** Whether that column contains numeric data */
    public var numeric: Bool?
    public var additionalProperties: [String:JSON]?

    public init(fieldName: String?, direction: Direction?, numeric: Bool?, additionalProperties: [String:JSON]?) {
        self.fieldName = fieldName
        self.direction = direction
        self.numeric = numeric
        self.additionalProperties = additionalProperties
    }


}



/** An outbound-messaging messaging campaign SMS Config */

public class OutboundMessagingMessagingCampaignConfigChangeSmsConfig: Codable {









    /** The Contact List column specifying the message to send to the contact. */
    public var messageColumn: String?
    /** The Contact List column specifying the phone number to send a message to. */
    public var phoneColumn: String?
    public var senderSmsPhoneNumber: OutboundMessagingMessagingCampaignConfigChangeSmsPhoneNumberRef?
    public var contentTemplate: OutboundMessagingMessagingCampaignConfigChangeResponseRef?

    public init(messageColumn: String?, phoneColumn: String?, senderSmsPhoneNumber: OutboundMessagingMessagingCampaignConfigChangeSmsPhoneNumberRef?, contentTemplate: OutboundMessagingMessagingCampaignConfigChangeResponseRef?) {
        self.messageColumn = messageColumn
        self.phoneColumn = phoneColumn
        self.senderSmsPhoneNumber = senderSmsPhoneNumber
        self.contentTemplate = contentTemplate
    }


}



/** A reference for an SmsPhoneNumber */

public class OutboundMessagingMessagingCampaignConfigChangeSmsPhoneNumberRef: Codable {



    /** The unique phone number */
    public var phoneNumber: String?

    public init(phoneNumber: String?) {
        self.phoneNumber = phoneNumber
    }


}



/** A UriReference for a resource */

public class OutboundMessagingMessagingCampaignConfigChangeUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class OutboundMessagingMessagingCampaignProgressEventCampaignProgress: Codable {















    public var campaign: OutboundMessagingMessagingCampaignProgressEventUriReference?
    /** The number of contacts that have been called so far */
    public var numberOfContactsCalled: Double?
    /** The number of contacts that have been messaged so far */
    public var numberOfContactsMessaged: Double?
    /** The total number of contacts in the contact list */
    public var totalNumberOfContacts: Double?
    /** numberOfContactsContacted/totalNumberOfContacts*100 */
    public var percentage: Int?
    /** A map of skipped reasons and the number of contacts associated with each. */
    public var numberOfContactsSkipped: [String:Int]?
    public var additionalProperties: [String:JSON]?

    public init(campaign: OutboundMessagingMessagingCampaignProgressEventUriReference?, numberOfContactsCalled: Double?, numberOfContactsMessaged: Double?, totalNumberOfContacts: Double?, percentage: Int?, numberOfContactsSkipped: [String:Int]?, additionalProperties: [String:JSON]?) {
        self.campaign = campaign
        self.numberOfContactsCalled = numberOfContactsCalled
        self.numberOfContactsMessaged = numberOfContactsMessaged
        self.totalNumberOfContacts = totalNumberOfContacts
        self.percentage = percentage
        self.numberOfContactsSkipped = numberOfContactsSkipped
        self.additionalProperties = additionalProperties
    }


}




public class OutboundRoute: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }









    public enum Distribution: String, Codable { 
        case sequential = "SEQUENTIAL"
        case random = "RANDOM"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** The site associated to the outbound route. */
    public var classificationTypes: [String]?
    public var enabled: Bool?
    public var distribution: Distribution?
    /** Trunk base settings of trunkType \"EXTERNAL\".  This base must also be set on an edge logical interface for correct routing. */
    public var externalTrunkBases: [DomainEntityRef]?
    /** The site associated to the outbound route. */
    public var site: Site?
    /** Is this outbound route being managed remotely. */
    public var managed: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, classificationTypes: [String]?, enabled: Bool?, distribution: Distribution?, externalTrunkBases: [DomainEntityRef]?, site: Site?, managed: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.classificationTypes = classificationTypes
        self.enabled = enabled
        self.distribution = distribution
        self.externalTrunkBases = externalTrunkBases
        self.site = site
        self.managed = managed
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case classificationTypes
        case enabled
        case distribution
        case externalTrunkBases
        case site
        case managed
        case selfUri
    }


}




public class OutcomeConfig: Codable {



    /** A set of valid Outcome UUIDs used to optimize a KPI. */
    public var values: [String]?

    public init(values: [String]?) {
        self.values = values
    }


}




public class OutcomeProbabilityCondition: Codable {







    /** The outcome ID. */
    public var outcomeId: String?
    /** Probability value for the selected outcome at or above which the action map will trigger. */
    public var maximumProbability: Float?
    /** Additional probability condition, where if set, the action map will trigger if the current outcome probability is lower or equal to the value. */
    public var probability: Float?

    public init(outcomeId: String?, maximumProbability: Float?, probability: Float?) {
        self.outcomeId = outcomeId
        self.maximumProbability = maximumProbability
        self.probability = probability
    }


}




public class OutcomeScore: Codable {















    /** The outcome that the score was calculated for. */
    public var outcome: AddressableEntityRef?
    /** Represents the max probability reached in the session. */
    public var sessionMaxProbability: Float?
    /** Represents the likelihood of a customer reaching or achieving a given outcome. */
    public var probability: Float?
    /** (Deprecated: use the 'quantile' field instead) Represents the predicted probability's percentile score when compared with all other generated probabilities for a given outcome. */
    public var percentile: Int?
    /** (Deprecated: use the 'quantile' field instead) Represents the maximum likelihood percentile score reached for a given outcome by the current session. */
    public var sessionMaxPercentile: Int?
    /** Represents the quantity of sessions that have a maximum probability less than the predicted probability. */
    public var quantile: Float?
    /** Represents the quantity of sessions that have a maximum probability less than the predicted session max probability. */
    public var sessionMaxQuantile: Float?

    public init(outcome: AddressableEntityRef?, sessionMaxProbability: Float?, probability: Float?, percentile: Int?, sessionMaxPercentile: Int?, quantile: Float?, sessionMaxQuantile: Float?) {
        self.outcome = outcome
        self.sessionMaxProbability = sessionMaxProbability
        self.probability = probability
        self.percentile = percentile
        self.sessionMaxPercentile = sessionMaxPercentile
        self.quantile = quantile
        self.sessionMaxQuantile = sessionMaxQuantile
    }


}




public class OverallBestPoints: Codable {







    /** The requested division */
    public var division: Division?
    /** List of gamification best point items */
    public var bestPoints: [OverallBestPointsItem]?
    /** The targeted performance profile for the average points */
    public var performanceProfile: AddressableEntityRef?

    public init(division: Division?, bestPoints: [OverallBestPointsItem]?, performanceProfile: AddressableEntityRef?) {
        self.division = division
        self.bestPoints = bestPoints
        self.performanceProfile = performanceProfile
    }


}



/** Represents the parsed certificate information. */

public class ParsedCertificate: Codable {



    /** The details of the certificates that were parsed correctly. */
    public var certificateDetails: [CertificateDetails]?

    public init(certificateDetails: [CertificateDetails]?) {
        self.certificateDetails = certificateDetails
    }


}




public class PasswordRequirements: Codable {

















    public var minimumLength: Int?
    public var minimumDigits: Int?
    public var minimumLetters: Int?
    public var minimumUpper: Int?
    public var minimumLower: Int?
    public var minimumSpecials: Int?
    public var minimumAgeSeconds: Int?
    public var expirationDays: Int?

    public init(minimumLength: Int?, minimumDigits: Int?, minimumLetters: Int?, minimumUpper: Int?, minimumLower: Int?, minimumSpecials: Int?, minimumAgeSeconds: Int?, expirationDays: Int?) {
        self.minimumLength = minimumLength
        self.minimumDigits = minimumDigits
        self.minimumLetters = minimumLetters
        self.minimumUpper = minimumUpper
        self.minimumLower = minimumLower
        self.minimumSpecials = minimumSpecials
        self.minimumAgeSeconds = minimumAgeSeconds
        self.expirationDays = expirationDays
    }


}




public class PatchActionTemplate: Codable {







    public enum MediaType: String, Codable { 
        case webchat = "webchat"
        case webmessagingoffer = "webMessagingOffer"
        case contentoffer = "contentOffer"
        case integrationaction = "integrationAction"
        case architectflow = "architectFlow"
        case openaction = "openAction"
    }

    public enum State: String, Codable { 
        case active = "Active"
        case inactive = "Inactive"
        case deleted = "Deleted"
    }



    /** Name of the action template. */
    public var name: String?
    /** Description of the action template's functionality. */
    public var _description: String?
    /** The version of the action template. */
    public var version: Int?
    /** Media type of action described by the action template. */
    public var mediaType: MediaType?
    /** Whether the action template is currently active, inactive or deleted. */
    public var state: State?
    /** Properties used to configure an action of type content offer */
    public var contentOffer: PatchContentOffer?

    public init(name: String?, _description: String?, version: Int?, mediaType: MediaType?, state: State?, contentOffer: PatchContentOffer?) {
        self.name = name
        self._description = _description
        self.version = version
        self.mediaType = mediaType
        self.state = state
        self.contentOffer = contentOffer
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _description = "description"
        case version
        case mediaType
        case state
        case contentOffer
    }


}




public class PatchContentOffer: Codable {



    public enum DisplayMode: String, Codable { 
        case modal = "Modal"
        case overlay = "Overlay"
        case toast = "Toast"
    }

    public enum LayoutMode: String, Codable { 
        case textOnly = "TextOnly"
        case imageOnly = "ImageOnly"
        case leftText = "LeftText"
        case rightText = "RightText"
        case topText = "TopText"
        case bottomText = "BottomText"
    }











    /** URL for image displayed to the customer when displaying content offer. */
    public var imageUrl: String?
    /** The display mode of Genesys Widgets when displaying content offer. */
    public var displayMode: DisplayMode?
    /** The layout mode of the text shown to the user when displaying content offer. */
    public var layoutMode: LayoutMode?
    /** Title used in the header of the content offer. */
    public var title: String?
    /** Headline displayed above the body text of the content offer. */
    public var headline: String?
    /** Body text of the content offer. */
    public var body: String?
    /** Properties customizing the call to action button on the content offer. */
    public var callToAction: PatchCallToAction?
    /** Properties customizing the styling of the content offer. */
    public var style: PatchContentOfferStylingConfiguration?

    public init(imageUrl: String?, displayMode: DisplayMode?, layoutMode: LayoutMode?, title: String?, headline: String?, body: String?, callToAction: PatchCallToAction?, style: PatchContentOfferStylingConfiguration?) {
        self.imageUrl = imageUrl
        self.displayMode = displayMode
        self.layoutMode = layoutMode
        self.title = title
        self.headline = headline
        self.body = body
        self.callToAction = callToAction
        self.style = style
    }


}




public class PatchCriteria: Codable {







    public enum Operator: String, Codable { 
        case containsall = "containsAll"
        case containsany = "containsAny"
        case notcontainsall = "notContainsAll"
        case notcontainsany = "notContainsAny"
        case equal = "equal"
        case notequal = "notEqual"
        case greaterthan = "greaterThan"
        case greaterthanorequal = "greaterThanOrEqual"
        case lessthan = "lessThan"
        case lessthanorequal = "lessThanOrEqual"
        case startswith = "startsWith"
        case endswith = "endsWith"
    }

    /** The criteria key. */
    public var key: String?
    /** The criteria values. */
    public var values: [String]?
    /** Should criteria be case insensitive. */
    public var shouldIgnoreCase: Bool?
    /** The comparison operator. */
    public var _operator: Operator?

    public init(key: String?, values: [String]?, shouldIgnoreCase: Bool?, _operator: Operator?) {
        self.key = key
        self.values = values
        self.shouldIgnoreCase = shouldIgnoreCase
        self._operator = _operator
    }

    public enum CodingKeys: String, CodingKey { 
        case key
        case values
        case shouldIgnoreCase
        case _operator = "operator"
    }


}




public class PatchCtaButtonStyleProperties: Codable {







    public enum TextAlign: String, Codable { 
        case _left = "Left"
        case _right = "Right"
        case center = "Center"
    }



    /** Color of the text. (eg. #FFFFFF) */
    public var color: String?
    /** Font of the text. (eg. Helvetica) */
    public var font: String?
    /** Font size of the text. (eg. '12') */
    public var fontSize: String?
    /** Text alignment. */
    public var textAlign: TextAlign?
    /** Background color of the CTA button. (eg. #A04033) */
    public var backgroundColor: String?

    public init(color: String?, font: String?, fontSize: String?, textAlign: TextAlign?, backgroundColor: String?) {
        self.color = color
        self.font = font
        self.fontSize = fontSize
        self.textAlign = textAlign
        self.backgroundColor = backgroundColor
    }


}




public class PatchEntityTypeCriteria: Codable {







    public enum Operator: String, Codable { 
        case containsall = "containsAll"
        case containsany = "containsAny"
        case notcontainsall = "notContainsAll"
        case notcontainsany = "notContainsAny"
        case equal = "equal"
        case notequal = "notEqual"
        case greaterthan = "greaterThan"
        case greaterthanorequal = "greaterThanOrEqual"
        case lessthan = "lessThan"
        case lessthanorequal = "lessThanOrEqual"
        case startswith = "startsWith"
        case endswith = "endsWith"
    }

    public enum EntityType: String, Codable { 
        case visit = "visit"
    }

    /** The criteria key. */
    public var key: String?
    /** The criteria values. */
    public var values: [String]?
    /** Should criteria be case insensitive. */
    public var shouldIgnoreCase: Bool?
    /** The comparison operator. */
    public var _operator: Operator?
    /** The entity to match the pattern against. */
    public var entityType: EntityType?

    public init(key: String?, values: [String]?, shouldIgnoreCase: Bool?, _operator: Operator?, entityType: EntityType?) {
        self.key = key
        self.values = values
        self.shouldIgnoreCase = shouldIgnoreCase
        self._operator = _operator
        self.entityType = entityType
    }

    public enum CodingKeys: String, CodingKey { 
        case key
        case values
        case shouldIgnoreCase
        case _operator = "operator"
        case entityType
    }


}




public class PatchTextStyleProperties: Codable {







    public enum TextAlign: String, Codable { 
        case _left = "Left"
        case _right = "Right"
        case center = "Center"
    }

    /** Color of the text. (eg. #FFFFFF) */
    public var color: String?
    /** Font of the text. (eg. Helvetica) */
    public var font: String?
    /** Font size of the text. (eg. '12') */
    public var fontSize: String?
    /** Text alignment. */
    public var textAlign: TextAlign?

    public init(color: String?, font: String?, fontSize: String?, textAlign: TextAlign?) {
        self.color = color
        self.font = font
        self.fontSize = fontSize
        self.textAlign = textAlign
    }


}




public class PatchWebMessagingOfferFields: Codable {





    /** Text value to be used when inviting a visitor to engage with a web messaging offer. */
    public var offerText: String?
    /** Flow to be invoked, overrides default flow when specified. */
    public var architectFlow: AddressableEntityRef?

    public init(offerText: String?, architectFlow: AddressableEntityRef?) {
        self.offerText = offerText
        self.architectFlow = architectFlow
    }


}




public class PerformancePredictionUploadSchema: Codable {





    /** Date as an ISO-8601 string, corresponding to the beginning of the performance prediction results */
    public var calculationStartDate: Date?
    /** List of agent on queue times by management unit */
    public var onQueueTimes: [MuAgentQueueTimeRequest]?

    public init(calculationStartDate: Date?, onQueueTimes: [MuAgentQueueTimeRequest]?) {
        self.calculationStartDate = calculationStartDate
        self.onQueueTimes = onQueueTimes
    }


}




public class PermissionDetails: Codable {

    public enum ModelType: String, Codable { 
        case requirescurrentuser = "requiresCurrentUser"
        case requirespermissions = "requiresPermissions"
        case requiresdivisionpermissions = "requiresDivisionPermissions"
        case requiresanydivisionpermissions = "requiresAnyDivisionPermissions"
        case requiresuserbeconversationparticipant = "requiresUserBeConversationParticipant"
    }







    /** The type of permission requirement */
    public var type: ModelType?
    /** List of required permissions */
    public var permissions: [String]?
    /** Whether the current user can subscribe, when division permissions are otherwise required */
    public var allowsCurrentUser: Bool?
    /** Whether or not this permission requirement is enforced */
    public var enforced: Bool?

    public init(type: ModelType?, permissions: [String]?, allowsCurrentUser: Bool?, enforced: Bool?) {
        self.type = type
        self.permissions = permissions
        self.allowsCurrentUser = allowsCurrentUser
        self.enforced = enforced
    }


}




public class Permissions: Codable {



    /** List of permission ids. */
    public var ids: [String]?

    public init(ids: [String]?) {
        self.ids = ids
    }


}




public class PhoneBase: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** A phone metabase is essentially a database for storing phone configuration settings, which simplifies the configuration process. */
    public var phoneMetaBase: DomainEntityRef?
    /** The list of linebases associated with the phone base. */
    public var lines: [LineBase]?
    public var properties: [String:JSON]?
    public var capabilities: PhoneCapabilities?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, phoneMetaBase: DomainEntityRef?, lines: [LineBase]?, properties: [String:JSON]?, capabilities: PhoneCapabilities?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.phoneMetaBase = phoneMetaBase
        self.lines = lines
        self.properties = properties
        self.capabilities = capabilities
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case phoneMetaBase
        case lines
        case properties
        case capabilities
        case selfUri
    }


}




public class PhoneChangeTopicLineStatus: Codable {











    public var _id: String?
    public var reachable: Bool?
    public var addressOfRecord: String?
    public var contactAddresses: [String]?
    public var reachableStateTime: Date?

    public init(_id: String?, reachable: Bool?, addressOfRecord: String?, contactAddresses: [String]?, reachableStateTime: Date?) {
        self._id = _id
        self.reachable = reachable
        self.addressOfRecord = addressOfRecord
        self.contactAddresses = contactAddresses
        self.reachableStateTime = reachableStateTime
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case reachable
        case addressOfRecord
        case contactAddresses
        case reachableStateTime
    }


}




public class PhoneChangeTopicPhone: Codable {









    public var userAgentInfo: PhoneChangeTopicUserAgentInfo?
    public var _id: String?
    public var status: PhoneChangeTopicPhoneStatus?
    public var secondaryStatus: PhoneChangeTopicPhoneStatus?

    public init(userAgentInfo: PhoneChangeTopicUserAgentInfo?, _id: String?, status: PhoneChangeTopicPhoneStatus?, secondaryStatus: PhoneChangeTopicPhoneStatus?) {
        self.userAgentInfo = userAgentInfo
        self._id = _id
        self.status = status
        self.secondaryStatus = secondaryStatus
    }

    public enum CodingKeys: String, CodingKey { 
        case userAgentInfo
        case _id = "id"
        case status
        case secondaryStatus
    }


}




public class PhoneChangeTopicUserAgentInfo: Codable {







    public var firmwareVersion: String?
    public var manufacturer: String?
    public var model: String?

    public init(firmwareVersion: String?, manufacturer: String?, model: String?) {
        self.firmwareVersion = firmwareVersion
        self.manufacturer = manufacturer
        self.model = model
    }


}




public class PhoneNumberColumn: Codable {





    public var columnName: String?
    public var type: String?

    public init(columnName: String?, type: String?) {
        self.columnName = columnName
        self.type = type
    }


}




public class PhoneStatus: Codable {





    public enum OperationalStatus: String, Codable { 
        case operational = "OPERATIONAL"
        case degraded = "DEGRADED"
        case offline = "OFFLINE"
        case unknown = "UNKNOWN"
    }

    public enum EdgesStatus: String, Codable { 
        case inService = "IN_SERVICE"
        case mixedService = "MIXED_SERVICE"
        case outOfService = "OUT_OF_SERVICE"
        case noEdges = "NO_EDGES"
    }







    public enum PhoneAssignmentToEdgeType: String, Codable { 
        case primary = "PRIMARY"
        case secondary = "SECONDARY"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The Operational Status of this phone */
    public var operationalStatus: OperationalStatus?
    /** The status of the primary or secondary Edges assigned to the phone lines. */
    public var edgesStatus: EdgesStatus?
    /** Event Creation Time represents an ISO-8601 string. For example: UTC, UTC+01:00, or Europe/London */
    public var eventCreationTime: String?
    /** Provision information for this phone */
    public var provision: ProvisionInfo?
    /** A list of LineStatus information for each of the lines of this phone */
    public var lineStatuses: [LineStatus]?
    /** The phone status's edge assignment type. */
    public var phoneAssignmentToEdgeType: PhoneAssignmentToEdgeType?
    /** The URI of the edge that provided this status information. */
    public var edge: DomainEntityRef?
    /** The URI for this object. Deprecated. Do not use. */
    public var selfUri: String?

    public init(_id: String?, name: String?, operationalStatus: OperationalStatus?, edgesStatus: EdgesStatus?, eventCreationTime: String?, provision: ProvisionInfo?, lineStatuses: [LineStatus]?, phoneAssignmentToEdgeType: PhoneAssignmentToEdgeType?, edge: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.operationalStatus = operationalStatus
        self.edgesStatus = edgesStatus
        self.eventCreationTime = eventCreationTime
        self.provision = provision
        self.lineStatuses = lineStatuses
        self.phoneAssignmentToEdgeType = phoneAssignmentToEdgeType
        self.edge = edge
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case operationalStatus
        case edgesStatus
        case eventCreationTime
        case provision
        case lineStatuses
        case phoneAssignmentToEdgeType
        case edge
        case selfUri
    }


}




public class PhonesReboot: Codable {





    /** The list of phone Ids to reboot. */
    public var phoneIds: [String]?
    /** ID of the site for which to reboot all phones at that site. no.active.edge and phone.cannot.resolve errors are ignored. */
    public var siteId: String?

    public init(phoneIds: [String]?, siteId: String?) {
        self.phoneIds = phoneIds
        self.siteId = siteId
    }


}




public class PhraseAssociations: Codable {





    /** Id of the phrase to be linked */
    public var phraseId: String?
    /** Id of the document to be linked */
    public var documentId: String?

    public init(phraseId: String?, documentId: String?) {
        self.phraseId = phraseId
        self.documentId = documentId
    }


}




public class PingIdentity: Codable {























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var disabled: Bool?
    public var issuerURI: String?
    public var ssoTargetURI: String?
    public var sloURI: String?
    public var sloBinding: String?
    public var relyingPartyIdentifier: String?
    public var certificate: String?
    public var certificates: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, disabled: Bool?, issuerURI: String?, ssoTargetURI: String?, sloURI: String?, sloBinding: String?, relyingPartyIdentifier: String?, certificate: String?, certificates: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.disabled = disabled
        self.issuerURI = issuerURI
        self.ssoTargetURI = ssoTargetURI
        self.sloURI = sloURI
        self.sloBinding = sloBinding
        self.relyingPartyIdentifier = relyingPartyIdentifier
        self.certificate = certificate
        self.certificates = certificates
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case disabled
        case issuerURI
        case ssoTargetURI
        case sloURI
        case sloBinding
        case relyingPartyIdentifier
        case certificate
        case certificates
        case selfUri
    }


}




public class PlanningGroupList: Codable {





    public var entities: [PlanningGroup]?
    /** Version metadata for the planning groups */
    public var metadata: WfmVersionedEntityMetadata?

    public init(entities: [PlanningGroup]?, metadata: WfmVersionedEntityMetadata?) {
        self.entities = entities
        self.metadata = metadata
    }


}




public class PlanningGroupOutputs: Codable {











    /** The ID for for the associated planning group result */
    public var planningGroupId: String?
    /** List of Service Level percentage (0.0-100.0) results per interval */
    public var serviceLevelPerInterval: [Double]?
    /** List of Occupancy percentage (0.0-100.0) results per interval */
    public var occupancyPerInterval: [Double]?
    /** List of Average Speed of Answer (in seconds) results per interval */
    public var averageSpeedOfAnswerSecondsPerInterval: [Double]?
    /** List of Abandon rate percentage (0.0-100.0) results per interval */
    public var abandonRatePerInterval: [Double]?

    public init(planningGroupId: String?, serviceLevelPerInterval: [Double]?, occupancyPerInterval: [Double]?, averageSpeedOfAnswerSecondsPerInterval: [Double]?, abandonRatePerInterval: [Double]?) {
        self.planningGroupId = planningGroupId
        self.serviceLevelPerInterval = serviceLevelPerInterval
        self.occupancyPerInterval = occupancyPerInterval
        self.averageSpeedOfAnswerSecondsPerInterval = averageSpeedOfAnswerSecondsPerInterval
        self.abandonRatePerInterval = abandonRatePerInterval
    }


}




public class PolicyActions: Codable {

























    /** true to retain the recording associated with the conversation. Default = true */
    public var retainRecording: Bool?
    /** true to delete the recording associated with the conversation. If retainRecording = true, this will be ignored. Default = false */
    public var deleteRecording: Bool?
    /** true to delete the recording associated with the conversation regardless of the values of retainRecording or deleteRecording. Default = false */
    public var alwaysDelete: Bool?
    public var assignEvaluations: [EvaluationAssignment]?
    public var assignMeteredEvaluations: [MeteredEvaluationAssignment]?
    public var assignMeteredAssignmentByAgent: [MeteredAssignmentByAgent]?
    public var assignCalibrations: [CalibrationAssignment]?
    public var assignSurveys: [SurveyAssignment]?
    public var retentionDuration: RetentionDuration?
    public var initiateScreenRecording: InitiateScreenRecording?
    public var mediaTranscriptions: [MediaTranscription]?
    /** Policy action for exporting recordings using an integration to 3rd party s3. */
    public var integrationExport: IntegrationExport?

    public init(retainRecording: Bool?, deleteRecording: Bool?, alwaysDelete: Bool?, assignEvaluations: [EvaluationAssignment]?, assignMeteredEvaluations: [MeteredEvaluationAssignment]?, assignMeteredAssignmentByAgent: [MeteredAssignmentByAgent]?, assignCalibrations: [CalibrationAssignment]?, assignSurveys: [SurveyAssignment]?, retentionDuration: RetentionDuration?, initiateScreenRecording: InitiateScreenRecording?, mediaTranscriptions: [MediaTranscription]?, integrationExport: IntegrationExport?) {
        self.retainRecording = retainRecording
        self.deleteRecording = deleteRecording
        self.alwaysDelete = alwaysDelete
        self.assignEvaluations = assignEvaluations
        self.assignMeteredEvaluations = assignMeteredEvaluations
        self.assignMeteredAssignmentByAgent = assignMeteredAssignmentByAgent
        self.assignCalibrations = assignCalibrations
        self.assignSurveys = assignSurveys
        self.retentionDuration = retentionDuration
        self.initiateScreenRecording = initiateScreenRecording
        self.mediaTranscriptions = mediaTranscriptions
        self.integrationExport = integrationExport
    }


}




public class PolicyCreate: Codable {

























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The policy name. */
    public var name: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    public var order: Int?
    public var _description: String?
    public var enabled: Bool?
    /** Conditions and actions per media type */
    public var mediaPolicies: MediaPolicies?
    /** Conditions */
    public var conditions: PolicyConditions?
    /** Actions */
    public var actions: PolicyActions?
    public var policyErrors: PolicyErrors?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, modifiedDate: Date?, createdDate: Date?, order: Int?, _description: String?, enabled: Bool?, mediaPolicies: MediaPolicies?, conditions: PolicyConditions?, actions: PolicyActions?, policyErrors: PolicyErrors?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.modifiedDate = modifiedDate
        self.createdDate = createdDate
        self.order = order
        self._description = _description
        self.enabled = enabled
        self.mediaPolicies = mediaPolicies
        self.conditions = conditions
        self.actions = actions
        self.policyErrors = policyErrors
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case modifiedDate
        case createdDate
        case order
        case _description = "description"
        case enabled
        case mediaPolicies
        case conditions
        case actions
        case policyErrors
        case selfUri
    }


}




public class PolicyErrorMessage: Codable {















    public var statusCode: Int?
    public var userMessage: JSON?
    public var userParamsMessage: String?
    public var errorCode: String?
    public var correlationId: String?
    public var userParams: [UserParam]?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var insertDate: Date?

    public init(statusCode: Int?, userMessage: JSON?, userParamsMessage: String?, errorCode: String?, correlationId: String?, userParams: [UserParam]?, insertDate: Date?) {
        self.statusCode = statusCode
        self.userMessage = userMessage
        self.userParamsMessage = userParamsMessage
        self.errorCode = errorCode
        self.correlationId = correlationId
        self.userParams = userParams
        self.insertDate = insertDate
    }


}




public class PolicyUpdate: Codable {



    public var enabled: Bool?

    public init(enabled: Bool?) {
        self.enabled = enabled
    }


}



/** The schemas defining all of the expected requests/inputs. */

public class PostInputContract: Codable {



    /** JSON Schema that defines the body of the request that the client (edge/architect/postman) is sending to the service, on the /execute path. */
    public var inputSchema: JsonSchemaDocument?

    public init(inputSchema: JsonSchemaDocument?) {
        self.inputSchema = inputSchema
    }


}




public class PostTextResponse: Codable {

    public enum BotState: String, Codable { 
        case complete = "Complete"
        case failed = "Failed"
        case moreData = "MoreData"
    }



















    /** The state of the bot after completion of the request */
    public var botState: BotState?
    /** The list of messages to respond with, if any */
    public var replyMessages: [PostTextMessage]?
    /** The name of the intent the bot is either processing or has processed, this will be blank if no intent could be detected. */
    public var intentName: String?
    /** Data parameters detected and filled by the bot. */
    public var slots: [String:String]?
    /** The optional ID specified in the request */
    public var botCorrelationId: String?
    /** Raw data response from AWS (if called) */
    public var amazonLex: [String:JSON]?
    /** Raw data response from Google Dialogflow (if called) */
    public var googleDialogFlow: [String:JSON]?
    /** Raw data response from Genesys' Dialogengine (if called) */
    public var genesysDialogEngine: [String:JSON]?
    /** Raw data response from Genesys' BotConnector (if called) */
    public var genesysBotConnector: [String:JSON]?
    /** Raw data response from Nuance Mix Dlg (if called) */
    public var nuanceMixDlg: [String:JSON]?

    public init(botState: BotState?, replyMessages: [PostTextMessage]?, intentName: String?, slots: [String:String]?, botCorrelationId: String?, amazonLex: [String:JSON]?, googleDialogFlow: [String:JSON]?, genesysDialogEngine: [String:JSON]?, genesysBotConnector: [String:JSON]?, nuanceMixDlg: [String:JSON]?) {
        self.botState = botState
        self.replyMessages = replyMessages
        self.intentName = intentName
        self.slots = slots
        self.botCorrelationId = botCorrelationId
        self.amazonLex = amazonLex
        self.googleDialogFlow = googleDialogFlow
        self.genesysDialogEngine = genesysDialogEngine
        self.genesysBotConnector = genesysBotConnector
        self.nuanceMixDlg = nuanceMixDlg
    }


}




public class PredictionResults: Codable {

    public enum Intent: String, Codable { 
        case all = "ALL"
        case call = "CALL"
        case callback = "CALLBACK"
        case chat = "CHAT"
        case email = "EMAIL"
        case socialexpression = "SOCIALEXPRESSION"
        case videocomm = "VIDEOCOMM"
        case message = "MESSAGE"
    }

    public enum Formula: String, Codable { 
        case best = "BEST"
        case simple = "SIMPLE"
        case abandon = "ABANDON"
        case patienceAbandon = "PATIENCE_ABANDON"
    }



    /** Indicates the media type scope of this estimated wait time */
    public var intent: Intent?
    /** Indicates the estimated wait time Formula */
    public var formula: Formula?
    /** Estimated wait time in seconds */
    public var estimatedWaitTimeSeconds: Int?

    public init(intent: Intent?, formula: Formula?, estimatedWaitTimeSeconds: Int?) {
        self.intent = intent
        self.formula = formula
        self.estimatedWaitTimeSeconds = estimatedWaitTimeSeconds
    }


}




public class Predictor: Codable {











    public enum State: String, Codable { 
        case created = "Created"
        case error = "Error"
        case active = "Active"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The queue IDs associated with the predictor. */
    public var queues: [AddressableEntityRef]?
    /** The KPI that the predictor attempts to maximize/minimize. */
    public var kpi: String?
    /** Number of seconds allocated to predictive routing before attempting a different routing method. This is a value between 12 and 900 seconds. */
    public var routingTimeoutSeconds: Int?
    /** The predictor schedule that determines when the predictor is used for routing interactions. */
    public var schedule: PredictorSchedule?
    /** The predictor state. */
    public var state: State?
    /** DateTime indicating when the predictor was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** DateTime indicating when the predictor was last updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The predictor balancing configuration to enable workload balancing. */
    public var workloadBalancingConfig: PredictorWorkloadBalancing?
    /** Predictor error code - optional details on why the predictor went into error state. */
    public var errorCode: String?
    /** Predictor's models */
    public var models: [PredictorModelBrief]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, queues: [AddressableEntityRef]?, kpi: String?, routingTimeoutSeconds: Int?, schedule: PredictorSchedule?, state: State?, dateCreated: Date?, dateModified: Date?, workloadBalancingConfig: PredictorWorkloadBalancing?, errorCode: String?, models: [PredictorModelBrief]?, selfUri: String?) {
        self._id = _id
        self.queues = queues
        self.kpi = kpi
        self.routingTimeoutSeconds = routingTimeoutSeconds
        self.schedule = schedule
        self.state = state
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.workloadBalancingConfig = workloadBalancingConfig
        self.errorCode = errorCode
        self.models = models
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case queues
        case kpi
        case routingTimeoutSeconds
        case schedule
        case state
        case dateCreated
        case dateModified
        case workloadBalancingConfig
        case errorCode
        case models
        case selfUri
    }


}




public class PredictorListing: Codable {









    public var entities: [Predictor]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [Predictor]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class PredictorModelBrief: Codable {

    public enum MediaType: String, Codable { 
        case voice = "voice"
        case email = "email"
        case message = "message"
    }





    public enum State: String, Codable { 
        case trained = "Trained"
        case error = "Error"
        case invalidDataset = "InvalidDataset"
        case inactive = "Inactive"
    }

    /** The media type of the model. */
    public var mediaType: MediaType?
    /** The date the model was modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The model's retraining errors. */
    public var retrainingErrors: [PredictorModelRetrainingError]?
    /** The state of the model */
    public var state: State?

    public init(mediaType: MediaType?, dateModified: Date?, retrainingErrors: [PredictorModelRetrainingError]?, state: State?) {
        self.mediaType = mediaType
        self.dateModified = dateModified
        self.retrainingErrors = retrainingErrors
        self.state = state
    }


}




public class PredictorWorkloadBalancing: Codable {







    /** Flag to activate and deactivate workload balancing. */
    public var enabled: Bool?
    /** Desired minimum occupancy threshold of agents. Must be between 0 and 100. */
    public var minimumOccupancy: Int?
    /** Desired maximum occupancy threshold of agents. Must be between 0 and 100. */
    public var maximumOccupancy: Int?

    public init(enabled: Bool?, minimumOccupancy: Int?, maximumOccupancy: Int?) {
        self.enabled = enabled
        self.minimumOccupancy = minimumOccupancy
        self.maximumOccupancy = maximumOccupancy
    }


}




public class PresenceDetailQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [PresenceDetailQueryPredicate]?

    public init(type: ModelType?, predicates: [PresenceDetailQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class PresenceEventOrganizationPresence: Codable {





    public var _id: String?
    public var systemPresence: String?

    public init(_id: String?, systemPresence: String?) {
        self._id = _id
        self.systemPresence = systemPresence
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case systemPresence
    }


}




public class PresenceSettings: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The settings for the restore presence feature */
    public var restorePresenceSettings: RestorePresenceSettings?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, restorePresenceSettings: RestorePresenceSettings?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.restorePresenceSettings = restorePresenceSettings
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case restorePresenceSettings
        case selfUri
    }


}




public class ProgramsEntityListing: Codable {











    public var entities: [ListedProgram]?
    public var pageSize: Int?
    public var nextUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ListedProgram]?, pageSize: Int?, nextUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class PromptAssetCreate: Codable {















    public enum UploadStatus: String, Codable { 
        case created = "created"
        case uploaded = "uploaded"
        case transcoded = "transcoded"
        case transcodefailed = "transcodeFailed"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Associated prompt ID */
    public var promptId: String?
    /** The prompt language. */
    public var language: String?
    /** URI of the resource audio */
    public var mediaUri: String?
    /** Text to speech of the resource */
    public var ttsString: String?
    /** Text of the resource */
    public var text: String?
    /** Audio upload status */
    public var uploadStatus: UploadStatus?
    /** Upload URI for the resource audio */
    public var uploadUri: String?
    /** Whether or not this resource locale is the default for the language */
    public var languageDefault: Bool?
    public var tags: [String:[String]]?
    public var durationSeconds: Double?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, promptId: String?, language: String?, mediaUri: String?, ttsString: String?, text: String?, uploadStatus: UploadStatus?, uploadUri: String?, languageDefault: Bool?, tags: [String:[String]]?, durationSeconds: Double?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.promptId = promptId
        self.language = language
        self.mediaUri = mediaUri
        self.ttsString = ttsString
        self.text = text
        self.uploadStatus = uploadStatus
        self.uploadUri = uploadUri
        self.languageDefault = languageDefault
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case promptId
        case language
        case mediaUri
        case ttsString
        case text
        case uploadStatus
        case uploadUri
        case languageDefault
        case tags
        case durationSeconds
        case selfUri
    }


}




public class ProvisionInfo: Codable {







    /** The time at which this phone was provisioned. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var time: Date?
    /** The source of the provisioning */
    public var source: String?
    /** The error information from the provision process, if any */
    public var errorInfo: String?

    public init(time: Date?, source: String?, errorInfo: String?) {
        self.time = time
        self.source = source
        self.errorInfo = errorInfo
    }


}




public class PublishTopicTopicsDefinitionsJob: Codable {



    public enum State: String, Codable { 
        case completed = "Completed"
        case failed = "Failed"
    }

    public var _id: String?
    public var state: State?

    public init(_id: String?, state: State?) {
        self._id = _id
        self.state = state
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
    }


}




public class PunctualityEvent: Codable {























    /** The scheduled activity start time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateScheduleStart: Date?
    /** The time the user started the activity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?
    /** The length of the activity in minutes */
    public var lengthMinutes: Int?
    /** The description of the activity */
    public var _description: String?
    /** The ID of the activity code associated with this activity */
    public var activityCodeId: String?
    /** The activity code */
    public var activityCode: String?
    /** The activity name */
    public var activityName: String?
    /** The category for the activity */
    public var category: String?
    /** The points earned for this activity */
    public var points: Int?
    /** Difference between this activity and the last activity in seconds */
    public var delta: Double?
    public var bullseye: Bool?

    public init(dateScheduleStart: Date?, dateStart: Date?, lengthMinutes: Int?, _description: String?, activityCodeId: String?, activityCode: String?, activityName: String?, category: String?, points: Int?, delta: Double?, bullseye: Bool?) {
        self.dateScheduleStart = dateScheduleStart
        self.dateStart = dateStart
        self.lengthMinutes = lengthMinutes
        self._description = _description
        self.activityCodeId = activityCodeId
        self.activityCode = activityCode
        self.activityName = activityName
        self.category = category
        self.points = points
        self.delta = delta
        self.bullseye = bullseye
    }

    public enum CodingKeys: String, CodingKey { 
        case dateScheduleStart
        case dateStart
        case lengthMinutes
        case _description = "description"
        case activityCodeId
        case activityCode
        case activityName
        case category
        case points
        case delta
        case bullseye
    }


}




public class PureCloud: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var disabled: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, disabled: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.disabled = disabled
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case disabled
        case selfUri
    }


}




public class PureEngage: Codable {

























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var disabled: Bool?
    public var issuerURI: String?
    public var ssoTargetURI: String?
    public var sloURI: String?
    public var sloBinding: String?
    public var relyingPartyIdentifier: String?
    public var certificate: String?
    public var certificates: [String]?
    public var autoProvisionUsers: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, disabled: Bool?, issuerURI: String?, ssoTargetURI: String?, sloURI: String?, sloBinding: String?, relyingPartyIdentifier: String?, certificate: String?, certificates: [String]?, autoProvisionUsers: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.disabled = disabled
        self.issuerURI = issuerURI
        self.ssoTargetURI = ssoTargetURI
        self.sloURI = sloURI
        self.sloBinding = sloBinding
        self.relyingPartyIdentifier = relyingPartyIdentifier
        self.certificate = certificate
        self.certificates = certificates
        self.autoProvisionUsers = autoProvisionUsers
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case disabled
        case issuerURI
        case ssoTargetURI
        case sloURI
        case sloBinding
        case relyingPartyIdentifier
        case certificate
        case certificates
        case autoProvisionUsers
        case selfUri
    }


}




public class QMAuditQueryRequest: Codable {







    /** Date and time range of data to query. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** List of filters for the query. */
    public var filters: [QualityAuditQueryFilter]?
    /** Sort parameter for the query. */
    public var sort: [AuditQuerySort]?

    public init(interval: String?, filters: [QualityAuditQueryFilter]?, sort: [AuditQuerySort]?) {
        self.interval = interval
        self.filters = filters
        self.sort = sort
    }


}




public class QualityEvaluationScoreItem: Codable {

















    public enum MediaTypes: String, Codable { 
        case callback = "callback"
        case chat = "chat"
        case cobrowse = "cobrowse"
        case email = "email"
        case message = "message"
        case screenshare = "screenshare"
        case unknown = "unknown"
        case video = "video"
        case voice = "voice"
    }

    /** The id of evaluation */
    public var evaluationId: String?
    /** The id of conversation */
    public var conversationId: String?
    /** The date of conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var conversationDate: Date?
    /** The end date of conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var conversationEndDate: Date?
    /** The name of form */
    public var formName: String?
    /** Gamification points earned for this metric */
    public var points: Int?
    /** The quality score of evaluation as a percentage */
    public var evaluationScore: Double?
    /** The maximum Gamification points a user may earn for this metric */
    public var maxPoints: Int?
    /** A list of media types for the metric */
    public var mediaTypes: [MediaTypes]?

    public init(evaluationId: String?, conversationId: String?, conversationDate: Date?, conversationEndDate: Date?, formName: String?, points: Int?, evaluationScore: Double?, maxPoints: Int?, mediaTypes: [MediaTypes]?) {
        self.evaluationId = evaluationId
        self.conversationId = conversationId
        self.conversationDate = conversationDate
        self.conversationEndDate = conversationEndDate
        self.formName = formName
        self.points = points
        self.evaluationScore = evaluationScore
        self.maxPoints = maxPoints
        self.mediaTypes = mediaTypes
    }


}



/** Query integrations for agents request */

public class QueryAgentsIntegrationsRequest: Codable {



    /** The IDs of the agents to query associated integrations */
    public var agentIds: [String]?

    public init(agentIds: [String]?) {
        self.agentIds = agentIds
    }


}




public class QueryResponseGroupedData: Codable {





    /** The group values for this data */
    public var group: [String:String]?
    /** The metrics in this group */
    public var data: [QueryResponseData]?

    public init(group: [String:String]?, data: [QueryResponseData]?) {
        self.group = group
        self.data = data
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationCallEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationCallEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}




public class QueueConversationCallEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: QueueConversationCallEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int?

    public init(agent: QueueConversationCallEventTopicUriReference?, score: Int?) {
        self.agent = agent
        self.score = score
    }


}




public class QueueConversationCallbackEventTopicCallbackMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case timeout = "timeout"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }







































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }





























    public var _id: String?
    public var name: String?
    public var address: String?
    public var startTime: Date?
    public var connectedTime: Date?
    public var endTime: Date?
    public var startHoldTime: Date?
    public var purpose: String?
    public var state: State?
    public var initialState: InitialState?
    public var direction: Direction?
    public var disconnectType: DisconnectType?
    public var held: Bool?
    public var wrapupRequired: Bool?
    public var wrapupPrompt: String?
    public var user: QueueConversationCallbackEventTopicUriReference?
    public var queue: QueueConversationCallbackEventTopicUriReference?
    public var team: QueueConversationCallbackEventTopicUriReference?
    public var attributes: [String:String]?
    public var errorInfo: QueueConversationCallbackEventTopicErrorBody?
    public var script: QueueConversationCallbackEventTopicUriReference?
    public var wrapupTimeoutMs: Int?
    public var wrapupSkipped: Bool?
    public var alertingTimeoutMs: Int?
    public var provider: String?
    public var externalContact: QueueConversationCallbackEventTopicUriReference?
    public var externalOrganization: QueueConversationCallbackEventTopicUriReference?
    public var wrapup: QueueConversationCallbackEventTopicWrapup?
    public var conversationRoutingData: QueueConversationCallbackEventTopicConversationRoutingData?
    public var peer: String?
    public var screenRecordingState: String?
    public var flaggedReason: FlaggedReason?
    public var journeyContext: QueueConversationCallbackEventTopicJourneyContext?
    public var startAcwTime: Date?
    public var endAcwTime: Date?
    public var mediaRoles: [String]?
    public var queueMediaSettings: QueueConversationCallbackEventTopicQueueMediaSettings?
    public var outboundPreview: QueueConversationCallbackEventTopicDialerPreview?
    public var voicemail: QueueConversationCallbackEventTopicVoicemail?
    public var callbackNumbers: [String]?
    public var callbackUserName: String?
    public var skipEnabled: Bool?
    public var externalCampaign: Bool?
    public var timeoutSeconds: Int?
    public var callbackScheduledTime: Date?
    public var automatedCallbackConfigId: String?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, initialState: InitialState?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, user: QueueConversationCallbackEventTopicUriReference?, queue: QueueConversationCallbackEventTopicUriReference?, team: QueueConversationCallbackEventTopicUriReference?, attributes: [String:String]?, errorInfo: QueueConversationCallbackEventTopicErrorBody?, script: QueueConversationCallbackEventTopicUriReference?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, alertingTimeoutMs: Int?, provider: String?, externalContact: QueueConversationCallbackEventTopicUriReference?, externalOrganization: QueueConversationCallbackEventTopicUriReference?, wrapup: QueueConversationCallbackEventTopicWrapup?, conversationRoutingData: QueueConversationCallbackEventTopicConversationRoutingData?, peer: String?, screenRecordingState: String?, flaggedReason: FlaggedReason?, journeyContext: QueueConversationCallbackEventTopicJourneyContext?, startAcwTime: Date?, endAcwTime: Date?, mediaRoles: [String]?, queueMediaSettings: QueueConversationCallbackEventTopicQueueMediaSettings?, outboundPreview: QueueConversationCallbackEventTopicDialerPreview?, voicemail: QueueConversationCallbackEventTopicVoicemail?, callbackNumbers: [String]?, callbackUserName: String?, skipEnabled: Bool?, externalCampaign: Bool?, timeoutSeconds: Int?, callbackScheduledTime: Date?, automatedCallbackConfigId: String?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.conversationRoutingData = conversationRoutingData
        self.peer = peer
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.mediaRoles = mediaRoles
        self.queueMediaSettings = queueMediaSettings
        self.outboundPreview = outboundPreview
        self.voicemail = voicemail
        self.callbackNumbers = callbackNumbers
        self.callbackUserName = callbackUserName
        self.skipEnabled = skipEnabled
        self.externalCampaign = externalCampaign
        self.timeoutSeconds = timeoutSeconds
        self.callbackScheduledTime = callbackScheduledTime
        self.automatedCallbackConfigId = automatedCallbackConfigId
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case initialState
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalOrganization
        case wrapup
        case conversationRoutingData
        case peer
        case screenRecordingState
        case flaggedReason
        case journeyContext
        case startAcwTime
        case endAcwTime
        case mediaRoles
        case queueMediaSettings
        case outboundPreview
        case voicemail
        case callbackNumbers
        case callbackUserName
        case skipEnabled
        case externalCampaign
        case timeoutSeconds
        case callbackScheduledTime
        case automatedCallbackConfigId
    }


}




public class QueueConversationCallbackEventTopicConversationRoutingData: Codable {











    /** A UriReference for a resource */
    public var queue: QueueConversationCallbackEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: QueueConversationCallbackEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int?
    /** The skills to use for routing decisions */
    public var skills: [QueueConversationCallbackEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [QueueConversationCallbackEventTopicScoredAgent]?

    public init(queue: QueueConversationCallbackEventTopicUriReference?, language: QueueConversationCallbackEventTopicUriReference?, priority: Int?, skills: [QueueConversationCallbackEventTopicUriReference]?, scoredAgents: [QueueConversationCallbackEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}




public class QueueConversationChatEventTopicChatConversation: Codable {









    public var _id: String?
    public var name: String?
    public var participants: [QueueConversationChatEventTopicChatMediaParticipant]?
    public var otherMediaUris: [String]?

    public init(_id: String?, name: String?, participants: [QueueConversationChatEventTopicChatMediaParticipant]?, otherMediaUris: [String]?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class QueueConversationChatEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: QueueConversationChatEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: QueueConversationChatEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}




public class QueueConversationChatEventTopicJourneyContext: Codable {







    public var customer: QueueConversationChatEventTopicJourneyCustomer?
    public var customerSession: QueueConversationChatEventTopicJourneyCustomerSession?
    public var triggeringAction: QueueConversationChatEventTopicJourneyAction?

    public init(customer: QueueConversationChatEventTopicJourneyCustomer?, customerSession: QueueConversationChatEventTopicJourneyCustomerSession?, triggeringAction: QueueConversationChatEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class QueueConversationChatEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}




public class QueueConversationCobrowseEventTopicCobrowseMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case timeout = "timeout"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }







































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }





















    public var _id: String?
    public var name: String?
    public var address: String?
    public var startTime: Date?
    public var connectedTime: Date?
    public var endTime: Date?
    public var startHoldTime: Date?
    public var purpose: String?
    public var state: State?
    public var initialState: InitialState?
    public var direction: Direction?
    public var disconnectType: DisconnectType?
    public var held: Bool?
    public var wrapupRequired: Bool?
    public var wrapupPrompt: String?
    public var user: QueueConversationCobrowseEventTopicUriReference?
    public var queue: QueueConversationCobrowseEventTopicUriReference?
    public var team: QueueConversationCobrowseEventTopicUriReference?
    public var attributes: [String:String]?
    public var errorInfo: QueueConversationCobrowseEventTopicErrorBody?
    public var script: QueueConversationCobrowseEventTopicUriReference?
    public var wrapupTimeoutMs: Int?
    public var wrapupSkipped: Bool?
    public var alertingTimeoutMs: Int?
    public var provider: String?
    public var externalContact: QueueConversationCobrowseEventTopicUriReference?
    public var externalOrganization: QueueConversationCobrowseEventTopicUriReference?
    public var wrapup: QueueConversationCobrowseEventTopicWrapup?
    public var conversationRoutingData: QueueConversationCobrowseEventTopicConversationRoutingData?
    public var peer: String?
    public var screenRecordingState: String?
    public var flaggedReason: FlaggedReason?
    public var journeyContext: QueueConversationCobrowseEventTopicJourneyContext?
    public var startAcwTime: Date?
    public var endAcwTime: Date?
    public var mediaRoles: [String]?
    public var queueMediaSettings: QueueConversationCobrowseEventTopicQueueMediaSettings?
    public var cobrowseSessionId: String?
    public var cobrowseRole: String?
    public var viewerUrl: String?
    public var providerEventTime: Date?
    public var controlling: [String]?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, initialState: InitialState?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, user: QueueConversationCobrowseEventTopicUriReference?, queue: QueueConversationCobrowseEventTopicUriReference?, team: QueueConversationCobrowseEventTopicUriReference?, attributes: [String:String]?, errorInfo: QueueConversationCobrowseEventTopicErrorBody?, script: QueueConversationCobrowseEventTopicUriReference?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, alertingTimeoutMs: Int?, provider: String?, externalContact: QueueConversationCobrowseEventTopicUriReference?, externalOrganization: QueueConversationCobrowseEventTopicUriReference?, wrapup: QueueConversationCobrowseEventTopicWrapup?, conversationRoutingData: QueueConversationCobrowseEventTopicConversationRoutingData?, peer: String?, screenRecordingState: String?, flaggedReason: FlaggedReason?, journeyContext: QueueConversationCobrowseEventTopicJourneyContext?, startAcwTime: Date?, endAcwTime: Date?, mediaRoles: [String]?, queueMediaSettings: QueueConversationCobrowseEventTopicQueueMediaSettings?, cobrowseSessionId: String?, cobrowseRole: String?, viewerUrl: String?, providerEventTime: Date?, controlling: [String]?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.conversationRoutingData = conversationRoutingData
        self.peer = peer
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.mediaRoles = mediaRoles
        self.queueMediaSettings = queueMediaSettings
        self.cobrowseSessionId = cobrowseSessionId
        self.cobrowseRole = cobrowseRole
        self.viewerUrl = viewerUrl
        self.providerEventTime = providerEventTime
        self.controlling = controlling
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case initialState
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalOrganization
        case wrapup
        case conversationRoutingData
        case peer
        case screenRecordingState
        case flaggedReason
        case journeyContext
        case startAcwTime
        case endAcwTime
        case mediaRoles
        case queueMediaSettings
        case cobrowseSessionId
        case cobrowseRole
        case viewerUrl
        case providerEventTime
        case controlling
    }


}




public class QueueConversationCobrowseEventTopicConversationRoutingData: Codable {











    /** A UriReference for a resource */
    public var queue: QueueConversationCobrowseEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: QueueConversationCobrowseEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int?
    /** The skills to use for routing decisions */
    public var skills: [QueueConversationCobrowseEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [QueueConversationCobrowseEventTopicScoredAgent]?

    public init(queue: QueueConversationCobrowseEventTopicUriReference?, language: QueueConversationCobrowseEventTopicUriReference?, priority: Int?, skills: [QueueConversationCobrowseEventTopicUriReference]?, scoredAgents: [QueueConversationCobrowseEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}




public class QueueConversationEmailEventTopicDetail: Codable {









    public var errorCode: String?
    public var fieldName: String?
    public var entityId: String?
    public var entityName: String?

    public init(errorCode: String?, fieldName: String?, entityId: String?, entityName: String?) {
        self.errorCode = errorCode
        self.fieldName = fieldName
        self.entityId = entityId
        self.entityName = entityName
    }


}




public class QueueConversationEmailEventTopicErrorBody: Codable {





















    public var message: String?
    public var code: String?
    public var status: Int?
    public var entityId: String?
    public var entityName: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var contextId: String?
    public var details: [QueueConversationEmailEventTopicDetail]?
    public var errors: [QueueConversationEmailEventTopicErrorBody]?

    public init(message: String?, code: String?, status: Int?, entityId: String?, entityName: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, details: [QueueConversationEmailEventTopicDetail]?, errors: [QueueConversationEmailEventTopicErrorBody]?) {
        self.message = message
        self.code = code
        self.status = status
        self.entityId = entityId
        self.entityName = entityName
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.details = details
        self.errors = errors
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class QueueConversationEmailEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int?

    public init(_id: String?, version: Int?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}




public class QueueConversationEmailEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class QueueConversationEventTopicAttachment: Codable {











    /** The unique identifier for the attachment. */
    public var attachmentId: String?
    /** The name of the attachment. */
    public var name: String?
    /** The content uri of the attachment. If set, this is commonly a public api download location. */
    public var contentUri: String?
    /** The type of file the attachment is. */
    public var contentType: String?
    /** The length of the attachment file. */
    public var contentLength: Int?

    public init(attachmentId: String?, name: String?, contentUri: String?, contentType: String?, contentLength: Int?) {
        self.attachmentId = attachmentId
        self.name = name
        self.contentUri = contentUri
        self.contentType = contentType
        self.contentLength = contentLength
    }


}




public class QueueConversationEventTopicEmail: Codable {



    public enum State: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case disconnected = "disconnected"
        case _none = "none"
        case transmitting = "transmitting"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case disconnected = "disconnected"
        case _none = "none"
        case transmitting = "transmitting"
    }

















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }









    public enum Direction: String, Codable { 
        case outbound = "outbound"
        case inbound = "inbound"
    }













    /** A globally unique identifier for this communication. */
    public var _id: String?
    public var state: State?
    public var initialState: InitialState?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** Indicates that the email was auto-generated like an Out of Office reply. */
    public var autoGenerated: Bool?
    /** The subject for the initial email that started this conversation. */
    public var subject: String?
    /** The source provider of the email. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The number of email messages sent by this participant. */
    public var messagesSent: Int?
    /** Detailed information about an error response. */
    public var errorInfo: QueueConversationEventTopicErrorDetails?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the email was placed on hold in the cloud clock if the email is currently on hold. */
    public var startHoldTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** A globally unique identifier for the stored content of this communication. */
    public var messageId: String?
    /** Whether an email is inbound or outbound. */
    public var direction: Direction?
    /** A list of uploaded attachments on the email draft. */
    public var draftAttachments: [QueueConversationEventTopicAttachment]?
    /** Indicates if the inbound email was marked as spam. */
    public var spam: Bool?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationEventTopicQueueMediaSettings?

    public init(_id: String?, state: State?, initialState: InitialState?, held: Bool?, autoGenerated: Bool?, subject: String?, provider: String?, scriptId: String?, peerId: String?, messagesSent: Int?, errorInfo: QueueConversationEventTopicErrorDetails?, disconnectType: DisconnectType?, startHoldTime: Date?, connectedTime: Date?, disconnectedTime: Date?, messageId: String?, direction: Direction?, draftAttachments: [QueueConversationEventTopicAttachment]?, spam: Bool?, wrapup: QueueConversationEventTopicWrapup?, afterCallWork: QueueConversationEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: QueueConversationEventTopicQueueMediaSettings?) {
        self._id = _id
        self.state = state
        self.initialState = initialState
        self.held = held
        self.autoGenerated = autoGenerated
        self.subject = subject
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.messagesSent = messagesSent
        self.errorInfo = errorInfo
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.messageId = messageId
        self.direction = direction
        self.draftAttachments = draftAttachments
        self.spam = spam
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case initialState
        case held
        case autoGenerated
        case subject
        case provider
        case scriptId
        case peerId
        case messagesSent
        case errorInfo
        case disconnectType
        case startHoldTime
        case connectedTime
        case disconnectedTime
        case messageId
        case direction
        case draftAttachments
        case spam
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}



/** Fields identifying the entity that updated the command. */

public class QueueConversationEventTopicModifiedBy: Codable {





    /** The id of the user if the updater is an internal user. */
    public var _id: String?
    /** The URI for the user if the updater is an internal user. */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class QueueConversationEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: QueueConversationEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int?

    public init(agent: QueueConversationEventTopicUriReference?, score: Int?) {
        self.agent = agent
        self.score = score
    }


}




public class QueueConversationEventTopicVideo: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }





















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }















    public var state: State?
    public var initialState: InitialState?
    /** Address and name data for a call endpoint. */
    public var _self: QueueConversationEventTopicAddress?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The room id context (xmpp jid) for the conference session. */
    public var context: String?
    /** Indicates whether this participant has muted their outgoing audio. */
    public var audioMuted: Bool?
    /** Indicates whether this participant has muted/paused their outgoing video. */
    public var videoMuted: Bool?
    /** Indicates whether this participant is sharing their screen to the session. */
    public var sharingScreen: Bool?
    /** The number of peer participants from the perspective of the participant in the conference. */
    public var peerCount: JSON?
    /** The media provider controlling the video. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** List of media stream ids */
    public var msids: [String]?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _self: QueueConversationEventTopicAddress?, _id: String?, context: String?, audioMuted: Bool?, videoMuted: Bool?, sharingScreen: Bool?, peerCount: JSON?, provider: String?, scriptId: String?, peerId: String?, disconnectType: DisconnectType?, connectedTime: Date?, disconnectedTime: Date?, msids: [String]?, wrapup: QueueConversationEventTopicWrapup?, afterCallWork: QueueConversationEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: QueueConversationEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._self = _self
        self._id = _id
        self.context = context
        self.audioMuted = audioMuted
        self.videoMuted = videoMuted
        self.sharingScreen = sharingScreen
        self.peerCount = peerCount
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.disconnectType = disconnectType
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.msids = msids
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _self = "self"
        case _id = "id"
        case context
        case audioMuted
        case videoMuted
        case sharingScreen
        case peerCount
        case provider
        case scriptId
        case peerId
        case disconnectType
        case connectedTime
        case disconnectedTime
        case msids
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class QueueConversationMessageEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: QueueConversationMessageEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: QueueConversationMessageEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}




public class QueueConversationMessageEventTopicJourneyContext: Codable {







    public var customer: QueueConversationMessageEventTopicJourneyCustomer?
    public var customerSession: QueueConversationMessageEventTopicJourneyCustomerSession?
    public var triggeringAction: QueueConversationMessageEventTopicJourneyAction?

    public init(customer: QueueConversationMessageEventTopicJourneyCustomer?, customerSession: QueueConversationMessageEventTopicJourneyCustomerSession?, triggeringAction: QueueConversationMessageEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class QueueConversationMessageEventTopicMessageConversation: Codable {









    public var _id: String?
    public var name: String?
    public var participants: [QueueConversationMessageEventTopicMessageMediaParticipant]?
    public var otherMediaUris: [String]?

    public init(_id: String?, name: String?, participants: [QueueConversationMessageEventTopicMessageMediaParticipant]?, otherMediaUris: [String]?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
    }


}




public class QueueConversationMessageEventTopicMessageDetails: Codable {







    public enum MessageStatus: String, Codable { 
        case queued = "queued"
        case sent = "sent"
        case failed = "failed"
        case received = "received"
        case deliverySuccess = "delivery-success"
        case deliveryFailed = "delivery-failed"
        case read = "read"
        case removed = "removed"
    }









    public var message: QueueConversationMessageEventTopicUriReference?
    public var messageTime: Date?
    public var messageSegmentCount: Int?
    public var messageStatus: MessageStatus?
    public var media: [QueueConversationMessageEventTopicMessageMedia]?
    public var stickers: [QueueConversationMessageEventTopicMessageSticker]?
    public var errorInfo: QueueConversationMessageEventTopicErrorDetails?
    public var messageMetadata: QueueConversationMessageEventTopicMessageMetadata?

    public init(message: QueueConversationMessageEventTopicUriReference?, messageTime: Date?, messageSegmentCount: Int?, messageStatus: MessageStatus?, media: [QueueConversationMessageEventTopicMessageMedia]?, stickers: [QueueConversationMessageEventTopicMessageSticker]?, errorInfo: QueueConversationMessageEventTopicErrorDetails?, messageMetadata: QueueConversationMessageEventTopicMessageMetadata?) {
        self.message = message
        self.messageTime = messageTime
        self.messageSegmentCount = messageSegmentCount
        self.messageStatus = messageStatus
        self.media = media
        self.stickers = stickers
        self.errorInfo = errorInfo
        self.messageMetadata = messageMetadata
    }


}




public class QueueConversationMessageEventTopicMessageMedia: Codable {











    /** The location of the media, useful for retrieving it */
    public var url: String?
    /** The optional internet media type of the the media object.  If null then the media type should be dictated by the url */
    public var mediaType: String?
    /** The optional content length of the the media object, in bytes. */
    public var contentLengthBytes: Int?
    /** The optional name of the the media object. */
    public var name: String?
    /** The optional id of the the media object. */
    public var _id: String?

    public init(url: String?, mediaType: String?, contentLengthBytes: Int?, name: String?, _id: String?) {
        self.url = url
        self.mediaType = mediaType
        self.contentLengthBytes = contentLengthBytes
        self.name = name
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case url
        case mediaType
        case contentLengthBytes
        case name
        case _id = "id"
    }


}




public class QueueConversationMessageEventTopicMessageMetadataEvent: Codable {





    /** Type of this event element. */
    public var eventType: String?
    /** Event subtype, if any */
    public var subType: String?

    public init(eventType: String?, subType: String?) {
        self.eventType = eventType
        self.subType = subType
    }


}




public class QueueConversationMessageEventTopicMessageSticker: Codable {





    /** The location of the sticker, useful for retrieving it */
    public var url: String?
    /** The unique id of the the sticker object. */
    public var _id: String?

    public init(url: String?, _id: String?) {
        self.url = url
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case url
        case _id = "id"
    }


}




public class QueueConversationVideoEventTopicCall: Codable {



    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case uploading = "uploading"
        case converting = "converting"
        case transmitting = "transmitting"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case uploading = "uploading"
        case converting = "converting"
        case transmitting = "transmitting"
        case _none = "none"
    }



    public enum RecordingState: String, Codable { 
        case _none = "none"
        case active = "active"
        case paused = "paused"
    }











    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }



    public enum Direction: String, Codable { 
        case outbound = "outbound"
        case inbound = "inbound"
    }



































    /** A globally unique identifier for this communication. */
    public var _id: String?
    public var state: State?
    public var initialState: InitialState?
    /** True if this call is being recorded. */
    public var recording: Bool?
    /** State of recording on this call. */
    public var recordingState: RecordingState?
    /** True if this call is muted so that remote participants can't hear any audio from this end. */
    public var muted: Bool?
    /** True if this call is held and the person on this side hears hold music. */
    public var confined: Bool?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** True when the recording of this call is in secure pause status. */
    public var securePause: Bool?
    public var errorInfo: QueueConversationVideoEventTopicErrorDetails?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the call was placed on hold in the cloud clock if the call is currently on hold. */
    public var startHoldTime: Date?
    /** Whether a call is inbound or outbound. */
    public var direction: Direction?
    /** If call is a fax of a document in content management, the id of the document in content management. */
    public var documentId: String?
    public var _self: QueueConversationVideoEventTopicAddress?
    /** Address and name data for a call endpoint. */
    public var other: QueueConversationVideoEventTopicAddress?
    /** The source provider of the call. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** List of reasons that this call was disconnected. This will be set once the call disconnects. */
    public var disconnectReasons: [QueueConversationVideoEventTopicDisconnectReason]?
    public var faxStatus: QueueConversationVideoEventTopicFaxStatus?
    /** User to User Information (UUI) data managed by SIP session application. */
    public var uuiData: String?
    /** The timestamp when this participant was connected to the barge conference in the provider clock. */
    public var bargedTime: Date?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationVideoEventTopicWrapup?
    public var afterCallWork: QueueConversationVideoEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** UUID of virtual agent assistant that provide suggestions to the agent participant during the conversation. */
    public var agentAssistantId: String?
    public var queueMediaSettings: QueueConversationVideoEventTopicQueueMediaSettings?

    public init(_id: String?, state: State?, initialState: InitialState?, recording: Bool?, recordingState: RecordingState?, muted: Bool?, confined: Bool?, held: Bool?, securePause: Bool?, errorInfo: QueueConversationVideoEventTopicErrorDetails?, disconnectType: DisconnectType?, startHoldTime: Date?, direction: Direction?, documentId: String?, _self: QueueConversationVideoEventTopicAddress?, other: QueueConversationVideoEventTopicAddress?, provider: String?, scriptId: String?, peerId: String?, connectedTime: Date?, disconnectedTime: Date?, disconnectReasons: [QueueConversationVideoEventTopicDisconnectReason]?, faxStatus: QueueConversationVideoEventTopicFaxStatus?, uuiData: String?, bargedTime: Date?, wrapup: QueueConversationVideoEventTopicWrapup?, afterCallWork: QueueConversationVideoEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, agentAssistantId: String?, queueMediaSettings: QueueConversationVideoEventTopicQueueMediaSettings?) {
        self._id = _id
        self.state = state
        self.initialState = initialState
        self.recording = recording
        self.recordingState = recordingState
        self.muted = muted
        self.confined = confined
        self.held = held
        self.securePause = securePause
        self.errorInfo = errorInfo
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.direction = direction
        self.documentId = documentId
        self._self = _self
        self.other = other
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.disconnectReasons = disconnectReasons
        self.faxStatus = faxStatus
        self.uuiData = uuiData
        self.bargedTime = bargedTime
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.agentAssistantId = agentAssistantId
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case initialState
        case recording
        case recordingState
        case muted
        case confined
        case held
        case securePause
        case errorInfo
        case disconnectType
        case startHoldTime
        case direction
        case documentId
        case _self = "self"
        case other
        case provider
        case scriptId
        case peerId
        case connectedTime
        case disconnectedTime
        case disconnectReasons
        case faxStatus
        case uuiData
        case bargedTime
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case agentAssistantId
        case queueMediaSettings
    }


}




public class QueueConversationMessageEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}




public class QueueConversationScreenShareEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}




public class QueueConversationSocialExpressionEventTopicAttachment: Codable {











    /** The unique identifier for the attachment. */
    public var attachmentId: String?
    /** The name of the attachment. */
    public var name: String?
    /** The content uri of the attachment. If set, this is commonly a public api download location. */
    public var contentUri: String?
    /** The type of file the attachment is. */
    public var contentType: String?
    /** The length of the attachment file. */
    public var contentLength: Int?

    public init(attachmentId: String?, name: String?, contentUri: String?, contentType: String?, contentLength: Int?) {
        self.attachmentId = attachmentId
        self.name = name
        self.contentUri = contentUri
        self.contentType = contentType
        self.contentLength = contentLength
    }


}




public class QueueConversationSocialExpressionEventTopicEmail: Codable {



    public enum State: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case disconnected = "disconnected"
        case _none = "none"
        case transmitting = "transmitting"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case disconnected = "disconnected"
        case _none = "none"
        case transmitting = "transmitting"
    }

















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }









    public enum Direction: String, Codable { 
        case outbound = "outbound"
        case inbound = "inbound"
    }













    /** A globally unique identifier for this communication. */
    public var _id: String?
    public var state: State?
    public var initialState: InitialState?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** Indicates that the email was auto-generated like an Out of Office reply. */
    public var autoGenerated: Bool?
    /** The subject for the initial email that started this conversation. */
    public var subject: String?
    /** The source provider of the email. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The number of email messages sent by this participant. */
    public var messagesSent: Int?
    /** Detailed information about an error response. */
    public var errorInfo: QueueConversationSocialExpressionEventTopicErrorDetails?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the email was placed on hold in the cloud clock if the email is currently on hold. */
    public var startHoldTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** A globally unique identifier for the stored content of this communication. */
    public var messageId: String?
    /** Whether an email is inbound or outbound. */
    public var direction: Direction?
    /** A list of uploaded attachments on the email draft. */
    public var draftAttachments: [QueueConversationSocialExpressionEventTopicAttachment]?
    /** Indicates if the inbound email was marked as spam. */
    public var spam: Bool?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationSocialExpressionEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationSocialExpressionEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationSocialExpressionEventTopicQueueMediaSettings?

    public init(_id: String?, state: State?, initialState: InitialState?, held: Bool?, autoGenerated: Bool?, subject: String?, provider: String?, scriptId: String?, peerId: String?, messagesSent: Int?, errorInfo: QueueConversationSocialExpressionEventTopicErrorDetails?, disconnectType: DisconnectType?, startHoldTime: Date?, connectedTime: Date?, disconnectedTime: Date?, messageId: String?, direction: Direction?, draftAttachments: [QueueConversationSocialExpressionEventTopicAttachment]?, spam: Bool?, wrapup: QueueConversationSocialExpressionEventTopicWrapup?, afterCallWork: QueueConversationSocialExpressionEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: QueueConversationSocialExpressionEventTopicQueueMediaSettings?) {
        self._id = _id
        self.state = state
        self.initialState = initialState
        self.held = held
        self.autoGenerated = autoGenerated
        self.subject = subject
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.messagesSent = messagesSent
        self.errorInfo = errorInfo
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.messageId = messageId
        self.direction = direction
        self.draftAttachments = draftAttachments
        self.spam = spam
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case initialState
        case held
        case autoGenerated
        case subject
        case provider
        case scriptId
        case peerId
        case messagesSent
        case errorInfo
        case disconnectType
        case startHoldTime
        case connectedTime
        case disconnectedTime
        case messageId
        case direction
        case draftAttachments
        case spam
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationSocialExpressionEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationSocialExpressionEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}



/** Fields identifying the entity that updated the command. */

public class QueueConversationSocialExpressionEventTopicModifiedBy: Codable {





    /** The id of the user if the updater is an internal user. */
    public var _id: String?
    /** The URI for the user if the updater is an internal user. */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class QueueConversationSocialExpressionEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: QueueConversationSocialExpressionEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int?

    public init(agent: QueueConversationSocialExpressionEventTopicUriReference?, score: Int?) {
        self.agent = agent
        self.score = score
    }


}




public class QueueConversationSocialExpressionEventTopicVideo: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }





















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }















    public var state: State?
    public var initialState: InitialState?
    /** Address and name data for a call endpoint. */
    public var _self: QueueConversationSocialExpressionEventTopicAddress?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The room id context (xmpp jid) for the conference session. */
    public var context: String?
    /** Indicates whether this participant has muted their outgoing audio. */
    public var audioMuted: Bool?
    /** Indicates whether this participant has muted/paused their outgoing video. */
    public var videoMuted: Bool?
    /** Indicates whether this participant is sharing their screen to the session. */
    public var sharingScreen: Bool?
    /** The number of peer participants from the perspective of the participant in the conference. */
    public var peerCount: JSON?
    /** The media provider controlling the video. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** List of media stream ids */
    public var msids: [String]?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationSocialExpressionEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationSocialExpressionEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationSocialExpressionEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _self: QueueConversationSocialExpressionEventTopicAddress?, _id: String?, context: String?, audioMuted: Bool?, videoMuted: Bool?, sharingScreen: Bool?, peerCount: JSON?, provider: String?, scriptId: String?, peerId: String?, disconnectType: DisconnectType?, connectedTime: Date?, disconnectedTime: Date?, msids: [String]?, wrapup: QueueConversationSocialExpressionEventTopicWrapup?, afterCallWork: QueueConversationSocialExpressionEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: QueueConversationSocialExpressionEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._self = _self
        self._id = _id
        self.context = context
        self.audioMuted = audioMuted
        self.videoMuted = videoMuted
        self.sharingScreen = sharingScreen
        self.peerCount = peerCount
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.disconnectType = disconnectType
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.msids = msids
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _self = "self"
        case _id = "id"
        case context
        case audioMuted
        case videoMuted
        case sharingScreen
        case peerCount
        case provider
        case scriptId
        case peerId
        case disconnectType
        case connectedTime
        case disconnectedTime
        case msids
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}



/** Address and name data for a call endpoint. */

public class QueueConversationVideoEventTopicAddress: Codable {











    /** This will be nameRaw if present, or a locality lookup of the address field otherwise. */
    public var name: String?
    /** The name as close to the bits on the wire as possible. */
    public var nameRaw: String?
    /** The normalized address. This field is acquired from the Address Normalization Table.  The addressRaw could have gone through some transformations, such as only using the numeric portion, before being run through the Address Normalization Table. */
    public var addressNormalized: String?
    /** The address as close to the bits on the wire as possible. */
    public var addressRaw: String?
    /** The displayable address. This field is acquired from the Address Normalization Table.  The addressRaw could have gone through some transformations, such as only using the numeric portion, before being run through the Address Normalization Table. */
    public var addressDisplayable: String?

    public init(name: String?, nameRaw: String?, addressNormalized: String?, addressRaw: String?, addressDisplayable: String?) {
        self.name = name
        self.nameRaw = nameRaw
        self.addressNormalized = addressNormalized
        self.addressRaw = addressRaw
        self.addressDisplayable = addressDisplayable
    }


}




public class QueueConversationVideoEventTopicConversation: Codable {

















    public var _id: String?
    public var maxParticipants: Int?
    public var participants: [QueueConversationVideoEventTopicParticipant]?
    public var recentTransfers: [QueueConversationVideoEventTopicRecentTransfer]?
    public var recordingState: String?
    public var address: String?
    public var externalTag: String?
    public var securePause: Bool?

    public init(_id: String?, maxParticipants: Int?, participants: [QueueConversationVideoEventTopicParticipant]?, recentTransfers: [QueueConversationVideoEventTopicRecentTransfer]?, recordingState: String?, address: String?, externalTag: String?, securePause: Bool?) {
        self._id = _id
        self.maxParticipants = maxParticipants
        self.participants = participants
        self.recentTransfers = recentTransfers
        self.recordingState = recordingState
        self.address = address
        self.externalTag = externalTag
        self.securePause = securePause
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case maxParticipants
        case participants
        case recentTransfers
        case recordingState
        case address
        case externalTag
        case securePause
    }


}




public class QueueConversationVideoEventTopicDisconnectReason: Codable {

    public enum ModelType: String, Codable { 
        case q850 = "q850"
        case sip = "sip"
    }





    /** Disconnect reason protocol type. */
    public var type: ModelType?
    /** Protocol specific reason code. See the Q.850 and SIP specs. */
    public var code: Int?
    /** Human readable English description of the disconnect reason. */
    public var phrase: String?

    public init(type: ModelType?, code: Int?, phrase: String?) {
        self.type = type
        self.code = code
        self.phrase = phrase
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class QueueConversationVideoEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int?

    public init(_id: String?, version: Int?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}



/** Metadata information about a message. */

public class QueueConversationVideoEventTopicMessageMetadata: Codable {







    /** Message type. */
    public var type: String?
    /** List of message events, if any */
    public var events: [QueueConversationVideoEventTopicMessageMetadataEvent]?
    /** List of message content, if any */
    public var content: [QueueConversationVideoEventTopicMessageMetadataContent]?

    public init(type: String?, events: [QueueConversationVideoEventTopicMessageMetadataEvent]?, content: [QueueConversationVideoEventTopicMessageMetadataContent]?) {
        self.type = type
        self.events = events
        self.content = content
    }


}




public class QueueConversationVideoEventTopicPhoneNumberColumn: Codable {





    public var columnName: String?
    public var type: String?

    public init(columnName: String?, type: String?) {
        self.columnName = columnName
        self.type = type
    }


}




public class QueueConversationVideoEventTopicSocialExpression: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }





















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }













    public var state: State?
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** A globally unique identifier for the social media. */
    public var socialMediaId: String?
    /** The social network of the communication */
    public var socialMediaHub: String?
    /** The social media user name of the communication */
    public var socialUserName: String?
    /** The text preview of the communication contents */
    public var previewText: String?
    /** A globally unique identifier for the recording associated with this chat. */
    public var recordingId: String?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** The source provider of the social expression. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the chat was placed on hold in the cloud clock if the chat is currently on hold. */
    public var startHoldTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationVideoEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationVideoEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?

    public init(state: State?, initialState: InitialState?, _id: String?, socialMediaId: String?, socialMediaHub: String?, socialUserName: String?, previewText: String?, recordingId: String?, held: Bool?, provider: String?, scriptId: String?, peerId: String?, disconnectType: DisconnectType?, startHoldTime: Date?, connectedTime: Date?, disconnectedTime: Date?, wrapup: QueueConversationVideoEventTopicWrapup?, afterCallWork: QueueConversationVideoEventTopicAfterCallWork?, afterCallWorkRequired: Bool?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.socialMediaId = socialMediaId
        self.socialMediaHub = socialMediaHub
        self.socialUserName = socialUserName
        self.previewText = previewText
        self.recordingId = recordingId
        self.held = held
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case socialMediaId
        case socialMediaHub
        case socialUserName
        case previewText
        case recordingId
        case held
        case provider
        case scriptId
        case peerId
        case disconnectType
        case startHoldTime
        case connectedTime
        case disconnectedTime
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
    }


}



/** A UriReference for a resource */

public class QueueConversationVideoEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class QueueEmailAddress: Codable {





    public var domain: DomainEntityRef?
    public var route: InboundRoute?

    public init(domain: DomainEntityRef?, route: InboundRoute?) {
        self.domain = domain
        self.route = route
    }


}




public class QueueObservationDataContainer: Codable {





    /** A mapping from dimension to value */
    public var group: [String:String]?
    public var data: [ObservationMetricData]?

    public init(group: [String:String]?, data: [ObservationMetricData]?) {
        self.group = group
        self.data = data
    }


}




public class QueueObservationQuery: Codable {



    public enum Metrics: String, Codable { 
        case oactiveusers = "oActiveUsers"
        case oalerting = "oAlerting"
        case ointeracting = "oInteracting"
        case omemberusers = "oMemberUsers"
        case ooffqueueusers = "oOffQueueUsers"
        case oonqueueusers = "oOnQueueUsers"
        case ouserpresences = "oUserPresences"
        case ouserroutingstatuses = "oUserRoutingStatuses"
        case owaiting = "oWaiting"
    }

    public enum DetailMetrics: String, Codable { 
        case oactiveusers = "oActiveUsers"
        case oalerting = "oAlerting"
        case ointeracting = "oInteracting"
        case omemberusers = "oMemberUsers"
        case ooffqueueusers = "oOffQueueUsers"
        case oonqueueusers = "oOnQueueUsers"
        case ouserpresences = "oUserPresences"
        case ouserroutingstatuses = "oUserRoutingStatuses"
        case owaiting = "oWaiting"
    }

    /** Filter to return a subset of observations. Expresses boolean logical predicates as well as dimensional filters */
    public var filter: QueueObservationQueryFilter?
    /** Behaves like a SQL SELECT clause. Only named metrics will be retrieved. */
    public var metrics: [Metrics]?
    /** Metrics for which to include additional detailed observations */
    public var detailMetrics: [DetailMetrics]?

    public init(filter: QueueObservationQueryFilter?, metrics: [Metrics]?, detailMetrics: [DetailMetrics]?) {
        self.filter = filter
        self.metrics = metrics
        self.detailMetrics = detailMetrics
    }


}




public class QueueObservationQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [QueueObservationQueryPredicate]?

    public init(type: ModelType?, predicates: [QueueObservationQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class RecallEntry: Codable {





    public var nbrAttempts: Int?
    public var minutesBetweenAttempts: Int?

    public init(nbrAttempts: Int?, minutesBetweenAttempts: Int?) {
        self.nbrAttempts = nbrAttempts
        self.minutesBetweenAttempts = minutesBetweenAttempts
    }


}



/** Additional identifiers for describing messaging recipient. */

public class RecipientAdditionalIdentifier: Codable {

    public enum ModelType: String, Codable { 
        case deployment = "Deployment"
        case subject = "Subject"
    }



    /** Type of the Identifier */
    public var type: ModelType?
    /** The Identifier value. */
    public var value: String?

    public init(type: ModelType?, value: String?) {
        self.type = type
        self.value = value
    }


}




public class Recording: Codable {























    public enum FileState: String, Codable { 
        case archived = "ARCHIVED"
        case available = "AVAILABLE"
        case deleted = "DELETED"
        case restored = "RESTORED"
        case restoring = "RESTORING"
        case uploading = "UPLOADING"
        case error = "ERROR"
    }











    public enum ArchiveMedium: String, Codable { 
        case cloudarchive = "CLOUDARCHIVE"
    }



















    public enum RecordingFileRole: String, Codable { 
        case customerExperience = "CUSTOMER_EXPERIENCE"
        case adhoc = "ADHOC"
    }

    public enum RecordingErrorStatus: String, Codable { 
        case emailTranscriptTooLarge = "EMAIL_TRANSCRIPT_TOO_LARGE"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var conversationId: String?
    public var path: String?
    /** The start time of the recording. Null when there is no playable media. */
    public var startTime: String?
    /** The end time of the recording. Null when there is no playable media. */
    public var endTime: String?
    /** The type of media that the recording is. At the moment that could be audio, chat, or email. */
    public var media: String?
    /** Annotations that belong to the recording. */
    public var annotations: [Annotation]?
    /** Represents a chat transcript */
    public var transcript: [ChatMessage]?
    /** Represents an email transcript */
    public var emailTranscript: [RecordingEmailMessage]?
    /** Represents a messaging transcript */
    public var messagingTranscript: [RecordingMessagingMessage]?
    /** Represents the current file state for a recording. Examples: Uploading, Archived, etc */
    public var fileState: FileState?
    /** The amount of time a restored recording will remain restored before being archived again. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var restoreExpirationTime: Date?
    /** The different mediaUris for the recording. Null when there is no playable media. */
    public var mediaUris: [String:MediaResult]?
    public var estimatedTranscodeTimeMs: Int64?
    public var actualTranscodeTimeMs: Int64?
    /** The date the recording will be archived. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var archiveDate: Date?
    /** The type of archive medium used. Example: CloudArchive */
    public var archiveMedium: ArchiveMedium?
    /** The date the recording will be deleted. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var deleteDate: Date?
    /** The date the recording will be exported. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var exportDate: Date?
    /** The date the recording was exported. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var exportedDate: Date?
    /** Duration of transcoded media in milliseconds */
    public var outputDurationMs: Int?
    /** Size of transcoded media in bytes. 0 if there is no transcoded media. */
    public var outputSizeInBytes: Int?
    /** How many archive restorations the organization is allowed to have. */
    public var maxAllowedRestorationsForOrg: Int?
    /** The remaining archive restorations the organization has. */
    public var remainingRestorationsAllowedForOrg: Int?
    /** The session id represents an external resource id, such as email, call, chat, etc */
    public var sessionId: String?
    /** The users participating in the conversation */
    public var users: [User]?
    /** Role of the file recording. It can be either customer_experience or adhoc. */
    public var recordingFileRole: RecordingFileRole?
    /** Status of a recording that cannot be returned because of an error */
    public var recordingErrorStatus: RecordingErrorStatus?
    /** The start time of the full recording, before any segment access restrictions are applied. Null when there is no playable media. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var originalRecordingStartTime: Date?
    /** The creation time of the recording. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var creationTime: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, conversationId: String?, path: String?, startTime: String?, endTime: String?, media: String?, annotations: [Annotation]?, transcript: [ChatMessage]?, emailTranscript: [RecordingEmailMessage]?, messagingTranscript: [RecordingMessagingMessage]?, fileState: FileState?, restoreExpirationTime: Date?, mediaUris: [String:MediaResult]?, estimatedTranscodeTimeMs: Int64?, actualTranscodeTimeMs: Int64?, archiveDate: Date?, archiveMedium: ArchiveMedium?, deleteDate: Date?, exportDate: Date?, exportedDate: Date?, outputDurationMs: Int?, outputSizeInBytes: Int?, maxAllowedRestorationsForOrg: Int?, remainingRestorationsAllowedForOrg: Int?, sessionId: String?, users: [User]?, recordingFileRole: RecordingFileRole?, recordingErrorStatus: RecordingErrorStatus?, originalRecordingStartTime: Date?, creationTime: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.conversationId = conversationId
        self.path = path
        self.startTime = startTime
        self.endTime = endTime
        self.media = media
        self.annotations = annotations
        self.transcript = transcript
        self.emailTranscript = emailTranscript
        self.messagingTranscript = messagingTranscript
        self.fileState = fileState
        self.restoreExpirationTime = restoreExpirationTime
        self.mediaUris = mediaUris
        self.estimatedTranscodeTimeMs = estimatedTranscodeTimeMs
        self.actualTranscodeTimeMs = actualTranscodeTimeMs
        self.archiveDate = archiveDate
        self.archiveMedium = archiveMedium
        self.deleteDate = deleteDate
        self.exportDate = exportDate
        self.exportedDate = exportedDate
        self.outputDurationMs = outputDurationMs
        self.outputSizeInBytes = outputSizeInBytes
        self.maxAllowedRestorationsForOrg = maxAllowedRestorationsForOrg
        self.remainingRestorationsAllowedForOrg = remainingRestorationsAllowedForOrg
        self.sessionId = sessionId
        self.users = users
        self.recordingFileRole = recordingFileRole
        self.recordingErrorStatus = recordingErrorStatus
        self.originalRecordingStartTime = originalRecordingStartTime
        self.creationTime = creationTime
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case conversationId
        case path
        case startTime
        case endTime
        case media
        case annotations
        case transcript
        case emailTranscript
        case messagingTranscript
        case fileState
        case restoreExpirationTime
        case mediaUris
        case estimatedTranscodeTimeMs
        case actualTranscodeTimeMs
        case archiveDate
        case archiveMedium
        case deleteDate
        case exportDate
        case exportedDate
        case outputDurationMs
        case outputSizeInBytes
        case maxAllowedRestorationsForOrg
        case remainingRestorationsAllowedForOrg
        case sessionId
        case users
        case recordingFileRole
        case recordingErrorStatus
        case originalRecordingStartTime
        case creationTime
        case selfUri
    }


}




public class RecordingEncryptionConfiguration: Codable {









    public enum KeyConfigurationType: String, Codable { 
        case kmsSymmetric = "KmsSymmetric"
        case localKeyManager = "LocalKeyManager"
        case native = "Native"
        case _none = "None"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** When keyConfigurationType is LocalKeyManager, this should be the url for decryption and must specify the path to where GenesysCloud can requests decryption. When keyConfigurationType is KmsSymmetric, this should be the arn to the key alias for the master key */
    public var url: String?
    /** The api id for Hawk Authentication. Null if keyConfigurationType is KmsSymmetric */
    public var apiId: String?
    /** The api shared symmetric key used for hawk authentication. Null if keyConfigurationType is KmsSymmetric */
    public var apiKey: String?
    /** Type should be LocalKeyManager or KmsSymmetric when create or update Key configurations; 'Native' for disabling configuration. */
    public var keyConfigurationType: KeyConfigurationType?
    /** The error message related to the configuration */
    public var lastError: ErrorBody?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, url: String?, apiId: String?, apiKey: String?, keyConfigurationType: KeyConfigurationType?, lastError: ErrorBody?, selfUri: String?) {
        self._id = _id
        self.url = url
        self.apiId = apiId
        self.apiKey = apiKey
        self.keyConfigurationType = keyConfigurationType
        self.lastError = lastError
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case url
        case apiId
        case apiKey
        case keyConfigurationType
        case lastError
        case selfUri
    }


}




public class RecordingEncryptionConfigurationListing: Codable {







    public var total: Int64?
    public var entities: [RecordingEncryptionConfiguration]?
    public var selfUri: String?

    public init(total: Int64?, entities: [RecordingEncryptionConfiguration]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class RecordingJobEntityListing: Codable {





















    public var entities: [RecordingJob]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [RecordingJob]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class RecordingMessagingMessage: Codable {



























    public enum ContentType: String, Codable { 
        case quickReply = "QuickReply"
        case story = "Story"
        case card = "Card"
        case carousel = "Carousel"
        case attachment = "Attachment"
        case location = "Location"
        case notification = "Notification"
        case genericTemplate = "GenericTemplate"
        case listTemplate = "ListTemplate"
        case postback = "Postback"
        case reactions = "Reactions"
        case mention = "Mention"
        case buttonResponse = "ButtonResponse"
    }

    /** The message sender session id. */
    public var from: String?
    /** The user who sent this message. */
    public var fromUser: User?
    /** The PureCloud external contact sender details. */
    public var fromExternalContact: ExternalContact?
    /** The message recipient. */
    public var to: String?
    /** The time when the message was sent. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var timestamp: Date?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The content of this message. */
    public var messageText: String?
    /** List of media objects attached  with this message. */
    public var messageMediaAttachments: [MessageMediaAttachment]?
    /** List of message stickers attached with this message. */
    public var messageStickerAttachments: [MessageStickerAttachment]?
    /** List of quick reply options offered with this message. */
    public var quickReplies: [QuickReply]?
    /** Button Response selected by user for this message. */
    public var buttonResponse: ButtonResponse?
    /** Ephemeral story content. */
    public var story: RecordingContentStory?
    /** List of cards offered for this message */
    public var cards: [Card]?
    /** Indicates the content type for this message */
    public var contentType: ContentType?

    public init(from: String?, fromUser: User?, fromExternalContact: ExternalContact?, to: String?, timestamp: Date?, _id: String?, messageText: String?, messageMediaAttachments: [MessageMediaAttachment]?, messageStickerAttachments: [MessageStickerAttachment]?, quickReplies: [QuickReply]?, buttonResponse: ButtonResponse?, story: RecordingContentStory?, cards: [Card]?, contentType: ContentType?) {
        self.from = from
        self.fromUser = fromUser
        self.fromExternalContact = fromExternalContact
        self.to = to
        self.timestamp = timestamp
        self._id = _id
        self.messageText = messageText
        self.messageMediaAttachments = messageMediaAttachments
        self.messageStickerAttachments = messageStickerAttachments
        self.quickReplies = quickReplies
        self.buttonResponse = buttonResponse
        self.story = story
        self.cards = cards
        self.contentType = contentType
    }

    public enum CodingKeys: String, CodingKey { 
        case from
        case fromUser
        case fromExternalContact
        case to
        case timestamp
        case _id = "id"
        case messageText
        case messageMediaAttachments
        case messageStickerAttachments
        case quickReplies
        case buttonResponse
        case story
        case cards
        case contentType
    }


}




public class ReplaceRequest: Codable {







    public var changeNumber: Int?
    public var name: String?
    public var authToken: String?

    public init(changeNumber: Int?, name: String?, authToken: String?) {
        self.changeNumber = changeNumber
        self.name = name
        self.authToken = authToken
    }


}




public class ReportMetaData: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var title: String?
    public var _description: String?
    public var keywords: [String]?
    public var availableLocales: [String]?
    public var parameters: [Parameter]?
    public var exampleUrl: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, title: String?, _description: String?, keywords: [String]?, availableLocales: [String]?, parameters: [Parameter]?, exampleUrl: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.title = title
        self._description = _description
        self.keywords = keywords
        self.availableLocales = availableLocales
        self.parameters = parameters
        self.exampleUrl = exampleUrl
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case title
        case _description = "description"
        case keywords
        case availableLocales
        case parameters
        case exampleUrl
        case selfUri
    }


}




public class ReportRunEntry: Codable {









    public enum RunStatus: String, Codable { 
        case running = "RUNNING"
        case completed = "COMPLETED"
        case completedWithErrors = "COMPLETED_WITH_ERRORS"
        case failed = "FAILED"
        case failedTimeout = "FAILED_TIMEOUT"
        case failedDatalimit = "FAILED_DATALIMIT"
        case unableToComplete = "UNABLE_TO_COMPLETE"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var reportId: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var runTime: Date?
    public var runStatus: RunStatus?
    public var errorMessage: String?
    public var runDurationMsec: Int64?
    public var reportUrl: String?
    public var reportFormat: String?
    public var scheduleUri: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, reportId: String?, runTime: Date?, runStatus: RunStatus?, errorMessage: String?, runDurationMsec: Int64?, reportUrl: String?, reportFormat: String?, scheduleUri: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.reportId = reportId
        self.runTime = runTime
        self.runStatus = runStatus
        self.errorMessage = errorMessage
        self.runDurationMsec = runDurationMsec
        self.reportUrl = reportUrl
        self.reportFormat = reportFormat
        self.scheduleUri = scheduleUri
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case reportId
        case runTime
        case runStatus
        case errorMessage
        case runDurationMsec
        case reportUrl
        case reportFormat
        case scheduleUri
        case selfUri
    }


}




public class ReportingDataExportTopicDataExportNotification: Codable {







    public enum Status: String, Codable { 
        case submitted = "SUBMITTED"
        case running = "RUNNING"
        case cancelling = "CANCELLING"
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case completedWithPartialResults = "COMPLETED_WITH_PARTIAL_RESULTS"
        case failed = "FAILED"
    }

    public enum ExportFormat: String, Codable { 
        case csv = "CSV"
        case pdf = "PDF"
    }



    public enum ViewType: String, Codable { 
        case queuePerformanceSummaryView = "QUEUE_PERFORMANCE_SUMMARY_VIEW"
        case queuePerformanceDetailView = "QUEUE_PERFORMANCE_DETAIL_VIEW"
        case interactionSearchView = "INTERACTION_SEARCH_VIEW"
        case agentPerformanceSummaryView = "AGENT_PERFORMANCE_SUMMARY_VIEW"
        case agentPerformanceDetailView = "AGENT_PERFORMANCE_DETAIL_VIEW"
        case agentStatusSummaryView = "AGENT_STATUS_SUMMARY_VIEW"
        case agentStatusDetailView = "AGENT_STATUS_DETAIL_VIEW"
        case agentEvaluationSummaryView = "AGENT_EVALUATION_SUMMARY_VIEW"
        case agentEvaluationDetailView = "AGENT_EVALUATION_DETAIL_VIEW"
        case agentQueueDetailView = "AGENT_QUEUE_DETAIL_VIEW"
        case agentInteractionDetailView = "AGENT_INTERACTION_DETAIL_VIEW"
        case abandonInsightsView = "ABANDON_INSIGHTS_VIEW"
        case skillsPerformanceView = "SKILLS_PERFORMANCE_VIEW"
        case surveyFormPerformanceSummaryView = "SURVEY_FORM_PERFORMANCE_SUMMARY_VIEW"
        case surveyFormPerformanceDetailView = "SURVEY_FORM_PERFORMANCE_DETAIL_VIEW"
        case dnisPerformanceSummaryView = "DNIS_PERFORMANCE_SUMMARY_VIEW"
        case dnisPerformanceDetailView = "DNIS_PERFORMANCE_DETAIL_VIEW"
        case wrapUpPerformanceSummaryView = "WRAP_UP_PERFORMANCE_SUMMARY_VIEW"
        case agentWrapUpPerformanceDetailView = "AGENT_WRAP_UP_PERFORMANCE_DETAIL_VIEW"
        case queueActivitySummaryView = "QUEUE_ACTIVITY_SUMMARY_VIEW"
        case queueActivityDetailView = "QUEUE_ACTIVITY_DETAIL_VIEW"
        case agentQueueActivitySummaryView = "AGENT_QUEUE_ACTIVITY_SUMMARY_VIEW"
        case queueAgentDetailView = "QUEUE_AGENT_DETAIL_VIEW"
        case queueInteractionDetailView = "QUEUE_INTERACTION_DETAIL_VIEW"
        case agentScheduleDetailView = "AGENT_SCHEDULE_DETAIL_VIEW"
        case ivrPerformanceSummaryView = "IVR_PERFORMANCE_SUMMARY_VIEW"
        case ivrPerformanceDetailView = "IVR_PERFORMANCE_DETAIL_VIEW"
        case answerInsightsView = "ANSWER_INSIGHTS_VIEW"
        case handleInsightsView = "HANDLE_INSIGHTS_VIEW"
        case talkInsightsView = "TALK_INSIGHTS_VIEW"
        case holdInsightsView = "HOLD_INSIGHTS_VIEW"
        case acwInsightsView = "ACW_INSIGHTS_VIEW"
        case waitInsightsView = "WAIT_INSIGHTS_VIEW"
        case agentWrapUpPerformanceIntervalDetailView = "AGENT_WRAP_UP_PERFORMANCE_INTERVAL_DETAIL_VIEW"
        case flowOutcomeSummaryView = "FLOW_OUTCOME_SUMMARY_VIEW"
        case flowOutcomePerformanceDetailView = "FLOW_OUTCOME_PERFORMANCE_DETAIL_VIEW"
        case flowOutcomePerformanceIntervalDetailView = "FLOW_OUTCOME_PERFORMANCE_INTERVAL_DETAIL_VIEW"
        case flowDestinationSummaryView = "FLOW_DESTINATION_SUMMARY_VIEW"
        case flowDestinationDetailView = "FLOW_DESTINATION_DETAIL_VIEW"
        case scheduledCallbacksView = "SCHEDULED_CALLBACKS_VIEW"
        case contentSearchView = "CONTENT_SEARCH_VIEW"
        case journeyActionMapSummaryView = "JOURNEY_ACTION_MAP_SUMMARY_VIEW"
        case journeyOutcomeSummaryView = "JOURNEY_OUTCOME_SUMMARY_VIEW"
        case journeySegmentSummaryView = "JOURNEY_SEGMENT_SUMMARY_VIEW"
        case agentDevelopmentDetailView = "AGENT_DEVELOPMENT_DETAIL_VIEW"
        case agentDevelopmentDetailMeView = "AGENT_DEVELOPMENT_DETAIL_ME_VIEW"
        case agentDevelopmentSummaryView = "AGENT_DEVELOPMENT_SUMMARY_VIEW"
        case agentScorecardView = "AGENT_SCORECARD_VIEW"
        case agentScorecardMeView = "AGENT_SCORECARD_ME_VIEW"
        case agentGamificationLeadershipView = "AGENT_GAMIFICATION_LEADERSHIP_VIEW"
        case agentScheduleMeView = "AGENT_SCHEDULE_ME_VIEW"
        case botPerformanceSummaryView = "BOT_PERFORMANCE_SUMMARY_VIEW"
        case botPerformanceDetailView = "BOT_PERFORMANCE_DETAIL_VIEW"
        case topicTrendSummaryView = "TOPIC_TREND_SUMMARY_VIEW"
        case topicTrendDetailView = "TOPIC_TREND_DETAIL_VIEW"
        case actionMapBlockedConstraintsDetailView = "ACTION_MAP_BLOCKED_CONSTRAINTS_DETAIL_VIEW"
        case actionMapBlockedConstraintsIntervalDetailView = "ACTION_MAP_BLOCKED_CONSTRAINTS_INTERVAL_DETAIL_VIEW"
        case flowMilestonePerformanceDetailView = "FLOW_MILESTONE_PERFORMANCE_DETAIL_VIEW"
        case flowMilestonePerformanceIntervalDetailView = "FLOW_MILESTONE_PERFORMANCE_INTERVAL_DETAIL_VIEW"
        case agentTopicSummaryView = "AGENT_TOPIC_SUMMARY_VIEW"
        case agentTopicDetailView = "AGENT_TOPIC_DETAIL_VIEW"
        case queueTopicSummaryView = "QUEUE_TOPIC_SUMMARY_VIEW"
        case queueTopicDetailView = "QUEUE_TOPIC_DETAIL_VIEW"
        case flowTopicSummaryView = "FLOW_TOPIC_SUMMARY_VIEW"
        case flowTopicDetailView = "FLOW_TOPIC_DETAIL_VIEW"
        case agentInteractionsMeView = "AGENT_INTERACTIONS_ME_VIEW"
        case dataActionsPerformanceSummaryView = "DATA_ACTIONS_PERFORMANCE_SUMMARY_VIEW"
        case dataActionsPerformanceDetailView = "DATA_ACTIONS_PERFORMANCE_DETAIL_VIEW"
        case agentTimelineSummaryView = "AGENT_TIMELINE_SUMMARY_VIEW"
        case agentTimelineDetailView = "AGENT_TIMELINE_DETAIL_VIEW"
        case agentLoginLogoutSummaryView = "AGENT_LOGIN_LOGOUT_SUMMARY_VIEW"
        case agentLoginLogoutDetailView = "AGENT_LOGIN_LOGOUT_DETAIL_VIEW"
        case campaignPerformanceSummaryView = "CAMPAIGN_PERFORMANCE_SUMMARY_VIEW"
        case campaignPerformanceDetailView = "CAMPAIGN_PERFORMANCE_DETAIL_VIEW"
        case queueWrapupDetailView = "QUEUE_WRAPUP_DETAIL_VIEW"
        case campaignInteractionDetailView = "CAMPAIGN_INTERACTION_DETAIL_VIEW"
        case campaignAttemptDetailView = "CAMPAIGN_ATTEMPT_DETAIL_VIEW"
        case workitemPerformanceSummaryView = "WORKITEM_PERFORMANCE_SUMMARY_VIEW"
        case queueRoutingPerformanceView = "QUEUE_ROUTING_PERFORMANCE_VIEW"
        case agentWorkitemPerformanceSummaryView = "AGENT_WORKITEM_PERFORMANCE_SUMMARY_VIEW"
        case agentWorkitemPerformanceDetailView = "AGENT_WORKITEM_PERFORMANCE_DETAIL_VIEW"
        case queueWorkitemPerformanceSummaryView = "QUEUE_WORKITEM_PERFORMANCE_SUMMARY_VIEW"
        case queueWorkitemPerformanceDetailView = "QUEUE_WORKITEM_PERFORMANCE_DETAIL_VIEW"
    }

    public enum ExportErrorMessagesType: String, Codable { 
        case failedConvertingExportJob = "FAILED_CONVERTING_EXPORT_JOB"
        case failedNoDataExportJobFound = "FAILED_NO_DATA_EXPORT_JOB_FOUND"
        case failedGettingDataFromService = "FAILED_GETTING_DATA_FROM_SERVICE"
        case failedGeneratingTempFile = "FAILED_GENERATING_TEMP_FILE"
        case failedSavingFileToS3 = "FAILED_SAVING_FILE_TO_S3"
        case failedNotifyingSkywalkerOfDownload = "FAILED_NOTIFYING_SKYWALKER_OF_DOWNLOAD"
        case failedBuildingDownloadUrlFromSkywalkerResponse = "FAILED_BUILDING_DOWNLOAD_URL_FROM_SKYWALKER_RESPONSE"
        case exportTypeNotImplemented = "EXPORT_TYPE_NOT_IMPLEMENTED"
        case reachedMaximumAttemptOfRetry = "REACHED_MAXIMUM_ATTEMPT_OF_RETRY"
        case failedLongRunningExport = "FAILED_LONG_RUNNING_EXPORT"
        case tooManyRequestsFromAnOrganization = "TOO_MANY_REQUESTS_FROM_AN_ORGANIZATION"
        case failedAsExportFileSizeIsGreaterThan10mb = "FAILED_AS_EXPORT_FILE_SIZE_IS_GREATER_THAN_10MB"
        case notAuthorizedToViewExport = "NOT_AUTHORIZED_TO_VIEW_EXPORT"
        case staticLinkExportFailed = "STATIC_LINK_EXPORT_FAILED"
        case tooManySearchCriteria = "TOO_MANY_SEARCH_CRITERIA"
        case searchCriteriaValuesExceedLimit = "SEARCH_CRITERIA_VALUES_EXCEED_LIMIT"
        case exportEmailFileSizeExceededLimit = "EXPORT_EMAIL_FILE_SIZE_EXCEEDED_LIMIT"
        case circuitBreakerOpenForViewType = "CIRCUIT_BREAKER_OPEN_FOR_VIEW_TYPE"
    }



















    public var _id: String?
    public var runId: String?
    public var name: String?
    public var status: Status?
    public var exportFormat: ExportFormat?
    public var downloadUrl: String?
    public var viewType: ViewType?
    public var exportErrorMessagesType: ExportErrorMessagesType?
    public var read: Bool?
    public var createdDateTime: Date?
    public var modifiedDateTime: Date?
    public var percentageComplete: Double?
    public var emailStatuses: [String:String]?
    public var emailErrorDescription: String?
    public var scheduleExpression: String?
    public var scheduleStaticLinkUrl: String?
    public var exportAllowedToRerun: Bool?

    public init(_id: String?, runId: String?, name: String?, status: Status?, exportFormat: ExportFormat?, downloadUrl: String?, viewType: ViewType?, exportErrorMessagesType: ExportErrorMessagesType?, read: Bool?, createdDateTime: Date?, modifiedDateTime: Date?, percentageComplete: Double?, emailStatuses: [String:String]?, emailErrorDescription: String?, scheduleExpression: String?, scheduleStaticLinkUrl: String?, exportAllowedToRerun: Bool?) {
        self._id = _id
        self.runId = runId
        self.name = name
        self.status = status
        self.exportFormat = exportFormat
        self.downloadUrl = downloadUrl
        self.viewType = viewType
        self.exportErrorMessagesType = exportErrorMessagesType
        self.read = read
        self.createdDateTime = createdDateTime
        self.modifiedDateTime = modifiedDateTime
        self.percentageComplete = percentageComplete
        self.emailStatuses = emailStatuses
        self.emailErrorDescription = emailErrorDescription
        self.scheduleExpression = scheduleExpression
        self.scheduleStaticLinkUrl = scheduleStaticLinkUrl
        self.exportAllowedToRerun = exportAllowedToRerun
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case runId
        case name
        case status
        case exportFormat
        case downloadUrl
        case viewType
        case exportErrorMessagesType
        case read
        case createdDateTime
        case modifiedDateTime
        case percentageComplete
        case emailStatuses
        case emailErrorDescription
        case scheduleExpression
        case scheduleStaticLinkUrl
        case exportAllowedToRerun
    }


}




public class ReportingExportMetadataJobListing: Codable {





















    public var entities: [ReportingExportMetadataJobResponse]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ReportingExportMetadataJobResponse]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ReportingTurnAction: Codable {







    public enum ActionType: String, Codable { 
        case addFlowMilestoneAction = "AddFlowMilestoneAction"
        case askForNLUIntentAction = "AskForNLUIntentAction"
        case askForBooleanAction = "AskForBooleanAction"
        case askForSlotAction = "AskForSlotAction"
        case askForNLUNextIntentAction = "AskForNLUNextIntentAction"
        case botState = "BotState"
        case callTaskAction = "CallTaskAction"
        case clearSlotAction = "ClearSlotAction"
        case clearUtilizationLabelAction = "ClearUtilizationLabelAction"
        case disconnectAction = "DisconnectAction"
        case endTaskAction = "EndTaskAction"
        case exitBotFlowAction = "ExitBotFlowAction"
        case updateVariableAction = "UpdateVariableAction"
        case communicateAction = "CommunicateAction"
        case decisionAction = "DecisionAction"
        case findGrammarAction = "FindGrammarAction"
        case findGrammarByIdAction = "FindGrammarByIdAction"
        case findGroupAction = "FindGroupAction"
        case findLanguageSkillAction = "FindLanguageSkillAction"
        case findQueueAction = "FindQueueAction"
        case findQueueByIdAction = "FindQueueByIdAction"
        case findSkillAction = "FindSkillAction"
        case findSystemPromptAction = "FindSystemPromptAction"
        case findUserAction = "FindUserAction"
        case findUserByIdAction = "FindUserByIdAction"
        case findUsersByIdAction = "FindUsersByIdAction"
        case findUserPromptAction = "FindUserPromptAction"
        case findUtilizationLabelAction = "FindUtilizationLabelAction"
        case switchAction = "SwitchAction"
        case dataAction = "DataAction"
        case dataTableLookupAction = "DataTableLookupAction"
        case getExternalContactAction = "GetExternalContactAction"
        case getExternalOrganizationAction = "GetExternalOrganizationAction"
        case loopAction = "LoopAction"
        case exitLoopAction = "ExitLoopAction"
        case nextLoopAction = "NextLoopAction"
        case loopUntilAction = "LoopUntilAction"
        case setActiveIntentAction = "SetActiveIntentAction"
        case setFlowOutcomeAction = "SetFlowOutcomeAction"
        case initializeFlowOutcomeAction = "InitializeFlowOutcomeAction"
        case askForStringAction = "AskForStringAction"
        case sendResponseAction = "SendResponseAction"
        case getResponseAction = "GetResponseAction"
        case extractSecureDataAction = "ExtractSecureDataAction"
        case secureAction = "SecureAction"
        case transferTaskAction = "TransferTaskAction"
        case digitalMenuAction = "DigitalMenuAction"
        case waitForInputAction = "WaitForInputAction"
        case showKnowledgeArticleAction = "ShowKnowledgeArticleAction"
        case setLocaleAction = "SetLocaleAction"
        case setUtilizationLabelAction = "SetUtilizationLabelAction"
        case transferPureMatchAction = "TransferPureMatchAction"
        case unknown = "Unknown"
    }

    /** The ID of the action in the bot flow. */
    public var actionId: String?
    /** The name of the action in the bot flow. */
    public var actionName: String?
    /** The number of the action in the bot flow. */
    public var actionNumber: Int?
    public var actionType: ActionType?

    public init(actionId: String?, actionName: String?, actionNumber: Int?, actionType: ActionType?) {
        self.actionId = actionId
        self.actionName = actionName
        self.actionNumber = actionNumber
        self.actionType = actionType
    }


}




public class ReportingTurnIntent: Codable {







    /** The name of the intent detected during this reporting turn. */
    public var name: String?
    /** The confidence score of the intent detected during this reporting turn. */
    public var confidence: Double?
    /** The slots detected during this reporting turn. */
    public var slots: [ReportingTurnIntentSlot]?

    public init(name: String?, confidence: Double?, slots: [ReportingTurnIntentSlot]?) {
        self.name = name
        self.confidence = confidence
        self.slots = slots
    }


}




public class ReportingTurnKnowledgeFeedback: Codable {







    /** The ID of the original knowledge search that this feedback relates to. */
    public var searchId: String?
    /** The feedback rating for the search (1.0 - 5.0). 1 = Negative, 5 = Positive. */
    public var rating: Int?
    /** The list of search documents that the feedback applies to. */
    public var documents: [ReportingTurnKnowledgeDocument]?

    public init(searchId: String?, rating: Int?, documents: [ReportingTurnKnowledgeDocument]?) {
        self.searchId = searchId
        self.rating = rating
        self.documents = documents
    }


}




public class ReportingTurnKnowledgeSearch: Codable {







    /** The ID of this knowledge search. */
    public var searchId: String?
    /** The list of search documents captured during this reporting turn. */
    public var documents: [ReportingTurnKnowledgeDocument]?
    /** The search query that was used to search the Knowledge Base documents for a matching question. */
    public var query: String?

    public init(searchId: String?, documents: [ReportingTurnKnowledgeDocument]?, query: String?) {
        self.searchId = searchId
        self.documents = documents
        self.query = query
    }


}




public class RequestContextPattern: Codable {



    /** A list of one or more criteria to satisfy. */
    public var criteria: [RequestEntityTypeCriteria]?

    public init(criteria: [RequestEntityTypeCriteria]?) {
        self.criteria = criteria
    }


}




public class ResolutionDetailQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [ResolutionDetailQueryPredicate]?

    public init(type: ModelType?, predicates: [ResolutionDetailQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class ResourceConditionNode: Codable {



    public enum Conjunction: String, Codable { 
        case and = "AND"
        case or = "OR"
    }

    public enum Operator: String, Codable { 
        case eq = "EQ"
        case _in = "IN"
        case ge = "GE"
        case gt = "GT"
        case le = "LE"
        case lt = "LT"
    }





    public var variableName: String?
    public var conjunction: Conjunction?
    public var _operator: Operator?
    public var operands: [ResourceConditionValue]?
    public var terms: [ResourceConditionNode]?

    public init(variableName: String?, conjunction: Conjunction?, _operator: Operator?, operands: [ResourceConditionValue]?, terms: [ResourceConditionNode]?) {
        self.variableName = variableName
        self.conjunction = conjunction
        self._operator = _operator
        self.operands = operands
        self.terms = terms
    }

    public enum CodingKeys: String, CodingKey { 
        case variableName
        case conjunction
        case _operator = "operator"
        case operands
        case terms
    }


}




public class Ring: Codable {







    /** The conditions that will trigger conversations to move to the next bullseye ring. */
    public var expansionCriteria: [ExpansionCriterium]?
    /** The actions that will be performed just before moving conversations to the next bullseye ring. */
    public var actions: Actions?
    /** The groups of agents associated with the ring, if any.  Ring membership will update to match group membership changes. */
    public var memberGroups: [MemberGroup]?

    public init(expansionCriteria: [ExpansionCriterium]?, actions: Actions?, memberGroups: [MemberGroup]?) {
        self.expansionCriteria = expansionCriteria
        self.actions = actions
        self.memberGroups = memberGroups
    }


}



/** Defines response components of the Action Request. */

public class ResponseConfig: Codable {









    /** Map 'attribute name' and 'JSON path' pairs used to extract data from REST response. */
    public var translationMap: [String:String]?
    /** Map 'attribute name' and 'default value' pairs used as fallback values if JSON path extraction fails for specified key. */
    public var translationMapDefaults: [String:String]?
    /** Velocity template to build response to return from Action. */
    public var successTemplate: String?
    /** URI to retrieve success template. */
    public var successTemplateUri: String?

    public init(translationMap: [String:String]?, translationMapDefaults: [String:String]?, successTemplate: String?, successTemplateUri: String?) {
        self.translationMap = translationMap
        self.translationMapDefaults = translationMapDefaults
        self.successTemplate = successTemplate
        self.successTemplateUri = successTemplateUri
    }


}



/** Used to return response query results */

public class ResponseQueryResults: Codable {



    /** Contains the query results */
    public var results: ResponseEntityList?

    public init(results: ResponseEntityList?) {
        self.results = results
    }


}




public class RestorePresenceSettings: Codable {







    /** Whether the restore presence feature is enabled */
    public var enabled: Bool?
    /** How many milliseconds the presence will be restored within */
    public var restoreTimeMilliseconds: Int64?
    /** Whether the ON_QUEUE presence will be restored */
    public var restoreOnQueueEnabled: Bool?

    public init(enabled: Bool?, restoreTimeMilliseconds: Int64?, restoreOnQueueEnabled: Bool?) {
        self.enabled = enabled
        self.restoreTimeMilliseconds = restoreTimeMilliseconds
        self.restoreOnQueueEnabled = restoreOnQueueEnabled
    }


}




public class ResultCounters: Codable {





    public var success: Int?
    public var failure: Int?

    public init(success: Int?, failure: Int?) {
        self.success = success
        self.failure = failure
    }


}




public class RetentionDuration: Codable {





    public var archiveRetention: ArchiveRetention?
    public var deleteRetention: DeleteRetention?

    public init(archiveRetention: ArchiveRetention?, deleteRetention: DeleteRetention?) {
        self.archiveRetention = archiveRetention
        self.deleteRetention = deleteRetention
    }


}




public class RoleDivisionPair: Codable {





    /** The ID of the role */
    public var roleId: String?
    /** The ID of the division */
    public var divisionId: String?

    public init(roleId: String?, divisionId: String?) {
        self.roleId = roleId
        self.divisionId = divisionId
    }


}




public class RoutingSkill: Codable {







    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the skill. */
    public var name: String?
    /** Date last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The current state for this skill. */
    public var state: State?
    /** Required when updating. Version must be the current version. Only the system can assign version. */
    public var version: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateModified: Date?, state: State?, version: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateModified = dateModified
        self.state = state
        self.version = version
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateModified
        case state
        case version
        case selfUri
    }


}




public class RoutingStatusDetailQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case routingstatus = "routingStatus"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension predicates */
    public var value: String?
    /** Right hand side for dimension predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case _operator = "operator"
        case value
        case range
    }


}




public class RoutingTransferEvent: Codable {







    public enum TransferType: String, Codable { 
        case attended = "Attended"
        case unattended = "Unattended"
    }















    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** Indicates the desired type of transfer. */
    public var transferType: TransferType?
    /** The id (V4 UUID) used by the external platform to refer to the transfer in subsequent *Transfer events. */
    public var commandId: String?
    /** Indicates the desired type of transfer. */
    public var initiatingCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred away from. In many cases this will be the same as the `initiatingCommunicationId`. */
    public var targetCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred. */
    public var objectCommunicationId: String?
    /** The id (V4 UUID) of the desired destination queue that the object communication should be transferred to. */
    public var destinationQueueId: String?
    /** The unique identifier (V4 UUID) for the language that should be used to determine the destination for the conversation. */
    public var languageId: String?
    /** The unique identifiers (V4 UUID) for the skills that should be used to determine the destination for the conversation. */
    public var skillIds: [String]?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, transferType: TransferType?, commandId: String?, initiatingCommunicationId: String?, targetCommunicationId: String?, objectCommunicationId: String?, destinationQueueId: String?, languageId: String?, skillIds: [String]?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.transferType = transferType
        self.commandId = commandId
        self.initiatingCommunicationId = initiatingCommunicationId
        self.targetCommunicationId = targetCommunicationId
        self.objectCommunicationId = objectCommunicationId
        self.destinationQueueId = destinationQueueId
        self.languageId = languageId
        self.skillIds = skillIds
    }


}




public class RuleSetEntityListing: Codable {





















    public var entities: [RuleSet]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [RuleSet]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class SMSAvailablePhoneNumberEntityListing: Codable {



    public var entities: [SmsAvailablePhoneNumber]?

    public init(entities: [SmsAvailablePhoneNumber]?) {
        self.entities = entities
    }


}




public class ScheduleEntityListing: Codable {





















    public var entities: [Schedule]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Schedule]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ScheduleGenerationWarning: Codable {








    public enum UnableToScheduleRequiredDays: String, Codable { 
        case sunday = "Sunday"
        case monday = "Monday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
        case thursday = "Thursday"
        case friday = "Friday"
        case saturday = "Saturday"
    }





    public enum NoNeedDays: String, Codable { 
        case sunday = "Sunday"
        case monday = "Monday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
        case thursday = "Thursday"
        case friday = "Friday"
        case saturday = "Saturday"
    }


    /** ID of the user in the warning */
    public var userId: String?
    /** Whether the user does not have the appropriate license to be scheduled */
    public var userNotLicensed: Bool?
    /** Whether the number of scheduled days exceeded the maximum days to schedule defined in the agent work plan */
    public var unableToMeetMaxDays: Bool?
    /** Days indicated as required to work in agent work plan where no viable shift was found to schedule */
    public var unableToScheduleRequiredDays: [UnableToScheduleRequiredDays]?
    /** Whether the schedule did not meet the minimum paid time for the week defined in the agent work plan */
    public var unableToMeetMinPaidForTheWeek: Bool?
    /** Whether the schedule exceeded the maximum paid time for the week defined in the agent work plan */
    public var unableToMeetMaxPaidForTheWeek: Bool?
    /** Days agent was scheduled but there was no need to meet. The scheduled days have no effect on service levels */
    public var noNeedDays: [NoNeedDays]?
    /** Whether the schedule did not meet the minimum time between shifts defined in the agent work plan */
    public var shiftsTooCloseTogether: Bool?

    public init(userId: String?, userNotLicensed: Bool?, unableToMeetMaxDays: Bool?, unableToScheduleRequiredDays: [UnableToScheduleRequiredDays]?, unableToMeetMinPaidForTheWeek: Bool?, unableToMeetMaxPaidForTheWeek: Bool?, noNeedDays: [NoNeedDays]?, shiftsTooCloseTogether: Bool?) {
        self.userId = userId
        self.userNotLicensed = userNotLicensed
        self.unableToMeetMaxDays = unableToMeetMaxDays
        self.unableToScheduleRequiredDays = unableToScheduleRequiredDays
        self.unableToMeetMinPaidForTheWeek = unableToMeetMinPaidForTheWeek
        self.unableToMeetMaxPaidForTheWeek = unableToMeetMaxPaidForTheWeek
        self.noNeedDays = noNeedDays
        self.shiftsTooCloseTogether = shiftsTooCloseTogether
    }


}




public class ScheduleGroupEntityListing: Codable {





















    public var entities: [ScheduleGroup]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ScheduleGroup]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ScheduleInterval: Codable {





    /** The scheduled start time as an ISO-8601 string, i.e yyyy-MM-ddTHH:mm:ss.SSSZ */
    public var start: String?
    /** The scheduled end time as an ISO-8601 string, i.e. yyyy-MM-ddTHH:mm:ss.SSSZ */
    public var end: String?

    public init(start: String?, end: String?) {
        self.start = start
        self.end = end
    }


}




public class SchedulingNoForecastOptionsRequest: Codable {

    public enum ShiftLength: String, Codable { 
        case shortest = "Shortest"
        case median = "Median"
        case longest = "Longest"
        case random = "Random"
    }

    public enum ShiftStart: String, Codable { 
        case earliest = "Earliest"
        case median = "Median"
        case latest = "Latest"
        case random = "Random"
    }

    /** The shift length option to apply if no forecast is supplied */
    public var shiftLength: ShiftLength?
    /** The shift start option to apply if no forecast is supplied */
    public var shiftStart: ShiftStart?

    public init(shiftLength: ShiftLength?, shiftStart: ShiftStart?) {
        self.shiftLength = shiftLength
        self.shiftStart = shiftStart
    }


}




public class SchedulingProcessingError: Codable {

    public enum InternalErrorCode: String, Codable { 
        case badJson = "BadJson"
        case notFound = "NotFound"
        case fail = "Fail"
    }



    /** An internal code representing the type of error. BadJson for 'Unable to parse json.' NotFound for 'Resource not found.' Fail for 'An unexpected server error occured.' */
    public var internalErrorCode: InternalErrorCode?
    /** A text description of the error */
    public var _description: String?

    public init(internalErrorCode: InternalErrorCode?, _description: String?) {
        self.internalErrorCode = internalErrorCode
        self._description = _description
    }

    public enum CodingKeys: String, CodingKey { 
        case internalErrorCode
        case _description = "description"
    }


}



/** Defines a response for a list of SCIM groups. */

public class ScimGroupListResponse: Codable {











    /** The list of supported schemas. */
    public var schemas: [String]?
    /** The total number of results. */
    public var totalResults: Int64?
    /** The 1-based index of the first result returned by this request. Add this to \"itemsPerPage\" when requesting the next page of results. */
    public var startIndex: Int64?
    /** The number of resources returned per page. */
    public var itemsPerPage: Int64?
    /** The list of requested resources. If \"count\" is 0, then the list will be empty. */
    public var resources: [ScimV2Group]?

    public init(schemas: [String]?, totalResults: Int64?, startIndex: Int64?, itemsPerPage: Int64?, resources: [ScimV2Group]?) {
        self.schemas = schemas
        self.totalResults = totalResults
        self.startIndex = startIndex
        self.itemsPerPage = itemsPerPage
        self.resources = resources
    }

    public enum CodingKeys: String, CodingKey { 
        case schemas
        case totalResults
        case startIndex
        case itemsPerPage
        case resources = "Resources"
    }


}



/** Defines a response for a list of SCIM users. */

public class ScimUserListResponse: Codable {











    /** The list of supported schemas. */
    public var schemas: [String]?
    /** The total number of results. */
    public var totalResults: Int64?
    /** The 1-based index of the first result returned by this request. Add this to \"itemsPerPage\" when requesting the next page of results. */
    public var startIndex: Int64?
    /** The number of resources returned per page. */
    public var itemsPerPage: Int64?
    /** The list of requested resources. If \"count\" is 0, then the list will be empty. */
    public var resources: [ScimV2User]?

    public init(schemas: [String]?, totalResults: Int64?, startIndex: Int64?, itemsPerPage: Int64?, resources: [ScimV2User]?) {
        self.schemas = schemas
        self.totalResults = totalResults
        self.startIndex = startIndex
        self.itemsPerPage = itemsPerPage
        self.resources = resources
    }

    public enum CodingKeys: String, CodingKey { 
        case schemas
        case totalResults
        case startIndex
        case itemsPerPage
        case resources = "Resources"
    }


}




public class ScorableSurvey: Codable {







    public enum Status: String, Codable { 
        case pending = "Pending"
        case sent = "Sent"
        case inProgress = "InProgress"
        case finished = "Finished"
        case optOut = "OptOut"
        case error = "Error"
        case expired = "Expired"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Survey form used for this survey. */
    public var surveyForm: SurveyForm?
    public var status: Status?
    public var answers: SurveyScoringSet?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, surveyForm: SurveyForm?, status: Status?, answers: SurveyScoringSet?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.surveyForm = surveyForm
        self.status = status
        self.answers = answers
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case surveyForm
        case status
        case answers
        case selfUri
    }


}




public class SdkLibrary: Codable {





    /** The name of the SDK. */
    public var name: String?
    /** The version of the SDK. */
    public var version: String?

    public init(name: String?, version: String?) {
        self.name = name
        self.version = version
    }


}




public class Section: Codable {









    public var fieldList: [FieldList]?
    public var instructionText: String?
    public var key: String?
    public var state: String?

    public init(fieldList: [FieldList]?, instructionText: String?, key: String?, state: String?) {
        self.fieldList = fieldList
        self.instructionText = instructionText
        self.key = key
        self.state = state
    }


}




public class SecureSession: Codable {







    public enum State: String, Codable { 
        case pending = "PENDING"
        case completed = "COMPLETED"
        case failed = "FAILED"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The flow to execute securely */
    public var flow: DomainEntityRef?
    /** Customer-provided data */
    public var userData: String?
    /** The current state of a secure session */
    public var state: State?
    /** Unique identifier for the participant initiating the secure session. */
    public var sourceParticipantId: String?
    /** If true, disconnect the agent after creating the session */
    public var disconnect: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, flow: DomainEntityRef?, userData: String?, state: State?, sourceParticipantId: String?, disconnect: Bool?, selfUri: String?) {
        self._id = _id
        self.flow = flow
        self.userData = userData
        self.state = state
        self.sourceParticipantId = sourceParticipantId
        self.disconnect = disconnect
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case flow
        case userData
        case state
        case sourceParticipantId
        case disconnect
        case selfUri
    }


}




public class SegmentDetailQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case addressfrom = "addressFrom"
        case addressto = "addressTo"
        case agentassistantid = "agentAssistantId"
        case agentowned = "agentOwned"
        case ani = "ani"
        case authenticated = "authenticated"
        case bargedparticipantid = "bargedParticipantId"
        case callbacknumber = "callbackNumber"
        case callbackscheduledtime = "callbackScheduledTime"
        case canonicalexternalcontactid = "canonicalExternalContactId"
        case cleared = "cleared"
        case coachedparticipantid = "coachedParticipantId"
        case conference = "conference"
        case deliverystatus = "deliveryStatus"
        case destinationaddress = "destinationAddress"
        case destinationconversationid = "destinationConversationId"
        case direction = "direction"
        case disconnecttype = "disconnectType"
        case dnis = "dnis"
        case edgeid = "edgeId"
        case errorcode = "errorCode"
        case exitreason = "exitReason"
        case extendeddeliverystatus = "extendedDeliveryStatus"
        case externalcontactid = "externalContactId"
        case externalorganizationid = "externalOrganizationId"
        case flaggedreason = "flaggedReason"
        case flowid = "flowId"
        case flowname = "flowName"
        case flowouttype = "flowOutType"
        case flowoutcome = "flowOutcome"
        case flowoutcomeid = "flowOutcomeId"
        case flowoutcomevalue = "flowOutcomeValue"
        case flowversion = "flowVersion"
        case groupid = "groupId"
        case journeyactionid = "journeyActionId"
        case journeyactionmapid = "journeyActionMapId"
        case journeycustomerid = "journeyCustomerId"
        case journeycustomeridtype = "journeyCustomerIdType"
        case journeycustomersessionid = "journeyCustomerSessionId"
        case mediacount = "mediaCount"
        case mediatype = "mediaType"
        case messagetype = "messageType"
        case monitoredparticipantid = "monitoredParticipantId"
        case outboundcampaignid = "outboundCampaignId"
        case outboundcontactid = "outboundContactId"
        case outboundcontactlistid = "outboundContactListId"
        case participantname = "participantName"
        case protocolcallid = "protocolCallId"
        case provider = "provider"
        case purpose = "purpose"
        case queueid = "queueId"
        case recording = "recording"
        case remote = "remote"
        case remotenamedisplayable = "remoteNameDisplayable"
        case requestedlanguageid = "requestedLanguageId"
        case requestedrouting = "requestedRouting"
        case requestedroutingskillid = "requestedRoutingSkillId"
        case scoredagentid = "scoredAgentId"
        case scriptid = "scriptId"
        case segmentend = "segmentEnd"
        case segmenttype = "segmentType"
        case sessiondnis = "sessionDnis"
        case sipresponsecode = "sipResponseCode"
        case subject = "subject"
        case teamid = "teamId"
        case transfertargetaddress = "transferTargetAddress"
        case transfertargetname = "transferTargetName"
        case transfertype = "transferType"
        case usedrouting = "usedRouting"
        case userid = "userId"
        case wrapupcode = "wrapUpCode"
        case wrapupnote = "wrapUpNote"
    }

    public enum PropertyType: String, Codable { 
        case bool = "bool"
        case integer = "integer"
        case real = "real"
        case date = "date"
        case string = "string"
        case uuid = "uuid"
    }



    public enum Metric: String, Codable { 
        case tsegmentduration = "tSegmentDuration"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Left hand side for property predicates */
    public var propertyType: PropertyType?
    /** Left hand side for property predicates */
    public var property: String?
    /** Left hand side for metric predicates */
    public var metric: Metric?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension, metric, or property predicates */
    public var value: String?
    /** Right hand side for dimension, metric, or property predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, propertyType: PropertyType?, property: String?, metric: Metric?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self.propertyType = propertyType
        self.property = property
        self.metric = metric
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case propertyType
        case property
        case metric
        case _operator = "operator"
        case value
        case range
    }


}




public class SegmentUrl: Codable {





    /** The Recording Reference */
    public var recording: AddressableEntityRef?
    /** The pre-signed S3 URL of the transcript */
    public var url: String?

    public init(recording: AddressableEntityRef?, url: String?) {
        self.recording = recording
        self.url = url
    }


}




public class SendAgentlessOutboundMessageRequest: Codable {





    public enum ToAddressMessengerType: String, Codable { 
        case sms = "sms"
        case whatsapp = "whatsapp"
        case _open = "open"
    }







    /** The messaging address of the sender of the message. For an SMS messenger type, this must be a currently provisioned SMS phone number. For a WhatsApp messenger type use the provisioned WhatsApp integration’s ID */
    public var fromAddress: String?
    /** The messaging address of the recipient of the message. For an SMS messenger type, the phone number address must be in E.164 format. E.g. +13175555555 or +34234234234. For WhatsApp messenger type, use a WhatsApp ID of a phone number. E.g for a E.164 formatted phone number `+13175555555`, a WhatsApp ID would be 13175555555 */
    public var toAddress: String?
    /** The recipient messaging address messenger type. */
    public var toAddressMessengerType: ToAddressMessengerType?
    /** The text of the message to send. This field is required in the case of SMS messenger type. Maximum character counts are: SMS - 765 characters, other channels - 2000 characters. */
    public var textBody: String?
    /** The messaging template to use in the case of WhatsApp messenger type. This field is required when using WhatsApp messenger type */
    public var messagingTemplate: MessagingTemplateRequest?
    /** Use an existing active conversation to send the agentless outbound message. Set this parameter to 'true' to use active conversation. Default value: false */
    public var useExistingActiveConversation: Bool?

    public init(fromAddress: String?, toAddress: String?, toAddressMessengerType: ToAddressMessengerType?, textBody: String?, messagingTemplate: MessagingTemplateRequest?, useExistingActiveConversation: Bool?) {
        self.fromAddress = fromAddress
        self.toAddress = toAddress
        self.toAddressMessengerType = toAddressMessengerType
        self.textBody = textBody
        self.messagingTemplate = messagingTemplate
        self.useExistingActiveConversation = useExistingActiveConversation
    }


}




public class ServiceLevel: Codable {





    /** The desired Service Level. A value between 0 and 1. */
    public var percentage: Double?
    /** Service Level target in milliseconds. */
    public var durationMs: Int64?

    public init(percentage: Double?, durationMs: Int64?) {
        self.percentage = percentage
        self.durationMs = durationMs
    }


}




public class Session: Codable {



































































    public enum OriginatingDirection: String, Codable { 
        case unknown = "Unknown"
        case inbound = "Inbound"
        case outbound = "Outbound"
    }



    public enum LastUserDisconnectType: String, Codable { 
        case unknown = "Unknown"
        case endpoint = "Endpoint"
        case client = "Client"
        case system = "System"
        case transfer = "Transfer"
        case error = "Error"
        case peer = "Peer"
        case other = "Other"
        case spam = "Spam"
        case timeout = "Timeout"
        case transportFailure = "TransportFailure"
        case conferenceTransfer = "ConferenceTransfer"
        case consultTransfer = "ConsultTransfer"
        case forwardTransfer = "ForwardTransfer"
        case noAnswerTransfer = "NoAnswerTransfer"
        case notAvailableTransfer = "NotAvailableTransfer"
        case uncallable = "Uncallable"
        case doNotDisturbEndpoint = "DoNotDisturbEndpoint"
        case doNotDisturbTransfer = "DoNotDisturbTransfer"
    }

    public enum LastAcdOutcome: String, Codable { 
        case unknown = "Unknown"
        case abandon = "Abandon"
        case answered = "Answered"
        case flowOut = "FlowOut"
    }

















    /** The ID of the session. */
    public var _id: String?
    /** Primary identifier of the customer in the source where the events for the session originate from. */
    public var customerId: String?
    /** Type of source customer identifier (e.g. cookie, email, phone). */
    public var customerIdType: String?
    /** Session types indicate the type or category of sessions (e.g. web, app). */
    public var type: String?
    /** Unique identifier in the external system where the events for the session originate from. */
    public var externalId: String?
    /** A URL that identifies an external system-of-record resource that may have more detailed information on the session. */
    public var externalUrl: String?
    /** Shortened numeric identifier of 4-6 digits. */
    public var shortId: String?
    /** List of the outcome achievements by the customer in this session. */
    public var outcomeAchievements: [OutcomeAchievement]?
    /** List of the segment assignments to the customer in this session. */
    public var segmentAssignments: [SessionSegmentAssignment]?
    /** Attributes projected from the session's event stream. */
    public var attributes: [String:CustomEventAttribute]?
    /** List-type attributes projected from the session's event stream. */
    public var attributeLists: [String:CustomEventAttributeList]?
    /** Customer's browser. */
    public var browser: Browser?
    /** Customer's device. */
    public var device: Device?
    /** Customer's geolocation. */
    public var geolocation: JourneyGeolocation?
    /** Customer's IP address. */
    public var ipAddress: String?
    /** Customer's IP-based organization or ISP name. */
    public var ipOrganization: String?
    /** The webpage where the customer's last web interaction occurred. */
    public var lastPage: JourneyPage?
    /** Marketing / traffic source information. */
    public var mktCampaign: JourneyCampaign?
    /** Identifies the page URL that originally generated the request for the current page being viewed. */
    public var referrer: Referrer?
    /** Application that the customer is interacting with (for app sessions). */
    public var app: JourneyApp?
    /** SDK library used to generate the events for the session (for app and web sessions). */
    public var sdkLibrary: SdkLibrary?
    /** Information relating to the device's network connectivity (for app sessions). */
    public var networkConnectivity: NetworkConnectivity?
    /** Search terms associated with the session. */
    public var searchTerms: [String]?
    /** String identifying the user agent. */
    public var userAgentString: String?
    /** Indicates how long the session has been active (valid for an individual device). */
    public var durationInSeconds: Int?
    /** The count of all events performed during the session. */
    public var eventCount: Int?
    /** The count of all pageviews performed during the session. */
    public var pageviewCount: Int?
    /** The count of all screenviews performed during the session. */
    public var screenviewCount: Int?
    /** Information about the most recent event in this session. */
    public var lastEvent: SessionLastEvent?
    /** The last queue connected to this session. */
    public var lastConnectedQueue: ConnectedQueue?
    /** The last user connected to this session. */
    public var lastConnectedUser: ConnectedUser?
    /** The last user disposition connected to this session. */
    public var lastUserDisposition: ConversationUserDisposition?
    /** Represents the channels used for this conversation. */
    public var conversationChannels: [ConversationChannel]?
    /** The original direction of the conversation. */
    public var originatingDirection: OriginatingDirection?
    /** The subject for the conversation, for example an email subject. */
    public var conversationSubject: String?
    /** Disconnect reason for the last user connected to the conversation. */
    public var lastUserDisconnectType: LastUserDisconnectType?
    /** Last ACD outcome for the conversation. */
    public var lastAcdOutcome: LastAcdOutcome?
    /** Indicates whether or not the session is authenticated. */
    public var authenticated: Bool?
    /** The URI for this object */
    public var selfUri: String?
    /** Timestamp indicating when the session was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    /** Timestamp indicating when the session was ended. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endedDate: Date?
    /** The external contact associated with this session. */
    public var externalContact: AddressableEntityRef?
    /** Timestamp indicating when the visitor should be considered as away. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var awayDate: Date?
    /** Timestamp indicating when the visitor should be considered as idle. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var idleDate: Date?
    /** The conversation for this session. */
    public var conversation: AddressableEntityRef?

    public init(_id: String?, customerId: String?, customerIdType: String?, type: String?, externalId: String?, externalUrl: String?, shortId: String?, outcomeAchievements: [OutcomeAchievement]?, segmentAssignments: [SessionSegmentAssignment]?, attributes: [String:CustomEventAttribute]?, attributeLists: [String:CustomEventAttributeList]?, browser: Browser?, device: Device?, geolocation: JourneyGeolocation?, ipAddress: String?, ipOrganization: String?, lastPage: JourneyPage?, mktCampaign: JourneyCampaign?, referrer: Referrer?, app: JourneyApp?, sdkLibrary: SdkLibrary?, networkConnectivity: NetworkConnectivity?, searchTerms: [String]?, userAgentString: String?, durationInSeconds: Int?, eventCount: Int?, pageviewCount: Int?, screenviewCount: Int?, lastEvent: SessionLastEvent?, lastConnectedQueue: ConnectedQueue?, lastConnectedUser: ConnectedUser?, lastUserDisposition: ConversationUserDisposition?, conversationChannels: [ConversationChannel]?, originatingDirection: OriginatingDirection?, conversationSubject: String?, lastUserDisconnectType: LastUserDisconnectType?, lastAcdOutcome: LastAcdOutcome?, authenticated: Bool?, selfUri: String?, createdDate: Date?, endedDate: Date?, externalContact: AddressableEntityRef?, awayDate: Date?, idleDate: Date?, conversation: AddressableEntityRef?) {
        self._id = _id
        self.customerId = customerId
        self.customerIdType = customerIdType
        self.type = type
        self.externalId = externalId
        self.externalUrl = externalUrl
        self.shortId = shortId
        self.outcomeAchievements = outcomeAchievements
        self.segmentAssignments = segmentAssignments
        self.attributes = attributes
        self.attributeLists = attributeLists
        self.browser = browser
        self.device = device
        self.geolocation = geolocation
        self.ipAddress = ipAddress
        self.ipOrganization = ipOrganization
        self.lastPage = lastPage
        self.mktCampaign = mktCampaign
        self.referrer = referrer
        self.app = app
        self.sdkLibrary = sdkLibrary
        self.networkConnectivity = networkConnectivity
        self.searchTerms = searchTerms
        self.userAgentString = userAgentString
        self.durationInSeconds = durationInSeconds
        self.eventCount = eventCount
        self.pageviewCount = pageviewCount
        self.screenviewCount = screenviewCount
        self.lastEvent = lastEvent
        self.lastConnectedQueue = lastConnectedQueue
        self.lastConnectedUser = lastConnectedUser
        self.lastUserDisposition = lastUserDisposition
        self.conversationChannels = conversationChannels
        self.originatingDirection = originatingDirection
        self.conversationSubject = conversationSubject
        self.lastUserDisconnectType = lastUserDisconnectType
        self.lastAcdOutcome = lastAcdOutcome
        self.authenticated = authenticated
        self.selfUri = selfUri
        self.createdDate = createdDate
        self.endedDate = endedDate
        self.externalContact = externalContact
        self.awayDate = awayDate
        self.idleDate = idleDate
        self.conversation = conversation
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case customerId
        case customerIdType
        case type
        case externalId
        case externalUrl
        case shortId
        case outcomeAchievements
        case segmentAssignments
        case attributes
        case attributeLists
        case browser
        case device
        case geolocation
        case ipAddress
        case ipOrganization
        case lastPage
        case mktCampaign
        case referrer
        case app
        case sdkLibrary
        case networkConnectivity
        case searchTerms
        case userAgentString
        case durationInSeconds
        case eventCount
        case pageviewCount
        case screenviewCount
        case lastEvent
        case lastConnectedQueue
        case lastConnectedUser
        case lastUserDisposition
        case conversationChannels
        case originatingDirection
        case conversationSubject
        case lastUserDisconnectType
        case lastAcdOutcome
        case authenticated
        case selfUri
        case createdDate
        case endedDate
        case externalContact
        case awayDate
        case idleDate
        case conversation
    }


}




public class SessionListing: Codable {









    public var entities: [Session]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [Session]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class SetSmsPhoneNumberActionSettings: Codable {



    /** The string address for the sms phone number. */
    public var senderSmsPhoneNumber: String?

    public init(senderSmsPhoneNumber: String?) {
        self.senderSmsPhoneNumber = senderSmsPhoneNumber
    }


}




public class SetUuiDataRequest: Codable {



    /** The value of the uuiData to set. */
    public var uuiData: String?

    public init(uuiData: String?) {
        self.uuiData = uuiData
    }


}




public class SetWrapperDayOfWeek: Codable {


    public enum Values: String, Codable { 
        case sunday = "Sunday"
        case monday = "Monday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
        case thursday = "Thursday"
        case friday = "Friday"
        case saturday = "Saturday"
    }
    public var values: [Values]?

    public init(values: [Values]?) {
        self.values = values
    }


}




public class ShiftStartVariance: Codable {


    public enum ApplicableDays: String, Codable { 
        case sunday = "Sunday"
        case monday = "Monday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
        case thursday = "Thursday"
        case friday = "Friday"
        case saturday = "Saturday"
    }


    /** Days for which shift start variance is configured */
    public var applicableDays: [ApplicableDays]?
    /** Maximum variance in minutes across shift starts */
    public var maxShiftStartVarianceMinutes: Int?

    public init(applicableDays: [ApplicableDays]?, maxShiftStartVarianceMinutes: Int?) {
        self.applicableDays = applicableDays
        self.maxShiftStartVarianceMinutes = maxShiftStartVarianceMinutes
    }


}




public class ShiftTradeListResponse: Codable {



    public var entities: [ShiftTradeResponse]?

    public init(entities: [ShiftTradeResponse]?) {
        self.entities = entities
    }


}




public class ShiftTradeSettings: Codable {









    public enum UnequalPaid: String, Codable { 
        case allow = "Allow"
        case disallow = "Disallow"
        case adminReview = "AdminReview"
    }

    public enum OneSided: String, Codable { 
        case allow = "Allow"
        case disallow = "Disallow"
        case adminReview = "AdminReview"
    }

    public enum WeeklyMinPaidViolations: String, Codable { 
        case allow = "Allow"
        case disallow = "Disallow"
        case adminReview = "AdminReview"
    }

    public enum WeeklyMaxPaidViolations: String, Codable { 
        case allow = "Allow"
        case disallow = "Disallow"
        case adminReview = "AdminReview"
    }











    /** Whether shift trading is enabled for this management unit */
    public var enabled: Bool?
    /** Whether automatic shift trade review is enabled according to the rules defined in for this management unit */
    public var autoReview: Bool?
    /** Whether direct shift trades between agents are allowed */
    public var allowDirectTrades: Bool?
    /** The minimum number of hours in the future shift trades are allowed */
    public var minHoursInFuture: Int?
    /** How to handle shift trades which involve unequal paid times */
    public var unequalPaid: UnequalPaid?
    /** How to handle one-sided shift trades */
    public var oneSided: OneSided?
    /** How to handle shift trades which result in violations of weekly minimum paid time constraint */
    public var weeklyMinPaidViolations: WeeklyMinPaidViolations?
    /** How to handle shift trades which result in violations of weekly maximum paid time constraint */
    public var weeklyMaxPaidViolations: WeeklyMaxPaidViolations?
    /** Whether to constrain shift trades to agents with matching queues */
    public var requiresMatchingQueues: Bool?
    /** Whether to constrain shift trades to agents with matching languages */
    public var requiresMatchingLanguages: Bool?
    /** Whether to constrain shift trades to agents with matching skills */
    public var requiresMatchingSkills: Bool?
    /** Whether to constrain shift trades to agents with matching planning groups */
    public var requiresMatchingPlanningGroups: Bool?
    /** Rules that specify what to do with activity categories that are part of a shift defined in a trade */
    public var activityCategoryRules: [ShiftTradeActivityRule]?

    public init(enabled: Bool?, autoReview: Bool?, allowDirectTrades: Bool?, minHoursInFuture: Int?, unequalPaid: UnequalPaid?, oneSided: OneSided?, weeklyMinPaidViolations: WeeklyMinPaidViolations?, weeklyMaxPaidViolations: WeeklyMaxPaidViolations?, requiresMatchingQueues: Bool?, requiresMatchingLanguages: Bool?, requiresMatchingSkills: Bool?, requiresMatchingPlanningGroups: Bool?, activityCategoryRules: [ShiftTradeActivityRule]?) {
        self.enabled = enabled
        self.autoReview = autoReview
        self.allowDirectTrades = allowDirectTrades
        self.minHoursInFuture = minHoursInFuture
        self.unequalPaid = unequalPaid
        self.oneSided = oneSided
        self.weeklyMinPaidViolations = weeklyMinPaidViolations
        self.weeklyMaxPaidViolations = weeklyMaxPaidViolations
        self.requiresMatchingQueues = requiresMatchingQueues
        self.requiresMatchingLanguages = requiresMatchingLanguages
        self.requiresMatchingSkills = requiresMatchingSkills
        self.requiresMatchingPlanningGroups = requiresMatchingPlanningGroups
        self.activityCategoryRules = activityCategoryRules
    }


}




public class ShortTermForecastReference: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?
    /** The weekDate of the short term forecast in yyyy-MM-dd format */
    public var weekDate: String?
    /** The description of the short term forecast */
    public var _description: String?

    public init(_id: String?, selfUri: String?, weekDate: String?, _description: String?) {
        self._id = _id
        self.selfUri = selfUri
        self.weekDate = weekDate
        self._description = _description
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case weekDate
        case _description = "description"
    }


}




public class Site: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }



























    public enum MediaModel: String, Codable { 
        case premises = "Premises"
        case cloud = "Cloud"
    }















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    public var primarySites: [DomainEntityRef]?
    public var secondarySites: [DomainEntityRef]?
    public var primaryEdges: [Edge]?
    public var secondaryEdges: [Edge]?
    public var addresses: [Contact]?
    public var edges: [Edge]?
    /** Recurrance rule, time zone, and start/end settings for automatic edge updates for this site */
    public var edgeAutoUpdateConfig: EdgeAutoUpdateConfig?
    public var mediaRegionsUseLatencyBased: Bool?
    /** Location */
    public var location: LocationDefinition?
    public var managed: Bool?
    /** Network Time Protocol settings for the site */
    public var ntpSettings: NTPSettings?
    /** Media model for the site */
    public var mediaModel: MediaModel?
    /** Is this site a core site */
    public var coreSite: Bool?
    /** The site connections */
    public var siteConnections: [SiteConnection]?
    /** The ordered list of AWS regions through which media can stream. */
    public var mediaRegions: [String]?
    /** The caller ID value for the site. */
    public var callerId: String?
    /** The caller name for the site. */
    public var callerName: String?
    /** Enables premises Edge Force Turn  */
    public var cloudProxyForceTurn: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, primarySites: [DomainEntityRef]?, secondarySites: [DomainEntityRef]?, primaryEdges: [Edge]?, secondaryEdges: [Edge]?, addresses: [Contact]?, edges: [Edge]?, edgeAutoUpdateConfig: EdgeAutoUpdateConfig?, mediaRegionsUseLatencyBased: Bool?, location: LocationDefinition?, managed: Bool?, ntpSettings: NTPSettings?, mediaModel: MediaModel?, coreSite: Bool?, siteConnections: [SiteConnection]?, mediaRegions: [String]?, callerId: String?, callerName: String?, cloudProxyForceTurn: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.primarySites = primarySites
        self.secondarySites = secondarySites
        self.primaryEdges = primaryEdges
        self.secondaryEdges = secondaryEdges
        self.addresses = addresses
        self.edges = edges
        self.edgeAutoUpdateConfig = edgeAutoUpdateConfig
        self.mediaRegionsUseLatencyBased = mediaRegionsUseLatencyBased
        self.location = location
        self.managed = managed
        self.ntpSettings = ntpSettings
        self.mediaModel = mediaModel
        self.coreSite = coreSite
        self.siteConnections = siteConnections
        self.mediaRegions = mediaRegions
        self.callerId = callerId
        self.callerName = callerName
        self.cloudProxyForceTurn = cloudProxyForceTurn
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case primarySites
        case secondarySites
        case primaryEdges
        case secondaryEdges
        case addresses
        case edges
        case edgeAutoUpdateConfig
        case mediaRegionsUseLatencyBased
        case location
        case managed
        case ntpSettings
        case mediaModel
        case coreSite
        case siteConnections
        case mediaRegions
        case callerId
        case callerName
        case cloudProxyForceTurn
        case selfUri
    }


}




public class SignedData: Codable {



    public var jwt: String?

    public init(jwt: String?) {
        self.jwt = jwt
    }


}




public class SingleWorkdayAverageValues: Codable {













    /** The targeted workday for average value query. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateWorkday: Date?
    /** The targeted division for the metrics */
    public var division: Division?
    /** The targeted user for the metrics */
    public var user: UserReference?
    /** The time zone used for aggregating metric values */
    public var timezone: String?
    /** The metric value averages */
    public var results: [WorkdayValuesMetricItem]?
    /** The targeted performance profile for the average points */
    public var performanceProfile: AddressableEntityRef?

    public init(dateWorkday: Date?, division: Division?, user: UserReference?, timezone: String?, results: [WorkdayValuesMetricItem]?, performanceProfile: AddressableEntityRef?) {
        self.dateWorkday = dateWorkday
        self.division = division
        self.user = user
        self.timezone = timezone
        self.results = results
        self.performanceProfile = performanceProfile
    }


}




public class SiteConnection: Codable {









    public enum ModelType: String, Codable { 
        case direct = "Direct"
        case _indirect = "Indirect"
        case cloudProxy = "CloudProxy"
    }



    public enum MediaModel: String, Codable { 
        case premises = "Premises"
        case cloud = "Cloud"
    }









    public var _id: String?
    public var name: String?
    public var selfUri: String?
    public var managed: Bool?
    /** Connection method from site to site (Direct, Indirect, CloudProxy */
    public var type: ModelType?
    /** Indicates if the current site is linked */
    public var enabled: Bool?
    /** Media model for the current site. */
    public var mediaModel: MediaModel?
    /** All of the edges to which the site connects */
    public var edgeList: [ConnectedEdge]?
    /** The core site */
    public var coreSite: Bool?
    /** List of site ids names and selfUris for the primary core sites */
    public var primaryCoreSites: [DomainEntityRef]?
    /** List of site ids names and selfUris for the secondary core sites */
    public var secondaryCoreSites: [DomainEntityRef]?

    public init(_id: String?, name: String?, selfUri: String?, managed: Bool?, type: ModelType?, enabled: Bool?, mediaModel: MediaModel?, edgeList: [ConnectedEdge]?, coreSite: Bool?, primaryCoreSites: [DomainEntityRef]?, secondaryCoreSites: [DomainEntityRef]?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
        self.managed = managed
        self.type = type
        self.enabled = enabled
        self.mediaModel = mediaModel
        self.edgeList = edgeList
        self.coreSite = coreSite
        self.primaryCoreSites = primaryCoreSites
        self.secondaryCoreSites = secondaryCoreSites
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
        case managed
        case type
        case enabled
        case mediaModel
        case edgeList
        case coreSite
        case primaryCoreSites
        case secondaryCoreSites
    }


}




public class SiteConnections: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** List of site connections */
    public var siteConnections: [SiteConnection]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, siteConnections: [SiteConnection]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.siteConnections = siteConnections
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case siteConnections
        case selfUri
    }


}




public class SkillGroupLanguageCondition: Codable {



    public enum Comparator: String, Codable { 
        case equalTo = "EqualTo"
        case notEqualTo = "NotEqualTo"
        case lessThan = "LessThan"
        case greaterThan = "GreaterThan"
        case greaterThanOrEqualTo = "GreaterThanOrEqualTo"
        case lessThanOrEqualTo = "LessThanOrEqualTo"
    }





    /** The language skill to be used in the skill condition query */
    public var languageSkill: String?
    /** Comparator that will be applied to the proficiency */
    public var comparator: Comparator?
    /** The skill proficiency that will be used for the language skill. Integer range 0-5 */
    public var proficiency: Int?
    /** Nested conditions to be applied to this skill condition */
    public var childConditions: [SkillGroupCondition]?

    public init(languageSkill: String?, comparator: Comparator?, proficiency: Int?, childConditions: [SkillGroupCondition]?) {
        self.languageSkill = languageSkill
        self.comparator = comparator
        self.proficiency = proficiency
        self.childConditions = childConditions
    }


}




public class SkillGroupMemberDivisionList: Codable {



    public var entities: [Division]?

    public init(entities: [Division]?) {
        self.entities = entities
    }


}




public class SkillGroupRoutingCondition: Codable {



    public enum Comparator: String, Codable { 
        case equalTo = "EqualTo"
        case notEqualTo = "NotEqualTo"
        case lessThan = "LessThan"
        case greaterThan = "GreaterThan"
        case greaterThanOrEqualTo = "GreaterThanOrEqualTo"
        case lessThanOrEqualTo = "LessThanOrEqualTo"
    }





    /** The routing skill to be used in the skill condition query */
    public var routingSkill: String?
    /** Comparator that will be applied to the proficiency */
    public var comparator: Comparator?
    /** The skill proficiency that will be used for the routing skill. Integer range 0-5 */
    public var proficiency: Int?
    /** Nested conditions to be applied to this skill condition */
    public var childConditions: [SkillGroupCondition]?

    public init(routingSkill: String?, comparator: Comparator?, proficiency: Int?, childConditions: [SkillGroupCondition]?) {
        self.routingSkill = routingSkill
        self.comparator = comparator
        self.proficiency = proficiency
        self.childConditions = childConditions
    }


}




public class SkillGroupWithMemberDivisions: Codable {















    public enum Status: String, Codable { 
        case inProgress = "InProgress"
        case complete = "Complete"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The group name. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    /** Group description */
    public var _description: String?
    /** Estimated number of members in this group. It can take some time for the count to be updated after expressions are changed. */
    public var memberCount: Int64?
    /** Last modified date/time of the skill group. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Created date/time of the skill group. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Group's filling status */
    public var status: Status?
    /** Conditions for this group */
    public var skillConditions: [SkillGroupCondition]?
    /** Member divisions for this skill group */
    public var memberDivisions: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, _description: String?, memberCount: Int64?, dateModified: Date?, dateCreated: Date?, status: Status?, skillConditions: [SkillGroupCondition]?, memberDivisions: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.memberCount = memberCount
        self.dateModified = dateModified
        self.dateCreated = dateCreated
        self.status = status
        self.skillConditions = skillConditions
        self.memberDivisions = memberDivisions
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case memberCount
        case dateModified
        case dateCreated
        case status
        case skillConditions
        case memberDivisions
        case selfUri
    }


}




public class SmsConfig: Codable {









    /** The Contact List column specifying the message to send to the contact. */
    public var messageColumn: String?
    /** The Contact List column specifying the phone number to send a message to. */
    public var phoneColumn: String?
    /** A reference to the SMS Phone Number that will be used as the sender of a message. */
    public var senderSmsPhoneNumber: SmsPhoneNumberRef?
    /** The content template used to formulate the message to send to the contact. */
    public var contentTemplate: DomainEntityRef?

    public init(messageColumn: String?, phoneColumn: String?, senderSmsPhoneNumber: SmsPhoneNumberRef?, contentTemplate: DomainEntityRef?) {
        self.messageColumn = messageColumn
        self.phoneColumn = phoneColumn
        self.senderSmsPhoneNumber = senderSmsPhoneNumber
        self.contentTemplate = contentTemplate
    }


}




public class SmsPhoneNumber: Codable {







    public enum PhoneNumberType: String, Codable { 
        case local = "local"
        case mobile = "mobile"
        case tollfree = "tollfree"
        case shortcode = "shortcode"
    }



    public enum PhoneNumberStatus: String, Codable { 
        case invalid = "INVALID"
        case active = "ACTIVE"
        case porting = "PORTING"
        case pending = "PENDING"
        case pendingCancellation = "PENDING_CANCELLATION"
        case initiated = "INITIATED"
    }

    public enum Capabilities: String, Codable { 
        case sms = "sms"
        case mms = "mms"
        case voice = "voice"
    }



















    public enum AutoRenewable: String, Codable { 
        case quarterly = "Quarterly"
    }



    public enum ShortCodeBillingType: String, Codable { 
        case basic = "Basic"
        case vanity = "Vanity"
    }

















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** A phone number provisioned for SMS communications in E.164 format. E.g. +13175555555 or +34234234234 */
    public var phoneNumber: String?
    /** Type of the phone number provisioned. */
    public var phoneNumberType: PhoneNumberType?
    /** Is set to false, if the phone number is provisioned through a SMS provider, outside of PureCloud */
    public var provisionedThroughPureCloud: Bool?
    /** Status of the provisioned phone number. */
    public var phoneNumberStatus: PhoneNumberStatus?
    /** The capabilities of the phone number available for provisioning. */
    public var capabilities: [Capabilities]?
    /** The ISO 3166-1 alpha-2 country code of the country this phone number is associated with. */
    public var countryCode: String?
    /** Date this phone number was provisioned. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date this phone number was modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** User that provisioned this phone number */
    public var createdBy: User?
    /** User that last modified this phone number */
    public var modifiedBy: User?
    /** Version number required for updates. */
    public var version: Int?
    /** Date this phone number was purchased, if the phoneNumberType is shortcode. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var purchaseDate: Date?
    /** Contract end date of this phone number, if the phoneNumberType is shortcode. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var cancellationDate: Date?
    /** Contract renewal date of this phone number, if the phoneNumberType is shortcode. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var renewalDate: Date?
    /** Renewal time period of this phone number, if the phoneNumberType is shortcode. */
    public var autoRenewable: AutoRenewable?
    /** The id of an address attached to this phone number. */
    public var addressId: SmsAddress?
    /** BillingType of this phone number, if the phoneNumberType is shortcode. */
    public var shortCodeBillingType: ShortCodeBillingType?
    /** Status of latest asynchronous provisioning action */
    public var provisioningStatus: SmsProvisioningStatus?
    /** Localized country name for the country code this phone number belongs too */
    public var country: String?
    /** Set to true if this phone number has the capability to support SMS */
    public var supportsSms: Bool?
    /** Set to true if this phone number has the capability to support MMS */
    public var supportsMms: Bool?
    /** Set to true if this phone number has the capability to support voice */
    public var supportsVoice: Bool?
    /** The Genesys Cloud integration this phone number belongs to. */
    public var integration: DomainEntityRef?
    /** Compliance configuration for short codes, including help, stop and opt in. */
    public var compliance: Compliance?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, phoneNumber: String?, phoneNumberType: PhoneNumberType?, provisionedThroughPureCloud: Bool?, phoneNumberStatus: PhoneNumberStatus?, capabilities: [Capabilities]?, countryCode: String?, dateCreated: Date?, dateModified: Date?, createdBy: User?, modifiedBy: User?, version: Int?, purchaseDate: Date?, cancellationDate: Date?, renewalDate: Date?, autoRenewable: AutoRenewable?, addressId: SmsAddress?, shortCodeBillingType: ShortCodeBillingType?, provisioningStatus: SmsProvisioningStatus?, country: String?, supportsSms: Bool?, supportsMms: Bool?, supportsVoice: Bool?, integration: DomainEntityRef?, compliance: Compliance?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.phoneNumber = phoneNumber
        self.phoneNumberType = phoneNumberType
        self.provisionedThroughPureCloud = provisionedThroughPureCloud
        self.phoneNumberStatus = phoneNumberStatus
        self.capabilities = capabilities
        self.countryCode = countryCode
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.version = version
        self.purchaseDate = purchaseDate
        self.cancellationDate = cancellationDate
        self.renewalDate = renewalDate
        self.autoRenewable = autoRenewable
        self.addressId = addressId
        self.shortCodeBillingType = shortCodeBillingType
        self.provisioningStatus = provisioningStatus
        self.country = country
        self.supportsSms = supportsSms
        self.supportsMms = supportsMms
        self.supportsVoice = supportsVoice
        self.integration = integration
        self.compliance = compliance
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case phoneNumber
        case phoneNumberType
        case provisionedThroughPureCloud
        case phoneNumberStatus
        case capabilities
        case countryCode
        case dateCreated
        case dateModified
        case createdBy
        case modifiedBy
        case version
        case purchaseDate
        case cancellationDate
        case renewalDate
        case autoRenewable
        case addressId
        case shortCodeBillingType
        case provisioningStatus
        case country
        case supportsSms
        case supportsMms
        case supportsVoice
        case integration
        case compliance
        case selfUri
    }


}




public class SmsPhoneNumberImport: Codable {





    public enum PhoneNumberType: String, Codable { 
        case local = "local"
        case mobile = "mobile"
        case tollfree = "tollfree"
        case shortcode = "shortcode"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** A phone number to be used for SMS communications. E.g. +13175555555 or +34234234234 */
    public var phoneNumber: String?
    /** Type of the phone number provisioned. */
    public var phoneNumberType: PhoneNumberType?
    /** The ISO 3166-1 alpha-2 country code of the country this phone number is associated with. */
    public var countryCode: String?
    /** The id of the Genesys Cloud integration this phone number belongs to. */
    public var integrationId: String?
    /** Compliance configuration for short codes, including help, stop and opt in. */
    public var compliance: Compliance?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, phoneNumber: String?, phoneNumberType: PhoneNumberType?, countryCode: String?, integrationId: String?, compliance: Compliance?, selfUri: String?) {
        self._id = _id
        self.phoneNumber = phoneNumber
        self.phoneNumberType = phoneNumberType
        self.countryCode = countryCode
        self.integrationId = integrationId
        self.compliance = compliance
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case phoneNumber
        case phoneNumberType
        case countryCode
        case integrationId
        case compliance
        case selfUri
    }


}




public class SmsPhoneNumberRef: Codable {





    /** A phone number provisioned for SMS communications in E.164 format. E.g. +13175555555 or +34234234234 */
    public var phoneNumber: String?
    public var selfUri: String?

    public init(phoneNumber: String?, selfUri: String?) {
        self.phoneNumber = phoneNumber
        self.selfUri = selfUri
    }


}




public class SocialExpression: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }





















    /** The connection state of this communication. */
    public var state: State?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** A globally unique identifier for the social media. */
    public var socialMediaId: String?
    /** The social network of the communication */
    public var socialMediaHub: String?
    /** The user name for the communication. */
    public var socialUserName: String?
    /** The text preview of the communication contents */
    public var previewText: String?
    /** A globally unique identifier for the recording associated with this chat. */
    public var recordingId: String?
    /** The time line of the participant's chat, divided into activity segments. */
    public var segments: [Segment]?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the chat was placed on hold in the cloud clock if the chat is currently on hold. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startHoldTime: Date?
    /** The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAlertingTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var disconnectedTime: Date?
    /** The source provider for the social expression. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** Call wrap up or disposition data. */
    public var wrapup: Wrapup?
    /** After-call work for the communication. */
    public var afterCallWork: AfterCallWork?
    /** Indicates if after-call work is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?

    public init(state: State?, _id: String?, socialMediaId: String?, socialMediaHub: String?, socialUserName: String?, previewText: String?, recordingId: String?, segments: [Segment]?, held: Bool?, disconnectType: DisconnectType?, startHoldTime: Date?, startAlertingTime: Date?, connectedTime: Date?, disconnectedTime: Date?, provider: String?, scriptId: String?, peerId: String?, wrapup: Wrapup?, afterCallWork: AfterCallWork?, afterCallWorkRequired: Bool?) {
        self.state = state
        self._id = _id
        self.socialMediaId = socialMediaId
        self.socialMediaHub = socialMediaHub
        self.socialUserName = socialUserName
        self.previewText = previewText
        self.recordingId = recordingId
        self.segments = segments
        self.held = held
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.startAlertingTime = startAlertingTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case _id = "id"
        case socialMediaId
        case socialMediaHub
        case socialUserName
        case previewText
        case recordingId
        case segments
        case held
        case disconnectType
        case startHoldTime
        case startAlertingTime
        case connectedTime
        case disconnectedTime
        case provider
        case scriptId
        case peerId
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
    }


}




public class Source: Codable {







    public enum ModelType: String, Codable { 
        case system = "System"
        case user = "User"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the source */
    public var name: String?
    /** The description of the source */
    public var _description: String?
    /** The type of source */
    public var type: ModelType?
    public var deactivated: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, type: ModelType?, deactivated: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.type = type
        self.deactivated = deactivated
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case type
        case deactivated
        case selfUri
    }


}




public class StarrableDivision: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}




public class StatEventWrapUpCodeTopicStatsNotification: Codable {





    public var group: [String:String]?
    public var data: [StatEventWrapUpCodeTopicIntervalMetrics]?

    public init(group: [String:String]?, data: [StatEventWrapUpCodeTopicIntervalMetrics]?) {
        self.group = group
        self.data = data
    }


}




public class StationEntityListing: Codable {





















    public var entities: [Station]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Station]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class SttEngineEntity: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The STT engine is intended to be used for Grammars */
    public var grammarBased: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, grammarBased: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.grammarBased = grammarBased
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case grammarBased
        case selfUri
    }


}




public class SttEngineEntityListing: Codable {





















    public var entities: [SttEngineEntity]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [SttEngineEntity]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class SubjectDivisionGrants: Codable {







    public enum ModelType: String, Codable { 
        case pcUser = "PC_USER"
        case pcGroup = "PC_GROUP"
        case pcOauthClient = "PC_OAUTH_CLIENT"
        case pcTrusteeUser = "PC_TRUSTEE_USER"
        case pcTrusteeGroup = "PC_TRUSTEE_GROUP"
        case unknown = "UNKNOWN"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var divisions: [Division]?
    public var type: ModelType?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, divisions: [Division]?, type: ModelType?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.divisions = divisions
        self.type = type
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case divisions
        case type
        case selfUri
    }


}




public class SuggestSearchCriteria: Codable {









    public enum Operator: String, Codable { 
        case and = "AND"
        case or = "OR"
        case not = "NOT"
    }







    /** The end value of the range. This field is used for range search types. */
    public var endValue: String?
    /** A list of values for the search to match against */
    public var values: [String]?
    /** The start value of the range. This field is used for range search types. */
    public var startValue: String?
    /** A value for the search to match against */
    public var value: String?
    /** How to apply this search criteria against other criteria */
    public var _operator: Operator?
    /** Groups multiple conditions */
    public var group: [SuggestSearchCriteria]?
    /** Set date format for criteria values when using date range search type.  Supports Java date format syntax, example yyyy-MM-dd'T'HH:mm:ss.SSSX. */
    public var dateFormat: String?
    /** Field names to search against */
    public var fields: [String]?

    public init(endValue: String?, values: [String]?, startValue: String?, value: String?, _operator: Operator?, group: [SuggestSearchCriteria]?, dateFormat: String?, fields: [String]?) {
        self.endValue = endValue
        self.values = values
        self.startValue = startValue
        self.value = value
        self._operator = _operator
        self.group = group
        self.dateFormat = dateFormat
        self.fields = fields
    }

    public enum CodingKeys: String, CodingKey { 
        case endValue
        case values
        case startValue
        case value
        case _operator = "operator"
        case group
        case dateFormat
        case fields
    }


}




public class SupportedLanguage: Codable {





    /** Architect supported language tag, e.g. en-us, es-us */
    public var language: String?
    /** Whether or not this language is the default language */
    public var isDefault: Bool?

    public init(language: String?, isDefault: Bool?) {
        self.language = language
        self.isDefault = isDefault
    }


}




public class SurveyAggregateQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [SurveyAggregateQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [SurveyAggregateQueryPredicate]?

    public init(type: ModelType?, clauses: [SurveyAggregateQueryClause]?, predicates: [SurveyAggregateQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class SurveyFormEntityListing: Codable {





















    public var entities: [SurveyForm]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [SurveyForm]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class SurveyQuestion: Codable {







    public enum ModelType: String, Codable { 
        case multiplechoicequestion = "multipleChoiceQuestion"
        case freetextquestion = "freeTextQuestion"
        case npsquestion = "npsQuestion"
        case readonlytextblockquestion = "readOnlyTextBlockQuestion"
    }











    public var _id: String?
    public var text: String?
    public var helpText: String?
    public var type: ModelType?
    public var naEnabled: Bool?
    public var visibilityCondition: VisibilityCondition?
    /** Options from which to choose an answer for this question. Only used by Multiple Choice type questions. */
    public var answerOptions: [AnswerOption]?
    /** How many characters are allowed in the text response to this question. Used by NPS and Free Text question types. */
    public var maxResponseCharacters: Int?
    /** Prompt for details explaining the chosen NPS score. Used by NPS questions. */
    public var explanationPrompt: String?

    public init(_id: String?, text: String?, helpText: String?, type: ModelType?, naEnabled: Bool?, visibilityCondition: VisibilityCondition?, answerOptions: [AnswerOption]?, maxResponseCharacters: Int?, explanationPrompt: String?) {
        self._id = _id
        self.text = text
        self.helpText = helpText
        self.type = type
        self.naEnabled = naEnabled
        self.visibilityCondition = visibilityCondition
        self.answerOptions = answerOptions
        self.maxResponseCharacters = maxResponseCharacters
        self.explanationPrompt = explanationPrompt
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case text
        case helpText
        case type
        case naEnabled
        case visibilityCondition
        case answerOptions
        case maxResponseCharacters
        case explanationPrompt
    }


}




public class SurveyQuestionGroup: Codable {













    public var _id: String?
    public var name: String?
    public var type: String?
    public var naEnabled: Bool?
    public var questions: [SurveyQuestion]?
    public var visibilityCondition: VisibilityCondition?

    public init(_id: String?, name: String?, type: String?, naEnabled: Bool?, questions: [SurveyQuestion]?, visibilityCondition: VisibilityCondition?) {
        self._id = _id
        self.name = name
        self.type = type
        self.naEnabled = naEnabled
        self.questions = questions
        self.visibilityCondition = visibilityCondition
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case type
        case naEnabled
        case questions
        case visibilityCondition
    }


}




public class TagValueEntityListing: Codable {





















    public var entities: [TagValue]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [TagValue]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** Information about the Trigger test mode processing step */

public class TestMatchesOperation: Codable {









    /** The name of the processing step */
    public var name: String?
    /** The number of the processing step */
    public var step: Int?
    /** Whether or not the operation matches expectations */
    public var matches: Bool?
    /** Details about why the operation did or did not succeed */
    public var details: [MatchCriteriaTestResult]?

    public init(name: String?, step: Int?, matches: Bool?, details: [MatchCriteriaTestResult]?) {
        self.name = name
        self.step = step
        self.matches = matches
        self.details = details
    }


}




public class TestMessage: Codable {















    /** After the message has been sent, this is the value of the Message-ID email header. */
    public var _id: String?
    /** The recipients of the email message. */
    public var to: [EmailAddress]?
    /** The sender of the email message. */
    public var from: EmailAddress?
    /** The subject of the email message. */
    public var subject: String?
    /** The text body of the email message. */
    public var textBody: String?
    /** The html body of the email message */
    public var htmlBody: String?
    /** The time when the message was sent. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var time: Date?

    public init(_id: String?, to: [EmailAddress]?, from: EmailAddress?, subject: String?, textBody: String?, htmlBody: String?, time: Date?) {
        self._id = _id
        self.to = to
        self.from = from
        self.subject = subject
        self.textBody = textBody
        self.htmlBody = htmlBody
        self.time = time
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case to
        case from
        case subject
        case textBody
        case htmlBody
        case time
    }


}



/** Settings for a next-action of exiting the bot flow. Any output variables are available in the details. */

public class TextBotExitAction: Codable {

    public enum Reason: String, Codable { 
        case triggeredByUser = "TriggeredByUser"
        case agentRequestedByUser = "AgentRequestedByUser"
        case triggeredByFlow = "TriggeredByFlow"
        case error = "Error"
        case recognitionFailure = "RecognitionFailure"
    }











    /** The reason for the exit. */
    public var reason: Reason?
    /** Extended information related to the reason, if available. */
    public var reasonExtendedInfo: String?
    /** The active intent at the time of the exit. */
    public var activeIntent: String?
    /** Describes where in the Bot Flow the user was when the exit occurred. */
    public var flowLocation: TextBotFlowLocation?
    /** The output data for the bot flow. */
    public var outputData: TextBotInputOutputData?
    /** The list of Flow Outcomes for the bot flow and their details. */
    public var flowOutcomes: [TextBotFlowOutcome]?

    public init(reason: Reason?, reasonExtendedInfo: String?, activeIntent: String?, flowLocation: TextBotFlowLocation?, outputData: TextBotInputOutputData?, flowOutcomes: [TextBotFlowOutcome]?) {
        self.reason = reason
        self.reasonExtendedInfo = reasonExtendedInfo
        self.activeIntent = activeIntent
        self.flowLocation = flowLocation
        self.outputData = outputData
        self.flowOutcomes = flowOutcomes
    }


}



/** Settings for launching an instance of a bot flow. */

public class TextBotFlowLaunchRequest: Codable {













    /** Specifies which Bot Flow to launch. */
    public var flow: TextBotFlow?
    /** The ID of the external session that is associated with the bot flow. */
    public var externalSessionId: String?
    /** A conversation ID to associate with the bot flow, if available. */
    public var conversationId: String?
    /** Input values to the flow. Valid values are defined by the flow's input JSON schema. */
    public var inputData: TextBotInputOutputData?
    /** Channel information relevant to the bot flow. */
    public var channel: TextBotChannel?
    /** The language that the bot will use in the session. Validated against list of supported languages and if the value is omitted or is invalid, the default language will be used. */
    public var language: String?

    public init(flow: TextBotFlow?, externalSessionId: String?, conversationId: String?, inputData: TextBotInputOutputData?, channel: TextBotChannel?, language: String?) {
        self.flow = flow
        self.externalSessionId = externalSessionId
        self.conversationId = conversationId
        self.inputData = inputData
        self.channel = channel
        self.language = language
    }


}



/** Mode constraints to observe when operating on a bot flow. */

public class TextBotTextModeConstraints: Codable {





    /** The list of language preferences by their ISO language code. */
    public var languagePreferences: [String]?
    /** The amount of time, in milliseconds, before the client should send the 'NoInput' event  to trigger the \"no input\" bot response and handling on digital channels.  Note: This optional field will only be returned for 'Digital Bot Flow' turns. */
    public var noInputTimeoutMilliseconds: Int?

    public init(languagePreferences: [String]?, noInputTimeoutMilliseconds: Int?) {
        self.languagePreferences = languagePreferences
        self.noInputTimeoutMilliseconds = noInputTimeoutMilliseconds
    }


}



/** Data for a single bot flow transcript. */

public class TextBotTranscript: Codable {





    /** The text of the transcript item. */
    public var text: String?
    /** The confidence factor, expressed as a decimal between 0.0 and 1.0, of the transcript item. */
    public var confidence: Float?

    public init(text: String?, confidence: Float?) {
        self.text = text
        self.confidence = confidence
    }


}



/** A reference to a bot flow turn. */

public class TextBotTurnReference: Codable {



    /** The id of the turn. */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class TextMessageListing: Codable {



    public var entities: [MessageData]?

    public init(entities: [MessageData]?) {
        self.entities = entities
    }


}




public class Ticker: Codable {





    /** The ticker symbol for this organization. Example: ININ, AAPL, MSFT, etc. */
    public var symbol: String?
    /** The exchange for this ticker symbol. Examples: NYSE, FTSE, NASDAQ, etc. */
    public var exchange: String?

    public init(symbol: String?, exchange: String?) {
        self.symbol = symbol
        self.exchange = exchange
    }


}




public class TimeOffBalanceJobResponse: Codable {



    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case error = "Error"
    }

    public var entities: [TimeOffBalanceResponse]?
    /** The status of the time off balance job */
    public var status: Status?

    public init(entities: [TimeOffBalanceResponse]?, status: Status?) {
        self.entities = entities
        self.status = status
    }


}




public class TimeOffBalanceRequest: Codable {





    /** The set of activity code IDs for which to query available time off balances */
    public var activityCodeIds: [String]?
    /** The list of date ranges for which to query time off balance */
    public var dateRanges: [LocalDateRange]?

    public init(activityCodeIds: [String]?, dateRanges: [LocalDateRange]?) {
        self.activityCodeIds = activityCodeIds
        self.dateRanges = dateRanges
    }


}




public class TimeOffLimitValueRange: Codable {





    public enum Granularity: String, Codable { 
        case daily = "Daily"
    }











    /** The ID of the time off limit */
    public var timeOffLimit: TimeOffLimitReference?
    /** Start date of the requested date range, in ISO-8601 format. The end date is determined by the size of interval lists */
    public var startDate: Date?
    /** Granularity choice for time off limit */
    public var granularity: Granularity?
    /** A list of time off limit values in minutes per granularity interval */
    public var limitMinutesPerInterval: [Int]?
    /** A list of allocated time off minutes per granularity interval */
    public var allocatedMinutesPerInterval: [Int]?
    /** A list of waitlisted time off minutes per granularity interval */
    public var waitlistedMinutesPerInterval: [Int]?
    /** The current number of waitlisted time off requests for every interval per granularity */
    public var waitlistedRequestsPerInterval: [Int]?
    /** Version metadata for the time off limit */
    public var metadata: WfmVersionedEntityMetadata?

    public init(timeOffLimit: TimeOffLimitReference?, startDate: Date?, granularity: Granularity?, limitMinutesPerInterval: [Int]?, allocatedMinutesPerInterval: [Int]?, waitlistedMinutesPerInterval: [Int]?, waitlistedRequestsPerInterval: [Int]?, metadata: WfmVersionedEntityMetadata?) {
        self.timeOffLimit = timeOffLimit
        self.startDate = startDate
        self.granularity = granularity
        self.limitMinutesPerInterval = limitMinutesPerInterval
        self.allocatedMinutesPerInterval = allocatedMinutesPerInterval
        self.waitlistedMinutesPerInterval = waitlistedMinutesPerInterval
        self.waitlistedRequestsPerInterval = waitlistedRequestsPerInterval
        self.metadata = metadata
    }


}




public class TimeZoneMappingPreview: Codable {



















    /** The associated ContactList */
    public var contactList: DomainEntityRef?
    /** The number of contacts per time zone that mapped to only that time zone */
    public var contactsPerTimeZone: [String:Int64]?
    /** The number of contacts per time zone that mapped to only that time zone and were mapped using the zip code column */
    public var contactsMappedUsingZipCode: [String:Int64]?
    /** The total number of contacts that mapped to a single time zone */
    public var contactsMappedToASingleZone: Int64?
    /** The total number of contacts that mapped to a single time zone and were mapped using the zip code column */
    public var contactsMappedToASingleZoneUsingZipCode: Int64?
    /** The total number of contacts that mapped to multiple time zones */
    public var contactsMappedToMultipleZones: Int64?
    /** The total number of contacts that mapped to multiple time zones and were mapped using the zip code column */
    public var contactsMappedToMultipleZonesUsingZipCode: Int64?
    /** The total number of contacts that will be dialed during the default window */
    public var contactsInDefaultWindow: Int64?
    /** The total number of contacts in the contact list */
    public var contactListSize: Int64?

    public init(contactList: DomainEntityRef?, contactsPerTimeZone: [String:Int64]?, contactsMappedUsingZipCode: [String:Int64]?, contactsMappedToASingleZone: Int64?, contactsMappedToASingleZoneUsingZipCode: Int64?, contactsMappedToMultipleZones: Int64?, contactsMappedToMultipleZonesUsingZipCode: Int64?, contactsInDefaultWindow: Int64?, contactListSize: Int64?) {
        self.contactList = contactList
        self.contactsPerTimeZone = contactsPerTimeZone
        self.contactsMappedUsingZipCode = contactsMappedUsingZipCode
        self.contactsMappedToASingleZone = contactsMappedToASingleZone
        self.contactsMappedToASingleZoneUsingZipCode = contactsMappedToASingleZoneUsingZipCode
        self.contactsMappedToMultipleZones = contactsMappedToMultipleZones
        self.contactsMappedToMultipleZonesUsingZipCode = contactsMappedToMultipleZonesUsingZipCode
        self.contactsInDefaultWindow = contactsInDefaultWindow
        self.contactListSize = contactListSize
    }


}




public class TranscriptAggregateQueryResponse: Codable {



    public var results: [TranscriptAggregateDataContainer]?

    public init(results: [TranscriptAggregateDataContainer]?) {
        self.results = results
    }


}




public class TranscriptAggregationView: Codable {

    public enum Target: String, Codable { 
        case ntopiccommunications = "nTopicCommunications"
        case ocustomersentiment = "oCustomerSentiment"
        case oovertalkspeechinstances = "oOverTalkSpeechInstances"
        case osentimentscore = "oSentimentScore"
        case tagentspeech = "tAgentSpeech"
        case tcustomerspeech = "tCustomerSpeech"
        case totheraudio = "tOtherAudio"
        case tovertalkspeech = "tOverTalkSpeech"
        case tsilence = "tSilence"
        case ttotalspeechandsilence = "tTotalSpeechAndSilence"
    }



    public enum Function: String, Codable { 
        case rangebound = "rangeBound"
    }



    /** Target metric name */
    public var target: Target?
    /** A unique name for this view. Must be distinct from other views and built-in metric names. */
    public var name: String?
    /** Type of view you wish to create */
    public var function: Function?
    /** Range of numbers for slicing up data */
    public var range: AggregationRange?

    public init(target: Target?, name: String?, function: Function?, range: AggregationRange?) {
        self.target = target
        self.name = name
        self.function = function
        self.range = range
    }


}




public class TranscriptionEngines: Codable {

    public enum Engine: String, Codable { 
        case genesys = "Genesys"
        case genesysExtended = "GenesysExtended"
    }



    public var engine: Engine?
    public var dialects: [String]?

    public init(engine: Engine?, dialects: [String]?) {
        self.engine = engine
        self.dialects = dialects
    }


}




public class TranscriptionEnginesRequest: Codable {



    /** The transcription engine setting */
    public var transcriptionEngines: [TranscriptionEngines]?

    public init(transcriptionEngines: [TranscriptionEngines]?) {
        self.transcriptionEngines = transcriptionEngines
    }


}




public class TranscriptionTopicTranscriptAlternative: Codable {















    public var confidence: Double?
    public var offsetMs: Int?
    public var durationMs: Int?
    public var transcript: String?
    public var words: [TranscriptionTopicTranscriptWord]?
    public var decoratedTranscript: String?
    public var decoratedWords: [TranscriptionTopicTranscriptWord]?

    public init(confidence: Double?, offsetMs: Int?, durationMs: Int?, transcript: String?, words: [TranscriptionTopicTranscriptWord]?, decoratedTranscript: String?, decoratedWords: [TranscriptionTopicTranscriptWord]?) {
        self.confidence = confidence
        self.offsetMs = offsetMs
        self.durationMs = durationMs
        self.transcript = transcript
        self.words = words
        self.decoratedTranscript = decoratedTranscript
        self.decoratedWords = decoratedWords
    }


}




public class TrunkBaseAssignment: Codable {





    /** The address family to use with the trunk base settings. 2=IPv4, 23=IPv6 */
    public var family: Int?
    /** A trunk base settings reference. */
    public var trunkBase: TrunkBase?

    public init(family: Int?, trunkBase: TrunkBase?) {
        self.family = family
        self.trunkBase = trunkBase
    }


}




public class TrunkErrorInfo: Codable {







    public var text: String?
    public var code: String?
    public var details: TrunkErrorInfoDetails?

    public init(text: String?, code: String?, details: TrunkErrorInfoDetails?) {
        self.text = text
        self.code = code
        self.details = details
    }


}




public class TrunkErrorInfoDetails: Codable {







    public var code: String?
    public var message: String?
    public var hostname: String?

    public init(code: String?, message: String?, hostname: String?) {
        self.code = code
        self.message = message
        self.hostname = hostname
    }


}




public class TrunkInstanceTopicTrunkConnectedStatus: Codable {





    public var connected: Bool?
    public var connectedStateTime: Date?

    public init(connected: Bool?, connectedStateTime: Date?) {
        self.connected = connected
        self.connectedStateTime = connectedStateTime
    }


}




public class TrunkInstanceTopicTrunkMetricsRegisters: Codable {









    public var proxyAddress: String?
    public var registerState: Bool?
    public var registerStateTime: Date?
    public var errorInfo: TrunkInstanceTopicTrunkErrorInfo?

    public init(proxyAddress: String?, registerState: Bool?, registerStateTime: Date?, errorInfo: TrunkInstanceTopicTrunkErrorInfo?) {
        self.proxyAddress = proxyAddress
        self.registerState = registerState
        self.registerStateTime = registerStateTime
        self.errorInfo = errorInfo
    }


}




public class TrunkMetricsTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class TrusteeAuditQueryRequest: Codable {















    /** Limit returned audits to these trustee organizationIds. */
    public var trusteeOrganizationIds: [String]?
    /** Limit returned audits to these trustee userIds. */
    public var trusteeUserIds: [String]?
    /** Starting date/time for the audit search. ISO-8601 formatted date-time, UTC. */
    public var startDate: Date?
    /** Ending date/time for the audit search. ISO-8601 formatted date-time, UTC. */
    public var endDate: Date?
    /** Word or phrase to look for in audit bodies. */
    public var queryPhrase: String?
    /** Facet information to be returned with the query results. */
    public var facets: [Facet]?
    /** Additional custom filters to be applied to the query. */
    public var filters: [Filter]?

    public init(trusteeOrganizationIds: [String]?, trusteeUserIds: [String]?, startDate: Date?, endDate: Date?, queryPhrase: String?, facets: [Facet]?, filters: [Filter]?) {
        self.trusteeOrganizationIds = trusteeOrganizationIds
        self.trusteeUserIds = trusteeUserIds
        self.startDate = startDate
        self.endDate = endDate
        self.queryPhrase = queryPhrase
        self.facets = facets
        self.filters = filters
    }


}




public class TtsEngineEntity: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The set of languages the TTS engine supports */
    public var languages: [String]?
    /** The set of output formats the TTS engine can produce */
    public var outputFormats: [String]?
    /** The set of voices the TTS engine supports */
    public var voices: [TtsVoiceEntity]?
    /** The TTS engine is the global default engine */
    public var isDefault: Bool?
    /** The TTS engine can be used in a secure call flow */
    public var isSecure: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, languages: [String]?, outputFormats: [String]?, voices: [TtsVoiceEntity]?, isDefault: Bool?, isSecure: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.languages = languages
        self.outputFormats = outputFormats
        self.voices = voices
        self.isDefault = isDefault
        self.isSecure = isSecure
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case languages
        case outputFormats
        case voices
        case isDefault
        case isSecure
        case selfUri
    }


}




public class TtsEngineEntityListing: Codable {





















    public var entities: [TtsEngineEntity]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [TtsEngineEntity]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class UCIcon: Codable {



    /** vector */
    public var vector: String?

    public init(vector: String?) {
        self.vector = vector
    }


}



/** Presence from a given source for a user */

public class UcUserPresence: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** User ID of the associated Genesys Cloud user. */
    public var userId: String?
    /** Deprecated - The sourceID field should be used as a replacement. */
    public var source: String?
    /** The registered source ID from where the presence was set */
    public var sourceId: String?
    public var presenceDefinition: PresenceDefinition?
    public var message: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, userId: String?, source: String?, sourceId: String?, presenceDefinition: PresenceDefinition?, message: String?, modifiedDate: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.userId = userId
        self.source = source
        self.sourceId = sourceId
        self.presenceDefinition = presenceDefinition
        self.message = message
        self.modifiedDate = modifiedDate
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case userId
        case source
        case sourceId
        case presenceDefinition
        case message
        case modifiedDate
        case selfUri
    }


}



/** UC Integration UI configuration data */

public class UnifiedCommunicationsIntegration: Codable {







    public enum IntegrationPresenceSource: String, Codable { 
        case microsoftTeams = "MicrosoftTeams"
        case zoomPhone = "ZoomPhone"
        case eightByEight = "EightByEight"
    }



















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** ucIntegrationKey */
    public var ucIntegrationKey: AddressableEntityRef?
    /** integrationPresenceType */
    public var integrationPresenceSource: IntegrationPresenceSource?
    /** pbxPermission */
    public var pbxPermission: String?
    /** icon */
    public var icon: UCIcon?
    /** badgeIcon */
    public var badgeIcons: [String:UCIcon]?
    /** i10n */
    public var i10n: [String:UCI10n]?
    /** polledPresence */
    public var polledPresence: Bool?
    /** pollIntervalSec */
    public var pollIntervalSec: Int?
    /** userPermissions */
    public var userPermissions: [String]?
    public var oauthScopes: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, ucIntegrationKey: AddressableEntityRef?, integrationPresenceSource: IntegrationPresenceSource?, pbxPermission: String?, icon: UCIcon?, badgeIcons: [String:UCIcon]?, i10n: [String:UCI10n]?, polledPresence: Bool?, pollIntervalSec: Int?, userPermissions: [String]?, oauthScopes: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.ucIntegrationKey = ucIntegrationKey
        self.integrationPresenceSource = integrationPresenceSource
        self.pbxPermission = pbxPermission
        self.icon = icon
        self.badgeIcons = badgeIcons
        self.i10n = i10n
        self.polledPresence = polledPresence
        self.pollIntervalSec = pollIntervalSec
        self.userPermissions = userPermissions
        self.oauthScopes = oauthScopes
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case ucIntegrationKey
        case integrationPresenceSource
        case pbxPermission
        case icon
        case badgeIcons
        case i10n
        case polledPresence
        case pollIntervalSec
        case userPermissions
        case oauthScopes
        case selfUri
    }


}




public class UnifiedCommunicationsIntegrationListing: Codable {





















    public var entities: [UnifiedCommunicationsIntegration]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [UnifiedCommunicationsIntegration]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class UnpublishedProgramsEntityListing: Codable {











    public var entities: [Program]?
    public var pageSize: Int?
    public var nextUri: String?
    public var pageCount: Int?
    public var selfUri: String?

    public init(entities: [Program]?, pageSize: Int?, nextUri: String?, pageCount: Int?, selfUri: String?) {
        self.entities = entities
        self.pageSize = pageSize
        self.nextUri = nextUri
        self.pageCount = pageCount
        self.selfUri = selfUri
    }


}




public class UpdateActionInput: Codable {









    /** Category of action, Can be up to 256 characters long */
    public var category: String?
    /** Name of action, Can be up to 256 characters long */
    public var name: String?
    /** Configuration to support request and response processing */
    public var config: ActionConfig?
    /** Version of this action */
    public var version: Int?

    public init(category: String?, name: String?, config: ActionConfig?, version: Int?) {
        self.category = category
        self.name = name
        self.config = config
        self.version = version
    }


}




public class UpdateActivityCodeRequest: Codable {



    public enum Category: String, Codable { 
        case onQueueWork = "OnQueueWork"
        case _break = "Break"
        case meal = "Meal"
        case meeting = "Meeting"
        case offQueueWork = "OffQueueWork"
        case timeOff = "TimeOff"
        case training = "Training"
        case unavailable = "Unavailable"
        case unscheduled = "Unscheduled"
    }



















    /** The name of the activity code */
    public var name: String?
    /** The activity code's category. Attempting to change the category of a default activity code will return an error */
    public var category: Category?
    /** The default length of the activity in minutes */
    public var lengthInMinutes: Int?
    /** Whether an agent is paid while performing this activity */
    public var countsAsPaidTime: Bool?
    /** Indicates whether or not the activity should be counted as work time */
    public var countsAsWorkTime: Bool?
    /** Whether an agent can select this activity code when creating or editing a time off request */
    public var agentTimeOffSelectable: Bool?
    /** Whether or not this activity code counts toward shrinkage calculations */
    public var countsTowardShrinkage: Bool?
    /** Whether this activity code is considered planned or unplanned shrinkage */
    public var plannedShrinkage: Bool?
    /** Whether this activity code is considered interruptible */
    public var interruptible: Bool?
    /** The secondary presences of this activity code */
    public var secondaryPresences: ListWrapperSecondaryPresence?
    /** Version metadata for the associated business unit's list of activity codes */
    public var metadata: WfmVersionedEntityMetadata?

    public init(name: String?, category: Category?, lengthInMinutes: Int?, countsAsPaidTime: Bool?, countsAsWorkTime: Bool?, agentTimeOffSelectable: Bool?, countsTowardShrinkage: Bool?, plannedShrinkage: Bool?, interruptible: Bool?, secondaryPresences: ListWrapperSecondaryPresence?, metadata: WfmVersionedEntityMetadata?) {
        self.name = name
        self.category = category
        self.lengthInMinutes = lengthInMinutes
        self.countsAsPaidTime = countsAsPaidTime
        self.countsAsWorkTime = countsAsWorkTime
        self.agentTimeOffSelectable = agentTimeOffSelectable
        self.countsTowardShrinkage = countsTowardShrinkage
        self.plannedShrinkage = plannedShrinkage
        self.interruptible = interruptible
        self.secondaryPresences = secondaryPresences
        self.metadata = metadata
    }


}




public class UpdateAdherenceExplanationStatusRequest: Codable {

    public enum Status: String, Codable { 
        case pending = "Pending"
        case approved = "Approved"
        case denied = "Denied"
    }

    /** The status of the adherence explanation */
    public var status: Status?

    public init(status: Status?) {
        self.status = status
    }


}




public class UpdateBusinessUnitSettingsRequest: Codable {

    public enum StartDayOfWeek: String, Codable { 
        case sunday = "Sunday"
        case monday = "Monday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
        case thursday = "Thursday"
        case friday = "Friday"
        case saturday = "Saturday"
    }









    /** The start day of week for this business unit */
    public var startDayOfWeek: StartDayOfWeek?
    /** The time zone for this business unit, using the Olsen tz database format */
    public var timeZone: String?
    /** Short term forecasting settings */
    public var shortTermForecasting: BuShortTermForecastingSettings?
    /** Scheduling settings */
    public var scheduling: BuSchedulingSettingsRequest?
    /** Version metadata for this business unit */
    public var metadata: WfmVersionedEntityMetadata?

    public init(startDayOfWeek: StartDayOfWeek?, timeZone: String?, shortTermForecasting: BuShortTermForecastingSettings?, scheduling: BuSchedulingSettingsRequest?, metadata: WfmVersionedEntityMetadata?) {
        self.startDayOfWeek = startDayOfWeek
        self.timeZone = timeZone
        self.shortTermForecasting = shortTermForecasting
        self.scheduling = scheduling
        self.metadata = metadata
    }


}




public class UpdateMuAgentRequest: Codable {





    /** Whether the agent can be included in schedule generation */
    public var schedulable: Bool?
    /** User to be updated */
    public var userId: String?

    public init(schedulable: Bool?, userId: String?) {
        self.schedulable = schedulable
        self.userId = userId
    }


}




public class UpdateMuAgentsRequest: Codable {



    /** List of agents to update */
    public var entities: [UpdateMuAgentRequest]?

    public init(entities: [UpdateMuAgentRequest]?) {
        self.entities = entities
    }


}




public class UpdateScheduleUploadSchema: Codable {













    /** The description to set for the schedule */
    public var _description: String?
    /** Whether to publish the schedule. Note: a schedule cannot be un-published unless another schedule is published over it */
    public var published: Bool?
    /** The short term forecast to associate with the schedule */
    public var shortTermForecast: BuShortTermForecastReference?
    /** The headcount forecast to associate with the schedule */
    public var headcountForecast: BuHeadcountForecast?
    /** Individual agent schedules */
    public var agentSchedules: [BuUpdateAgentScheduleUploadSchema]?
    /** Version metadata for this schedule */
    public var metadata: WfmVersionedEntityMetadata?

    public init(_description: String?, published: Bool?, shortTermForecast: BuShortTermForecastReference?, headcountForecast: BuHeadcountForecast?, agentSchedules: [BuUpdateAgentScheduleUploadSchema]?, metadata: WfmVersionedEntityMetadata?) {
        self._description = _description
        self.published = published
        self.shortTermForecast = shortTermForecast
        self.headcountForecast = headcountForecast
        self.agentSchedules = agentSchedules
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey { 
        case _description = "description"
        case published
        case shortTermForecast
        case headcountForecast
        case agentSchedules
        case metadata
    }


}




public class UpdateTriggerRequest: Codable {



















    /** Version of this trigger */
    public var version: Int64?
    /** Boolean indicating if Trigger is enabled */
    public var enabled: Bool?
    /** The target to invoke when a matching event is received */
    public var target: TriggerTarget?
    /** The configuration for when a trigger is considered to be a match for an event */
    public var matchCriteria: [MatchCriteria]?
    /** The name of the trigger */
    public var name: String?
    /** The topic that will cause the trigger to be invoked. Must match existing trigger topicName. */
    public var topicName: String?
    /** Optional length of time that events are meaningful after origination. Events older than this threshold may be dropped if the platform is delayed in processing events. Unset means events are valid indefinitely, otherwise must be set to at least 10 seconds. Only one of eventTTLSeconds or delayBySeconds can be set. */
    public var eventTTLSeconds: Int?
    /** Optional delay invoking target after trigger fires. Must be in the range of 60 to 900 seconds. Only one of eventTTLSeconds or delayBySeconds can be set. */
    public var delayBySeconds: Int?
    /** Description of the trigger. Can be up to 512 characters in length. */
    public var _description: String?

    public init(version: Int64?, enabled: Bool?, target: TriggerTarget?, matchCriteria: [MatchCriteria]?, name: String?, topicName: String?, eventTTLSeconds: Int?, delayBySeconds: Int?, _description: String?) {
        self.version = version
        self.enabled = enabled
        self.target = target
        self.matchCriteria = matchCriteria
        self.name = name
        self.topicName = topicName
        self.eventTTLSeconds = eventTTLSeconds
        self.delayBySeconds = delayBySeconds
        self._description = _description
    }

    public enum CodingKeys: String, CodingKey { 
        case version
        case enabled
        case target
        case matchCriteria
        case name
        case topicName
        case eventTTLSeconds
        case delayBySeconds
        case _description = "description"
    }


}




public class UploadUrlRequest: Codable {









    public enum ServerSideEncryption: String, Codable { 
        case aes256 = "AES256"
    }

    /** Name of the file to upload. It must not start with a dot and not end with a forward slash. Whitespace and the following characters are not allowed: \\{^}%`]\">[~<#| */
    public var fileName: String?
    /** Content MD5 of the file to upload */
    public var contentMd5: String?
    /** The number of seconds the presigned URL is valid for (from 1 to 604800 seconds). If none provided, defaults to 600 seconds */
    public var signedUrlTimeoutSeconds: Int?
    /** The content type of the file to upload. Allows all MIME types */
    public var contentType: String?
    public var serverSideEncryption: ServerSideEncryption?

    public init(fileName: String?, contentMd5: String?, signedUrlTimeoutSeconds: Int?, contentType: String?, serverSideEncryption: ServerSideEncryption?) {
        self.fileName = fileName
        self.contentMd5 = contentMd5
        self.signedUrlTimeoutSeconds = signedUrlTimeoutSeconds
        self.contentType = contentType
        self.serverSideEncryption = serverSideEncryption
    }


}




public class UsageItem: Codable {

    public enum ModelType: String, Codable { 
        case recording = "RECORDING"
        case fax = "FAX"
        case document = "DOCUMENT"
        case all = "ALL"
    }





    public var type: ModelType?
    public var totalDocumentByteCount: Int64?
    public var totalDocumentCount: Int64?

    public init(type: ModelType?, totalDocumentByteCount: Int64?, totalDocumentCount: Int64?) {
        self.type = type
        self.totalDocumentByteCount = totalDocumentByteCount
        self.totalDocumentCount = totalDocumentCount
    }


}




public class User: Codable {

















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }

























































    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    public var chat: Chat?
    public var department: String?
    public var email: String?
    /** Auto populated from addresses. */
    public var primaryContactInfo: [Contact]?
    /** Email addresses and phone numbers for this user */
    public var addresses: [Contact]?
    /** The current state for this user. */
    public var state: State?
    public var title: String?
    public var username: String?
    public var manager: User?
    public var images: [UserImage]?
    /** Required when updating a user, this value should be the current version of the user.  The current version can be obtained with a GET on the user before doing a PATCH. */
    public var version: Int?
    public var certifications: [String]?
    public var biography: Biography?
    public var employerInfo: EmployerInfo?
    /** Preferred full name of the agent */
    public var preferredName: String?
    /** ACD routing status */
    public var routingStatus: RoutingStatus?
    /** Active presence */
    public var presence: UserPresence?
    /** Integration presence */
    public var integrationPresence: UserPresence?
    /** Summary of conversion statistics for conversation types. */
    public var conversationSummary: UserConversationSummary?
    /** Determine if out of office is enabled */
    public var outOfOffice: OutOfOffice?
    /** Current geolocation position */
    public var geolocation: Geolocation?
    /** Effective, default, and last station information */
    public var station: UserStations?
    /** Roles and permissions assigned to the user */
    public var authorization: UserAuthorization?
    /** Profile skills possessed by the user */
    public var profileSkills: [String]?
    /** The user placement at each site location. */
    public var locations: [Location]?
    /** The groups the user is a member of */
    public var groups: [Group]?
    /** The team the user is a member of */
    public var team: Team?
    /** Routing (ACD) skills possessed by the user */
    public var skills: [UserRoutingSkill]?
    /** Routing (ACD) languages possessed by the user */
    public var languages: [UserRoutingLanguage]?
    /** acd auto answer */
    public var acdAutoAnswer: Bool?
    /** preferred language by the user */
    public var languagePreference: String?
    public var lastTokenIssued: OAuthLastTokenIssued?
    /** The last time the user logged in using username and password. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateLastLogin: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, chat: Chat?, department: String?, email: String?, primaryContactInfo: [Contact]?, addresses: [Contact]?, state: State?, title: String?, username: String?, manager: User?, images: [UserImage]?, version: Int?, certifications: [String]?, biography: Biography?, employerInfo: EmployerInfo?, preferredName: String?, routingStatus: RoutingStatus?, presence: UserPresence?, integrationPresence: UserPresence?, conversationSummary: UserConversationSummary?, outOfOffice: OutOfOffice?, geolocation: Geolocation?, station: UserStations?, authorization: UserAuthorization?, profileSkills: [String]?, locations: [Location]?, groups: [Group]?, team: Team?, skills: [UserRoutingSkill]?, languages: [UserRoutingLanguage]?, acdAutoAnswer: Bool?, languagePreference: String?, lastTokenIssued: OAuthLastTokenIssued?, dateLastLogin: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.chat = chat
        self.department = department
        self.email = email
        self.primaryContactInfo = primaryContactInfo
        self.addresses = addresses
        self.state = state
        self.title = title
        self.username = username
        self.manager = manager
        self.images = images
        self.version = version
        self.certifications = certifications
        self.biography = biography
        self.employerInfo = employerInfo
        self.preferredName = preferredName
        self.routingStatus = routingStatus
        self.presence = presence
        self.integrationPresence = integrationPresence
        self.conversationSummary = conversationSummary
        self.outOfOffice = outOfOffice
        self.geolocation = geolocation
        self.station = station
        self.authorization = authorization
        self.profileSkills = profileSkills
        self.locations = locations
        self.groups = groups
        self.team = team
        self.skills = skills
        self.languages = languages
        self.acdAutoAnswer = acdAutoAnswer
        self.languagePreference = languagePreference
        self.lastTokenIssued = lastTokenIssued
        self.dateLastLogin = dateLastLogin
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case chat
        case department
        case email
        case primaryContactInfo
        case addresses
        case state
        case title
        case username
        case manager
        case images
        case version
        case certifications
        case biography
        case employerInfo
        case preferredName
        case routingStatus
        case presence
        case integrationPresence
        case conversationSummary
        case outOfOffice
        case geolocation
        case station
        case authorization
        case profileSkills
        case locations
        case groups
        case team
        case skills
        case languages
        case acdAutoAnswer
        case languagePreference
        case lastTokenIssued
        case dateLastLogin
        case selfUri
    }


}




public class UserAggregateQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case userid = "userId"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension predicates */
    public var value: String?
    /** Right hand side for dimension predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case _operator = "operator"
        case value
        case range
    }


}




public class UserBestPoints: Codable {





    /** The requested user for the best points */
    public var user: UserReference?
    /** List of best point for the requested user */
    public var bestPoints: [UserBestPointsItem]?

    public init(user: UserReference?, bestPoints: [UserBestPointsItem]?) {
        self.user = user
        self.bestPoints = bestPoints
    }


}




public class UserConversationSummary: Codable {

















    public var userId: String?
    public var call: MediaSummary?
    public var callback: MediaSummary?
    public var email: MediaSummary?
    public var message: MediaSummary?
    public var chat: MediaSummary?
    public var socialExpression: MediaSummary?
    public var video: MediaSummary?

    public init(userId: String?, call: MediaSummary?, callback: MediaSummary?, email: MediaSummary?, message: MediaSummary?, chat: MediaSummary?, socialExpression: MediaSummary?, video: MediaSummary?) {
        self.userId = userId
        self.call = call
        self.callback = callback
        self.email = email
        self.message = message
        self.chat = chat
        self.socialExpression = socialExpression
        self.video = video
    }


}




public class UserInsightsTrend: Codable {





    public enum Granularity: String, Codable { 
        case daily = "Daily"
        case weekly = "Weekly"
        case monthly = "Monthly"
    }











    /** The performance profile */
    public var performanceProfile: AddressableEntityRef?
    /** The division */
    public var division: DivisionReference?
    /** Granularity */
    public var granularity: Granularity?
    /** The comparative period work day date range */
    public var comparativePeriod: WorkdayPeriod?
    /** The primary period work day date range */
    public var primaryPeriod: WorkdayPeriod?
    /** The query user */
    public var user: UserReference?
    /** The list of insights trend for each metric */
    public var entities: [UserInsightsTrendMetricItem]?
    /** The insights trend in total */
    public var total: UserInsightsTrendTotalItem?

    public init(performanceProfile: AddressableEntityRef?, division: DivisionReference?, granularity: Granularity?, comparativePeriod: WorkdayPeriod?, primaryPeriod: WorkdayPeriod?, user: UserReference?, entities: [UserInsightsTrendMetricItem]?, total: UserInsightsTrendTotalItem?) {
        self.performanceProfile = performanceProfile
        self.division = division
        self.granularity = granularity
        self.comparativePeriod = comparativePeriod
        self.primaryPeriod = primaryPeriod
        self.user = user
        self.entities = entities
        self.total = total
    }


}




public class UserInsightsTrendTotalItem: Codable {



    /** Trends for the metric */
    public var trends: UserInsightsTrends?

    public init(trends: UserInsightsTrends?) {
        self.trends = trends
    }


}




public class UserInsightsTrends: Codable {





    /** List of trend data in the comparative period */
    public var comparativePeriod: [UserTrendData]?
    /** List of trend data in the primary period */
    public var primaryPeriod: [UserTrendData]?

    public init(comparativePeriod: [UserTrendData]?, primaryPeriod: [UserTrendData]?) {
        self.comparativePeriod = comparativePeriod
        self.primaryPeriod = primaryPeriod
    }


}




public class UserObservationQueryResponse: Codable {



    public var results: [UserObservationDataContainer]?

    public init(results: [UserObservationDataContainer]?) {
        self.results = results
    }


}




public class UserPresenceEvent: Codable {













    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** The User ID of the user associated with this UserPresence */
    public var userId: String?
    /** The id (V4 UUID) of the presence source being updated */
    public var sourceId: String?
    /** The id (UUID) of the presence definition that the user presence is associated with */
    public var presenceDefinitionId: String?
    /** The message associated with the presence */
    public var message: String?

    public init(eventId: String?, eventDateTime: Date?, userId: String?, sourceId: String?, presenceDefinitionId: String?, message: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.userId = userId
        self.sourceId = sourceId
        self.presenceDefinitionId = presenceDefinitionId
        self.message = message
    }


}




public class UserPrimarySource: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The id of the source */
    public var sourceId: String?
    /** Whether or not the source is registered */
    public var registered: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, sourceId: String?, registered: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.sourceId = sourceId
        self.registered = registered
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case sourceId
        case registered
        case selfUri
    }


}




public class UserRecording: Codable {



























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    public var contentUri: String?
    public var workspace: DomainEntityRef?
    public var createdBy: DomainEntityRef?
    public var conversation: Conversation?
    public var contentLength: Int64?
    public var durationMilliseconds: Int64?
    public var thumbnails: [DocumentThumbnail]?
    public var read: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, contentUri: String?, workspace: DomainEntityRef?, createdBy: DomainEntityRef?, conversation: Conversation?, contentLength: Int64?, durationMilliseconds: Int64?, thumbnails: [DocumentThumbnail]?, read: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.contentUri = contentUri
        self.workspace = workspace
        self.createdBy = createdBy
        self.conversation = conversation
        self.contentLength = contentLength
        self.durationMilliseconds = durationMilliseconds
        self.thumbnails = thumbnails
        self.read = read
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case contentUri
        case workspace
        case createdBy
        case conversation
        case contentLength
        case durationMilliseconds
        case thumbnails
        case read
        case selfUri
    }


}



/** Represents an organization language assigned to a user. When assigning to a user specify the organization langauge id as the id. */

public class UserRoutingLanguagePost: Codable {









    /** The id of the existing routing language to add to the user */
    public var _id: String?
    /** Proficiency is a rating from 0.0 to 5.0 on how competent an agent is for a particular language. It is used when a queue is set to \"Best available language\" mode to allow acd interactions to target agents with higher proficiency ratings. */
    public var proficiency: Double?
    /** URI to the organization language used by this user language. */
    public var languageUri: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, proficiency: Double?, languageUri: String?, selfUri: String?) {
        self._id = _id
        self.proficiency = proficiency
        self.languageUri = languageUri
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case proficiency
        case languageUri
        case selfUri
    }


}



/** Represents an organization skill assigned to a user. When assigning to a user specify the organization skill id as the id. */

public class UserRoutingSkill: Codable {







    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** A rating from 0.0 to 5.0 that indicates how adept an agent is at a particular skill. When \"Best available skills\" is enabled for a queue in Genesys Cloud, ACD interactions in that queue are routed to agents with higher proficiency ratings. */
    public var proficiency: Double?
    /** Activate or deactivate this routing skill. */
    public var state: State?
    /** URI to the organization skill used by this user skill. */
    public var skillUri: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, proficiency: Double?, state: State?, skillUri: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.proficiency = proficiency
        self.state = state
        self.skillUri = skillUri
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case proficiency
        case state
        case skillUri
        case selfUri
    }


}




public class UserRoutingStatusUserParam: Codable {







    public var key: String?
    public var value: String?
    public var additionalProperties: [String:JSON]?

    public init(key: String?, value: String?, additionalProperties: [String:JSON]?) {
        self.key = key
        self.value = value
        self.additionalProperties = additionalProperties
    }


}




public class UsersSearchResponse: Codable {



















    /** The total number of results found */
    public var total: Int64?
    /** The total number of pages */
    public var pageCount: Int?
    /** The current page size */
    public var pageSize: Int?
    /** The current page number */
    public var pageNumber: Int?
    /** Q64 value for the previous page of results */
    public var previousPage: String?
    /** Q64 value for the current page of results */
    public var currentPage: String?
    /** Q64 value for the next page of results */
    public var nextPage: String?
    /** Resource types the search was performed against */
    public var types: [String]?
    /** Search results */
    public var results: [User]?

    public init(total: Int64?, pageCount: Int?, pageSize: Int?, pageNumber: Int?, previousPage: String?, currentPage: String?, nextPage: String?, types: [String]?, results: [User]?) {
        self.total = total
        self.pageCount = pageCount
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.previousPage = previousPage
        self.currentPage = currentPage
        self.nextPage = nextPage
        self.types = types
        self.results = results
    }


}




public class UtilizationLabel: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}




public class UtilizationRequest: Codable {



    /** Map of media type to utilization settings. */
    public var utilization: [String:MediaUtilization]?

    public init(utilization: [String:MediaUtilization]?) {
        self.utilization = utilization
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationMessageContent: Codable {

    public enum ContentType: String, Codable { 
        case attachment = "Attachment"
        case location = "Location"
        case story = "Story"
        case quickReply = "QuickReply"
        case notification = "Notification"
        case buttonResponse = "ButtonResponse"
        case genericTemplate = "GenericTemplate"
    }















    public var contentType: ContentType?
    public var location: V2ConversationMessageTypingEventForUserTopicConversationContentLocation?
    public var story: V2ConversationMessageTypingEventForUserTopicConversationContentStory?
    public var attachment: V2ConversationMessageTypingEventForUserTopicConversationContentAttachment?
    public var quickReply: V2ConversationMessageTypingEventForUserTopicConversationContentQuickReply?
    public var template: V2ConversationMessageTypingEventForUserTopicConversationContentNotificationTemplate?
    public var buttonResponse: V2ConversationMessageTypingEventForUserTopicConversationContentButtonResponse?
    public var generic: V2ConversationMessageTypingEventForUserTopicConversationContentGeneric?

    public init(contentType: ContentType?, location: V2ConversationMessageTypingEventForUserTopicConversationContentLocation?, story: V2ConversationMessageTypingEventForUserTopicConversationContentStory?, attachment: V2ConversationMessageTypingEventForUserTopicConversationContentAttachment?, quickReply: V2ConversationMessageTypingEventForUserTopicConversationContentQuickReply?, template: V2ConversationMessageTypingEventForUserTopicConversationContentNotificationTemplate?, buttonResponse: V2ConversationMessageTypingEventForUserTopicConversationContentButtonResponse?, generic: V2ConversationMessageTypingEventForUserTopicConversationContentGeneric?) {
        self.contentType = contentType
        self.location = location
        self.story = story
        self.attachment = attachment
        self.quickReply = quickReply
        self.template = template
        self.buttonResponse = buttonResponse
        self.generic = generic
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationRecipientAdditionalIdentifier: Codable {

    public enum ModelType: String, Codable { 
        case deployment = "Deployment"
        case subject = "Subject"
        case unknown = "Unknown"
    }



    public var type: ModelType?
    public var value: String?

    public init(type: ModelType?, value: String?) {
        self.type = type
        self.value = value
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationContentLocation: Codable {











    public var url: String?
    public var address: String?
    public var text: String?
    public var latitude: Double?
    public var longitude: Double?

    public init(url: String?, address: String?, text: String?, latitude: Double?, longitude: Double?) {
        self.url = url
        self.address = address
        self.text = text
        self.latitude = latitude
        self.longitude = longitude
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationContentStory: Codable {

    public enum ModelType: String, Codable { 
        case mention = "Mention"
        case reply = "Reply"
    }





    public var type: ModelType?
    public var url: String?
    public var replyToId: String?

    public init(type: ModelType?, url: String?, replyToId: String?) {
        self.type = type
        self.url = url
        self.replyToId = replyToId
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationMessagingFromRecipient: Codable {





    public enum IdType: String, Codable { 
        case email = "Email"
        case phone = "Phone"
        case opaque = "Opaque"
    }











    public var nickname: String?
    public var _id: String?
    public var idType: IdType?
    public var image: String?
    public var firstName: String?
    public var lastName: String?
    public var email: String?
    public var additionalIds: [V2ConversationMessageTypingEventForWorkflowTopicConversationRecipientAdditionalIdentifier]?

    public init(nickname: String?, _id: String?, idType: IdType?, image: String?, firstName: String?, lastName: String?, email: String?, additionalIds: [V2ConversationMessageTypingEventForWorkflowTopicConversationRecipientAdditionalIdentifier]?) {
        self.nickname = nickname
        self._id = _id
        self.idType = idType
        self.image = image
        self.firstName = firstName
        self.lastName = lastName
        self.email = email
        self.additionalIds = additionalIds
    }

    public enum CodingKeys: String, CodingKey { 
        case nickname
        case _id = "id"
        case idType
        case image
        case firstName
        case lastName
        case email
        case additionalIds
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationNotificationTemplateBody: Codable {





    public var text: String?
    public var parameters: [V2ConversationMessageTypingEventForWorkflowTopicConversationNotificationTemplateParameter]?

    public init(text: String?, parameters: [V2ConversationMessageTypingEventForWorkflowTopicConversationNotificationTemplateParameter]?) {
        self.text = text
        self.parameters = parameters
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationNotificationTemplateFooter: Codable {



    public var text: String?

    public init(text: String?) {
        self.text = text
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationReason: Codable {

    public enum Code: String, Codable { 
        case messageExpired = "MessageExpired"
        case rateLimited = "RateLimited"
        case messageNotAllowed = "MessageNotAllowed"
        case generalError = "GeneralError"
        case unsupportedMessage = "UnsupportedMessage"
        case unknownMessage = "UnknownMessage"
        case invalidMessageStructure = "InvalidMessageStructure"
        case invalidDestination = "InvalidDestination"
        case serverError = "ServerError"
        case mediaTypeNotAllowed = "MediaTypeNotAllowed"
        case invalidMediaContentLength = "InvalidMediaContentLength"
        case recipientOptedOut = "RecipientOptedOut"
    }



    public var code: Code?
    public var message: String?

    public init(code: Code?, message: String?) {
        self.code = code
        self.message = message
    }


}




public class V2MobiusAlertsTopicAddressableEntityRef: Codable {



    /** The ID of the resource */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class V2MobiusAlertsTopicAlertRuleProperties: Codable {





    public enum ModelType: String, Codable { 
        case conversationMetrics = "ConversationMetrics"
        case userPresence = "UserPresence"
        case workforceManagement = "WorkforceManagement"
        case unknown = "Unknown"
    }

    public var _id: UUID?
    public var name: String?
    public var type: ModelType?

    public init(_id: UUID?, name: String?, type: ModelType?) {
        self._id = _id
        self.name = name
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case type
    }


}




public class V2MobiusAlertsTopicAlertSummaryEntity: Codable {

    public enum EntityType: String, Codable { 
        case organization = "Organization"
        case user = "User"
        case queue = "Queue"
        case group = "Group"
        case edge = "Edge"
        case team = "Team"
        case teamMembers = "TeamMembers"
    }











    public var entityType: EntityType?
    public var user: V2MobiusAlertsTopicAddressableEntityRef?
    public var group: V2MobiusAlertsTopicAddressableEntityRef?
    public var queue: V2MobiusAlertsTopicAddressableEntityRef?
    public var team: V2MobiusAlertsTopicAddressableEntityRef?
    public var alerting: Bool?

    public init(entityType: EntityType?, user: V2MobiusAlertsTopicAddressableEntityRef?, group: V2MobiusAlertsTopicAddressableEntityRef?, queue: V2MobiusAlertsTopicAddressableEntityRef?, team: V2MobiusAlertsTopicAddressableEntityRef?, alerting: Bool?) {
        self.entityType = entityType
        self.user = user
        self.group = group
        self.queue = queue
        self.team = team
        self.alerting = alerting
    }


}




public class V2MobiusAlertsTopicConditionRulePredicate: Codable {





    public enum MetricType: String, Codable { 
        case interval = "Interval"
        case instance = "Instance"
        case unknown = "Unknown"
    }

    public enum MetricValueType: String, Codable { 
        case count = "Count"
        case percentage = "Percentage"
        case average = "Average"
        case timer = "Timer"
        case observation = "Observation"
        case min = "Min"
        case max = "Max"
        case unknown = "Unknown"
    }



    public enum ComparisonOperator: String, Codable { 
        case gt = "Gt"
        case gte = "Gte"
        case lt = "Lt"
        case lte = "Lte"
        case eq = "Eq"
        case ne = "Ne"
        case unknown = "Unknown"
    }

    public var entity: V2MobiusAlertsTopicEntityProperties?
    public var metric: String?
    public var metricType: MetricType?
    public var metricValueType: MetricValueType?
    public var value: Double?
    public var comparisonOperator: ComparisonOperator?

    public init(entity: V2MobiusAlertsTopicEntityProperties?, metric: String?, metricType: MetricType?, metricValueType: MetricValueType?, value: Double?, comparisonOperator: ComparisonOperator?) {
        self.entity = entity
        self.metric = metric
        self.metricType = metricType
        self.metricValueType = metricValueType
        self.value = value
        self.comparisonOperator = comparisonOperator
    }


}




public class V2MobiusAlertsTopicEntityProperties: Codable {

    public enum EntityType: String, Codable { 
        case organization = "Organization"
        case user = "User"
        case queue = "Queue"
        case group = "Group"
        case edge = "Edge"
        case team = "Team"
        case teamMembers = "TeamMembers"
    }









    public var entityType: EntityType?
    public var user: V2MobiusAlertsTopicAddressableEntityRef?
    public var group: V2MobiusAlertsTopicAddressableEntityRef?
    public var queue: V2MobiusAlertsTopicAddressableEntityRef?
    public var team: V2MobiusAlertsTopicAddressableEntityRef?

    public init(entityType: EntityType?, user: V2MobiusAlertsTopicAddressableEntityRef?, group: V2MobiusAlertsTopicAddressableEntityRef?, queue: V2MobiusAlertsTopicAddressableEntityRef?, team: V2MobiusAlertsTopicAddressableEntityRef?) {
        self.entityType = entityType
        self.user = user
        self.group = group
        self.queue = queue
        self.team = team
    }


}




public class ValidateAddressRequest: Codable {



    /** Address schema */
    public var address: StreetAddress?

    public init(address: StreetAddress?) {
        self.address = address
    }


}




public class VerificationResult: Codable {

    public enum Status: String, Codable { 
        case failed = "FAILED"
        case pending = "PENDING"
        case verified = "VERIFIED"
        case unknown = "UNKNOWN"
    }



    /** The verification status. */
    public var status: Status?
    /** The list of DNS records that pertain that need to exist for verification. */
    public var records: [Record]?

    public init(status: Status?, records: [Record]?) {
        self.status = status
        self.records = records
    }


}




public class VerifierEntityListing: Codable {







    public var total: Int64?
    public var entities: [Verifier]?
    public var selfUri: String?

    public init(total: Int64?, entities: [Verifier]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class VideoConferenceUpdateTopicVideoConference: Codable {







    public var conversationId: String?
    public var conferenceId: String?
    public var participantInfo: VideoConferenceUpdateTopicParticipantInfo?

    public init(conversationId: String?, conferenceId: String?, participantInfo: VideoConferenceUpdateTopicParticipantInfo?) {
        self.conversationId = conversationId
        self.conferenceId = conferenceId
        self.participantInfo = participantInfo
    }


}




public class ViewFilter: Codable {

    public enum MediaTypes: String, Codable { 
        case callback = "callback"
        case chat = "chat"
        case cobrowse = "cobrowse"
        case email = "email"
        case message = "message"
        case screenshare = "screenshare"
        case unknown = "unknown"
        case video = "video"
        case voice = "voice"
    }











    public enum Directions: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum OriginatingDirections: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }





























































    public enum MessageTypes: String, Codable { 
        case sms = "sms"
        case twitter = "twitter"
        case line = "line"
        case facebook = "facebook"
        case whatsapp = "whatsapp"
        case webmessaging = "webmessaging"
        case _open = "open"
        case instagram = "instagram"
    }















































    public enum FlowOutcomeValues: String, Codable { 
        case success = "SUCCESS"
        case failure = "FAILURE"
    }

    public enum FlowDestinationTypes: String, Codable { 
        case acd = "ACD"
        case user = "USER"
        case group = "GROUP"
        case number = "NUMBER"
        case flow = "FLOW"
        case secureFlow = "SECURE_FLOW"
        case acdVoicemail = "ACD_VOICEMAIL"
        case userVoicemail = "USER_VOICEMAIL"
        case groupVoicemail = "GROUP_VOICEMAIL"
        case returnToAgent = "RETURN_TO_AGENT"
    }

    public enum FlowDisconnectReasons: String, Codable { 
        case flowDisconnect = "FLOW_DISCONNECT"
        case flowErrorDisconnect = "FLOW_ERROR_DISCONNECT"
        case disconnect = "DISCONNECT"
    }

    public enum FlowTypes: String, Codable { 
        case bot = "bot"
        case commonmodule = "commonmodule"
        case digitalbot = "digitalbot"
        case inboundcall = "inboundcall"
        case inboundchat = "inboundchat"
        case inboundemail = "inboundemail"
        case inboundshortmessage = "inboundshortmessage"
        case inqueuecall = "inqueuecall"
        case inqueueshortmessage = "inqueueshortmessage"
        case inqueueemail = "inqueueemail"
        case outboundcall = "outboundcall"
        case securecall = "securecall"
        case surveyinvite = "surveyinvite"
        case voice = "voice"
        case voicemail = "voicemail"
        case voicesurvey = "voicesurvey"
        case workflow = "workflow"
        case workitem = "workitem"
    }

    public enum FlowEntryTypes: String, Codable { 
        case agent = "agent"
        case direct = "direct"
        case dnis = "dnis"
        case flow = "flow"
        case outbound = "outbound"
    }





























    public enum UsedRoutingTypes: String, Codable { 
        case bullseye = "Bullseye"
        case conditional = "Conditional"
        case direct = "Direct"
        case last = "Last"
        case manual = "Manual"
        case predictive = "Predictive"
        case preferred = "Preferred"
        case standard = "Standard"
        case vip = "Vip"
    }

    public enum RequestedRoutingTypes: String, Codable { 
        case bullseye = "Bullseye"
        case conditional = "Conditional"
        case direct = "Direct"
        case last = "Last"
        case manual = "Manual"
        case predictive = "Predictive"
        case preferred = "Preferred"
        case standard = "Standard"
        case vip = "Vip"
    }







    public enum ParticipantPurposes: String, Codable { 
        case _internal = "internal"
        case external = "external"
    }













    public enum JourneyActionMapTypes: String, Codable { 
        case webchat = "webchat"
        case webmessagingoffer = "webMessagingOffer"
        case contentoffer = "contentOffer"
        case integrationaction = "integrationAction"
        case architectflow = "architectFlow"
        case openaction = "openAction"
    }

    public enum DevelopmentRoleList: String, Codable { 
        case creator = "Creator"
        case facilitator = "Facilitator"
        case attendee = "Attendee"
    }

    public enum DevelopmentTypeList: String, Codable { 
        case informational = "Informational"
        case coaching = "Coaching"
        case assessment = "Assessment"
        case assessedContent = "AssessedContent"
        case external = "External"
    }

    public enum DevelopmentStatusList: String, Codable { 
        case planned = "Planned"
        case scheduled = "Scheduled"
        case invalidSchedule = "InvalidSchedule"
        case inProgress = "InProgress"
        case completed = "Completed"
        case notCompleted = "NotCompleted"
    }

























    public enum BotMessageTypes: String, Codable { 
        case unknown = "Unknown"
        case phone = "Phone"
        case sms = "SMS"
        case genesysChatWidget = "GenesysChatWidget"
        case facebookMessenger = "FacebookMessenger"
        case weChat = "WeChat"
        case whatsapp = "Whatsapp"
        case appleBusinessChat = "AppleBusinessChat"
        case telegram = "Telegram"
        case slack = "Slack"
        case signal = "Signal"
        case line = "Line"
        case discord = "Discord"
        case twitterDirectMessage = "TwitterDirectMessage"
        case other = "Other"
    }

    public enum BotProviderList: String, Codable { 
        case unknown = "Unknown"
        case genesys = "Genesys"
        case amazon = "Amazon"
        case google = "Google"
        case nuance = "Nuance"
    }

    public enum BotProductList: String, Codable { 
        case unknown = "Unknown"
        case genesysDialogEngine = "GenesysDialogEngine"
        case amazonLex = "AmazonLex"
        case googleDialogFlow = "GoogleDialogFlow"
        case googleDialogFlowResell = "GoogleDialogFlowResell"
        case genesysBotFlow = "GenesysBotFlow"
        case nuanceDlg = "NuanceDlg"
        case googleDialogFlowCx = "GoogleDialogFlowCx"
        case genesysByob = "GenesysByob"
        case amazonLexV2 = "AmazonLexV2"
        case googleDialogFlowCxResell = "GoogleDialogFlowCxResell"
        case googleSttBotFlow = "GoogleSttBotFlow"
        case microsoftSttBotFlow = "MicrosoftSttBotFlow"
    }

    public enum BotRecognitionFailureReasonList: String, Codable { 
        case unknown = "Unknown"
        case noInputCollection = "NoInputCollection"
        case noInputConfirmation = "NoInputConfirmation"
        case noInputDisambiguation = "NoInputDisambiguation"
        case noMatchCollection = "NoMatchCollection"
        case noMatchConfirmation = "NoMatchConfirmation"
        case noMatchDisambiguation = "NoMatchDisambiguation"
        case maxWrongMatch = "MaxWrongMatch"
    }







    public enum BotResultList: String, Codable { 
        case unknown = "Unknown"
        case exitRequestedByUser = "ExitRequestedByUser"
        case exitRequestedByBot = "ExitRequestedByBot"
        case exitError = "ExitError"
        case exitRecognitionFailure = "ExitRecognitionFailure"
        case disconnectRequestedByUser = "DisconnectRequestedByUser"
        case disconnectRequestedByBot = "DisconnectRequestedByBot"
        case disconnectSessionExpired = "DisconnectSessionExpired"
        case disconnectError = "DisconnectError"
        case disconnectRecognitionFailure = "DisconnectRecognitionFailure"
        case transferToACD = "TransferToACD"
    }

    public enum BlockedReasons: String, Codable { 
        case pageUrlConditionsNotMatching = "PageUrlConditionsNotMatching"
        case alreadyExistingOffer = "AlreadyExistingOffer"
        case triggerDateInFuture = "TriggerDateInFuture"
        case multipleSimultaneousOffers = "MultipleSimultaneousOffers"
        case frequencyCapping = "FrequencyCapping"
        case offeredOutsideSchedule = "OfferedOutsideSchedule"
        case serviceLevelThrottling = "ServiceLevelThrottling"
        case noAvailableAgents = "NoAvailableAgents"
    }







    public enum EmailDeliveryStatusList: String, Codable { 
        case deliveryFailed = "DeliveryFailed"
        case deliverySuccess = "DeliverySuccess"
        case failed = "Failed"
        case queued = "Queued"
        case read = "Read"
        case received = "Received"
        case sent = "Sent"
    }





















































    public enum AvailableDashboard: String, Codable { 
        case _public = "Public"
        case _private = "Private"
    }













    public enum EvaluationStatuses: String, Codable { 
        case finished = "Finished"
        case inProgress = "InProgress"
        case inReview = "InReview"
        case pending = "Pending"
        case retracted = "Retracted"
    }





















    public enum UserState: String, Codable { 
        case activeAndInactive = "ActiveAndInactive"
        case active = "Active"
        case inactive = "Inactive"
        case deleted = "Deleted"
    }















    /** The media types are used to filter the view */
    public var mediaTypes: [MediaTypes]?
    /** The queue ids are used to filter the view */
    public var queueIds: [String]?
    /** The skill ids are used to filter the view */
    public var skillIds: [String]?
    /** The skill groups used to filter the view */
    public var skillGroups: [String]?
    /** The language ids are used to filter the view */
    public var languageIds: [String]?
    /** The language groups used to filter the view */
    public var languageGroups: [String]?
    /** The directions are used to filter the view */
    public var directions: [Directions]?
    /** The list of orginating directions used to filter the view */
    public var originatingDirections: [OriginatingDirections]?
    /** The wrap up codes are used to filter the view */
    public var wrapUpCodes: [String]?
    /** The dnis list is used to filter the view */
    public var dnisList: [String]?
    /** The list of session dnis used to filter the view */
    public var sessionDnisList: [String]?
    /** The user ids are used to fetch associated queues for the view */
    public var filterQueuesByUserIds: [String]?
    /** The queue ids are used to fetch associated users for the view */
    public var filterUsersByQueueIds: [String]?
    /** The user ids are used to filter the view */
    public var userIds: [String]?
    /** The management unit ids are used to filter the view */
    public var managementUnitIds: [String]?
    /** The address To values are used to filter the view */
    public var addressTos: [String]?
    /** The address from values are used to filter the view */
    public var addressFroms: [String]?
    /** The outbound campaign ids are used to filter the view */
    public var outboundCampaignIds: [String]?
    /** The outbound contact list ids are used to filter the view */
    public var outboundContactListIds: [String]?
    /** The contact ids are used to filter the view */
    public var contactIds: [String]?
    /** The external contact ids are used to filter the view */
    public var externalContactIds: [String]?
    /** The external org ids are used to filter the view */
    public var externalOrgIds: [String]?
    /** The ani list ids are used to filter the view */
    public var aniList: [String]?
    /** The durations in milliseconds used to filter the view */
    public var durationsMilliseconds: [NumericRange]?
    /** The acd durations in milliseconds used to filter the view */
    public var acdDurationsMilliseconds: [NumericRange]?
    /** The talk durations in milliseconds used to filter the view */
    public var talkDurationsMilliseconds: [NumericRange]?
    /** The acw durations in milliseconds used to filter the view */
    public var acwDurationsMilliseconds: [NumericRange]?
    /** The handle durations in milliseconds used to filter the view */
    public var handleDurationsMilliseconds: [NumericRange]?
    /** The hold durations in milliseconds used to filter the view */
    public var holdDurationsMilliseconds: [NumericRange]?
    /** The abandon durations in milliseconds used to filter the view */
    public var abandonDurationsMilliseconds: [NumericRange]?
    /** The evaluationScore is used to filter the view */
    public var evaluationScore: NumericRange?
    /** The evaluationCriticalScore is used to filter the view */
    public var evaluationCriticalScore: NumericRange?
    /** The evaluation form ids are used to filter the view */
    public var evaluationFormIds: [String]?
    /** The evaluated agent ids are used to filter the view */
    public var evaluatedAgentIds: [String]?
    /** The evaluator ids are used to filter the view */
    public var evaluatorIds: [String]?
    /** Indicates filtering for transfers */
    public var transferred: Bool?
    /** Indicates filtering for abandons */
    public var abandoned: Bool?
    /** Indicates filtering for answered interactions */
    public var answered: Bool?
    /** The message media types used to filter the view */
    public var messageTypes: [MessageTypes]?
    /** The divison Ids used to filter the view */
    public var divisionIds: [String]?
    /** The survey form ids used to filter the view */
    public var surveyFormIds: [String]?
    /** The survey total score used to filter the view */
    public var surveyTotalScore: NumericRange?
    /** The survey NPS score used to filter the view */
    public var surveyNpsScore: NumericRange?
    /** The desired range for mos values */
    public var mos: NumericRange?
    /** The survey question group score used to filter the view */
    public var surveyQuestionGroupScore: NumericRange?
    /** The survey promoter score used to filter the view */
    public var surveyPromoterScore: NumericRange?
    /** The list of survey form context ids used to filter the view */
    public var surveyFormContextIds: [String]?
    /** The list of conversation ids used to filter the view */
    public var conversationIds: [String]?
    /** The list of SIP call ids used to filter the view */
    public var sipCallIds: [String]?
    /** Indicates filtering for ended */
    public var isEnded: Bool?
    /** Indicates filtering for survey */
    public var isSurveyed: Bool?
    /** The list of survey score ranges used to filter the view */
    public var surveyScores: [NumericRange]?
    /** The list of promoter score ranges used to filter the view */
    public var promoterScores: [NumericRange]?
    /** Indicates filtering for campaign */
    public var isCampaign: Bool?
    /** The list of survey statuses used to filter the view */
    public var surveyStatuses: [String]?
    /** A grouping of conversation level filters */
    public var conversationProperties: ConversationProperties?
    /** Indicates filtering for blind transferred */
    public var isBlindTransferred: Bool?
    /** Indicates filtering for consulted */
    public var isConsulted: Bool?
    /** Indicates filtering for consult transferred */
    public var isConsultTransferred: Bool?
    /** The list of remote participants used to filter the view */
    public var remoteParticipants: [String]?
    /** The list of flow Ids */
    public var flowIds: [String]?
    /** A list of outcome ids of the flow */
    public var flowOutcomeIds: [String]?
    /** A list of outcome values of the flow */
    public var flowOutcomeValues: [FlowOutcomeValues]?
    /** The list of destination types of the flow */
    public var flowDestinationTypes: [FlowDestinationTypes]?
    /** The list of reasons for the flow to disconnect */
    public var flowDisconnectReasons: [FlowDisconnectReasons]?
    /** A list of types of the flow */
    public var flowTypes: [FlowTypes]?
    /** A list of types of the flow entry */
    public var flowEntryTypes: [FlowEntryTypes]?
    /** A list of reasons of flow entry */
    public var flowEntryReasons: [String]?
    /** A list of versions of a flow */
    public var flowVersions: [String]?
    /** A list of directory group ids */
    public var groupIds: [String]?
    /** Indicates filtering for journey customer id */
    public var hasJourneyCustomerId: Bool?
    /** Indicates filtering for Journey action map id */
    public var hasJourneyActionMapId: Bool?
    /** Indicates filtering for Journey visit id */
    public var hasJourneyVisitId: Bool?
    /** Indicates filtering for presence of MMS media */
    public var hasMedia: Bool?
    /** The role Ids used to filter the view */
    public var roleIds: [String]?
    /** The report to user IDs used to filter the view */
    public var reportsTos: [String]?
    /** The location Ids used to filter the view */
    public var locationIds: [String]?
    /** A list of flow out types */
    public var flowOutTypes: [String]?
    /** A list of providers */
    public var providerList: [String]?
    /** A list of callback numbers or substrings of numbers (ex: [\"317\", \"13172222222\"]) */
    public var callbackNumberList: [String]?
    /** An interval of time to filter for scheduled callbacks. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var callbackInterval: String?
    /** A list of routing types used */
    public var usedRoutingTypes: [UsedRoutingTypes]?
    /** A list of routing types requested */
    public var requestedRoutingTypes: [RequestedRoutingTypes]?
    /** Indicates filtering for agent assist id */
    public var hasAgentAssistId: Bool?
    /** A list of transcript contents requested */
    public var transcripts: [Transcripts]?
    /** A list of transcript languages requested */
    public var transcriptLanguages: [String]?
    /** A list of participant purpose requested */
    public var participantPurposes: [ParticipantPurposes]?
    /** Indicates filtering for first queue data */
    public var showFirstQueue: Bool?
    /** The team ids used to filter the view data */
    public var teamIds: [String]?
    /** The team ids are used to fetch associated users for the view */
    public var filterUsersByTeamIds: [String]?
    /** The journey action map ids are used to fetch action maps for the associated view */
    public var journeyActionMapIds: [String]?
    /** The journey outcome ids are used to fetch outcomes for the associated view */
    public var journeyOutcomeIds: [String]?
    /** The journey segment ids are used to fetch segments for the associated view */
    public var journeySegmentIds: [String]?
    /** The journey action map types are used to filter action map data for the associated view */
    public var journeyActionMapTypes: [JourneyActionMapTypes]?
    /** The list of development roles used to filter agent development view */
    public var developmentRoleList: [DevelopmentRoleList]?
    /** The list of development types used to filter agent development view */
    public var developmentTypeList: [DevelopmentTypeList]?
    /** The list of development status used to filter agent development view */
    public var developmentStatusList: [DevelopmentStatusList]?
    /** The list of development moduleIds used to filter agent development view */
    public var developmentModuleIds: [String]?
    /** Indicates filtering for development activities */
    public var developmentActivityOverdue: Bool?
    /** The customer sentiment score used to filter the view */
    public var customerSentimentScore: NumericRange?
    /** The customer sentiment trend used to filter the view */
    public var customerSentimentTrend: NumericRange?
    /** The list of transfer targets used to filter flow data */
    public var flowTransferTargets: [String]?
    /** Filter for development name */
    public var developmentName: String?
    /** Represents the topics detected in the transcript */
    public var topicIds: [String]?
    /** The list of external Tags used to filter conversation data */
    public var externalTags: [String]?
    /** Indicates filtering for not responding users */
    public var isNotResponding: Bool?
    /** Indicates filtering for the authenticated chat */
    public var isAuthenticated: Bool?
    /** The list of bot IDs used to filter bot views */
    public var botIds: [String]?
    /** The list of bot versions used to filter bot views */
    public var botVersions: [String]?
    /** The list of bot message types used to filter bot views */
    public var botMessageTypes: [BotMessageTypes]?
    /** The list of bot providers used to filter bot views */
    public var botProviderList: [BotProviderList]?
    /** The list of bot products used to filter bot views */
    public var botProductList: [BotProductList]?
    /** The list of bot recognition failure reasons used to filter bot views */
    public var botRecognitionFailureReasonList: [BotRecognitionFailureReasonList]?
    /** The list of bot intents used to filter bot views */
    public var botIntentList: [String]?
    /** The list of bot final intents used to filter bot views */
    public var botFinalIntentList: [String]?
    /** The list of bot slots used to filter bot views */
    public var botSlotList: [String]?
    /** The list of bot results used to filter bot views */
    public var botResultList: [BotResultList]?
    /** The list of blocked reason used to filter action map constraints views */
    public var blockedReasons: [BlockedReasons]?
    /** Indicates filtering for recorded */
    public var isRecorded: Bool?
    /** Indicates filtering for evaluation */
    public var hasEvaluation: Bool?
    /** Indicates filtering for scored evaluation */
    public var hasScoredEvaluation: Bool?
    /** The list of email delivery statuses used to filter views */
    public var emailDeliveryStatusList: [EmailDeliveryStatusList]?
    /** Indicates filtering for agent owned callback interactions */
    public var isAgentOwnedCallback: Bool?
    /** The list of callback owners used to filter interactions */
    public var agentCallbackOwnerIds: [String]?
    /** The list of transcript topics requested in filter */
    public var transcriptTopics: [TranscriptTopics]?
    /** The list of frequency cap reasons to filter offer constraints */
    public var journeyFrequencyCapReasons: [String]?
    /** The list of blocking action maps to filter offer constraints */
    public var journeyBlockingActionMapIds: [String]?
    /** The list of action targets to filter offer constraints */
    public var journeyActionTargetIds: [String]?
    /** The list of blocking schedule groups to filter offer constraints */
    public var journeyBlockingScheduleGroupIds: [String]?
    /** The list of emergency schedule groups to filter offer constraints */
    public var journeyBlockingEmergencyScheduleGroupIds: [String]?
    /** The list of url equal conditions to filter offer constraints */
    public var journeyUrlEqualConditions: [String]?
    /** The list of url not equal conditions to filter offer constraints */
    public var journeyUrlNotEqualConditions: [String]?
    /** The list of url starts with conditions to filter offer constraints */
    public var journeyUrlStartsWithConditions: [String]?
    /** The list of url ends with conditions to filter offer constraints */
    public var journeyUrlEndsWithConditions: [String]?
    /** The list of url contains any conditions to filter offer constraints */
    public var journeyUrlContainsAnyConditions: [String]?
    /** The list of url not contains any conditions to filter offer constraints */
    public var journeyUrlNotContainsAnyConditions: [String]?
    /** The list of url contains all conditions to filter offer constraints */
    public var journeyUrlContainsAllConditions: [String]?
    /** The list of url not contains all conditions to filter offer constraints */
    public var journeyUrlNotContainsAllConditions: [String]?
    /** The list of flow milestones to filter exports */
    public var flowMilestoneIds: [String]?
    /** Filter to indicate if Agent passed assessment or not */
    public var isAssessmentPassed: Bool?
    /** The list to filter based on Brands (Bot/User/Agent) or End User who initiated the first message in the conversation */
    public var conversationInitiators: [String]?
    /** Indicates if the customer has participated in an initiated conversation */
    public var hasCustomerParticipated: Bool?
    /** Filter to indicate if interaction was ACD or non-ACD */
    public var isAcdInteraction: Bool?
    /** Filters to indicate if interaction has FAX */
    public var hasFax: Bool?
    /** The list of Data Action IDs  */
    public var dataActionIds: [String]?
    /** Deprecated - Please use integrationIds instead */
    public var actionCategoryName: String?
    /** The list of integration IDs for Data Action */
    public var integrationIds: [String]?
    /** The list of Response codes for Data Action */
    public var responseStatuses: [String]?
    /** Filter to indicate the availability of the dashboard is public or private. */
    public var availableDashboard: AvailableDashboard?
    /** Filter to indicate whether the dashboard is favorite or unfavorite. */
    public var favouriteDashboard: Bool?
    /** Filter to indicate the dashboard owned by the user. */
    public var myDashboard: Bool?
    /** The list of agent errors that are related to station */
    public var stationErrors: [String]?
    /** The canonical contact ids are used to filter the view */
    public var canonicalContactIds: [String]?
    /** The list of Alert Rule IDs */
    public var alertRuleIds: [String]?
    /** The list of Evaluation Form Context IDs */
    public var evaluationFormContextIds: [String]?
    /** The evaluation statuses that are used to filter the view */
    public var evaluationStatuses: [EvaluationStatuses]?
    /** The list of Workbin IDs */
    public var workbinIds: [String]?
    /** The list of Worktype IDs */
    public var worktypeIds: [String]?
    /** The list of Workitem IDs */
    public var workitemIds: [String]?
    /** The list of Workitem Assignee IDs */
    public var workitemAssigneeIds: [String]?
    /** The list of Workitem Statuses IDs */
    public var workitemStatuses: [String]?
    /** Deprecated - Use hasPciData or hasPiiData instead. */
    public var isAnalyzedForSensitiveData: Bool?
    /** Deprecated. Use hasPciData or hasPiiData instead. */
    public var hasSensitiveData: Bool?
    /** Filter to indicate the transcript contains Pci data. */
    public var hasPciData: Bool?
    /** Filter to indicate the transcript contains Pii data. */
    public var hasPiiData: Bool?
    /** Filter for Sub Path */
    public var subPath: String?
    /** The user supplied state value in the view */
    public var userState: UserState?
    /** Filter to indicate if the customer cleared the conversation. */
    public var isClearedByCustomer: Bool?
    /** The evaluation assignee ids that are used to filter the view. */
    public var evaluationAssigneeIds: [String]?
    /** Filter to indicate that the user has no assigned evaluation. */
    public var evaluationAssigned: Bool?
    /** The assistant ids that are used to filter the view. */
    public var assistantIds: [String]?
    /** The knowledge base ids that are used to filter the view. */
    public var knowledgeBaseIds: [String]?
    /** Filter to indicate if the interactions are parked. */
    public var isParked: Bool?
    /** The agentEmpathyScore is used to filter the view */
    public var agentEmpathyScore: NumericRange?

    public init(mediaTypes: [MediaTypes]?, queueIds: [String]?, skillIds: [String]?, skillGroups: [String]?, languageIds: [String]?, languageGroups: [String]?, directions: [Directions]?, originatingDirections: [OriginatingDirections]?, wrapUpCodes: [String]?, dnisList: [String]?, sessionDnisList: [String]?, filterQueuesByUserIds: [String]?, filterUsersByQueueIds: [String]?, userIds: [String]?, managementUnitIds: [String]?, addressTos: [String]?, addressFroms: [String]?, outboundCampaignIds: [String]?, outboundContactListIds: [String]?, contactIds: [String]?, externalContactIds: [String]?, externalOrgIds: [String]?, aniList: [String]?, durationsMilliseconds: [NumericRange]?, acdDurationsMilliseconds: [NumericRange]?, talkDurationsMilliseconds: [NumericRange]?, acwDurationsMilliseconds: [NumericRange]?, handleDurationsMilliseconds: [NumericRange]?, holdDurationsMilliseconds: [NumericRange]?, abandonDurationsMilliseconds: [NumericRange]?, evaluationScore: NumericRange?, evaluationCriticalScore: NumericRange?, evaluationFormIds: [String]?, evaluatedAgentIds: [String]?, evaluatorIds: [String]?, transferred: Bool?, abandoned: Bool?, answered: Bool?, messageTypes: [MessageTypes]?, divisionIds: [String]?, surveyFormIds: [String]?, surveyTotalScore: NumericRange?, surveyNpsScore: NumericRange?, mos: NumericRange?, surveyQuestionGroupScore: NumericRange?, surveyPromoterScore: NumericRange?, surveyFormContextIds: [String]?, conversationIds: [String]?, sipCallIds: [String]?, isEnded: Bool?, isSurveyed: Bool?, surveyScores: [NumericRange]?, promoterScores: [NumericRange]?, isCampaign: Bool?, surveyStatuses: [String]?, conversationProperties: ConversationProperties?, isBlindTransferred: Bool?, isConsulted: Bool?, isConsultTransferred: Bool?, remoteParticipants: [String]?, flowIds: [String]?, flowOutcomeIds: [String]?, flowOutcomeValues: [FlowOutcomeValues]?, flowDestinationTypes: [FlowDestinationTypes]?, flowDisconnectReasons: [FlowDisconnectReasons]?, flowTypes: [FlowTypes]?, flowEntryTypes: [FlowEntryTypes]?, flowEntryReasons: [String]?, flowVersions: [String]?, groupIds: [String]?, hasJourneyCustomerId: Bool?, hasJourneyActionMapId: Bool?, hasJourneyVisitId: Bool?, hasMedia: Bool?, roleIds: [String]?, reportsTos: [String]?, locationIds: [String]?, flowOutTypes: [String]?, providerList: [String]?, callbackNumberList: [String]?, callbackInterval: String?, usedRoutingTypes: [UsedRoutingTypes]?, requestedRoutingTypes: [RequestedRoutingTypes]?, hasAgentAssistId: Bool?, transcripts: [Transcripts]?, transcriptLanguages: [String]?, participantPurposes: [ParticipantPurposes]?, showFirstQueue: Bool?, teamIds: [String]?, filterUsersByTeamIds: [String]?, journeyActionMapIds: [String]?, journeyOutcomeIds: [String]?, journeySegmentIds: [String]?, journeyActionMapTypes: [JourneyActionMapTypes]?, developmentRoleList: [DevelopmentRoleList]?, developmentTypeList: [DevelopmentTypeList]?, developmentStatusList: [DevelopmentStatusList]?, developmentModuleIds: [String]?, developmentActivityOverdue: Bool?, customerSentimentScore: NumericRange?, customerSentimentTrend: NumericRange?, flowTransferTargets: [String]?, developmentName: String?, topicIds: [String]?, externalTags: [String]?, isNotResponding: Bool?, isAuthenticated: Bool?, botIds: [String]?, botVersions: [String]?, botMessageTypes: [BotMessageTypes]?, botProviderList: [BotProviderList]?, botProductList: [BotProductList]?, botRecognitionFailureReasonList: [BotRecognitionFailureReasonList]?, botIntentList: [String]?, botFinalIntentList: [String]?, botSlotList: [String]?, botResultList: [BotResultList]?, blockedReasons: [BlockedReasons]?, isRecorded: Bool?, hasEvaluation: Bool?, hasScoredEvaluation: Bool?, emailDeliveryStatusList: [EmailDeliveryStatusList]?, isAgentOwnedCallback: Bool?, agentCallbackOwnerIds: [String]?, transcriptTopics: [TranscriptTopics]?, journeyFrequencyCapReasons: [String]?, journeyBlockingActionMapIds: [String]?, journeyActionTargetIds: [String]?, journeyBlockingScheduleGroupIds: [String]?, journeyBlockingEmergencyScheduleGroupIds: [String]?, journeyUrlEqualConditions: [String]?, journeyUrlNotEqualConditions: [String]?, journeyUrlStartsWithConditions: [String]?, journeyUrlEndsWithConditions: [String]?, journeyUrlContainsAnyConditions: [String]?, journeyUrlNotContainsAnyConditions: [String]?, journeyUrlContainsAllConditions: [String]?, journeyUrlNotContainsAllConditions: [String]?, flowMilestoneIds: [String]?, isAssessmentPassed: Bool?, conversationInitiators: [String]?, hasCustomerParticipated: Bool?, isAcdInteraction: Bool?, hasFax: Bool?, dataActionIds: [String]?, actionCategoryName: String?, integrationIds: [String]?, responseStatuses: [String]?, availableDashboard: AvailableDashboard?, favouriteDashboard: Bool?, myDashboard: Bool?, stationErrors: [String]?, canonicalContactIds: [String]?, alertRuleIds: [String]?, evaluationFormContextIds: [String]?, evaluationStatuses: [EvaluationStatuses]?, workbinIds: [String]?, worktypeIds: [String]?, workitemIds: [String]?, workitemAssigneeIds: [String]?, workitemStatuses: [String]?, isAnalyzedForSensitiveData: Bool?, hasSensitiveData: Bool?, hasPciData: Bool?, hasPiiData: Bool?, subPath: String?, userState: UserState?, isClearedByCustomer: Bool?, evaluationAssigneeIds: [String]?, evaluationAssigned: Bool?, assistantIds: [String]?, knowledgeBaseIds: [String]?, isParked: Bool?, agentEmpathyScore: NumericRange?) {
        self.mediaTypes = mediaTypes
        self.queueIds = queueIds
        self.skillIds = skillIds
        self.skillGroups = skillGroups
        self.languageIds = languageIds
        self.languageGroups = languageGroups
        self.directions = directions
        self.originatingDirections = originatingDirections
        self.wrapUpCodes = wrapUpCodes
        self.dnisList = dnisList
        self.sessionDnisList = sessionDnisList
        self.filterQueuesByUserIds = filterQueuesByUserIds
        self.filterUsersByQueueIds = filterUsersByQueueIds
        self.userIds = userIds
        self.managementUnitIds = managementUnitIds
        self.addressTos = addressTos
        self.addressFroms = addressFroms
        self.outboundCampaignIds = outboundCampaignIds
        self.outboundContactListIds = outboundContactListIds
        self.contactIds = contactIds
        self.externalContactIds = externalContactIds
        self.externalOrgIds = externalOrgIds
        self.aniList = aniList
        self.durationsMilliseconds = durationsMilliseconds
        self.acdDurationsMilliseconds = acdDurationsMilliseconds
        self.talkDurationsMilliseconds = talkDurationsMilliseconds
        self.acwDurationsMilliseconds = acwDurationsMilliseconds
        self.handleDurationsMilliseconds = handleDurationsMilliseconds
        self.holdDurationsMilliseconds = holdDurationsMilliseconds
        self.abandonDurationsMilliseconds = abandonDurationsMilliseconds
        self.evaluationScore = evaluationScore
        self.evaluationCriticalScore = evaluationCriticalScore
        self.evaluationFormIds = evaluationFormIds
        self.evaluatedAgentIds = evaluatedAgentIds
        self.evaluatorIds = evaluatorIds
        self.transferred = transferred
        self.abandoned = abandoned
        self.answered = answered
        self.messageTypes = messageTypes
        self.divisionIds = divisionIds
        self.surveyFormIds = surveyFormIds
        self.surveyTotalScore = surveyTotalScore
        self.surveyNpsScore = surveyNpsScore
        self.mos = mos
        self.surveyQuestionGroupScore = surveyQuestionGroupScore
        self.surveyPromoterScore = surveyPromoterScore
        self.surveyFormContextIds = surveyFormContextIds
        self.conversationIds = conversationIds
        self.sipCallIds = sipCallIds
        self.isEnded = isEnded
        self.isSurveyed = isSurveyed
        self.surveyScores = surveyScores
        self.promoterScores = promoterScores
        self.isCampaign = isCampaign
        self.surveyStatuses = surveyStatuses
        self.conversationProperties = conversationProperties
        self.isBlindTransferred = isBlindTransferred
        self.isConsulted = isConsulted
        self.isConsultTransferred = isConsultTransferred
        self.remoteParticipants = remoteParticipants
        self.flowIds = flowIds
        self.flowOutcomeIds = flowOutcomeIds
        self.flowOutcomeValues = flowOutcomeValues
        self.flowDestinationTypes = flowDestinationTypes
        self.flowDisconnectReasons = flowDisconnectReasons
        self.flowTypes = flowTypes
        self.flowEntryTypes = flowEntryTypes
        self.flowEntryReasons = flowEntryReasons
        self.flowVersions = flowVersions
        self.groupIds = groupIds
        self.hasJourneyCustomerId = hasJourneyCustomerId
        self.hasJourneyActionMapId = hasJourneyActionMapId
        self.hasJourneyVisitId = hasJourneyVisitId
        self.hasMedia = hasMedia
        self.roleIds = roleIds
        self.reportsTos = reportsTos
        self.locationIds = locationIds
        self.flowOutTypes = flowOutTypes
        self.providerList = providerList
        self.callbackNumberList = callbackNumberList
        self.callbackInterval = callbackInterval
        self.usedRoutingTypes = usedRoutingTypes
        self.requestedRoutingTypes = requestedRoutingTypes
        self.hasAgentAssistId = hasAgentAssistId
        self.transcripts = transcripts
        self.transcriptLanguages = transcriptLanguages
        self.participantPurposes = participantPurposes
        self.showFirstQueue = showFirstQueue
        self.teamIds = teamIds
        self.filterUsersByTeamIds = filterUsersByTeamIds
        self.journeyActionMapIds = journeyActionMapIds
        self.journeyOutcomeIds = journeyOutcomeIds
        self.journeySegmentIds = journeySegmentIds
        self.journeyActionMapTypes = journeyActionMapTypes
        self.developmentRoleList = developmentRoleList
        self.developmentTypeList = developmentTypeList
        self.developmentStatusList = developmentStatusList
        self.developmentModuleIds = developmentModuleIds
        self.developmentActivityOverdue = developmentActivityOverdue
        self.customerSentimentScore = customerSentimentScore
        self.customerSentimentTrend = customerSentimentTrend
        self.flowTransferTargets = flowTransferTargets
        self.developmentName = developmentName
        self.topicIds = topicIds
        self.externalTags = externalTags
        self.isNotResponding = isNotResponding
        self.isAuthenticated = isAuthenticated
        self.botIds = botIds
        self.botVersions = botVersions
        self.botMessageTypes = botMessageTypes
        self.botProviderList = botProviderList
        self.botProductList = botProductList
        self.botRecognitionFailureReasonList = botRecognitionFailureReasonList
        self.botIntentList = botIntentList
        self.botFinalIntentList = botFinalIntentList
        self.botSlotList = botSlotList
        self.botResultList = botResultList
        self.blockedReasons = blockedReasons
        self.isRecorded = isRecorded
        self.hasEvaluation = hasEvaluation
        self.hasScoredEvaluation = hasScoredEvaluation
        self.emailDeliveryStatusList = emailDeliveryStatusList
        self.isAgentOwnedCallback = isAgentOwnedCallback
        self.agentCallbackOwnerIds = agentCallbackOwnerIds
        self.transcriptTopics = transcriptTopics
        self.journeyFrequencyCapReasons = journeyFrequencyCapReasons
        self.journeyBlockingActionMapIds = journeyBlockingActionMapIds
        self.journeyActionTargetIds = journeyActionTargetIds
        self.journeyBlockingScheduleGroupIds = journeyBlockingScheduleGroupIds
        self.journeyBlockingEmergencyScheduleGroupIds = journeyBlockingEmergencyScheduleGroupIds
        self.journeyUrlEqualConditions = journeyUrlEqualConditions
        self.journeyUrlNotEqualConditions = journeyUrlNotEqualConditions
        self.journeyUrlStartsWithConditions = journeyUrlStartsWithConditions
        self.journeyUrlEndsWithConditions = journeyUrlEndsWithConditions
        self.journeyUrlContainsAnyConditions = journeyUrlContainsAnyConditions
        self.journeyUrlNotContainsAnyConditions = journeyUrlNotContainsAnyConditions
        self.journeyUrlContainsAllConditions = journeyUrlContainsAllConditions
        self.journeyUrlNotContainsAllConditions = journeyUrlNotContainsAllConditions
        self.flowMilestoneIds = flowMilestoneIds
        self.isAssessmentPassed = isAssessmentPassed
        self.conversationInitiators = conversationInitiators
        self.hasCustomerParticipated = hasCustomerParticipated
        self.isAcdInteraction = isAcdInteraction
        self.hasFax = hasFax
        self.dataActionIds = dataActionIds
        self.actionCategoryName = actionCategoryName
        self.integrationIds = integrationIds
        self.responseStatuses = responseStatuses
        self.availableDashboard = availableDashboard
        self.favouriteDashboard = favouriteDashboard
        self.myDashboard = myDashboard
        self.stationErrors = stationErrors
        self.canonicalContactIds = canonicalContactIds
        self.alertRuleIds = alertRuleIds
        self.evaluationFormContextIds = evaluationFormContextIds
        self.evaluationStatuses = evaluationStatuses
        self.workbinIds = workbinIds
        self.worktypeIds = worktypeIds
        self.workitemIds = workitemIds
        self.workitemAssigneeIds = workitemAssigneeIds
        self.workitemStatuses = workitemStatuses
        self.isAnalyzedForSensitiveData = isAnalyzedForSensitiveData
        self.hasSensitiveData = hasSensitiveData
        self.hasPciData = hasPciData
        self.hasPiiData = hasPiiData
        self.subPath = subPath
        self.userState = userState
        self.isClearedByCustomer = isClearedByCustomer
        self.evaluationAssigneeIds = evaluationAssigneeIds
        self.evaluationAssigned = evaluationAssigned
        self.assistantIds = assistantIds
        self.knowledgeBaseIds = knowledgeBaseIds
        self.isParked = isParked
        self.agentEmpathyScore = agentEmpathyScore
    }


}




public class VmPairingInfo: Codable {









    /** This is to be used to complete the setup process of a locally deployed virtual edge device. */
    public var metaData: MetaData?
    public var edgeId: String?
    public var authToken: String?
    public var orgId: String?

    public init(metaData: MetaData?, edgeId: String?, authToken: String?, orgId: String?) {
        self.metaData = metaData
        self.edgeId = edgeId
        self.authToken = authToken
        self.orgId = orgId
    }

    public enum CodingKeys: String, CodingKey { 
        case metaData = "meta-data"
        case edgeId = "edge-id"
        case authToken = "auth-token"
        case orgId = "org-id"
    }


}




public class VoicemailGroupPolicy: Codable {





















    public enum GroupAlertType: String, Codable { 
        case random = "RANDOM"
        case roundRobin = "ROUND_ROBIN"
        case sequential = "SEQUENTIAL"
    }





    public var name: String?
    /** The group associated with the policy */
    public var group: Group?
    /** Whether voicemail is enabled for the group */
    public var enabled: Bool?
    /** Whether email notifications are sent to group members when a new voicemail is received */
    public var sendEmailNotifications: Bool?
    /** Removes any PII from group emails. This is overridden by the analogous organization configuration value. This is always true if HIPAA is enabled or unknown for an organization. */
    public var disableEmailPii: Bool?
    /** Whether to include the voicemail transcription in a group notification email */
    public var includeEmailTranscriptions: Bool?
    /** The language preference for the group.  Used for group voicemail transcription */
    public var languagePreference: String?
    /** How many seconds to ring before rotating to the next member in the group */
    public var rotateCallsSecs: Int?
    /** How many rotations to go through */
    public var stopRingingAfterRotations: Int?
    /** A fallback group to contact when all of the members in this group did not answer the call. */
    public var overflowGroupId: String?
    /** Specifies if the members in this group should be contacted randomly, in a specific order, or by round-robin. */
    public var groupAlertType: GroupAlertType?
    /** The prompt to use when connecting a user to a Group Ring call */
    public var interactiveResponsePromptId: String?
    /** Whether user should be prompted with a confirmation prompt when connecting to a Group Ring call */
    public var interactiveResponseRequired: Bool?

    public init(name: String?, group: Group?, enabled: Bool?, sendEmailNotifications: Bool?, disableEmailPii: Bool?, includeEmailTranscriptions: Bool?, languagePreference: String?, rotateCallsSecs: Int?, stopRingingAfterRotations: Int?, overflowGroupId: String?, groupAlertType: GroupAlertType?, interactiveResponsePromptId: String?, interactiveResponseRequired: Bool?) {
        self.name = name
        self.group = group
        self.enabled = enabled
        self.sendEmailNotifications = sendEmailNotifications
        self.disableEmailPii = disableEmailPii
        self.includeEmailTranscriptions = includeEmailTranscriptions
        self.languagePreference = languagePreference
        self.rotateCallsSecs = rotateCallsSecs
        self.stopRingingAfterRotations = stopRingingAfterRotations
        self.overflowGroupId = overflowGroupId
        self.groupAlertType = groupAlertType
        self.interactiveResponsePromptId = interactiveResponsePromptId
        self.interactiveResponseRequired = interactiveResponseRequired
    }


}




public class VoicemailMessage: Codable {









































    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The conversation that the voicemail message is associated with */
    public var conversation: Conversation?
    /** Whether the voicemail message is marked as read */
    public var read: Bool?
    /** The voicemail message's audio recording duration in seconds */
    public var audioRecordingDurationSeconds: Int?
    /** The voicemail message's audio recording size in bytes */
    public var audioRecordingSizeBytes: Int64?
    /** The date the voicemail message was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    /** The date the voicemail message was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    /** The date the voicemail message deleted property was set to true. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var deletedDate: Date?
    /** The caller address */
    public var callerAddress: String?
    /** Optionally the name of the caller that left the voicemail message if the caller was a known user */
    public var callerName: String?
    /** Optionally the user that left the voicemail message if the caller was a known user */
    public var callerUser: User?
    /** Whether the voicemail message has been marked as deleted */
    public var deleted: Bool?
    /** An optional note */
    public var note: String?
    /** The user that the voicemail message belongs to or null which means the voicemail message belongs to a group or queue */
    public var user: User?
    /** The group that the voicemail message belongs to or null which means the voicemail message belongs to a user or queue */
    public var group: Group?
    /** The queue that the voicemail message belongs to or null which means the voicemail message belongs to a user or group */
    public var queue: Queue?
    /** Represents where this voicemail message was copied from */
    public var copiedFrom: VoicemailCopyRecord?
    /** Represents where this voicemail has been copied to */
    public var copiedTo: [VoicemailCopyRecord]?
    /** The retention policy for this voicemail when deleted is set to true */
    public var deleteRetentionPolicy: VoicemailRetentionPolicy?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, conversation: Conversation?, read: Bool?, audioRecordingDurationSeconds: Int?, audioRecordingSizeBytes: Int64?, createdDate: Date?, modifiedDate: Date?, deletedDate: Date?, callerAddress: String?, callerName: String?, callerUser: User?, deleted: Bool?, note: String?, user: User?, group: Group?, queue: Queue?, copiedFrom: VoicemailCopyRecord?, copiedTo: [VoicemailCopyRecord]?, deleteRetentionPolicy: VoicemailRetentionPolicy?, selfUri: String?) {
        self._id = _id
        self.conversation = conversation
        self.read = read
        self.audioRecordingDurationSeconds = audioRecordingDurationSeconds
        self.audioRecordingSizeBytes = audioRecordingSizeBytes
        self.createdDate = createdDate
        self.modifiedDate = modifiedDate
        self.deletedDate = deletedDate
        self.callerAddress = callerAddress
        self.callerName = callerName
        self.callerUser = callerUser
        self.deleted = deleted
        self.note = note
        self.user = user
        self.group = group
        self.queue = queue
        self.copiedFrom = copiedFrom
        self.copiedTo = copiedTo
        self.deleteRetentionPolicy = deleteRetentionPolicy
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case conversation
        case read
        case audioRecordingDurationSeconds
        case audioRecordingSizeBytes
        case createdDate
        case modifiedDate
        case deletedDate
        case callerAddress
        case callerName
        case callerUser
        case deleted
        case note
        case user
        case group
        case queue
        case copiedFrom
        case copiedTo
        case deleteRetentionPolicy
        case selfUri
    }


}




public class VoicemailMessagesTopicVoicemailCopyRecord: Codable {





    public var user: VoicemailMessagesTopicOwner?
    public var group: VoicemailMessagesTopicOwner?

    public init(user: VoicemailMessagesTopicOwner?, group: VoicemailMessagesTopicOwner?) {
        self.user = user
        self.group = group
    }


}




public class VoicemailUserPolicy: Codable {











    /** Whether the user has voicemail enabled */
    public var enabled: Bool?
    /** The number of seconds to ring the user's phone before a call is transfered to voicemail */
    public var alertTimeoutSeconds: Int?
    /** The user's PIN to access their voicemail. This property is only used for updates and never provided otherwise to ensure security */
    public var pin: String?
    /** The date the policy was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    /** Whether email notifications are sent to the user when a new voicemail is received */
    public var sendEmailNotifications: Bool?

    public init(enabled: Bool?, alertTimeoutSeconds: Int?, pin: String?, modifiedDate: Date?, sendEmailNotifications: Bool?) {
        self.enabled = enabled
        self.alertTimeoutSeconds = alertTimeoutSeconds
        self.pin = pin
        self.modifiedDate = modifiedDate
        self.sendEmailNotifications = sendEmailNotifications
    }


}




public class WebChatConversation: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Chat Member */
    public var member: WebChatMemberInfo?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, member: WebChatMemberInfo?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.member = member
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case member
        case selfUri
    }


}



/** Object representing the guest model of a media request of a chat conversation. */

public class WebChatGuestMediaRequest: Codable {





    public enum Types: String, Codable { 
        case cobrowse = "COBROWSE"
        case screenshare = "SCREENSHARE"
    }

    public enum State: String, Codable { 
        case pending = "PENDING"
        case accepted = "ACCEPTED"
        case declined = "DECLINED"
        case timedout = "TIMEDOUT"
        case cancelled = "CANCELLED"
        case errored = "ERRORED"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The types of media being requested. */
    public var types: [Types]?
    /** The state of the media request, one of PENDING|ACCEPTED|DECLINED|TIMEDOUT|CANCELLED|ERRORED. */
    public var state: State?
    /** The ID of the new media communication, if applicable. */
    public var communicationId: String?
    /** The security information related to a media request. */
    public var securityKey: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, types: [Types]?, state: State?, communicationId: String?, securityKey: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.types = types
        self.state = state
        self.communicationId = communicationId
        self.securityKey = securityKey
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case types
        case state
        case communicationId
        case securityKey
        case selfUri
    }


}




public class WebChatMemberInfoEntityList: Codable {





















    public var entities: [WebChatMemberInfo]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [WebChatMemberInfo]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class WebChatTyping: Codable {









    /** The event identifier of this typing indicator event (useful to guard against event re-delivery */
    public var _id: String?
    /** The identifier of the conversation */
    public var conversation: WebChatConversation?
    /** The member who sent the message */
    public var sender: WebChatMemberInfo?
    /** The timestamp of the message, in ISO-8601 format */
    public var timestamp: Date?

    public init(_id: String?, conversation: WebChatConversation?, sender: WebChatMemberInfo?, timestamp: Date?) {
        self._id = _id
        self.conversation = conversation
        self.sender = sender
        self.timestamp = timestamp
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case conversation
        case sender
        case timestamp
    }


}




public class WebDeploymentConfigurationVersionEntityListing: Codable {







    public var total: Int64?
    public var entities: [WebDeploymentConfigurationVersion]?
    public var selfUri: String?

    public init(total: Int64?, entities: [WebDeploymentConfigurationVersion]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class WebDeploymentConfigurationVersionEntityRef: Codable {









    /** The configuration version ID */
    public var _id: String?
    /** The configuration version name */
    public var name: String?
    public var selfUri: String?
    /** The version of the configuration */
    public var version: String?

    public init(_id: String?, name: String?, selfUri: String?, version: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
        case version
    }


}



/** Details about the configuration version of a Web Deployment */

public class WebDeploymentConfigurationVersionResponse: Codable {









































    public enum Status: String, Codable { 
        case pending = "Pending"
        case active = "Active"
        case inactive = "Inactive"
        case error = "Error"
        case deleting = "Deleting"
    }



    /** The configuration version ID */
    public var _id: String?
    /** The configuration version name */
    public var name: String?
    /** The version of the configuration */
    public var version: String?
    /** Headless Mode Support which Controls UI components. When enabled, native UI components will be disabled and allows for custom-built UI. */
    public var headlessMode: WebDeploymentHeadlessMode?
    /** The description of the configuration */
    public var _description: String?
    /** A list of languages supported on the configuration required if the messenger is enabled */
    public var languages: [String]?
    /** The default language to use for the configuration required if the messenger is enabled */
    public var defaultLanguage: String?
    /** The localization settings for homescreen app */
    public var customI18nLabels: [CustomI18nLabels]?
    /** The settings for messenger */
    public var messenger: MessengerSettings?
    /** The settings for position */
    public var position: PositionSettings?
    /** The settings for knowledge portal (previously support center) */
    public var supportCenter: SupportCenterSettings?
    /** The settings for cobrowse */
    public var cobrowse: CobrowseSettings?
    /** The settings for journey events */
    public var journeyEvents: JourneyEventsSettings?
    /** The settings for authenticated deployments */
    public var authenticationSettings: AuthenticationSettings?
    /** The date the configuration version was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date the configuration version was most recently modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The date the configuration version was most recently published. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var datePublished: Date?
    /** A reference to the user who most recently modified the configuration version */
    public var lastModifiedUser: AddressableEntityRef?
    /** A reference to the user who created the configuration version */
    public var createdUser: AddressableEntityRef?
    /** A reference to the user who published the configuration version */
    public var publishedUser: AddressableEntityRef?
    /** The current status of the configuration version */
    public var status: Status?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, version: String?, headlessMode: WebDeploymentHeadlessMode?, _description: String?, languages: [String]?, defaultLanguage: String?, customI18nLabels: [CustomI18nLabels]?, messenger: MessengerSettings?, position: PositionSettings?, supportCenter: SupportCenterSettings?, cobrowse: CobrowseSettings?, journeyEvents: JourneyEventsSettings?, authenticationSettings: AuthenticationSettings?, dateCreated: Date?, dateModified: Date?, datePublished: Date?, lastModifiedUser: AddressableEntityRef?, createdUser: AddressableEntityRef?, publishedUser: AddressableEntityRef?, status: Status?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.version = version
        self.headlessMode = headlessMode
        self._description = _description
        self.languages = languages
        self.defaultLanguage = defaultLanguage
        self.customI18nLabels = customI18nLabels
        self.messenger = messenger
        self.position = position
        self.supportCenter = supportCenter
        self.cobrowse = cobrowse
        self.journeyEvents = journeyEvents
        self.authenticationSettings = authenticationSettings
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.datePublished = datePublished
        self.lastModifiedUser = lastModifiedUser
        self.createdUser = createdUser
        self.publishedUser = publishedUser
        self.status = status
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case version
        case headlessMode
        case _description = "description"
        case languages
        case defaultLanguage
        case customI18nLabels
        case messenger
        case position
        case supportCenter
        case cobrowse
        case journeyEvents
        case authenticationSettings
        case dateCreated
        case dateModified
        case datePublished
        case lastModifiedUser
        case createdUser
        case publishedUser
        case status
        case selfUri
    }


}




public class WebDeploymentsDeploymentTopicWebMessagingConfigChangeEventBody: Codable {





    public enum Status: String, Codable { 
        case pending = "Pending"
        case active = "Active"
        case inactive = "Inactive"
        case error = "Error"
        case deleting = "Deleting"
    }

    public var _id: String?
    public var version: String?
    public var status: Status?

    public init(_id: String?, version: String?, status: Status?) {
        self._id = _id
        self.version = version
        self.status = status
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
        case status
    }


}



/** Attachment object. */

public class WebMessagingAttachment: Codable {



    public enum MediaType: String, Codable { 
        case image = "Image"
        case video = "Video"
        case audio = "Audio"
        case file = "File"
        case link = "Link"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The type of attachment this instance represents. */
    public var mediaType: MediaType?
    /** URL of the attachment. */
    public var url: String?
    /** Attachment mime type (https://www.iana.org/assignments/media-types/media-types.xhtml). */
    public var mime: String?
    /** Text associated with attachment such as an image caption. */
    public var text: String?
    /** Secure hash of the attachment content. */
    public var sha256: String?
    /** Suggested file name for attachment. */
    public var filename: String?
    /** The file size associated with the file */
    public var fileSize: Int?

    public init(_id: String?, mediaType: MediaType?, url: String?, mime: String?, text: String?, sha256: String?, filename: String?, fileSize: Int?) {
        self._id = _id
        self.mediaType = mediaType
        self.url = url
        self.mime = mime
        self.text = text
        self.sha256 = sha256
        self.filename = filename
        self.fileSize = fileSize
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case mediaType
        case url
        case mime
        case text
        case sha256
        case filename
        case fileSize
    }


}



/** Button response object representing the click of a structured message button, such as a quick reply. */

public class WebMessagingButtonResponse: Codable {



    public enum ModelType: String, Codable { 
        case button = "Button"
        case quickReply = "QuickReply"
    }





    /** An ID assigned to the button response (Deprecated). */
    public var _id: String?
    /** Describes the button that resulted in the Button Response. */
    public var type: ModelType?
    /** The response text from the button click. */
    public var text: String?
    /** The response payload associated with the clicked button. */
    public var payload: String?

    public init(_id: String?, type: ModelType?, text: String?, payload: String?) {
        self._id = _id
        self.type = type
        self.text = text
        self.payload = payload
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
        case text
        case payload
    }


}



/** A Cobrowse event. */

public class WebMessagingEventCoBrowse: Codable {

    public enum ModelType: String, Codable { 
        case offering = "Offering"
        case offeringExpired = "OfferingExpired"
        case offeringAccepted = "OfferingAccepted"
        case offeringRejected = "OfferingRejected"
    }





    /** Describes the type of Cobrowse event. */
    public var type: ModelType?
    /** The Cobrowse session ID. */
    public var sessionId: String?
    /** The Cobrowse session join token. */
    public var sessionJoinToken: String?

    public init(type: ModelType?, sessionId: String?, sessionJoinToken: String?) {
        self.type = type
        self.sessionId = sessionId
        self.sessionJoinToken = sessionJoinToken
    }


}




public class WebMessagingMessageEntityList: Codable {











    public var entities: [WebMessagingMessage]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var pageCount: Int?

    public init(entities: [WebMessagingMessage]?, pageSize: Int?, pageNumber: Int?, total: Int64?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.pageCount = pageCount
    }


}



/** Quick reply object */

public class WebMessagingQuickReply: Codable {







    public enum Action: String, Codable { 
        case message = "Message"
    }

    /** Text to show inside the quick reply. This is also used as the response text after clicking on the quick reply. */
    public var text: String?
    /** Content of the payload included in the quick reply response. Could be an ID identifying the quick reply response. */
    public var payload: String?
    /** URL of an image associated with the quick reply. */
    public var image: String?
    /** Specifies the type of action that is triggered upon clicking the quick reply. */
    public var action: Action?

    public init(text: String?, payload: String?, image: String?, action: Action?) {
        self.text = text
        self.payload = payload
        self.image = image
        self.action = action
    }


}




public class WeekScheduleReference: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?
    /** First day of this week schedule in yyyy-MM-dd format */
    public var weekDate: String?

    public init(_id: String?, selfUri: String?, weekDate: String?) {
        self._id = _id
        self.selfUri = selfUri
        self.weekDate = weekDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case weekDate
    }


}




public class WemCoachingUserNotificationTopicCoachingUserNotification: Codable {







    public enum ActionType: String, Codable { 
        case create = "Create"
        case update = "Update"
        case delete = "Delete"
        case statusChange = "StatusChange"
    }

    public enum Relationship: String, Codable { 
        case attendee = "Attendee"
        case facilitator = "Facilitator"
        case creator = "Creator"
    }







    public enum Status: String, Codable { 
        case scheduled = "Scheduled"
        case inProgress = "InProgress"
        case completed = "Completed"
        case invalidSchedule = "InvalidSchedule"
    }

    public var _id: String?
    public var name: String?
    public var markedAsRead: Bool?
    public var actionType: ActionType?
    public var relationship: Relationship?
    public var appointment: WemCoachingUserNotificationTopicCoachingAppointmentReference?
    public var dateStart: Date?
    public var lengthInMinutes: Int?
    public var status: Status?

    public init(_id: String?, name: String?, markedAsRead: Bool?, actionType: ActionType?, relationship: Relationship?, appointment: WemCoachingUserNotificationTopicCoachingAppointmentReference?, dateStart: Date?, lengthInMinutes: Int?, status: Status?) {
        self._id = _id
        self.name = name
        self.markedAsRead = markedAsRead
        self.actionType = actionType
        self.relationship = relationship
        self.appointment = appointment
        self.dateStart = dateStart
        self.lengthInMinutes = lengthInMinutes
        self.status = status
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case markedAsRead
        case actionType
        case relationship
        case appointment
        case dateStart
        case lengthInMinutes
        case status
    }


}




public class WfmAdherenceExplanationJobCompleteTopicAdherenceExplanationJobNotification: Codable {



    public enum ModelType: String, Codable { 
        case addExplanation = "AddExplanation"
        case updateExplanation = "UpdateExplanation"
        case queryAgentExplanations = "QueryAgentExplanations"
        case queryBuExplanations = "QueryBuExplanations"
    }

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case error = "Error"
    }







    public var _id: String?
    public var type: ModelType?
    public var status: Status?
    public var adherenceExplanation: WfmAdherenceExplanationJobCompleteTopicAdherenceExplanationChangedNotification?
    public var downloadUrl: String?
    public var error: WfmAdherenceExplanationJobCompleteTopicErrorBody?

    public init(_id: String?, type: ModelType?, status: Status?, adherenceExplanation: WfmAdherenceExplanationJobCompleteTopicAdherenceExplanationChangedNotification?, downloadUrl: String?, error: WfmAdherenceExplanationJobCompleteTopicErrorBody?) {
        self._id = _id
        self.type = type
        self.status = status
        self.adherenceExplanation = adherenceExplanation
        self.downloadUrl = downloadUrl
        self.error = error
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
        case status
        case adherenceExplanation
        case downloadUrl
        case error
    }


}




public class WfmBuIntradayDataUpdateTopicBuIntradayNotification: Codable {





    public var operationId: String?
    public var result: WfmBuIntradayDataUpdateTopicBuIntradayResult?

    public init(operationId: String?, result: WfmBuIntradayDataUpdateTopicBuIntradayResult?) {
        self.operationId = operationId
        self.result = result
    }


}




public class WfmBuScheduleRunTopicSchedulerMessageSeverityCount: Codable {

    public enum Severity: String, Codable { 
        case ignore = "Ignore"
        case information = "Information"
        case warning = "Warning"
        case error = "Error"
    }



    public var severity: Severity?
    public var count: Int?

    public init(severity: Severity?, count: Int?) {
        self.severity = severity
        self.count = count
    }


}




public class WfmBuScheduleRunTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmBuScheduleSearchResultTopicBuScheduleSearchResultNotification: Codable {







    public var operationId: String?
    public var businessUnitId: String?
    public var downloadUrl: String?

    public init(operationId: String?, businessUnitId: String?, downloadUrl: String?) {
        self.operationId = operationId
        self.businessUnitId = businessUnitId
        self.downloadUrl = downloadUrl
    }


}




public class WfmBuShortTermForecastImportCompleteTopicBuForecastModification: Codable {

    public enum ModelType: String, Codable { 
        case minimumPerInterval = "MinimumPerInterval"
        case maximumPerInterval = "MaximumPerInterval"
        case setValuePerInterval = "SetValuePerInterval"
        case changeValuePerInterval = "ChangeValuePerInterval"
        case changePercentPerInterval = "ChangePercentPerInterval"
        case setValueOverRange = "SetValueOverRange"
        case changeValueOverRange = "ChangeValueOverRange"
        case setValuesForIntervalSet = "SetValuesForIntervalSet"
        case setMultiGranularityValuesForIntervalSet = "SetMultiGranularityValuesForIntervalSet"
    }





    public enum Metric: String, Codable { 
        case offered = "Offered"
        case averageHandleTimeSeconds = "AverageHandleTimeSeconds"
    }

    public enum LegacyMetric: String, Codable { 
        case averageAfterCallWorkTimeSeconds = "AverageAfterCallWorkTimeSeconds"
        case averageHandleTimeSeconds = "AverageHandleTimeSeconds"
        case averageTalkTimeSeconds = "AverageTalkTimeSeconds"
        case offered = "Offered"
    }

















    public var type: ModelType?
    public var startIntervalIndex: Int?
    public var endIntervalIndex: Int?
    public var metric: Metric?
    public var legacyMetric: LegacyMetric?
    public var value: Double?
    public var values: [WfmBuShortTermForecastImportCompleteTopicModificationIntervalOffsetValue]?
    public var secondaryValues: [WfmBuShortTermForecastImportCompleteTopicModificationIntervalOffsetValue]?
    public var enabled: Bool?
    public var granularity: String?
    public var secondaryGranularity: String?
    public var displayGranularity: String?
    public var planningGroupIds: [String]?

    public init(type: ModelType?, startIntervalIndex: Int?, endIntervalIndex: Int?, metric: Metric?, legacyMetric: LegacyMetric?, value: Double?, values: [WfmBuShortTermForecastImportCompleteTopicModificationIntervalOffsetValue]?, secondaryValues: [WfmBuShortTermForecastImportCompleteTopicModificationIntervalOffsetValue]?, enabled: Bool?, granularity: String?, secondaryGranularity: String?, displayGranularity: String?, planningGroupIds: [String]?) {
        self.type = type
        self.startIntervalIndex = startIntervalIndex
        self.endIntervalIndex = endIntervalIndex
        self.metric = metric
        self.legacyMetric = legacyMetric
        self.value = value
        self.values = values
        self.secondaryValues = secondaryValues
        self.enabled = enabled
        self.granularity = granularity
        self.secondaryGranularity = secondaryGranularity
        self.displayGranularity = displayGranularity
        self.planningGroupIds = planningGroupIds
    }


}




public class WfmBuShortTermForecastImportCompleteTopicModificationIntervalOffsetValue: Codable {





    public var intervalIndex: Int?
    public var value: Double?

    public init(intervalIndex: Int?, value: Double?) {
        self.intervalIndex = intervalIndex
        self.value = value
    }


}




public class WfmBuShortTermForecastImportCompleteTopicWfmVersionedEntityMetadata: Codable {







    public var version: Int?
    public var modifiedBy: WfmBuShortTermForecastImportCompleteTopicUserReference?
    public var dateModified: Date?

    public init(version: Int?, modifiedBy: WfmBuShortTermForecastImportCompleteTopicUserReference?, dateModified: Date?) {
        self.version = version
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
    }


}




public class WfmBulkShiftTradeStateUpdateNotificationTopicBulkShiftTradeStateUpdateNotification: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }







    public var status: Status?
    public var operationId: String?
    public var result: WfmBulkShiftTradeStateUpdateNotificationTopicBulkShiftTradeStateUpdateResultListing?
    public var weekDate: Date?

    public init(status: Status?, operationId: String?, result: WfmBulkShiftTradeStateUpdateNotificationTopicBulkShiftTradeStateUpdateResultListing?, weekDate: Date?) {
        self.status = status
        self.operationId = operationId
        self.result = result
        self.weekDate = weekDate
    }


}




public class WfmForecastModificationIntervalOffsetValue: Codable {





    /** The number of intervals past referenceStartDate to which to apply this modification */
    public var intervalIndex: Int?
    /** The value to set for the given interval */
    public var value: Double?

    public init(intervalIndex: Int?, value: Double?) {
        self.intervalIndex = intervalIndex
        self.value = value
    }


}




public class WfmHistoricalAdherenceBulkResponse: Codable {







    /** A reference to the job that was started by the request */
    public var job: WfmHistoricalAdherenceBulkJobReference?
    /** The uri list to GET the results of the Historical Adherence query. This field is populated only if query state is Complete */
    public var downloadUrls: [String]?
    /** Results will always come via downloadUrls; however the schema is included for documentation */
    public var downloadResult: WfmHistoricalAdherenceBulkResult?

    public init(job: WfmHistoricalAdherenceBulkJobReference?, downloadUrls: [String]?, downloadResult: WfmHistoricalAdherenceBulkResult?) {
        self.job = job
        self.downloadUrls = downloadUrls
        self.downloadResult = downloadResult
    }


}




public class WfmHistoricalAdherenceQueryForTeams: Codable {











    /** Beginning of the date range to query in ISO-8601 format */
    public var startDate: Date?
    /** End of the date range to query in ISO-8601 format. If it is not set, end date will be set to current time */
    public var endDate: Date?
    /** The time zone, in olson format, to use in defining days when computing adherence. The results will be returned as UTC timestamps regardless of the time zone input. */
    public var timeZone: String?
    /** The userIds to report on. If null or not set, adherence will be computed for all the users in management unit or requested teamIds */
    public var userIds: [String]?
    /** Whether user exceptions should be returned as part of the results */
    public var includeExceptions: Bool?

    public init(startDate: Date?, endDate: Date?, timeZone: String?, userIds: [String]?, includeExceptions: Bool?) {
        self.startDate = startDate
        self.endDate = endDate
        self.timeZone = timeZone
        self.userIds = userIds
        self.includeExceptions = includeExceptions
    }


}




public class WfmHistoricalDataUploadPurgeRequestStatusTopicHistoricalDataUploadPurgeRequestUpdate: Codable {

    public enum Status: String, Codable { 
        case inProgress = "InProgress"
        case success = "Success"
        case failed = "Failed"
    }

    public var status: Status?

    public init(status: Status?) {
        self.status = status
    }


}




public class WfmHistoricalDataUploadRequestStatusTopicHistoricalDataUploadRequestUpdate: Codable {











    public enum Status: String, Codable { 
        case initiated = "Initiated"
        case inProgress = "InProgress"
        case pending = "Pending"
        case success = "Success"
        case failed = "Failed"
        case cancelled = "Cancelled"
        case purged = "Purged"
        case purgePending = "PurgePending"
    }





    public enum ModelType: String, Codable { 
        case csv = "Csv"
        case json = "Json"
    }

    public var requestId: String?
    public var dateImportStarted: Date?
    public var dateImportEnded: Date?
    public var dateCreated: Date?
    public var dateModified: Date?
    public var status: Status?
    public var error: String?
    public var active: Bool?
    public var type: ModelType?

    public init(requestId: String?, dateImportStarted: Date?, dateImportEnded: Date?, dateCreated: Date?, dateModified: Date?, status: Status?, error: String?, active: Bool?, type: ModelType?) {
        self.requestId = requestId
        self.dateImportStarted = dateImportStarted
        self.dateImportEnded = dateImportEnded
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.status = status
        self.error = error
        self.active = active
        self.type = type
    }


}




public class WfmHistoricalShrinkageTeamsRequest: Codable {







    public enum Granularity: String, Codable { 
        case daily = "Daily"
        case weekly = "Weekly"
    }

    /** Beginning of the date range to query in ISO-8601 format */
    public var startDate: Date?
    /** End of the date range to query in ISO-8601 format. If it is not set, end date will be set to current time */
    public var endDate: Date?
    /** The time zone, in olson format, to use in defining days when computing shrinkage for requested granularity. The results will be returned as UTC timestamps regardless of the time zone input. */
    public var timeZone: String?
    /** Shrinkage aggregation interval granularity */
    public var granularity: Granularity?

    public init(startDate: Date?, endDate: Date?, timeZone: String?, granularity: Granularity?) {
        self.startDate = startDate
        self.endDate = endDate
        self.timeZone = timeZone
        self.granularity = granularity
    }


}




public class WfmIntegrationReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class WfmIntegrationsHrisTimeOffTypesJobTopicHrisTimeOffType: Codable {







    public var _id: String?
    public var name: String?
    public var secondaryId: String?

    public init(_id: String?, name: String?, secondaryId: String?) {
        self._id = _id
        self.name = name
        self.secondaryId = secondaryId
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case secondaryId
    }


}




public class WfmIntradayDataUpdateTopicIntradayForecastData: Codable {







    public var offered: Double?
    public var averageTalkTimeSeconds: Double?
    public var averageAfterCallWorkSeconds: Double?

    public init(offered: Double?, averageTalkTimeSeconds: Double?, averageAfterCallWorkSeconds: Double?) {
        self.offered = offered
        self.averageTalkTimeSeconds = averageTalkTimeSeconds
        self.averageAfterCallWorkSeconds = averageAfterCallWorkSeconds
    }


}




public class WfmIntradayDataUpdateTopicIntradayScheduleData: Codable {





    public var onQueueTimeSeconds: Int?
    public var scheduledTimeSeconds: Int?

    public init(onQueueTimeSeconds: Int?, scheduledTimeSeconds: Int?) {
        self.onQueueTimeSeconds = onQueueTimeSeconds
        self.scheduledTimeSeconds = scheduledTimeSeconds
    }


}




public class WfmTimeOffBalanceJobTopicTimeOffBalanceJobNotification: Codable {





    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case error = "Error"
    }



    public var _id: String?
    public var entities: [WfmTimeOffBalanceJobTopicTimeOffBalance]?
    public var status: Status?
    public var error: WfmTimeOffBalanceJobTopicErrorBody?

    public init(_id: String?, entities: [WfmTimeOffBalanceJobTopicTimeOffBalance]?, status: Status?, error: WfmTimeOffBalanceJobTopicErrorBody?) {
        self._id = _id
        self.entities = entities
        self.status = status
        self.error = error
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case entities
        case status
        case error
    }


}




public class WfmTimeOffRequestUpdateTopicTimeOffRequestUpdate: Codable {













    public enum Status: String, Codable { 
        case pending = "PENDING"
        case approved = "APPROVED"
        case denied = "DENIED"
        case canceled = "CANCELED"
    }

    public enum Substatus: String, Codable { 
        case advanceTimeElapsed = "AdvanceTimeElapsed"
        case autoApproved = "AutoApproved"
        case insufficientBalance = "InsufficientBalance"
        case invalidDailyDuration = "InvalidDailyDuration"
        case outsideShift = "OutsideShift"
        case removedFromWaitlist = "RemovedFromWaitlist"
        case waitlisted = "Waitlisted"
    }





















    public var _id: String?
    public var user: WfmTimeOffRequestUpdateTopicUserReference?
    public var isFullDayRequest: Bool?
    public var markedAsRead: Bool?
    public var activityCodeId: String?
    public var paid: Bool?
    public var status: Status?
    public var substatus: Substatus?
    public var partialDayStartDateTimes: [String]?
    public var fullDayManagementUnitDates: [String]?
    public var dailyDurationMinutes: Int?
    public var notes: String?
    public var reviewedDate: String?
    public var reviewedBy: String?
    public var submittedDate: String?
    public var submittedBy: String?
    public var modifiedDate: String?
    public var modifiedBy: String?

    public init(_id: String?, user: WfmTimeOffRequestUpdateTopicUserReference?, isFullDayRequest: Bool?, markedAsRead: Bool?, activityCodeId: String?, paid: Bool?, status: Status?, substatus: Substatus?, partialDayStartDateTimes: [String]?, fullDayManagementUnitDates: [String]?, dailyDurationMinutes: Int?, notes: String?, reviewedDate: String?, reviewedBy: String?, submittedDate: String?, submittedBy: String?, modifiedDate: String?, modifiedBy: String?) {
        self._id = _id
        self.user = user
        self.isFullDayRequest = isFullDayRequest
        self.markedAsRead = markedAsRead
        self.activityCodeId = activityCodeId
        self.paid = paid
        self.status = status
        self.substatus = substatus
        self.partialDayStartDateTimes = partialDayStartDateTimes
        self.fullDayManagementUnitDates = fullDayManagementUnitDates
        self.dailyDurationMinutes = dailyDurationMinutes
        self.notes = notes
        self.reviewedDate = reviewedDate
        self.reviewedBy = reviewedBy
        self.submittedDate = submittedDate
        self.submittedBy = submittedBy
        self.modifiedDate = modifiedDate
        self.modifiedBy = modifiedBy
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case user
        case isFullDayRequest
        case markedAsRead
        case activityCodeId
        case paid
        case status
        case substatus
        case partialDayStartDateTimes
        case fullDayManagementUnitDates
        case dailyDurationMinutes
        case notes
        case reviewedDate
        case reviewedBy
        case submittedDate
        case submittedBy
        case modifiedDate
        case modifiedBy
    }


}




public class WfmUserEntityListing: Codable {



    public var entities: [User]?

    public init(entities: [User]?) {
        self.entities = entities
    }


}




public class WfmUserNotificationTopicShiftTradeNotification: Codable {







    public enum NewState: String, Codable { 
        case unmatched = "Unmatched"
        case matched = "Matched"
        case approved = "Approved"
        case denied = "Denied"
        case expired = "Expired"
        case canceled = "Canceled"
    }









    public var weekDate: String?
    public var tradeId: String?
    public var oneSided: Bool?
    public var newState: NewState?
    public var initiatingUser: WfmUserNotificationTopicUserReference?
    public var initiatingShiftDate: Date?
    public var receivingUser: WfmUserNotificationTopicUserReference?
    public var receivingShiftDate: Date?

    public init(weekDate: String?, tradeId: String?, oneSided: Bool?, newState: NewState?, initiatingUser: WfmUserNotificationTopicUserReference?, initiatingShiftDate: Date?, receivingUser: WfmUserNotificationTopicUserReference?, receivingShiftDate: Date?) {
        self.weekDate = weekDate
        self.tradeId = tradeId
        self.oneSided = oneSided
        self.newState = newState
        self.initiatingUser = initiatingUser
        self.initiatingShiftDate = initiatingShiftDate
        self.receivingUser = receivingUser
        self.receivingShiftDate = receivingShiftDate
    }


}




public class WfmUserNotificationTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmUserScheduleAdherenceUpdatedMuTopicQueueReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmUserScheduleAdherenceUpdatedMuTopicSecondaryPresenceReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmUserScheduleAdherenceUpdatedTeamTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmUserScheduleAdherenceUpdatedTopicRealTimeAdherenceExplanation: Codable {







    public enum Status: String, Codable { 
        case pending = "Pending"
        case approved = "Approved"
        case denied = "Denied"
    }

    public var _id: String?
    public var startDate: Date?
    public var lengthMinutes: Int?
    public var status: Status?

    public init(_id: String?, startDate: Date?, lengthMinutes: Int?, status: Status?) {
        self._id = _id
        self.startDate = startDate
        self.lengthMinutes = lengthMinutes
        self.status = status
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case startDate
        case lengthMinutes
        case status
    }


}




public class WhatsAppIntegrationUpdateRequest: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** WhatsApp Integration name */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    /** Defines the message settings to be applied for this integration */
    public var messagingSetting: MessagingSettingRequestReference?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingRequestReference?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case selfUri
    }


}




public class WorkPlanConfigurationViolationMessage: Codable {

    public enum ModelType: String, Codable { 
        case activitiesOverlap = "ActivitiesOverlap"
        case activityEndGreaterThanShiftStop = "ActivityEndGreaterThanShiftStop"
        case activityPaidTimeGreaterThanShiftPaidTime = "ActivityPaidTimeGreaterThanShiftPaidTime"
        case activityStartBeforeShiftStart = "ActivityStartBeforeShiftStart"
        case activityStartGreaterThanEqualToShiftStop = "ActivityStartGreaterThanEqualToShiftStop"
        case activityStartIncrementMinutesNotDivisibleByScheduleIntervalMinutes = "ActivityStartIncrementMinutesNotDivisibleByScheduleIntervalMinutes"
        case dailyExactPaidMinutes = "DailyExactPaidMinutes"
        case dailyMaxTotalLessThanWeeklyMin = "DailyMaxTotalLessThanWeeklyMin"
        case dailyMaxTotalLessThanWeeklyMinWithOptional = "DailyMaxTotalLessThanWeeklyMinWithOptional"
        case dailyMaxTotalLessThanWeeklyMinWithoutOptional = "DailyMaxTotalLessThanWeeklyMinWithoutOptional"
        case dailyMinTotalGreaterThanWeeklyMax = "DailyMinTotalGreaterThanWeeklyMax"
        case dailyMinTotalGreaterThanWeeklyMaxWithOptional = "DailyMinTotalGreaterThanWeeklyMaxWithOptional"
        case dailyMinTotalGreaterThanWeeklyMaxWithoutOptional = "DailyMinTotalGreaterThanWeeklyMaxWithoutOptional"
        case dailyRequiredDaysGreaterThanWeeklyMaxDays = "DailyRequiredDaysGreaterThanWeeklyMaxDays"
        case dailyShiftHasNoDaysSelected = "DailyShiftHasNoDaysSelected"
        case dailyShiftMaxPossibilitiesViolated = "DailyShiftMaxPossibilitiesViolated"
        case earliestShiftStopIsTooLate = "EarliestShiftStopIsTooLate"
        case exactPaidTimeNotDivisibleByGranularity = "ExactPaidTimeNotDivisibleByGranularity"
        case maxConsecutiveWorkingDaysNoMoreThanDoubleMaxWorkingDaysPerWeek = "MaxConsecutiveWorkingDaysNoMoreThanDoubleMaxWorkingDaysPerWeek"
        case maxDaysOffPerPlanningPeriodNotCorrect = "MaxDaysOffPerPlanningPeriodNotCorrect"
        case maxPaidTimeIsMoreThanShiftLength = "MaxPaidTimeIsMoreThanShiftLength"
        case maxPaidTimeNotDivisibleByGranularity = "MaxPaidTimeNotDivisibleByGranularity"
        case maxPaidTimePerPlanningPeriod = "MaxPaidTimePerPlanningPeriod"
        case maxShifts = "MaxShifts"
        case minPaidTimeNotDivisibleByGranularity = "MinPaidTimeNotDivisibleByGranularity"
        case minPaidTimePerPlanningPeriod = "MinPaidTimePerPlanningPeriod"
        case noShifts = "NoShifts"
        case paidTimeGreaterThanMaxWorkTime = "PaidTimeGreaterThanMaxWorkTime"
        case paidTimeLessThanMinWorkTime = "PaidTimeLessThanMinWorkTime"
        case paidTimeNotMetByShiftStartStop = "PaidTimeNotMetByShiftStartStop"
        case shiftDaysSelectMoreThanMinWorkingDays = "ShiftDaysSelectMoreThanMinWorkingDays"
        case shiftStopEarlierThanStart = "ShiftStopEarlierThanStart"
        case shiftVarianceCannotBeMet = "ShiftVarianceCannotBeMet"
        case weeklyExactPaidMinutes = "WeeklyExactPaidMinutes"
    }



    public enum Severity: String, Codable { 
        case information = "Information"
        case warning = "Warning"
        case error = "Error"
    }

    /** Type of configuration violation message for this work plan */
    public var type: ModelType?
    /** Arguments of the message that provide information about the misconfigured value or the threshold that is exceeded by the misconfigured value */
    public var arguments: [WorkPlanValidationMessageArgument]?
    /** Severity of the message. A message with Error severity indicates the scheduler won't be able to produce schedules and thus the work plan is invalid. */
    public var severity: Severity?

    public init(type: ModelType?, arguments: [WorkPlanValidationMessageArgument]?, severity: Severity?) {
        self.type = type
        self.arguments = arguments
        self.severity = severity
    }


}




public class WorkPlanPatternResponse: Codable {



    /** List of work plans in order of rotation on a weekly basis */
    public var workPlans: [WorkPlanReference]?

    public init(workPlans: [WorkPlanReference]?) {
        self.workPlans = workPlans
    }


}




public class WorkPlanReference: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The management unit to which this work plan belongs.  Nullable in some routes */
    public var managementUnit: ManagementUnitReference?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, managementUnit: ManagementUnitReference?, selfUri: String?) {
        self._id = _id
        self.managementUnit = managementUnit
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case managementUnit
        case selfUri
    }


}




public class WorkdayValuesTrend: Codable {



















    /** The start workday for the query range for the metric value trend. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStartWorkday: Date?
    /** The end workday for the query range for the metric value trend. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEndWorkday: Date?
    /** The reference workday used to determine the metric definition. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateReferenceWorkday: Date?
    /** The targeted division for the query */
    public var division: Division?
    /** The targeted user for the query */
    public var user: UserReference?
    /** The time zone used for aggregating metric values */
    public var timezone: String?
    /** The metric value trends */
    public var results: [WorkdayValuesMetricItem]?
    /** The targeted performance profile for the average points */
    public var performanceProfile: AddressableEntityRef?
    /** The targeted metric for the average points */
    public var metric: AddressableEntityRef?

    public init(dateStartWorkday: Date?, dateEndWorkday: Date?, dateReferenceWorkday: Date?, division: Division?, user: UserReference?, timezone: String?, results: [WorkdayValuesMetricItem]?, performanceProfile: AddressableEntityRef?, metric: AddressableEntityRef?) {
        self.dateStartWorkday = dateStartWorkday
        self.dateEndWorkday = dateEndWorkday
        self.dateReferenceWorkday = dateReferenceWorkday
        self.division = division
        self.user = user
        self.timezone = timezone
        self.results = results
        self.performanceProfile = performanceProfile
        self.metric = metric
    }


}




public class WorkitemsQueueEventsNotificationWrapup: Codable {





    public enum Op: String, Codable { 
        case unknown = "Unknown"
        case add = "Add"
        case remove = "Remove"
    }

    public enum Action: String, Codable { 
        case unknown = "Unknown"
        case add = "Add"
        case remove = "Remove"
    }

    public var code: String?
    public var userId: String?
    public var op: Op?
    public var action: Action?

    public init(code: String?, userId: String?, op: Op?, action: Action?) {
        self.code = code
        self.userId = userId
        self.op = op
        self.action = action
    }


}




public class WorkspaceEntityListing: Codable {





















    public var entities: [Workspace]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Workspace]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class WorkspaceMemberEntityListing: Codable {





















    public var entities: [WorkspaceMember]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [WorkspaceMember]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class WrapupCodeEntityListing: Codable {





















    public var entities: [WrapupCode]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [WrapupCode]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class WritableDialerContact: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The identifier of the contact list containing this contact. */
    public var contactListId: String?
    /** An ordered map of the contact's columns and corresponding values. */
    public var data: [String:String]?
    /** A map of SMS records for the contact phone columns. */
    public var latestSmsEvaluations: [String:MessageEvaluation]?
    /** A map of email records for the contact email columns. */
    public var latestEmailEvaluations: [String:MessageEvaluation]?
    /** Indicates whether or not the contact can be called. */
    public var callable: Bool?
    /** A map of phone number columns to PhoneNumberStatuses, which indicate if the phone number is callable or not. */
    public var phoneNumberStatus: [String:PhoneNumberStatus]?
    /** A map of media types (Voice, SMS and Email) to ContactableStatus, which indicates if the contact can be contacted using the specified media type. */
    public var contactableStatus: [String:ContactableStatus]?
    /** Timestamp for when the contact was added. Contacts added prior to 2023 September 1 may be missing this value. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?

    public init(_id: String?, contactListId: String?, data: [String:String]?, latestSmsEvaluations: [String:MessageEvaluation]?, latestEmailEvaluations: [String:MessageEvaluation]?, callable: Bool?, phoneNumberStatus: [String:PhoneNumberStatus]?, contactableStatus: [String:ContactableStatus]?, dateCreated: Date?) {
        self._id = _id
        self.contactListId = contactListId
        self.data = data
        self.latestSmsEvaluations = latestSmsEvaluations
        self.latestEmailEvaluations = latestEmailEvaluations
        self.callable = callable
        self.phoneNumberStatus = phoneNumberStatus
        self.contactableStatus = contactableStatus
        self.dateCreated = dateCreated
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case contactListId
        case data
        case latestSmsEvaluations
        case latestEmailEvaluations
        case callable
        case phoneNumberStatus
        case contactableStatus
        case dateCreated
    }


}

