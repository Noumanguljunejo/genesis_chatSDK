//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation



public class ADFS: Codable {























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var disabled: Bool?
    public var issuerURI: String?
    public var ssoTargetURI: String?
    public var sloURI: String?
    public var sloBinding: String?
    public var relyingPartyIdentifier: String?
    public var certificate: String?
    public var certificates: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, disabled: Bool?, issuerURI: String?, ssoTargetURI: String?, sloURI: String?, sloBinding: String?, relyingPartyIdentifier: String?, certificate: String?, certificates: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.disabled = disabled
        self.issuerURI = issuerURI
        self.ssoTargetURI = ssoTargetURI
        self.sloURI = sloURI
        self.sloBinding = sloBinding
        self.relyingPartyIdentifier = relyingPartyIdentifier
        self.certificate = certificate
        self.certificates = certificates
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case disabled
        case issuerURI
        case ssoTargetURI
        case sloURI
        case sloBinding
        case relyingPartyIdentifier
        case certificate
        case certificates
        case selfUri
    }


}



/** Metadata for a CX infrastructure as code accelerator */

public class AcceleratorMetadata: Codable {







    public enum Origin: String, Codable { 
        case community = "Community"
        case partner = "Partner"
        case genesys = "Genesys"
    }

    public enum ModelType: String, Codable { 
        case module = "Module"
        case accelerator = "Accelerator"
        case blueprint = "Blueprint"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** name of this accelerator */
    public var name: String?
    /** a description of the general purpose of this accelerator */
    public var _description: String?
    /** where the accelerator originated */
    public var origin: Origin?
    /** type of the artifact */
    public var type: ModelType?
    /** architectural classification into which the accelerator belongs */
    public var classification: String?
    /** tags */
    public var tags: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, origin: Origin?, type: ModelType?, classification: String?, tags: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.origin = origin
        self.type = type
        self.classification = classification
        self.tags = tags
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case origin
        case type
        case classification
        case tags
        case selfUri
    }


}




public class Action: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The ID of the integration for which this action is associated */
    public var integrationId: String?
    /** Category of Action */
    public var category: String?
    /** Action contract */
    public var contract: ActionContract?
    /** Version of this action */
    public var version: Int?
    /** Indication of whether or not the action is designed to accept sensitive data */
    public var secure: Bool?
    /** Configuration to support request and response processing */
    public var config: ActionConfig?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, integrationId: String?, category: String?, contract: ActionContract?, version: Int?, secure: Bool?, config: ActionConfig?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.integrationId = integrationId
        self.category = category
        self.contract = contract
        self.version = version
        self.secure = secure
        self.config = config
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case integrationId
        case category
        case contract
        case version
        case secure
        case config
        case selfUri
    }


}




public class ActionAggregateQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case actioncategory = "actionCategory"
        case actionid = "actionId"
        case actionname = "actionName"
        case correlationid = "correlationId"
        case errortype = "errorType"
        case integrationid = "integrationId"
        case integrationname = "integrationName"
        case responsestatus = "responseStatus"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension predicates */
    public var value: String?
    /** Right hand side for dimension predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case _operator = "operator"
        case value
        case range
    }


}



/** This resource contains all of the schemas needed to define the inputs and outputs, of a single Action. */

public class ActionContract: Codable {





    /** The output to expect when executing this action. */
    public var output: ActionOutput?
    /** The input required when executing this action. */
    public var input: ActionInput?

    public init(output: ActionOutput?, input: ActionInput?) {
        self.output = output
        self.input = input
    }


}




public class ActionMapActionTemplate: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class ActionMapEstimateOutcomeCriteria: Codable {











    /** ID of outcome. */
    public var outcomeId: String?
    /** Probability value for the selected outcome at or above which the action map will trigger. */
    public var maxProbability: Float?
    /** Additional probability condition, where if set, the action map will trigger if the current outcome probability is lower or equal to the value. */
    public var probability: Float?
    /** Represents the quantity of sessions that have a maximum probability less than the predicted probability. */
    public var quantile: Float?
    /** Represents the quantity of sessions that have a maximum probability less than the predicted session max probability. */
    public var maxQuantile: Float?

    public init(outcomeId: String?, maxProbability: Float?, probability: Float?, quantile: Float?, maxQuantile: Float?) {
        self.outcomeId = outcomeId
        self.maxProbability = maxProbability
        self.probability = probability
        self.quantile = quantile
        self.maxQuantile = maxQuantile
    }


}




public class ActionTarget: Codable {







    public enum SupportedMediaTypes: String, Codable { 
        case callback = "callback"
        case call = "call"
        case email = "email"
        case generic = "generic"
        case messaging = "messaging"
        case social = "social"
        case webchat = "webchat"
    }

    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Additional user data associated with the target in key/value format. */
    public var userData: [KeyValue]?
    /** Supported media types of the target. */
    public var supportedMediaTypes: [SupportedMediaTypes]?
    /** Indicates the state of the target. */
    public var state: State?
    /** Description of the target. */
    public var _description: String?
    /** Service Level of the action target. Chat offers for the target will be throttled with the aim of achieving this service level. */
    public var serviceLevel: ServiceLevel?
    /** Indicates the non-default short abandon threshold */
    public var shortAbandonThreshold: Int?
    /** The URI for this object */
    public var selfUri: String?
    /** The date the target was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    /** The date the target was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?

    public init(_id: String?, name: String?, userData: [KeyValue]?, supportedMediaTypes: [SupportedMediaTypes]?, state: State?, _description: String?, serviceLevel: ServiceLevel?, shortAbandonThreshold: Int?, selfUri: String?, createdDate: Date?, modifiedDate: Date?) {
        self._id = _id
        self.name = name
        self.userData = userData
        self.supportedMediaTypes = supportedMediaTypes
        self.state = state
        self._description = _description
        self.serviceLevel = serviceLevel
        self.shortAbandonThreshold = shortAbandonThreshold
        self.selfUri = selfUri
        self.createdDate = createdDate
        self.modifiedDate = modifiedDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case userData
        case supportedMediaTypes
        case state
        case _description = "description"
        case serviceLevel
        case shortAbandonThreshold
        case selfUri
        case createdDate
        case modifiedDate
    }


}




public class ActionTargetListing: Codable {





















    public var entities: [ActionTarget]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ActionTarget]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class Actions: Codable {



    public var skillsToRemove: [SkillsToRemove]?

    public init(skillsToRemove: [SkillsToRemove]?) {
        self.skillsToRemove = skillsToRemove
    }


}




public class AddShiftTradeRequest: Codable {











    /** The ID of the schedule to which the initiating and receiving shifts belong */
    public var scheduleId: String?
    /** The ID of the shift that the initiating user wants to give up */
    public var initiatingShiftId: String?
    /** The ID of the user to whom to send the request (for use in direct trade requests) */
    public var receivingUserId: String?
    /** When this shift trade request should expire. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var expiration: Date?
    public var acceptableIntervals: [String]?

    public init(scheduleId: String?, initiatingShiftId: String?, receivingUserId: String?, expiration: Date?, acceptableIntervals: [String]?) {
        self.scheduleId = scheduleId
        self.initiatingShiftId = initiatingShiftId
        self.receivingUserId = receivingUserId
        self.expiration = expiration
        self.acceptableIntervals = acceptableIntervals
    }


}




public class AdditionalLanguagesSynonyms: Codable {



    /** Synonyms for additional language */
    public var synonyms: [String]?

    public init(synonyms: [String]?) {
        self.synonyms = synonyms
    }


}




public class AdditionalMessage: Codable {









    /** The body of the text message.  Maximum character counts are: SMS - 765 characters, other channels - 2000 characters. */
    public var textBody: String?
    /** The media ids associated with the text message. See https://developer.genesys.cloud/api/rest/v2/conversations/messaging-media-upload for example usage. */
    public var mediaIds: [String]?
    /** The sticker ids associated with the text message. */
    public var stickerIds: [String]?
    /** The messaging template use to send a predefined canned response with the message */
    public var messagingTemplate: MessagingTemplateRequest?

    public init(textBody: String?, mediaIds: [String]?, stickerIds: [String]?, messagingTemplate: MessagingTemplateRequest?) {
        self.textBody = textBody
        self.mediaIds = mediaIds
        self.stickerIds = stickerIds
        self.messagingTemplate = messagingTemplate
    }


}




public class AddressableEntity: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class AddressableEntityRef: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class AdherenceExplanationListingAgentQueryResponse: Codable {



    public var entities: [AdherenceExplanationResponse]?

    public init(entities: [AdherenceExplanationResponse]?) {
        self.entities = entities
    }


}




public class AdhocRecordingTopicLockData: Codable {







    public var lockedBy: AdhocRecordingTopicUserData?
    public var dateCreated: Date?
    public var dateExpires: Date?

    public init(lockedBy: AdhocRecordingTopicUserData?, dateCreated: Date?, dateExpires: Date?) {
        self.lockedBy = lockedBy
        self.dateCreated = dateCreated
        self.dateExpires = dateExpires
    }


}




public class AdhocRecordingTopicWorkspaceData: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class AgentActivityChangedTopicRoutingStatus: Codable {

    public enum Status: String, Codable { 
        case offQueue = "OFF_QUEUE"
        case idle = "IDLE"
        case interacting = "INTERACTING"
        case notResponding = "NOT_RESPONDING"
        case communicating = "COMMUNICATING"
    }



    /** Indicates the Routing State of the agent. */
    public var status: Status?
    /** The timestamp when the agent went into this state. */
    public var startTime: Date?

    public init(status: Status?, startTime: Date?) {
        self.status = status
        self.startTime = startTime
    }


}




public class AgentIntegrationsRequest: Codable {





    /** The ID of the integration selected for the agent. If not set, no integration will be used for the agent */
    public var selectedIntegrationId: String?
    /** The list of integrations associated with the agent */
    public var associatedIntegrations: [AgentIntegrationAssociationRequest]?

    public init(selectedIntegrationId: String?, associatedIntegrations: [AgentIntegrationAssociationRequest]?) {
        self.selectedIntegrationId = selectedIntegrationId
        self.associatedIntegrations = associatedIntegrations
    }


}




public class AgentMaxUtilizationResponse: Codable {



    public enum Level: String, Codable { 
        case agent = "Agent"
        case organization = "Organization"
    }

    /** Map of media type to utilization settings. */
    public var utilization: [String:MediaUtilization]?
    public var level: Level?

    public init(utilization: [String:MediaUtilization]?, level: Level?) {
        self.utilization = utilization
        self.level = level
    }


}




public class AgentQueryAdherenceExplanationsResponse: Codable {







    /** The asynchronous job handling the query */
    public var job: AdherenceExplanationJobReference?
    /** The result of the query. May come via notification */
    public var result: AdherenceExplanationListingAgentQueryResponse?
    /** The URL from which to download the result. May come via notification */
    public var downloadUrl: String?

    public init(job: AdherenceExplanationJobReference?, result: AdherenceExplanationListingAgentQueryResponse?, downloadUrl: String?) {
        self.job = job
        self.result = result
        self.downloadUrl = downloadUrl
    }


}




public class AgentQueueTimeRequest: Codable {







    /** ID of the agent */
    public var agentId: String?
    /** List of offsets in minutes from calculationStartDate */
    public var startOffsetMinutes: [Int]?
    /** List of on queue time lengths in minutes per interval of elements in startOffsetMinutes */
    public var onQueueLengthMinutesPerInterval: [Int]?

    public init(agentId: String?, startOffsetMinutes: [Int]?, onQueueLengthMinutesPerInterval: [Int]?) {
        self.agentId = agentId
        self.startOffsetMinutes = startOffsetMinutes
        self.onQueueLengthMinutesPerInterval = onQueueLengthMinutesPerInterval
    }


}




public class AgentlessEmailSendRequestDto: Codable {

    public enum SenderType: String, Codable { 
        case outbound = "Outbound"
        case inbound = "Inbound"
        case integration = "Integration"
    }















    /** The direction of the message. */
    public var senderType: SenderType?
    /** The identifier of the conversation. This must be an email interaction. */
    public var conversationId: String?
    /** The sender of the message. */
    public var fromAddress: EmailAddress?
    /** The recipient of the message. We currently support one recipient only. */
    public var toAddresses: [EmailAddress]?
    /** The address to use for reply. */
    public var replyToAddress: EmailAddress?
    /** The subject of the message. */
    public var subject: String?
    /** The Content of the message, in plain text. */
    public var textBody: String?
    /** The Content of the message, in HTML. Links, images and styles are allowed */
    public var htmlBody: String?

    public init(senderType: SenderType?, conversationId: String?, fromAddress: EmailAddress?, toAddresses: [EmailAddress]?, replyToAddress: EmailAddress?, subject: String?, textBody: String?, htmlBody: String?) {
        self.senderType = senderType
        self.conversationId = conversationId
        self.fromAddress = fromAddress
        self.toAddresses = toAddresses
        self.replyToAddress = replyToAddress
        self.subject = subject
        self.textBody = textBody
        self.htmlBody = htmlBody
    }


}




public class AgentsIntegrationsListing: Codable {



    public var entities: [AgentIntegrationsResponse]?

    public init(entities: [AgentIntegrationsResponse]?) {
        self.entities = entities
    }


}




public class AggregationRange: Codable {





    /** Greater than or equal to */
    public var gte: Double?
    /** Less than */
    public var lt: Double?

    public init(gte: Double?, lt: Double?) {
        self.gte = gte
        self.lt = lt
    }


}




public class AlertRuleProperties: Codable {





    public enum ModelType: String, Codable { 
        case conversationMetrics = "ConversationMetrics"
        case userPresence = "UserPresence"
        case workforceManagement = "WorkforceManagement"
        case unknown = "Unknown"
    }

    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the object. */
    public var name: String?
    /** The type of rule being alerted. */
    public var type: ModelType?

    public init(_id: String?, name: String?, type: ModelType?) {
        self._id = _id
        self.name = name
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case type
    }


}




public class AlertSummaryEntity: Codable {

    public enum EntityType: String, Codable { 
        case user = "User"
        case group = "Group"
        case queue = "Queue"
        case team = "Team"
        case teamMembers = "TeamMembers"
    }











    /** Specifies the type of entity being evaluated */
    public var entityType: EntityType?
    /** User id of the entity being monitored */
    public var user: AddressableEntityRef?
    /** Group id of the entity being monitored */
    public var group: AddressableEntityRef?
    /** Queue id of the entity being monitored */
    public var queue: AddressableEntityRef?
    /** Team id of the entity being monitored */
    public var team: AddressableEntityRef?
    /** Flag that indicated if the entity is current causing the alert to be triggered */
    public var alerting: Bool?

    public init(entityType: EntityType?, user: AddressableEntityRef?, group: AddressableEntityRef?, queue: AddressableEntityRef?, team: AddressableEntityRef?, alerting: Bool?) {
        self.entityType = entityType
        self.user = user
        self.group = group
        self.queue = queue
        self.team = team
        self.alerting = alerting
    }


}




public class AmazonLexRequest: Codable {





    /** AttributeName/AttributeValue pairs of User Defined Request Attributes to be sent to the amazon bot See - https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-request-attribs */
    public var requestAttributes: [String:String]?
    /** AttributeName/AttributeValue pairs of Session Attributes to be sent to the amazon bot. See - https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-session-attribs */
    public var sessionAttributes: [String:String]?

    public init(requestAttributes: [String:String]?, sessionAttributes: [String:String]?) {
        self.requestAttributes = requestAttributes
        self.sessionAttributes = sessionAttributes
    }


}




public class AnalyticsAgentGroup: Codable {



    public enum AgentGroupType: String, Codable { 
        case group = "Group"
        case skillGroup = "SkillGroup"
        case team = "Team"
    }

    /** Conditional group routing agent group identifier */
    public var agentGroupId: String?
    /** Conditional group routing agent group type */
    public var agentGroupType: AgentGroupType?

    public init(agentGroupId: String?, agentGroupType: AgentGroupType?) {
        self.agentGroupId = agentGroupId
        self.agentGroupType = agentGroupType
    }


}




public class AnalyticsConversation: Codable {







    public enum ConversationInitiator: String, Codable { 
        case acd = "acd"
        case agent = "agent"
        case api = "api"
        case botflow = "botflow"
        case campaign = "campaign"
        case customer = "customer"
        case dialer = "dialer"
        case external = "external"
        case fax = "fax"
        case group = "group"
        case inbound = "inbound"
        case ivr = "ivr"
        case manual = "manual"
        case outbound = "outbound"
        case station = "station"
        case user = "user"
        case voicemail = "voicemail"
        case workflow = "workflow"
    }















    public enum OriginatingDirection: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }











    /** The start time of a conference call. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var conferenceStart: Date?
    /** The end time of a conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var conversationEnd: Date?
    /** Unique identifier for the conversation */
    public var conversationId: String?
    /** Indicates the participant purpose of the participant initiating a message conversation */
    public var conversationInitiator: ConversationInitiator?
    /** The start time of a conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var conversationStart: Date?
    /** Indicates a messaging conversation in which the customer participated by sending at least one message */
    public var customerParticipation: Bool?
    /** Identifier(s) of division(s) associated with a conversation */
    public var divisionIds: [String]?
    /** External tag for the conversation */
    public var externalTag: String?
    /** The unique identifier(s) of the knowledge base(s) used */
    public var knowledgeBaseIds: [String]?
    /** The lowest estimated average MOS among all the audio streams belonging to this conversation */
    public var mediaStatsMinConversationMos: Double?
    /** The lowest R-factor value among all of the audio streams belonging to this conversation */
    public var mediaStatsMinConversationRFactor: Double?
    /** The original direction of the conversation */
    public var originatingDirection: OriginatingDirection?
    /** Indicates whether all flow sessions were self serviced */
    public var selfServed: Bool?
    /** Evaluations associated with this conversation */
    public var evaluations: [AnalyticsEvaluation]?
    /** Surveys associated with this conversation */
    public var surveys: [AnalyticsSurvey]?
    /** Resolutions associated with this conversation */
    public var resolutions: [AnalyticsResolution]?
    /** Participants in the conversation */
    public var participants: [AnalyticsParticipant]?

    public init(conferenceStart: Date?, conversationEnd: Date?, conversationId: String?, conversationInitiator: ConversationInitiator?, conversationStart: Date?, customerParticipation: Bool?, divisionIds: [String]?, externalTag: String?, knowledgeBaseIds: [String]?, mediaStatsMinConversationMos: Double?, mediaStatsMinConversationRFactor: Double?, originatingDirection: OriginatingDirection?, selfServed: Bool?, evaluations: [AnalyticsEvaluation]?, surveys: [AnalyticsSurvey]?, resolutions: [AnalyticsResolution]?, participants: [AnalyticsParticipant]?) {
        self.conferenceStart = conferenceStart
        self.conversationEnd = conversationEnd
        self.conversationId = conversationId
        self.conversationInitiator = conversationInitiator
        self.conversationStart = conversationStart
        self.customerParticipation = customerParticipation
        self.divisionIds = divisionIds
        self.externalTag = externalTag
        self.knowledgeBaseIds = knowledgeBaseIds
        self.mediaStatsMinConversationMos = mediaStatsMinConversationMos
        self.mediaStatsMinConversationRFactor = mediaStatsMinConversationRFactor
        self.originatingDirection = originatingDirection
        self.selfServed = selfServed
        self.evaluations = evaluations
        self.surveys = surveys
        self.resolutions = resolutions
        self.participants = participants
    }


}




public class AnalyticsFlowOutcome: Codable {











    /** Combination of unique flow outcome identifier and its value separated by colon */
    public var flowOutcome: String?
    /** The outcome ending timestamp in ISO 8601 format. This may be null if the outcome did not succeed. */
    public var flowOutcomeEndTimestamp: Date?
    /** Unique identifier of a flow outcome */
    public var flowOutcomeId: String?
    /** The outcome starting timestamp in ISO 8601 format */
    public var flowOutcomeStartTimestamp: Date?
    /** Flow outcome value, e.g. SUCCESS */
    public var flowOutcomeValue: String?

    public init(flowOutcome: String?, flowOutcomeEndTimestamp: Date?, flowOutcomeId: String?, flowOutcomeStartTimestamp: Date?, flowOutcomeValue: String?) {
        self.flowOutcome = flowOutcome
        self.flowOutcomeEndTimestamp = flowOutcomeEndTimestamp
        self.flowOutcomeId = flowOutcomeId
        self.flowOutcomeStartTimestamp = flowOutcomeStartTimestamp
        self.flowOutcomeValue = flowOutcomeValue
    }


}




public class AnalyticsMediaEndpointStat: Codable {























    /** The MIME type(s) of the audio encodings used by the audio streams belonging to this endpoint */
    public var codecs: [String]?
    /** The total number of packets received too late or too early, jitter queue overrun or underrun, for all audio streams belonging to this endpoint */
    public var discardedPackets: Int64?
    /** The total number of packets received with the same sequence number as another one recently received (window of 64 packets), for all audio streams belonging to this endpoint */
    public var duplicatePackets: Int64?
    /** Specifies when an event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventTime: Date?
    /** The total number of malformed or not RTP packets, unknown payload type, or discarded probation packets for all audio streams belonging to this endpoint */
    public var invalidPackets: Int64?
    /** The maximum latency experienced by any audio stream belonging to this endpoint, in milliseconds */
    public var maxLatencyMs: Int64?
    /** The lowest estimated average MOS among all the audio streams belonging to this endpoint */
    public var minMos: Double?
    /** The lowest R-factor value among all of the audio streams belonging to this endpoint */
    public var minRFactor: Double?
    /** The total number of packets for which there was no room in the jitter queue when it was received, for all audio streams belonging to this endpoint (also counted in discarded) */
    public var overrunPackets: Int64?
    /** The total number of packets received for all audio streams belonging to this endpoint (includes invalid, duplicate, and discarded packets) */
    public var receivedPackets: Int64?
    /** The total number of packets received after their timestamp/seqnum has been played out, for all audio streams belonging to this endpoint (also counted in discarded) */
    public var underrunPackets: Int64?

    public init(codecs: [String]?, discardedPackets: Int64?, duplicatePackets: Int64?, eventTime: Date?, invalidPackets: Int64?, maxLatencyMs: Int64?, minMos: Double?, minRFactor: Double?, overrunPackets: Int64?, receivedPackets: Int64?, underrunPackets: Int64?) {
        self.codecs = codecs
        self.discardedPackets = discardedPackets
        self.duplicatePackets = duplicatePackets
        self.eventTime = eventTime
        self.invalidPackets = invalidPackets
        self.maxLatencyMs = maxLatencyMs
        self.minMos = minMos
        self.minRFactor = minRFactor
        self.overrunPackets = overrunPackets
        self.receivedPackets = receivedPackets
        self.underrunPackets = underrunPackets
    }


}




public class AnalyticsParticipantWithoutAttributes: Codable {





    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }





    public enum Purpose: String, Codable { 
        case acd = "acd"
        case agent = "agent"
        case api = "api"
        case botflow = "botflow"
        case campaign = "campaign"
        case customer = "customer"
        case dialer = "dialer"
        case external = "external"
        case fax = "fax"
        case group = "group"
        case inbound = "inbound"
        case ivr = "ivr"
        case manual = "manual"
        case outbound = "outbound"
        case station = "station"
        case user = "user"
        case voicemail = "voicemail"
        case workflow = "workflow"
    }







    /** External contact identifier */
    public var externalContactId: String?
    /** External organization identifier */
    public var externalOrganizationId: String?
    /** Reason for which participant flagged conversation */
    public var flaggedReason: FlaggedReason?
    /** Unique identifier for the participant */
    public var participantId: String?
    /** A human readable name identifying the participant */
    public var participantName: String?
    /** The participant's purpose */
    public var purpose: Purpose?
    /** The team ID the user is a member of */
    public var teamId: String?
    /** Unique identifier for the user */
    public var userId: String?
    /** List of sessions associated to this participant */
    public var sessions: [AnalyticsSession]?

    public init(externalContactId: String?, externalOrganizationId: String?, flaggedReason: FlaggedReason?, participantId: String?, participantName: String?, purpose: Purpose?, teamId: String?, userId: String?, sessions: [AnalyticsSession]?) {
        self.externalContactId = externalContactId
        self.externalOrganizationId = externalOrganizationId
        self.flaggedReason = flaggedReason
        self.participantId = participantId
        self.participantName = participantName
        self.purpose = purpose
        self.teamId = teamId
        self.userId = userId
        self.sessions = sessions
    }


}




public class AnalyticsRoutingStatusRecord: Codable {





    public enum RoutingStatus: String, Codable { 
        case offQueue = "OFF_QUEUE"
        case idle = "IDLE"
        case interacting = "INTERACTING"
        case notResponding = "NOT_RESPONDING"
        case communicating = "COMMUNICATING"
    }

    /** The start time of the record. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startTime: Date?
    /** The end time of the record. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?
    /** The user's ACD routing status */
    public var routingStatus: RoutingStatus?

    public init(startTime: Date?, endTime: Date?, routingStatus: RoutingStatus?) {
        self.startTime = startTime
        self.endTime = endTime
        self.routingStatus = routingStatus
    }


}




public class AnalyticsSession: Codable {













































    public enum DeliveryStatus: String, Codable { 
        case deliveryFailed = "DeliveryFailed"
        case deliverySuccess = "DeliverySuccess"
        case failed = "Failed"
        case queued = "Queued"
        case read = "Read"
        case received = "Received"
        case sent = "Sent"
    }





    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }



































    public enum MediaType: String, Codable { 
        case callback = "callback"
        case chat = "chat"
        case cobrowse = "cobrowse"
        case email = "email"
        case message = "message"
        case screenshare = "screenshare"
        case unknown = "unknown"
        case video = "video"
        case voice = "voice"
    }

























    public enum RequestedRoutings: String, Codable { 
        case bullseye = "Bullseye"
        case conditional = "Conditional"
        case direct = "Direct"
        case last = "Last"
        case manual = "Manual"
        case predictive = "Predictive"
        case preferred = "Preferred"
        case standard = "Standard"
        case vip = "Vip"
    }







    public enum RoutingRuleType: String, Codable { 
        case bullseye = "Bullseye"
        case conditional = "Conditional"
        case predictive = "Predictive"
        case preferred = "Preferred"
    }





















    public enum UsedRouting: String, Codable { 
        case bullseye = "Bullseye"
        case conditional = "Conditional"
        case direct = "Direct"
        case last = "Last"
        case manual = "Manual"
        case predictive = "Predictive"
        case preferred = "Preferred"
        case standard = "Standard"
        case vip = "Vip"
    }



















    /** ID(s) of Skill(s) that are active on the conversation */
    public var activeSkillIds: [String]?
    /** Marker for an agent that skipped after call work */
    public var acwSkipped: Bool?
    /** The address that initiated an action */
    public var addressFrom: String?
    /** The email address for the participant on the other side of the email conversation */
    public var addressOther: String?
    /** The email address for the participant on this side of the email conversation */
    public var addressSelf: String?
    /** The address receiving an action */
    public var addressTo: String?
    /** Unique identifier of the active virtual agent assistant */
    public var agentAssistantId: String?
    /** Bullseye ring of the targeted agent */
    public var agentBullseyeRing: Int?
    /** Flag indicating an agent-owned callback */
    public var agentOwned: Bool?
    /** Automatic Number Identification (caller's number) */
    public var ani: String?
    /** ID of the user that manually assigned a conversation */
    public var assignerId: String?
    /** Flag that indicates that the identity of the customer has been asserted as verified by the provider. */
    public var authenticated: Bool?
    /** The participantId being barged in on (if someone (e.g. an agent) is being barged in on, this would correspond to one of the other participantIds present in the conversation) */
    public var bargedParticipantId: String?
    /** Blind carbon copy email address(es) */
    public var bcc: [String]?
    /** Callback phone number(s) */
    public var callbackNumbers: [String]?
    /** Scheduled callback date/time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var callbackScheduledTime: Date?
    /** The name of the user requesting a call back */
    public var callbackUserName: String?
    /** Carbon copy email address(es) */
    public var cc: [String]?
    /** Flag that indicates that the conversation has been cleared by the customer */
    public var cleared: Bool?
    /** The participantId being coached (if someone (e.g. an agent) is being coached, this would correspond to one of the other participantIds present in the conversation) */
    public var coachedParticipantId: String?
    /** Describes side of the cobrowse (sharer or viewer) */
    public var cobrowseRole: String?
    /** A unique identifier for a PureCloud cobrowse room */
    public var cobrowseRoomId: String?
    /** The email or SMS delivery status */
    public var deliveryStatus: DeliveryStatus?
    /** Date and time of the most recent delivery status change. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var deliveryStatusChangeDate: Date?
    /** Destination address(es) of transfers or consults */
    public var destinationAddresses: [String]?
    /** The direction of the communication */
    public var direction: Direction?
    /** (Dialer) Analyzer (for example speech.person) */
    public var dispositionAnalyzer: String?
    /** (Dialer) Result of the analysis (for example disposition.classification.callable.machine) */
    public var dispositionName: String?
    /** Dialed number identification service (number dialed by the calling party) */
    public var dnis: String?
    /** Unique identifier of the edge device */
    public var edgeId: String?
    /** Number of eligible agents for each predictive routing attempt */
    public var eligibleAgentCounts: [Int]?
    /** Extended delivery status */
    public var extendedDeliveryStatus: String?
    /** Type of flow in that occurred when entering ACD. */
    public var flowInType: String?
    /** Type of flow out that occurred when emitting tFlowOut. */
    public var flowOutType: String?
    /** Identifier of the journey action. */
    public var journeyActionId: String?
    /** Identifier of the journey action map that triggered the action. */
    public var journeyActionMapId: String?
    /** Version of the journey action map that triggered the action. */
    public var journeyActionMapVersion: Int?
    /** Primary identifier of the journey customer in the source where the activities originate from. */
    public var journeyCustomerId: String?
    /** Type of primary identifier of the journey customer (e.g. cookie). */
    public var journeyCustomerIdType: String?
    /** Unique identifier of the journey session. */
    public var journeyCustomerSessionId: String?
    /** Type or category of journey sessions (e.g. web, ticket, delivery, atm). */
    public var journeyCustomerSessionIdType: String?
    /** Media bridge ID for the conference session consistent across all participants */
    public var mediaBridgeId: String?
    /** Count of any media (images, files, etc) included in this session */
    public var mediaCount: Int?
    /** The session media type */
    public var mediaType: MediaType?
    /** Message type for messaging services. E.g.: sms, facebook, twitter, line */
    public var messageType: String?
    /** The participantId being monitored (if someone (e.g. an agent) is being monitored, this would correspond to one of the other participantIds present in the conversation) */
    public var monitoredParticipantId: String?
    /** (Dialer) Unique identifier of the outbound campaign */
    public var outboundCampaignId: String?
    /** (Dialer) Unique identifier of the contact */
    public var outboundContactId: String?
    /** (Dialer) Unique identifier of the contact list that this contact belongs to */
    public var outboundContactListId: String?
    /** This identifies pairs of related sessions on a conversation. E.g. an external session’s peerId will be the session that the call originally connected to, e.g. if an IVR was dialed, the IVR session, which will also have the external session’s ID as its peer. After that point, any transfers of that session to other internal components (acd, agent, etc.) will all spawn new sessions whose peerIds point back to that original external session. */
    public var peerId: String?
    /** The original voice protocol call ID, e.g. a SIP call ID */
    public var protocolCallId: String?
    /** The source provider for the communication. */
    public var provider: String?
    /** Flag determining if an audio recording was started or not */
    public var recording: Bool?
    /** Name, phone number, or email address of the remote party. */
    public var remote: String?
    /** Unique identifier for the remote party */
    public var remoteNameDisplayable: String?
    /** ID(s) of Skill(s) that have been removed by bullseye routing */
    public var removedSkillIds: [String]?
    /** Routing type(s) for requested/attempted routing methods. */
    public var requestedRoutings: [RequestedRoutings]?
    /** Unique identifier for the room */
    public var roomId: String?
    /** Routing ring for bullseye or preferred agent routing */
    public var routingRing: Int?
    /** Routing rule for preferred, conditional and predictive routing type */
    public var routingRule: String?
    /** Routing rule type */
    public var routingRuleType: RoutingRuleType?
    /** Direct ScreenShare address */
    public var screenShareAddressSelf: String?
    /** A unique identifier for a PureCloud ScreenShare room */
    public var screenShareRoomId: String?
    /** A unique identifier for a script */
    public var scriptId: String?
    /** Selected agent ID */
    public var selectedAgentId: String?
    /** Selected agent GPR rank */
    public var selectedAgentRank: Int?
    /** Dialed number for the current session; this can be different from dnis, e.g. if the call was transferred */
    public var sessionDnis: String?
    /** The unique identifier of this session */
    public var sessionId: String?
    /** Flag determining if screenShare is started or not (true/false) */
    public var sharingScreen: Bool?
    /** (Dialer) Whether the agent can skip the dialer contact */
    public var skipEnabled: Bool?
    /** The number of seconds before PureCloud begins the call for a call back (0 disables automatic calling) */
    public var timeoutSeconds: Int?
    /** Complete routing method */
    public var usedRouting: UsedRouting?
    /** Direct Video address */
    public var videoAddressSelf: String?
    /** A unique identifier for a PureCloud video room */
    public var videoRoomId: String?
    /** Number of waiting interactions for each predictive routing attempt */
    public var waitingInteractionCounts: [Int]?
    /** Conditional group routing agent groups */
    public var agentGroups: [AnalyticsAgentGroup]?
    /** Proposed agents */
    public var proposedAgents: [AnalyticsProposedAgent]?
    /** MediaEndpointStats associated with this session */
    public var mediaEndpointStats: [AnalyticsMediaEndpointStat]?
    /** IVR flow execution associated with this session */
    public var flow: AnalyticsFlow?
    /** List of metrics for this session */
    public var metrics: [AnalyticsSessionMetric]?
    /** List of segments for this session */
    public var segments: [AnalyticsConversationSegment]?

    public init(activeSkillIds: [String]?, acwSkipped: Bool?, addressFrom: String?, addressOther: String?, addressSelf: String?, addressTo: String?, agentAssistantId: String?, agentBullseyeRing: Int?, agentOwned: Bool?, ani: String?, assignerId: String?, authenticated: Bool?, bargedParticipantId: String?, bcc: [String]?, callbackNumbers: [String]?, callbackScheduledTime: Date?, callbackUserName: String?, cc: [String]?, cleared: Bool?, coachedParticipantId: String?, cobrowseRole: String?, cobrowseRoomId: String?, deliveryStatus: DeliveryStatus?, deliveryStatusChangeDate: Date?, destinationAddresses: [String]?, direction: Direction?, dispositionAnalyzer: String?, dispositionName: String?, dnis: String?, edgeId: String?, eligibleAgentCounts: [Int]?, extendedDeliveryStatus: String?, flowInType: String?, flowOutType: String?, journeyActionId: String?, journeyActionMapId: String?, journeyActionMapVersion: Int?, journeyCustomerId: String?, journeyCustomerIdType: String?, journeyCustomerSessionId: String?, journeyCustomerSessionIdType: String?, mediaBridgeId: String?, mediaCount: Int?, mediaType: MediaType?, messageType: String?, monitoredParticipantId: String?, outboundCampaignId: String?, outboundContactId: String?, outboundContactListId: String?, peerId: String?, protocolCallId: String?, provider: String?, recording: Bool?, remote: String?, remoteNameDisplayable: String?, removedSkillIds: [String]?, requestedRoutings: [RequestedRoutings]?, roomId: String?, routingRing: Int?, routingRule: String?, routingRuleType: RoutingRuleType?, screenShareAddressSelf: String?, screenShareRoomId: String?, scriptId: String?, selectedAgentId: String?, selectedAgentRank: Int?, sessionDnis: String?, sessionId: String?, sharingScreen: Bool?, skipEnabled: Bool?, timeoutSeconds: Int?, usedRouting: UsedRouting?, videoAddressSelf: String?, videoRoomId: String?, waitingInteractionCounts: [Int]?, agentGroups: [AnalyticsAgentGroup]?, proposedAgents: [AnalyticsProposedAgent]?, mediaEndpointStats: [AnalyticsMediaEndpointStat]?, flow: AnalyticsFlow?, metrics: [AnalyticsSessionMetric]?, segments: [AnalyticsConversationSegment]?) {
        self.activeSkillIds = activeSkillIds
        self.acwSkipped = acwSkipped
        self.addressFrom = addressFrom
        self.addressOther = addressOther
        self.addressSelf = addressSelf
        self.addressTo = addressTo
        self.agentAssistantId = agentAssistantId
        self.agentBullseyeRing = agentBullseyeRing
        self.agentOwned = agentOwned
        self.ani = ani
        self.assignerId = assignerId
        self.authenticated = authenticated
        self.bargedParticipantId = bargedParticipantId
        self.bcc = bcc
        self.callbackNumbers = callbackNumbers
        self.callbackScheduledTime = callbackScheduledTime
        self.callbackUserName = callbackUserName
        self.cc = cc
        self.cleared = cleared
        self.coachedParticipantId = coachedParticipantId
        self.cobrowseRole = cobrowseRole
        self.cobrowseRoomId = cobrowseRoomId
        self.deliveryStatus = deliveryStatus
        self.deliveryStatusChangeDate = deliveryStatusChangeDate
        self.destinationAddresses = destinationAddresses
        self.direction = direction
        self.dispositionAnalyzer = dispositionAnalyzer
        self.dispositionName = dispositionName
        self.dnis = dnis
        self.edgeId = edgeId
        self.eligibleAgentCounts = eligibleAgentCounts
        self.extendedDeliveryStatus = extendedDeliveryStatus
        self.flowInType = flowInType
        self.flowOutType = flowOutType
        self.journeyActionId = journeyActionId
        self.journeyActionMapId = journeyActionMapId
        self.journeyActionMapVersion = journeyActionMapVersion
        self.journeyCustomerId = journeyCustomerId
        self.journeyCustomerIdType = journeyCustomerIdType
        self.journeyCustomerSessionId = journeyCustomerSessionId
        self.journeyCustomerSessionIdType = journeyCustomerSessionIdType
        self.mediaBridgeId = mediaBridgeId
        self.mediaCount = mediaCount
        self.mediaType = mediaType
        self.messageType = messageType
        self.monitoredParticipantId = monitoredParticipantId
        self.outboundCampaignId = outboundCampaignId
        self.outboundContactId = outboundContactId
        self.outboundContactListId = outboundContactListId
        self.peerId = peerId
        self.protocolCallId = protocolCallId
        self.provider = provider
        self.recording = recording
        self.remote = remote
        self.remoteNameDisplayable = remoteNameDisplayable
        self.removedSkillIds = removedSkillIds
        self.requestedRoutings = requestedRoutings
        self.roomId = roomId
        self.routingRing = routingRing
        self.routingRule = routingRule
        self.routingRuleType = routingRuleType
        self.screenShareAddressSelf = screenShareAddressSelf
        self.screenShareRoomId = screenShareRoomId
        self.scriptId = scriptId
        self.selectedAgentId = selectedAgentId
        self.selectedAgentRank = selectedAgentRank
        self.sessionDnis = sessionDnis
        self.sessionId = sessionId
        self.sharingScreen = sharingScreen
        self.skipEnabled = skipEnabled
        self.timeoutSeconds = timeoutSeconds
        self.usedRouting = usedRouting
        self.videoAddressSelf = videoAddressSelf
        self.videoRoomId = videoRoomId
        self.waitingInteractionCounts = waitingInteractionCounts
        self.agentGroups = agentGroups
        self.proposedAgents = proposedAgents
        self.mediaEndpointStats = mediaEndpointStats
        self.flow = flow
        self.metrics = metrics
        self.segments = segments
    }


}




public class AnalyticsUserDetail: Codable {







    /** The identifier for the user */
    public var userId: String?
    /** The presence records for the user */
    public var primaryPresence: [AnalyticsUserPresenceRecord]?
    /** The ACD routing status records for the user */
    public var routingStatus: [AnalyticsRoutingStatusRecord]?

    public init(userId: String?, primaryPresence: [AnalyticsUserPresenceRecord]?, routingStatus: [AnalyticsRoutingStatusRecord]?) {
        self.userId = userId
        self.primaryPresence = primaryPresence
        self.routingStatus = routingStatus
    }


}




public class Annotation: Codable {























    public enum Reason: String, Codable { 
        case hold = "Hold"
        case securePause = "SecurePause"
        case flowOrQueue = "FlowOrQueue"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var type: String?
    /** Offset of annotation in milliseconds. */
    public var location: Int64?
    /** Duration of annotation in milliseconds. */
    public var durationMs: Int64?
    /** Offset of annotation (milliseconds) from start of recording (after removing the cumulative duration of all pauses). */
    public var absoluteLocation: Int64?
    /** Duration of annotation (milliseconds). */
    public var absoluteDurationMs: Int64?
    /** Offset of annotation (milliseconds) from start of recording, adjusted for any recording cuts */
    public var recordingLocation: Int64?
    /** Duration of annotation (milliseconds), adjusted for any recording cuts. */
    public var recordingDurationMs: Int64?
    /** User that created this annotation (if any). */
    public var user: User?
    /** Text of annotation. Maximum character limit is 500. */
    public var _description: String?
    /** Reason for a pause annotation. Valid values: Hold,SecurePause,FlowOrQueue */
    public var reason: Reason?
    /** List of annotations */
    public var annotations: [Annotation]?
    /** Offset of annotation (milliseconds) from start of the recording before removing the cumulative duration of all pauses before this annotation */
    public var realtimeLocation: Int64?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, type: String?, location: Int64?, durationMs: Int64?, absoluteLocation: Int64?, absoluteDurationMs: Int64?, recordingLocation: Int64?, recordingDurationMs: Int64?, user: User?, _description: String?, reason: Reason?, annotations: [Annotation]?, realtimeLocation: Int64?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.type = type
        self.location = location
        self.durationMs = durationMs
        self.absoluteLocation = absoluteLocation
        self.absoluteDurationMs = absoluteDurationMs
        self.recordingLocation = recordingLocation
        self.recordingDurationMs = recordingDurationMs
        self.user = user
        self._description = _description
        self.reason = reason
        self.annotations = annotations
        self.realtimeLocation = realtimeLocation
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case type
        case location
        case durationMs
        case absoluteLocation
        case absoluteDurationMs
        case recordingLocation
        case recordingDurationMs
        case user
        case _description = "description"
        case reason
        case annotations
        case realtimeLocation
        case selfUri
    }


}




public class ApiUsageOrganizationQuery: Codable {



    public enum Granularity: String, Codable { 
        case day = "Day"
        case week = "Week"
        case month = "Month"
    }

    public enum Metrics: String, Codable { 
        case status200 = "Status200"
        case status300 = "Status300"
        case status400 = "Status400"
        case status500 = "Status500"
        case status429 = "Status429"
        case requests = "Requests"
    }

    public enum GroupBy: String, Codable { 
        case oauthclientid = "OAuthClientId"
        case organizationId = "OrganizationId"
        case userId = "UserId"
        case templateUri = "TemplateUri"
        case httpMethod = "HttpMethod"
    }

    /** Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Date granularity of the results */
    public var granularity: Granularity?
    /** Behaves like a SQL SELECT clause. Enables retrieving only named metrics. If omitted, all metrics that are available will be returned (like SELECT *). */
    public var metrics: [Metrics]?
    /** Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group. */
    public var groupBy: [GroupBy]?

    public init(interval: String?, granularity: Granularity?, metrics: [Metrics]?, groupBy: [GroupBy]?) {
        self.interval = interval
        self.granularity = granularity
        self.metrics = metrics
        self.groupBy = groupBy
    }


}




public class ApiUsageQueryResult: Codable {



    public enum QueryStatus: String, Codable { 
        case complete = "Complete"
        case failed = "Failed"
        case running = "Running"
    }

    /** Query results */
    public var results: [ApiUsageRow]?
    /** Query status */
    public var queryStatus: QueryStatus?

    public init(results: [ApiUsageRow]?, queryStatus: QueryStatus?) {
        self.results = results
        self.queryStatus = queryStatus
    }


}




public class ApprovalNamespace: Codable {

    public enum Namespace: String, Codable { 
        case agentAssistant = "agent.assistant"
        case analyticsAlerting = "analytics.alerting"
        case analytics = "analytics"
        case analyticsRealtime = "analytics.realtime"
        case analyticsReportingSettings = "analytics.reporting.settings"
        case architect = "architect"
        case audiohook = "audiohook"
        case audit = "audit"
        case authApi = "auth.api"
        case authorization = "authorization"
        case automationTesting = "automation.testing"
        case bots = "bots"
        case botsVoice = "bots.voice"
        case callback = "callback"
        case cobrowse = "cobrowse"
        case contentManagement = "content.management"
        case conversation = "conversation"
        case dataactions = "dataactions"
        case datatables = "datatables"
        case directory = "directory"
        case email = "email"
        case employeeEngagement = "employee.engagement"
        case eventOrchestration = "event.orchestration"
        case externalContacts = "external.contacts"
        case gcv = "gcv"
        case gdpr = "gdpr"
        case groups = "groups"
        case historicalAdherence = "historical.adherence"
        case infrastructureascode = "infrastructureascode"
        case integrations = "integrations"
        case intentMiner = "intent.miner"
        case journey = "journey"
        case knowledge = "knowledge"
        case languageUnderstanding = "language.understanding"
        case learning = "learning"
        case limitRegistry = "limit.registry"
        case marketplace = "marketplace"
        case mediaCommunications = "media.communications"
        case messaging = "messaging"
        case notifications = "notifications"
        case onboarding = "onboarding"
        case outbound = "outbound"
        case platformApi = "platform.api"
        case predictiveRouting = "predictive.routing"
        case presence = "presence"
        case quality = "quality"
        case recording = "recording"
        case responseManagement = "response.management"
        case routing = "routing"
        case scim = "scim"
        case search = "search"
        case secondaryAutomationTesting = "secondary.automation.testing"
        case skills = "skills"
        case speechAndTextAnalytics = "speech.and.text.analytics"
        case speechIntegration = "speech.integration"
        case supportability = "supportability"
        case taskManagement = "task.management"
        case telephonyConfiguration = "telephony.configuration"
        case usage = "usage"
        case users = "users"
        case webDeployments = "web.deployments"
        case webMessaging = "web.messaging"
        case webchat = "webchat"
        case webhooks = "webhooks"
        case workforceManagement = "workforce.management"
    }

    public enum Status: String, Codable { 
        case approved = "Approved"
        case rejected = "Rejected"
        case rollback = "Rollback"
        case pending = "Pending"
        case _open = "Open"
        case secondaryApprovalNamespacesAdded = "SecondaryApprovalNamespacesAdded"
        case reviewerApproved = "ReviewerApproved"
        case reviewerRejected = "ReviewerRejected"
        case reviewerRollback = "ReviewerRollback"
        case implementingChange = "ImplementingChange"
        case changeImplemented = "ChangeImplemented"
        case implementingRollback = "ImplementingRollback"
        case rollbackImplemented = "RollbackImplemented"
    }

    public enum ModelType: String, Codable { 
        case primary = "Primary"
        case secondary = "Secondary"
    }

    /** The namespace of the associated approvers. */
    public var namespace: Namespace?
    /** The current namespace approval status. */
    public var status: Status?
    /** The type of namespace approval. */
    public var type: ModelType?

    public init(namespace: Namespace?, status: Status?, type: ModelType?) {
        self.namespace = namespace
        self.status = status
        self.type = type
    }


}




public class ArchitectFlowFields: Codable {





    /** The architect flow. */
    public var architectFlow: AddressableEntityRef?
    /** Collection of Architect Flow Request Mappings to use. */
    public var flowRequestMappings: [RequestMapping]?

    public init(architectFlow: AddressableEntityRef?, flowRequestMappings: [RequestMapping]?) {
        self.architectFlow = architectFlow
        self.flowRequestMappings = flowRequestMappings
    }


}



/** Describes an operation being performed on an Architect object */

public class ArchitectFlowNotificationArchitectOperation: Codable {









    public enum ActionName: String, Codable { 
        case create = "CREATE"
        case checkin = "CHECKIN"
        case checkout = "CHECKOUT"
        case debug = "DEBUG"
        case delete = "DELETE"
        case history = "HISTORY"
        case publish = "PUBLISH"
        case revert = "REVERT"
        case save = "SAVE"
        case stateChange = "STATE_CHANGE"
        case update = "UPDATE"
        case validate = "VALIDATE"
    }

    public enum ActionStatus: String, Codable { 
        case locked = "LOCKED"
        case unlocked = "UNLOCKED"
        case started = "STARTED"
        case pendingGeneration = "PENDING_GENERATION"
        case pendingBackendNotification = "PENDING_BACKEND_NOTIFICATION"
        case success = "SUCCESS"
        case failure = "FAILURE"
    }









    /** A unique identifier for this operation, as generated by the initiating client */
    public var _id: String?
    /** Indicates if the operation is complete */
    public var complete: Bool?
    public var user: ArchitectFlowNotificationUser?
    public var client: ArchitectFlowNotificationClient?
    /** The action being performed */
    public var actionName: ActionName?
    /** The action status */
    public var actionStatus: ActionStatus?
    /** The error message, if the action failed */
    public var errorMessage: String?
    /** The error code, if the action failed */
    public var errorCode: String?
    public var errorMessageParams: ArchitectFlowNotificationErrorMessageParams?
    /** The error details, if the action failed */
    public var errorDetails: [ArchitectFlowNotificationErrorDetail]?

    public init(_id: String?, complete: Bool?, user: ArchitectFlowNotificationUser?, client: ArchitectFlowNotificationClient?, actionName: ActionName?, actionStatus: ActionStatus?, errorMessage: String?, errorCode: String?, errorMessageParams: ArchitectFlowNotificationErrorMessageParams?, errorDetails: [ArchitectFlowNotificationErrorDetail]?) {
        self._id = _id
        self.complete = complete
        self.user = user
        self.client = client
        self.actionName = actionName
        self.actionStatus = actionStatus
        self.errorMessage = errorMessage
        self.errorCode = errorCode
        self.errorMessageParams = errorMessageParams
        self.errorDetails = errorDetails
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case complete
        case user
        case client
        case actionName
        case actionStatus
        case errorMessage
        case errorCode
        case errorMessageParams
        case errorDetails
    }


}



/** The client who initiated the change. */

public class ArchitectFlowOutcomeNotificationClient: Codable {





    /** The ID of the client. */
    public var _id: String?
    /** The name of the client, if available. */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class ArchitectFlowOutcomeNotificationErrorDetail: Codable {









    public var errorCode: String?
    public var entityId: String?
    public var entityName: String?
    public var fieldName: String?

    public init(errorCode: String?, entityId: String?, entityName: String?, fieldName: String?) {
        self.errorCode = errorCode
        self.entityId = entityId
        self.entityName = entityName
        self.fieldName = fieldName
    }


}




public class ArchitectFlowOutcomeNotificationHomeOrganization: Codable {







    public var _id: String?
    public var name: String?
    public var thirdPartyOrgName: String?

    public init(_id: String?, name: String?, thirdPartyOrgName: String?) {
        self._id = _id
        self.name = name
        self.thirdPartyOrgName = thirdPartyOrgName
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case thirdPartyOrgName
    }


}




public class ArchitectJobMessage: Codable {



    public enum ModelType: String, Codable { 
        case error = "Error"
        case warning = "Warning"
    }



    /** The DateTime when the message was generated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateTime: Date?
    /** The message type. */
    public var type: ModelType?
    /** The text of the message. */
    public var text: String?

    public init(dateTime: Date?, type: ModelType?, text: String?) {
        self.dateTime = dateTime
        self.type = type
        self.text = text
    }


}



/** The user who initiated the change. */

public class ArchitectPromptNotificationUser: Codable {







    /** The ID of the user. */
    public var _id: String?
    /** The name of the user, if available. */
    public var name: String?
    public var homeOrg: ArchitectPromptNotificationHomeOrganization?

    public init(_id: String?, name: String?, homeOrg: ArchitectPromptNotificationHomeOrganization?) {
        self._id = _id
        self.name = name
        self.homeOrg = homeOrg
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case homeOrg
    }


}




public class AssessmentForm: Codable {















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Last modified date of the assessment form. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The unique Id for all versions of this assessment form */
    public var contextId: String?
    /** The URI for this object */
    public var selfUri: String?
    /** If true, assessment form is published */
    public var published: Bool?
    /** The pass percent for the assessment form */
    public var passPercent: Int?
    /** A list of question groups */
    public var questionGroups: [AssessmentFormQuestionGroup]?

    public init(_id: String?, dateModified: Date?, contextId: String?, selfUri: String?, published: Bool?, passPercent: Int?, questionGroups: [AssessmentFormQuestionGroup]?) {
        self._id = _id
        self.dateModified = dateModified
        self.contextId = contextId
        self.selfUri = selfUri
        self.published = published
        self.passPercent = passPercent
        self.questionGroups = questionGroups
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case dateModified
        case contextId
        case selfUri
        case published
        case passPercent
        case questionGroups
    }


}




public class AssessmentQuestionGroupScore: Codable {

































    /** The ID of the question group */
    public var questionGroupId: String?
    /** The total score for the questions */
    public var totalScore: Float?
    /** The maximum total score for the questions */
    public var maxTotalScore: Float?
    /** True if this question group is marked NA */
    public var markedNA: Bool?
    /** If markedNA is true, systemMarkedNA indicates whether it was marked by a user or by the system due to visibility conditions. Always false if markedNA is false. */
    public var systemMarkedNA: Bool?
    /** The total score for the critical questions */
    public var totalCriticalScore: Float?
    /** The maximum total score for the critical questions */
    public var maxTotalCriticalScore: Float?
    /** The total score for the non-critical questions */
    public var totalNonCriticalScore: Float?
    /** The maximum total score for the non-critical questions */
    public var maxTotalNonCriticalScore: Float?
    /** The unweighted total score for this question group */
    public var totalScoreUnweighted: Float?
    /** The maximum unweighted total score for this question group */
    public var maxTotalScoreUnweighted: Float?
    /** The unweighted total score for the critical questions */
    public var totalCriticalScoreUnweighted: Float?
    /** The maximum unweighted total score for the critical questions */
    public var maxTotalCriticalScoreUnweighted: Float?
    /** The total unweighted score for the non-critical questions */
    public var totalNonCriticalScoreUnweighted: Float?
    /** The maximum unweighted total score for the non-critical questions */
    public var maxTotalNonCriticalScoreUnweighted: Float?
    /** The individual question scores */
    public var questionScores: [AssessmentQuestionScore]?

    public init(questionGroupId: String?, totalScore: Float?, maxTotalScore: Float?, markedNA: Bool?, systemMarkedNA: Bool?, totalCriticalScore: Float?, maxTotalCriticalScore: Float?, totalNonCriticalScore: Float?, maxTotalNonCriticalScore: Float?, totalScoreUnweighted: Float?, maxTotalScoreUnweighted: Float?, totalCriticalScoreUnweighted: Float?, maxTotalCriticalScoreUnweighted: Float?, totalNonCriticalScoreUnweighted: Float?, maxTotalNonCriticalScoreUnweighted: Float?, questionScores: [AssessmentQuestionScore]?) {
        self.questionGroupId = questionGroupId
        self.totalScore = totalScore
        self.maxTotalScore = maxTotalScore
        self.markedNA = markedNA
        self.systemMarkedNA = systemMarkedNA
        self.totalCriticalScore = totalCriticalScore
        self.maxTotalCriticalScore = maxTotalCriticalScore
        self.totalNonCriticalScore = totalNonCriticalScore
        self.maxTotalNonCriticalScore = maxTotalNonCriticalScore
        self.totalScoreUnweighted = totalScoreUnweighted
        self.maxTotalScoreUnweighted = maxTotalScoreUnweighted
        self.totalCriticalScoreUnweighted = totalCriticalScoreUnweighted
        self.maxTotalCriticalScoreUnweighted = maxTotalCriticalScoreUnweighted
        self.totalNonCriticalScoreUnweighted = totalNonCriticalScoreUnweighted
        self.maxTotalNonCriticalScoreUnweighted = maxTotalNonCriticalScoreUnweighted
        self.questionScores = questionScores
    }


}




public class AssessmentQuestionScore: Codable {

















    /** True if this was a failed Kill question */
    public var failedKillQuestion: Bool?
    /** Comments provided for the answer */
    public var comments: String?
    /** The ID of the question */
    public var questionId: String?
    /** The ID of the selected answer */
    public var answerId: String?
    /** The score received for this question */
    public var score: Int?
    /** True if this question was marked as NA */
    public var markedNA: Bool?
    /** If markedNA is true, systemMarkedNA indicates whether it was marked by a user or by the system due to visibility conditions. Always false if markedNA is false. */
    public var systemMarkedNA: Bool?
    /** Answer for free text answer type */
    public var freeTextAnswer: String?

    public init(failedKillQuestion: Bool?, comments: String?, questionId: String?, answerId: String?, score: Int?, markedNA: Bool?, systemMarkedNA: Bool?, freeTextAnswer: String?) {
        self.failedKillQuestion = failedKillQuestion
        self.comments = comments
        self.questionId = questionId
        self.answerId = answerId
        self.score = score
        self.markedNA = markedNA
        self.systemMarkedNA = systemMarkedNA
        self.freeTextAnswer = freeTextAnswer
    }


}




public class AssignedLearningModuleDomainEntityListing: Codable {





















    public var entities: [AssignedLearningModule]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [AssignedLearningModule]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class AssignmentError: Codable {





    /** A user that is failed to be removed from the performance profile */
    public var user: UserReference?
    /** Error message from membership assignment */
    public var message: String?

    public init(user: UserReference?, message: String?) {
        self.user = user
        self.message = message
    }


}




public class AsyncQueryResponse: Codable {



    /** Unique identifier for the async query execution. Can be used to check the status of the query and retrieve results. */
    public var jobId: String?

    public init(jobId: String?) {
        self.jobId = jobId
    }


}




public class AttemptLimits: Codable {

















    public enum ResetPeriod: String, Codable { 
        case never = "NEVER"
        case today = "TODAY"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** The maximum number of times a contact can be called within the resetPeriod. Required if maxAttemptsPerNumber is not defined. */
    public var maxAttemptsPerContact: Int?
    /** The maximum number of times a phone number can be called within the resetPeriod. Required if maxAttemptsPerContact is not defined. */
    public var maxAttemptsPerNumber: Int?
    /** If the resetPeriod is TODAY, this specifies the timezone in which TODAY occurs. Required if the resetPeriod is TODAY. */
    public var timeZoneId: String?
    /** After how long the number of attempts will be set back to 0. Defaults to NEVER. */
    public var resetPeriod: ResetPeriod?
    /** Configuration for recall attempts. */
    public var recallEntries: [String:RecallEntry]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, maxAttemptsPerContact: Int?, maxAttemptsPerNumber: Int?, timeZoneId: String?, resetPeriod: ResetPeriod?, recallEntries: [String:RecallEntry]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.maxAttemptsPerContact = maxAttemptsPerContact
        self.maxAttemptsPerNumber = maxAttemptsPerNumber
        self.timeZoneId = timeZoneId
        self.resetPeriod = resetPeriod
        self.recallEntries = recallEntries
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case maxAttemptsPerContact
        case maxAttemptsPerNumber
        case timeZoneId
        case resetPeriod
        case recallEntries
        case selfUri
    }


}




public class AttributeDetailEventTopicAttributeUpdateEvent: Codable {















    public var eventTime: Int?
    public var conversationId: String?
    public var participantId: String?
    public var attributes: [String:String]?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?
    public var communications: [AttributeDetailEventTopicCommunication]?

    public init(eventTime: Int?, conversationId: String?, participantId: String?, attributes: [String:String]?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?, communications: [AttributeDetailEventTopicCommunication]?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.attributes = attributes
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
        self.communications = communications
    }


}




public class AttributeFilterItem: Codable {



    public enum Operator: String, Codable { 
        case _in = "IN"
        case range = "RANGE"
        case equals = "EQUALS"
        case notequals = "NOTEQUALS"
        case lessthan = "LESSTHAN"
        case lessthanequals = "LESSTHANEQUALS"
        case greaterthan = "GREATERTHAN"
        case greaterthanequals = "GREATERTHANEQUALS"
        case contains = "CONTAINS"
    }



    public var _id: String?
    public var _operator: Operator?
    public var values: [String]?

    public init(_id: String?, _operator: Operator?, values: [String]?) {
        self._id = _id
        self._operator = _operator
        self.values = values
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case _operator = "operator"
        case values
    }


}




public class AudioState: Codable {





    /** Indicates that this communication's audio allows its participant to hear others. */
    public var canHear: Bool?
    /** Indicates that this communication's audio allows others to hear this participant. */
    public var canSpeak: Bool?

    public init(canHear: Bool?, canSpeak: Bool?) {
        self.canHear = canHear
        self.canSpeak = canSpeak
    }


}




public class AuditFacet: Codable {





    /** The name of the field on which to facet. */
    public var name: String?
    /** The type of the facet, DATE or STRING. */
    public var type: String?

    public init(name: String?, type: String?) {
        self.name = name
        self.type = type
    }


}




public class AuditQueryExecutionResultsResponse: Codable {









    /** Id of the audit query execution request. */
    public var _id: String?
    /** Number of results in a page. */
    public var pageSize: Int?
    /** Optional cursor to indicate where to resume the results. */
    public var cursor: String?
    /** List of audit messages. */
    public var entities: [AuditLogMessage]?

    public init(_id: String?, pageSize: Int?, cursor: String?, entities: [AuditLogMessage]?) {
        self._id = _id
        self.pageSize = pageSize
        self.cursor = cursor
        self.entities = entities
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case pageSize
        case cursor
        case entities
    }


}




public class AuditQueryExecutionStatusResponse: Codable {



    public enum State: String, Codable { 
        case queued = "Queued"
        case running = "Running"
        case succeeded = "Succeeded"
        case failed = "Failed"
        case cancelled = "Cancelled"
    }











    /** Id of the audit query execution request. */
    public var _id: String?
    /** Status of the audit query execution request. */
    public var state: State?
    /** Start date and time of the audit query execution. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** Interval for the audit query. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Service name for the audit query. */
    public var serviceName: String?
    /** Filters for the audit query. */
    public var filters: [AuditQueryFilter]?
    /** Sort parameter for the audit query. */
    public var sort: [AuditQuerySort]?

    public init(_id: String?, state: State?, startDate: Date?, interval: String?, serviceName: String?, filters: [AuditQueryFilter]?, sort: [AuditQuerySort]?) {
        self._id = _id
        self.state = state
        self.startDate = startDate
        self.interval = interval
        self.serviceName = serviceName
        self.filters = filters
        self.sort = sort
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case startDate
        case interval
        case serviceName
        case filters
        case sort
    }


}




public class AuditQueryFilter: Codable {

    public enum Property: String, Codable { 
        case userId = "UserId"
        case trusteeOrganizationId = "TrusteeOrganizationId"
        case clientId = "ClientId"
        case action = "Action"
        case entityType = "EntityType"
        case entityId = "EntityId"
    }



    /** Name of the property to filter. */
    public var property: Property?
    /** Value of the property to filter. */
    public var value: String?

    public init(property: Property?, value: String?) {
        self.property = property
        self.value = value
    }


}




public class AuditQuerySort: Codable {

    public enum Name: String, Codable { 
        case timestamp = "Timestamp"
    }

    public enum SortOrder: String, Codable { 
        case ascending = "ascending"
        case descending = "descending"
    }

    /** Name of the property to sort. */
    public var name: Name?
    /** Sort Order */
    public var sortOrder: SortOrder?

    public init(name: Name?, sortOrder: SortOrder?) {
        self.name = name
        self.sortOrder = sortOrder
    }


}




public class AuditRealtimeQueryRequest: Codable {













    /** Date and time range of data to query. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ssZ/YYYY-MM-DDThh:mm:ssZ */
    public var interval: String?
    /** Name of the service to query audits for. */
    public var serviceName: String?
    /** Additional filters for the query. */
    public var filters: [AuditQueryFilter]?
    /** Sort parameter for the query. */
    public var sort: [AuditQuerySort]?
    /** Page number */
    public var pageNumber: Int?
    /** Page size */
    public var pageSize: Int?

    public init(interval: String?, serviceName: String?, filters: [AuditQueryFilter]?, sort: [AuditQuerySort]?, pageNumber: Int?, pageSize: Int?) {
        self.interval = interval
        self.serviceName = serviceName
        self.filters = filters
        self.sort = sort
        self.pageNumber = pageNumber
        self.pageSize = pageSize
    }


}




public class AuditTopicAuditLogMessage: Codable {















    public enum ServiceName: String, Codable { 
        case languageUnderstanding = "LanguageUnderstanding"
        case contentManagement = "ContentManagement"
        case peoplePermissions = "PeoplePermissions"
        case presence = "Presence"
        case architect = "Architect"
        case contactCenter = "ContactCenter"
        case quality = "Quality"
        case speechAndTextAnalytics = "SpeechAndTextAnalytics"
        case predictiveEngagement = "PredictiveEngagement"
        case knowledge = "Knowledge"
        case coaching = "Coaching"
        case learning = "Learning"
        case workforceManagement = "WorkforceManagement"
        case triggers = "Triggers"
        case processAutomation = "ProcessAutomation"
        case responseManagement = "ResponseManagement"
        case groups = "Groups"
        case telephony = "Telephony"
        case outbound = "Outbound"
        case routing = "Routing"
        case gamification = "Gamification"
        case integrations = "Integrations"
        case webhooks = "Webhooks"
        case analyticsReporting = "AnalyticsReporting"
        case limits = "Limits"
        case employeePerformance = "EmployeePerformance"
        case datatables = "Datatables"
        case messaging = "Messaging"
        case webDeployments = "WebDeployments"
        case supportability = "Supportability"
        case callback = "Callback"
        case directory = "Directory"
        case externalContacts = "ExternalContacts"
        case taskManagement = "TaskManagement"
        case scim = "SCIM"
        case numberPurchasing = "NumberPurchasing"
        case marketplace = "Marketplace"
        case logCapture = "LogCapture"
        case gdpr = "GDPR"
        case agentConfig = "AgentConfig"
        case emails = "Emails"
        case scripter = "Scripter"
        case billing = "Billing"
        case journeyAnalytics = "JourneyAnalytics"
    }







    public enum Action: String, Codable { 
        case view = "View"
        case create = "Create"
        case update = "Update"
        case delete = "Delete"
        case move = "Move"
        case copy = "Copy"
        case download = "Download"
        case shareAdd = "ShareAdd"
        case shareRemove = "ShareRemove"
        case fax = "Fax"
        case versionCreate = "VersionCreate"
        case tagAdd = "TagAdd"
        case tagRemove = "TagRemove"
        case tagUpdate = "TagUpdate"
        case add = "Add"
        case remove = "Remove"
        case memberAdd = "MemberAdd"
        case memberUpdate = "MemberUpdate"
        case memberRemove = "MemberRemove"
        case authorize = "Authorize"
        case deauthorize = "Deauthorize"
        case authenticate = "Authenticate"
        case changePassword = "ChangePassword"
        case revoke = "Revoke"
        case checkin = "Checkin"
        case checkout = "Checkout"
        case deactivate = "Deactivate"
        case debug = "Debug"
        case publish = "Publish"
        case revert = "Revert"
        case save = "Save"
        case transcode = "Transcode"
        case upload = "Upload"
        case wrapupCodeAdd = "WrapupCodeAdd"
        case wrapupCodeRemove = "WrapupCodeRemove"
        case read = "Read"
        case execute = "Execute"
        case abandon = "Abandon"
        case archive = "Archive"
        case export = "Export"
        case restoreRequest = "RestoreRequest"
        case restoreComplete = "RestoreComplete"
        case updateRetention = "UpdateRetention"
        case applyProtection = "ApplyProtection"
        case revokeProtection = "RevokeProtection"
        case rotate = "Rotate"
        case deleteAll = "DeleteAll"
        case reassign = "Reassign"
        case unarchive = "Unarchive"
        case activate = "Activate"
        case assign = "Assign"
        case unassign = "Unassign"
        case reset = "Reset"
        case reschedule = "Reschedule"
        case unpublish = "Unpublish"
        case purge = "Purge"
        case processed = "Processed"
        case enable = "Enable"
        case disable = "Disable"
        case recycle = "Recycle"
        case append = "Append"
        case restore = "Restore"
        case _open = "Open"
        case approved = "Approved"
        case rejected = "Rejected"
        case rollback = "Rollback"
        case implementingChange = "ImplementingChange"
        case changeImplemented = "ChangeImplemented"
        case implementingRollback = "ImplementingRollback"
        case rollbackImplemented = "RollbackImplemented"
        case write = "Write"
        case replace = "Replace"
        case updateInService = "UpdateInService"
        case updateOutOfService = "UpdateOutOfService"
        case cycle = "Cycle"
        case scale = "Scale"
        case ipAllowlistClear = "IpAllowlistClear"
        case addPairingRole = "AddPairingRole"
        case verify = "Verify"
        case restoreDeleted = "RestoreDeleted"
        case restoreAll = "RestoreAll"
        case approve = "Approve"
        case reject = "Reject"
        case reverse = "Reverse"
        case cancel = "Cancel"
        case hardDelete = "HardDelete"
        case softDelete = "SoftDelete"
        case enableCapture = "EnableCapture"
        case downloadCapture = "DownloadCapture"
        case initiate = "Initiate"
        case reverseManually = "ReverseManually"
    }

    public enum EntityType: String, Codable { 
        case feedback = "Feedback"
        case document = "Document"
        case workspace = "Workspace"
        case tag = "Tag"
        case accessToken = "AccessToken"
        case oauthclientauthorization = "OAuthClientAuthorization"
        case authOrganization = "AuthOrganization"
        case oauthclient = "OAuthClient"
        case authUser = "AuthUser"
        case organizationAuthorizationTrust = "OrganizationAuthorizationTrust"
        case organizationAuthorizationUserTrust = "OrganizationAuthorizationUserTrust"
        case role = "Role"
        case roleSettings = "RoleSettings"
        case voicemailUserPolicy = "VoicemailUserPolicy"
        case userPresence = "UserPresence"
        case dependencyTrackingBuild = "DependencyTrackingBuild"
        case flow = "Flow"
        case prompt = "Prompt"
        case promptResource = "PromptResource"
        case flowOutcome = "FlowOutcome"
        case flowMilestone = "FlowMilestone"
        case grammar = "Grammar"
        case grammarLanguage = "GrammarLanguage"
        case agentRoutingInfo = "AgentRoutingInfo"
        case queue = "Queue"
        case wrapupCode = "WrapupCode"
        case maxOrgRoutingUtilizationCapacity = "MaxOrgRoutingUtilizationCapacity"
        case conversationAttributes = "ConversationAttributes"
        case routingUtilizationTag = "RoutingUtilizationTag"
        case evaluation = "Evaluation"
        case calibration = "Calibration"
        case survey = "Survey"
        case evaluationForm = "EvaluationForm"
        case surveyForm = "SurveyForm"
        case recording = "Recording"
        case screenRecording = "ScreenRecording"
        case bulkActions = "BulkActions"
        case orphanedRecording = "OrphanedRecording"
        case policy = "Policy"
        case recordingAnnotation = "RecordingAnnotation"
        case recordingSettings = "RecordingSettings"
        case recordingKey = "RecordingKey"
        case recordingKeyConfig = "RecordingKeyConfig"
        case topic = "Topic"
        case program = "Program"
        case category = "Category"
        case sentimentFeedback = "SentimentFeedback"
        case dictionaryFeedback = "DictionaryFeedback"
        case segment = "Segment"
        case outcome = "Outcome"
        case actionMap = "ActionMap"
        case actionTemplate = "ActionTemplate"
        case clickstreamSettings = "ClickstreamSettings"
        case eventType = "EventType"
        case sessionType = "SessionType"
        case knowledgeBase = "KnowledgeBase"
        case knowledgeCategory = "KnowledgeCategory"
        case knowledgeContext = "KnowledgeContext"
        case knowledgeContextValue = "KnowledgeContextValue"
        case knowledgeDocument = "KnowledgeDocument"
        case knowledgeDocumentVariation = "KnowledgeDocumentVariation"
        case knowledgeLabel = "KnowledgeLabel"
        case knowledgeTraining = "KnowledgeTraining"
        case knowledgeSearchFeedback = "KnowledgeSearchFeedback"
        case transcriptionSettings = "TranscriptionSettings"
        case speechTextAnalyticsSettings = "SpeechTextAnalyticsSettings"
        case appointment = "Appointment"
        case annotation = "Annotation"
        case organization = "Organization"
        case module = "Module"
        case rule = "Rule"
        case assignment = "Assignment"
        case activityCode = "ActivityCode"
        case adherenceExplanation = "AdherenceExplanation"
        case businessUnit = "BusinessUnit"
        case forecast = "Forecast"
        case managementUnit = "ManagementUnit"
        case planningGroup = "PlanningGroup"
        case schedule = "Schedule"
        case serviceGoalTemplate = "ServiceGoalTemplate"
        case shiftTrade = "ShiftTrade"
        case timeOffLimit = "TimeOffLimit"
        case timeOffPlan = "TimeOffPlan"
        case timeOffRequest = "TimeOffRequest"
        case workPlan = "WorkPlan"
        case workPlanRotation = "WorkPlanRotation"
        case historicalData = "HistoricalData"
        case staffingGroup = "StaffingGroup"
        case trigger = "Trigger"
        case response = "Response"
        case responseAsset = "ResponseAsset"
        case skillGroup = "SkillGroup"
        case directoryGroup = "DirectoryGroup"
        case team = "Team"
        case skillGroupDefinition = "SkillGroupDefinition"
        case edge = "Edge"
        case edgeGroup = "EdgeGroup"
        case voicemailPolicy = "VoicemailPolicy"
        case routingTranscriptionSettings = "RoutingTranscriptionSettings"
        case trunk = "Trunk"
        case trunkBase = "TrunkBase"
        case scheduleGroup = "ScheduleGroup"
        case emergencyGroup = "EmergencyGroup"
        case ivr = "IVR"
        case did = "DID"
        case didpool = "DIDPool"
        case _extension = "Extension"
        case extensionPool = "ExtensionPool"
        case phone = "Phone"
        case phoneBase = "PhoneBase"
        case line = "Line"
        case lineBase = "LineBase"
        case outboundRoute = "OutboundRoute"
        case numberPlan = "NumberPlan"
        case site = "Site"
        case attemptLimits = "AttemptLimits"
        case callableTimeSet = "CallableTimeSet"
        case campaign = "Campaign"
        case campaignRule = "CampaignRule"
        case campaignSchedule = "CampaignSchedule"
        case sequence = "Sequence"
        case sequenceSchedule = "SequenceSchedule"
        case contactList = "ContactList"
        case contactListFilter = "ContactListFilter"
        case contactListTemplate = "ContactListTemplate"
        case digitalRuleSet = "DigitalRuleSet"
        case dnclist = "DNCList"
        case fileSpecificationTemplate = "FileSpecificationTemplate"
        case importTemplate = "ImportTemplate"
        case organizationSettings = "OrganizationSettings"
        case callAnalysisResponseSet = "CallAnalysisResponseSet"
        case ruleSet = "RuleSet"
        case wrapUpCodeMapping = "WrapUpCodeMapping"
        case messagingCampaign = "MessagingCampaign"
        case messagingCampaignSchedule = "MessagingCampaignSchedule"
        case emailCampaignSchedule = "EmailCampaignSchedule"
        case predictor = "Predictor"
        case kpiSpecification = "KpiSpecification"
        case metric = "Metric"
        case status = "Status"
        case profile = "Profile"
        case profileMembers = "ProfileMembers"
        case action = "Action"
        case actionDraft = "ActionDraft"
        case integration = "Integration"
        case webhook = "Webhook"
        case dashboardSettings = "DashboardSettings"
        case insightSettings = "InsightSettings"
        case analyticsReportingSettings = "AnalyticsReportingSettings"
        case scheduledExports = "ScheduledExports"
        case exports = "Exports"
        case changeRequest = "ChangeRequest"
        case migration = "Migration"
        case externalMetricsDefinition = "ExternalMetricsDefinition"
        case externalMetricsData = "ExternalMetricsData"
        case schema = "Schema"
        case row = "Row"
        case bulk = "Bulk"
        case supportedContent = "SupportedContent"
        case conversationPhoneNumber = "ConversationPhoneNumber"
        case conversationRecipient = "ConversationRecipient"
        case conversationAccount = "ConversationAccount"
        case conversationDefaultSupportedContent = "ConversationDefaultSupportedContent"
        case conversationThreadingWindow = "ConversationThreadingWindow"
        case deployment = "Deployment"
        case configuration = "Configuration"
        case configurationVersion = "ConfigurationVersion"
        case edgePreferences = "EdgePreferences"
        case edgeTraceLevel = "EdgeTraceLevel"
        case organizationIntegrationsAccess = "OrganizationIntegrationsAccess"
        case supportFile = "SupportFile"
        case edgeLogZip = "EdgeLogZip"
        case pcaps = "Pcaps"
        case mediaDiagnosticsTraceFile = "MediaDiagnosticsTraceFile"
        case edgePcaps = "EdgePcaps"
        case edgeLog = "EdgeLog"
        case organizationFeature = "OrganizationFeature"
        case product = "Product"
        case user = "User"
        case location = "Location"
        case conversation = "Conversation"
        case organizationSuspension = "OrganizationSuspension"
        case participant = "Participant"
        case contactSchema = "ContactSchema"
        case externalOrganizationSchema = "ExternalOrganizationSchema"
        case workbin = "Workbin"
        case worktype = "Worktype"
        case credential = "Credential"
        case numberOrder = "NumberOrder"
        case enterpriseAgreement = "EnterpriseAgreement"
        case gdprRequest = "GdprRequest"
        case defaultPanelSettings = "DefaultPanelSettings"
        case inboundDomain = "InboundDomain"
        case outboundDomain = "OutboundDomain"
        case inboundRoute = "InboundRoute"
        case organizationLimits = "OrganizationLimits"
        case userSkill = "UserSkill"
        case userLanguage = "UserLanguage"
        case composerPage = "ComposerPage"
        case composerPublishedScript = "ComposerPublishedScript"
        case composerScript = "ComposerScript"
        case composerTemplate = "ComposerTemplate"
        case intentMiner = "IntentMiner"
        case topicMiner = "TopicMiner"
        case softSuspension = "SoftSuspension"
        case activityPlan = "ActivityPlan"
        case activityPlanOccurrence = "ActivityPlanOccurrence"
        case journeyView = "JourneyView"
        case alternativeShiftTrade = "AlternativeShiftTrade"
    }







    public var _id: String?
    public var userId: String?
    public var userHomeOrgId: String?
    public var username: AuditTopicDomainEntityRef?
    public var userDisplay: String?
    public var clientId: AuditTopicAddressableEntityRef?
    public var remoteIp: [String]?
    public var serviceName: ServiceName?
    public var level: String?
    public var eventTime: Date?
    public var message: AuditTopicMessageInfo?
    public var action: Action?
    public var entityType: EntityType?
    public var entity: AuditTopicDomainEntityRef?
    public var propertyChanges: [AuditTopicPropertyChange]?
    public var context: [String:String]?

    public init(_id: String?, userId: String?, userHomeOrgId: String?, username: AuditTopicDomainEntityRef?, userDisplay: String?, clientId: AuditTopicAddressableEntityRef?, remoteIp: [String]?, serviceName: ServiceName?, level: String?, eventTime: Date?, message: AuditTopicMessageInfo?, action: Action?, entityType: EntityType?, entity: AuditTopicDomainEntityRef?, propertyChanges: [AuditTopicPropertyChange]?, context: [String:String]?) {
        self._id = _id
        self.userId = userId
        self.userHomeOrgId = userHomeOrgId
        self.username = username
        self.userDisplay = userDisplay
        self.clientId = clientId
        self.remoteIp = remoteIp
        self.serviceName = serviceName
        self.level = level
        self.eventTime = eventTime
        self.message = message
        self.action = action
        self.entityType = entityType
        self.entity = entity
        self.propertyChanges = propertyChanges
        self.context = context
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case userId
        case userHomeOrgId
        case username
        case userDisplay
        case clientId
        case remoteIp
        case serviceName
        case level
        case eventTime
        case message
        case action
        case entityType
        case entity
        case propertyChanges
        case context
    }


}




public class AuditTopicDomainEntityRef: Codable {







    public var _id: String?
    public var name: String?
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}



/** Settings for authenticated webdeployments. */

public class AuthenticationSettings: Codable {







    /** Indicate if these auth is required for this deployment. If, for example, this flag is set to true then webmessaging sessions can not send messages unless the end-user is authenticated. */
    public var enabled: Bool?
    /** The integration identifier which contains the auth settings required on the deployment. */
    public var integrationId: String?
    /** Allow end-users to upgrade an anonymous session to authenticated conversation. */
    public var allowSessionUpgrade: Bool?

    public init(enabled: Bool?, integrationId: String?, allowSessionUpgrade: Bool?) {
        self.enabled = enabled
        self.integrationId = integrationId
        self.allowSessionUpgrade = allowSessionUpgrade
    }


}




public class AuthzDivision: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** A helpful description for the division. */
    public var _description: String?
    /** A flag indicating whether this division is the \"Home\" (default) division. Cannot be modified and any supplied value will be ignored on create or update. */
    public var homeDivision: Bool?
    /** A count of objects in this division, grouped by type. */
    public var objectCounts: [String:Int64]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, homeDivision: Bool?, objectCounts: [String:Int64]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.homeDivision = homeDivision
        self.objectCounts = objectCounts
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case homeDivision
        case objectCounts
        case selfUri
    }


}




public class AuthzDivisionGrantEntityListing: Codable {











    public var entities: [AuthzGrant]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var pageCount: Int?

    public init(entities: [AuthzGrant]?, pageSize: Int?, pageNumber: Int?, total: Int64?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.pageCount = pageCount
    }


}




public class AuthzGrantPolicy: Codable {









    public var actions: [String]?
    public var condition: String?
    public var domain: String?
    public var entityName: String?

    public init(actions: [String]?, condition: String?, domain: String?, entityName: String?) {
        self.actions = actions
        self.condition = condition
        self.domain = domain
        self.entityName = entityName
    }


}




public class AutomaticTimeZoneMappingSettings: Codable {





    /** The time intervals to use for automatic time zone mapping. */
    public var callableWindows: [CallableWindow]?
    /** The countries that are supported for automatic time zone mapping. */
    public var supportedCountries: [String]?

    public init(callableWindows: [CallableWindow]?, supportedCountries: [String]?) {
        self.callableWindows = callableWindows
        self.supportedCountries = supportedCountries
    }


}




public class AvailableTime: Codable {







    public enum ActivityCategory: String, Codable { 
        case onQueueWork = "OnQueueWork"
        case _break = "Break"
        case meal = "Meal"
        case meeting = "Meeting"
        case offQueueWork = "OffQueueWork"
        case timeOff = "TimeOff"
        case training = "Training"
        case unavailable = "Unavailable"
    }



    /** Start of the availability period. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?
    /** Length of availability period in minutes */
    public var lengthInMinutes: Int?
    /** Indicates if this availability period is paid in Workforce Management schedule */
    public var isPaid: Bool?
    /** Workforce Management activity category for this availability period */
    public var activityCategory: ActivityCategory?
    /** Workforce Management schedule information associated with the available time */
    public var wfmSchedule: WfmScheduleReference?

    public init(dateStart: Date?, lengthInMinutes: Int?, isPaid: Bool?, activityCategory: ActivityCategory?, wfmSchedule: WfmScheduleReference?) {
        self.dateStart = dateStart
        self.lengthInMinutes = lengthInMinutes
        self.isPaid = isPaid
        self.activityCategory = activityCategory
        self.wfmSchedule = wfmSchedule
    }


}




public class AvailableTimeOffResponse: Codable {



    public var values: [AvailableTimeOffRange]?

    public init(values: [AvailableTimeOffRange]?) {
        self.values = values
    }


}



/** A maximum of 100 events are allowed per request */

public class BatchConversationEventRequest: Codable {





































    /** Voice - EndTransfer events for this batch */
    public var endTransferEvents: [EndTransferEvent]?
    /** Voice - PhoneTransfer events for this batch */
    public var phoneTransferEvents: [PhoneTransferEvent]?
    /** Voice - ProgressTransfer events for this batch */
    public var progressTransferEvents: [ProgressTransferEvent]?
    /** Voice - RoutingTransfer events for this batch */
    public var routingTransferEvents: [RoutingTransferEvent]?
    /** Voice - UserTransfer events for this batch */
    public var userTransferEvents: [UserTransferEvent]?
    /** Voice - CommunicationAnswered events for this batch */
    public var communicationAnsweredEvents: [CommunicationAnsweredEvent]?
    /** Voice - CommunicationDispositionApplied events for this batch */
    public var communicationDispositionAppliedEvents: [CommunicationDispositionAppliedEvent]?
    /** Voice - HoldUpdated events for this batch */
    public var holdUpdatedEvents: [HoldUpdatedEvent]?
    /** Voice - ExternalEstablished events for this batch */
    public var externalEstablishedEvents: [ExternalEstablishedEvent]?
    /** Voice - IvrEstablished events for this batch */
    public var ivrEstablishedEvents: [IvrEstablishedEvent]?
    /** Voice - PhoneEstablished events for this batch */
    public var phoneEstablishedEvents: [PhoneEstablishedEvent]?
    /** Voice - RoutingEstablished events for this batch */
    public var routingEstablishedEvents: [RoutingEstablishedEvent]?
    /** Voice - UserEstablished events for this batch */
    public var userEstablishedEvents: [UserEstablishedEvent]?
    /** Voice - AudioUpdated events for this batch */
    public var audioUpdatedEvents: [AudioUpdatedEvent]?
    /** Voice - CommunicationEnded events for this batch */
    public var communicationEndedEvents: [CommunicationEndedEvent]?
    /** Voice - ConsultTransfer events for this batch */
    public var consultTransferEvents: [ConsultTransferEvent]?
    /** Voice - ProgressConsultTransfer events for this batch */
    public var progressConsultTransferEvents: [ProgressConsultTransferEvent]?
    /** Voice - EndConsultTransfer events for this batch */
    public var endConsultTransferEvents: [EndConsultTransferEvent]?

    public init(endTransferEvents: [EndTransferEvent]?, phoneTransferEvents: [PhoneTransferEvent]?, progressTransferEvents: [ProgressTransferEvent]?, routingTransferEvents: [RoutingTransferEvent]?, userTransferEvents: [UserTransferEvent]?, communicationAnsweredEvents: [CommunicationAnsweredEvent]?, communicationDispositionAppliedEvents: [CommunicationDispositionAppliedEvent]?, holdUpdatedEvents: [HoldUpdatedEvent]?, externalEstablishedEvents: [ExternalEstablishedEvent]?, ivrEstablishedEvents: [IvrEstablishedEvent]?, phoneEstablishedEvents: [PhoneEstablishedEvent]?, routingEstablishedEvents: [RoutingEstablishedEvent]?, userEstablishedEvents: [UserEstablishedEvent]?, audioUpdatedEvents: [AudioUpdatedEvent]?, communicationEndedEvents: [CommunicationEndedEvent]?, consultTransferEvents: [ConsultTransferEvent]?, progressConsultTransferEvents: [ProgressConsultTransferEvent]?, endConsultTransferEvents: [EndConsultTransferEvent]?) {
        self.endTransferEvents = endTransferEvents
        self.phoneTransferEvents = phoneTransferEvents
        self.progressTransferEvents = progressTransferEvents
        self.routingTransferEvents = routingTransferEvents
        self.userTransferEvents = userTransferEvents
        self.communicationAnsweredEvents = communicationAnsweredEvents
        self.communicationDispositionAppliedEvents = communicationDispositionAppliedEvents
        self.holdUpdatedEvents = holdUpdatedEvents
        self.externalEstablishedEvents = externalEstablishedEvents
        self.ivrEstablishedEvents = ivrEstablishedEvents
        self.phoneEstablishedEvents = phoneEstablishedEvents
        self.routingEstablishedEvents = routingEstablishedEvents
        self.userEstablishedEvents = userEstablishedEvents
        self.audioUpdatedEvents = audioUpdatedEvents
        self.communicationEndedEvents = communicationEndedEvents
        self.consultTransferEvents = consultTransferEvents
        self.progressConsultTransferEvents = progressConsultTransferEvents
        self.endConsultTransferEvents = endConsultTransferEvents
    }


}




public class BatchDownloadJobSubmissionResult: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class BatchDownloadRequest: Codable {





    /** Conversation id requested */
    public var conversationId: String?
    /** Recording id requested, optional.  Leave null for all recordings on the conversation */
    public var recordingId: String?

    public init(conversationId: String?, recordingId: String?) {
        self.conversationId = conversationId
        self.recordingId = recordingId
    }


}




public class BenefitAssessmentJob: Codable {



    public enum State: String, Codable { 
        case created = "Created"
        case finished = "Finished"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** State of the benefit assessment job. */
    public var state: State?
    /** Creation Date of the benefit assessment job. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Modified Date of the benefit assessment job. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, state: State?, dateCreated: Date?, dateModified: Date?, selfUri: String?) {
        self._id = _id
        self.state = state
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case dateCreated
        case dateModified
        case selfUri
    }


}




public class BillingUsage: Codable {







    /** Identifies the billable usage. */
    public var name: String?
    /** The total amount of usage, expressed as a decimal number in string format. */
    public var totalUsage: String?
    /** The resources for which usage was observed (e.g. license users, devices). */
    public var resources: [BillingUsageResource]?

    public init(name: String?, totalUsage: String?, resources: [BillingUsageResource]?) {
        self.name = name
        self.totalUsage = totalUsage
        self.resources = resources
    }


}




public class BillingUsageResource: Codable {





    /** Identifies the resource (e.g. license user, device). */
    public var name: String?
    /** The date that the usage was first observed by the billing subsystem. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var date: Date?

    public init(name: String?, date: Date?) {
        self.name = name
        self.date = date
    }


}




public class BotFlowSession: Codable {











    public enum BotResult: String, Codable { 
        case unknown = "Unknown"
        case exitRequestedByUser = "ExitRequestedByUser"
        case exitRequestedByBot = "ExitRequestedByBot"
        case exitError = "ExitError"
        case exitRecognitionFailure = "ExitRecognitionFailure"
        case disconnectRequestedByUser = "DisconnectRequestedByUser"
        case disconnectRequestedByBot = "DisconnectRequestedByBot"
        case disconnectSessionExpired = "DisconnectSessionExpired"
        case disconnectError = "DisconnectError"
        case disconnectRecognitionFailure = "DisconnectRecognitionFailure"
        case transferToACD = "TransferToACD"
    }

    public enum BotResultCategory: String, Codable { 
        case unknown = "Unknown"
        case userExit = "UserExit"
        case botExit = "BotExit"
        case error = "Error"
        case recognitionFailure = "RecognitionFailure"
        case userDisconnect = "UserDisconnect"
        case botDisconnect = "BotDisconnect"
        case sessionExpired = "SessionExpired"
        case transfer = "Transfer"
    }





    /** The ID of the bot session. */
    public var _id: String?
    /** The flow associated to this bot session. */
    public var flow: Entity?
    /** Channel-specific information that describes the message channel/provider. */
    public var channel: BotChannel?
    /** The initial language of operation for the session. */
    public var language: String?
    /** The language of the session at the time the session ended */
    public var endLanguage: String?
    /** The reason for session termination. */
    public var botResult: BotResult?
    /** The category of result for the session. */
    public var botResultCategory: BotResultCategory?
    /** Timestamp indicating when the session was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The conversation details, across potentially multiple Bot Flow sessions. */
    public var conversation: AddressableEntityRef?

    public init(_id: String?, flow: Entity?, channel: BotChannel?, language: String?, endLanguage: String?, botResult: BotResult?, botResultCategory: BotResultCategory?, dateCreated: Date?, conversation: AddressableEntityRef?) {
        self._id = _id
        self.flow = flow
        self.channel = channel
        self.language = language
        self.endLanguage = endLanguage
        self.botResult = botResult
        self.botResultCategory = botResultCategory
        self.dateCreated = dateCreated
        self.conversation = conversation
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case flow
        case channel
        case language
        case endLanguage
        case botResult
        case botResultCategory
        case dateCreated
        case conversation
    }


}




public class BotMessengerProfile: Codable {





    /** Name of the Bot */
    public var name: String?
    /** Avatar for Bot */
    public var avatarUrl: String?

    public init(name: String?, avatarUrl: String?) {
        self.name = name
        self.avatarUrl = avatarUrl
    }


}



/** Description of a data value returned from an intent */

public class BotSlot: Codable {





    /** The name of the slot. This can be up to 100 characters long and must be comprised of displayable characters without leading or trailing whitespace */
    public var name: String?
    /** The data type of the slot string, integer, decimal, duration, boolean, currency, datetime or the xxxCollection versions of those types */
    public var type: String?

    public init(name: String?, type: String?) {
        self.name = name
        self.type = type
    }


}




public class BuAgentScheduleActivity: Codable {



















    public enum ExternalActivityType: String, Codable { 
        case activityPlan = "ActivityPlan"
        case coaching = "Coaching"
        case learning = "Learning"
    }

    /** The start date/time of this activity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** The length of this activity in minutes */
    public var lengthMinutes: Int?
    /** The description of this activity */
    public var _description: String?
    /** The ID of the activity code associated with this activity */
    public var activityCodeId: String?
    /** Whether this activity is paid */
    public var paid: Bool?
    /** Payable minutes for this activity */
    public var payableMinutes: Int?
    /** The ID of the time off request associated with this activity, if applicable */
    public var timeOffRequestId: String?
    /** The sync version of the partial day time off request for which the scheduled activity is associated, if applicable */
    public var timeOffRequestSyncVersion: Int?
    /** The ID of the external activity associated with this activity, if applicable */
    public var externalActivityId: String?
    /** The type of the external activity associated with this activity, if applicable */
    public var externalActivityType: ExternalActivityType?

    public init(startDate: Date?, lengthMinutes: Int?, _description: String?, activityCodeId: String?, paid: Bool?, payableMinutes: Int?, timeOffRequestId: String?, timeOffRequestSyncVersion: Int?, externalActivityId: String?, externalActivityType: ExternalActivityType?) {
        self.startDate = startDate
        self.lengthMinutes = lengthMinutes
        self._description = _description
        self.activityCodeId = activityCodeId
        self.paid = paid
        self.payableMinutes = payableMinutes
        self.timeOffRequestId = timeOffRequestId
        self.timeOffRequestSyncVersion = timeOffRequestSyncVersion
        self.externalActivityId = externalActivityId
        self.externalActivityType = externalActivityType
    }

    public enum CodingKeys: String, CodingKey { 
        case startDate
        case lengthMinutes
        case _description = "description"
        case activityCodeId
        case paid
        case payableMinutes
        case timeOffRequestId
        case timeOffRequestSyncVersion
        case externalActivityId
        case externalActivityType
    }


}




public class BuAgentScheduleRescheduleResponse: Codable {











    /** The user to whom this agent schedule applies */
    public var user: UserReference?
    /** The shift definitions for this agent schedule */
    public var shifts: [BuAgentScheduleShift]?
    /** Full day time off markers which apply to this agent schedule */
    public var fullDayTimeOffMarkers: [BuFullDayTimeOffMarker]?
    /** The work plan for this user */
    public var workPlan: WorkPlanReference?
    /** The work plans per week for this user from the work plan rotation. Null values in the list denotes that user is not part of any work plan for that week */
    public var workPlansPerWeek: [WorkPlanReference]?

    public init(user: UserReference?, shifts: [BuAgentScheduleShift]?, fullDayTimeOffMarkers: [BuFullDayTimeOffMarker]?, workPlan: WorkPlanReference?, workPlansPerWeek: [WorkPlanReference]?) {
        self.user = user
        self.shifts = shifts
        self.fullDayTimeOffMarkers = fullDayTimeOffMarkers
        self.workPlan = workPlan
        self.workPlansPerWeek = workPlansPerWeek
    }


}




public class BuAgentScheduleSearchResponse: Codable {







    /** The user to whom this agent schedule applies */
    public var user: UserReference?
    /** The shift definitions for this agent schedule */
    public var shifts: [BuAgentScheduleShift]?
    /** Full day time off markers which apply to this agent schedule */
    public var fullDayTimeOffMarkers: [BuFullDayTimeOffMarker]?

    public init(user: UserReference?, shifts: [BuAgentScheduleShift]?, fullDayTimeOffMarkers: [BuFullDayTimeOffMarker]?) {
        self.user = user
        self.shifts = shifts
        self.fullDayTimeOffMarkers = fullDayTimeOffMarkers
    }


}




public class BuAgentScheduleShift: Codable {













    /** The ID of the shift */
    public var _id: String?
    /** The start date of this shift. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** The length of this shift in minutes */
    public var lengthMinutes: Int?
    /** The activities associated with this shift */
    public var activities: [BuAgentScheduleActivity]?
    /** Whether this shift was manually edited. This is only set by clients and is used for rescheduling */
    public var manuallyEdited: Bool?
    /** The schedule to which this shift belongs */
    public var schedule: BuScheduleReference?

    public init(_id: String?, startDate: Date?, lengthMinutes: Int?, activities: [BuAgentScheduleActivity]?, manuallyEdited: Bool?, schedule: BuScheduleReference?) {
        self._id = _id
        self.startDate = startDate
        self.lengthMinutes = lengthMinutes
        self.activities = activities
        self.manuallyEdited = manuallyEdited
        self.schedule = schedule
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case startDate
        case lengthMinutes
        case activities
        case manuallyEdited
        case schedule
    }


}




public class BuAgentSchedulesSearchResponse: Codable {







    /** The requested agent schedules */
    public var agentSchedules: [BuAgentScheduleSearchResponse]?
    /** The time zone configured for the business unit to which this schedule applies */
    public var businessUnitTimeZone: String?
    /** References to all published week schedules overlapping the start/end date query parameters */
    public var publishedSchedules: [BuAgentSchedulePublishedScheduleReference]?

    public init(agentSchedules: [BuAgentScheduleSearchResponse]?, businessUnitTimeZone: String?, publishedSchedules: [BuAgentSchedulePublishedScheduleReference]?) {
        self.agentSchedules = agentSchedules
        self.businessUnitTimeZone = businessUnitTimeZone
        self.publishedSchedules = publishedSchedules
    }


}




public class BuAsyncAgentSchedulesSearchResponse: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }









    /** The status of the operation */
    public var status: Status?
    /** The ID for the operation */
    public var operationId: String?
    /** The result of the operation.  Null unless status == Complete */
    public var result: BuAgentSchedulesSearchResponse?
    /** Percent progress for the operation */
    public var progress: Int?
    /** The URL from which to download the result if it is too large to pass directly */
    public var downloadUrl: String?

    public init(status: Status?, operationId: String?, result: BuAgentSchedulesSearchResponse?, progress: Int?, downloadUrl: String?) {
        self.status = status
        self.operationId = operationId
        self.result = result
        self.progress = progress
        self.downloadUrl = downloadUrl
    }


}




public class BuForecastGenerationResult: Codable {



    /** Generation results, broken down by planning group */
    public var planningGroupResults: [BuForecastGenerationPlanningGroupResult]?

    public init(planningGroupResults: [BuForecastGenerationPlanningGroupResult]?) {
        self.planningGroupResults = planningGroupResults
    }


}




public class BuForecastModificationResponse: Codable {

    public enum ModelType: String, Codable { 
        case minimumPerInterval = "MinimumPerInterval"
        case maximumPerInterval = "MaximumPerInterval"
        case setValuePerInterval = "SetValuePerInterval"
        case changeValuePerInterval = "ChangeValuePerInterval"
        case changePercentPerInterval = "ChangePercentPerInterval"
        case setValueOverRange = "SetValueOverRange"
        case changeValueOverRange = "ChangeValueOverRange"
        case setValuesForIntervalSet = "SetValuesForIntervalSet"
        case setMultiGranularityValuesForIntervalSet = "SetMultiGranularityValuesForIntervalSet"
    }





    public enum Metric: String, Codable { 
        case offered = "Offered"
        case averageHandleTimeSeconds = "AverageHandleTimeSeconds"
    }

    public enum LegacyMetric: String, Codable { 
        case averageAfterCallWorkTimeSeconds = "AverageAfterCallWorkTimeSeconds"
        case averageHandleTimeSeconds = "AverageHandleTimeSeconds"
        case averageTalkTimeSeconds = "AverageTalkTimeSeconds"
        case offered = "Offered"
    }

















    /** The type of the modification */
    public var type: ModelType?
    /** The number of intervals past referenceStartDate representing the first interval to which this modification applies */
    public var startIntervalIndex: Int?
    /** The number of intervals past referenceStartDate representing the last interval to which this modification applies */
    public var endIntervalIndex: Int?
    /** The metric to which this modification applies */
    public var metric: Metric?
    /** The legacy metric to which this modification applies if applicable */
    public var legacyMetric: LegacyMetric?
    /** The value of the modification */
    public var value: Double?
    /** The list of modification values. Only applicable for grid-type modifications */
    public var values: [WfmForecastModificationIntervalOffsetValue]?
    /** The list of modification secondary values. Only applicable for multi granularity modifications */
    public var secondaryValues: [WfmForecastModificationIntervalOffsetValue]?
    /** The client side display granularity of the modification, expressed in the ISO-8601 duration format. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H */
    public var displayGranularity: String?
    /** The actual granularity of the modification as stored behind the scenes, expressed in the ISO-8601 duration format. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H */
    public var granularity: String?
    /** The granularity of the 'secondaryValues' modification as stored behind the scenes, expressed in the ISO-8601 duration format. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H */
    public var secondaryGranularity: String?
    /** Whether the modification is enabled for the forecast */
    public var enabled: Bool?
    /** The IDs of the planning groups to which this forecast modification applies */
    public var planningGroupIds: [String]?

    public init(type: ModelType?, startIntervalIndex: Int?, endIntervalIndex: Int?, metric: Metric?, legacyMetric: LegacyMetric?, value: Double?, values: [WfmForecastModificationIntervalOffsetValue]?, secondaryValues: [WfmForecastModificationIntervalOffsetValue]?, displayGranularity: String?, granularity: String?, secondaryGranularity: String?, enabled: Bool?, planningGroupIds: [String]?) {
        self.type = type
        self.startIntervalIndex = startIntervalIndex
        self.endIntervalIndex = endIntervalIndex
        self.metric = metric
        self.legacyMetric = legacyMetric
        self.value = value
        self.values = values
        self.secondaryValues = secondaryValues
        self.displayGranularity = displayGranularity
        self.granularity = granularity
        self.secondaryGranularity = secondaryGranularity
        self.enabled = enabled
        self.planningGroupIds = planningGroupIds
    }


}




public class BuHeadcountForecastResponse: Codable {





    /** The headcount forecast, null when downloadUrl is provided */
    public var result: BuHeadcountForecast?
    /** Download URL.  Null unless the response is too large to pass directly through the api */
    public var downloadUrl: String?

    public init(result: BuHeadcountForecast?, downloadUrl: String?) {
        self.result = result
        self.downloadUrl = downloadUrl
    }


}




public class BuRescheduleRequest: Codable {



















    /** The start of the range to reschedule.  Defaults to the beginning of the schedule. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** The end of the range to reschedule.  Defaults the the end of the schedule. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endDate: Date?
    /** The IDs of the agents to consider for rescheduling.  Omit to consider all agents in the specified management units.Agents not in the specified management units will be ignored */
    public var agentIds: [String]?
    /** The IDs of the activity codes to consider for rescheduling.  Omit to consider all activity codes */
    public var activityCodeIds: [String]?
    /** The IDs of the management units to reschedule */
    public var managementUnitIds: [String]?
    /** Instructs the scheduler whether it is allowed to change weekly paid time */
    public var doNotChangeWeeklyPaidTime: Bool?
    /** Instructs the scheduler whether it is allowed to change daily paid time */
    public var doNotChangeDailyPaidTime: Bool?
    /** Instructs the scheduler whether it is allowed to change shift start times */
    public var doNotChangeShiftStartTimes: Bool?
    /** Instructs the scheduler whether it is allowed to change manually edited shifts */
    public var doNotChangeManuallyEditedShifts: Bool?

    public init(startDate: Date?, endDate: Date?, agentIds: [String]?, activityCodeIds: [String]?, managementUnitIds: [String]?, doNotChangeWeeklyPaidTime: Bool?, doNotChangeDailyPaidTime: Bool?, doNotChangeShiftStartTimes: Bool?, doNotChangeManuallyEditedShifts: Bool?) {
        self.startDate = startDate
        self.endDate = endDate
        self.agentIds = agentIds
        self.activityCodeIds = activityCodeIds
        self.managementUnitIds = managementUnitIds
        self.doNotChangeWeeklyPaidTime = doNotChangeWeeklyPaidTime
        self.doNotChangeDailyPaidTime = doNotChangeDailyPaidTime
        self.doNotChangeShiftStartTimes = doNotChangeShiftStartTimes
        self.doNotChangeManuallyEditedShifts = doNotChangeManuallyEditedShifts
    }


}




public class BuScheduleListing: Codable {



    public var entities: [BuScheduleListItem]?

    public init(entities: [BuScheduleListItem]?) {
        self.entities = entities
    }


}




public class BulkContactsResponse: Codable {







    public var results: [BulkResponseResultExternalContactExternalContact]?
    public var errorCount: Int?
    public var errorIndexes: [Int]?

    public init(results: [BulkResponseResultExternalContactExternalContact]?, errorCount: Int?, errorIndexes: [Int]?) {
        self.results = results
        self.errorCount = errorCount
        self.errorIndexes = errorIndexes
    }


}




public class BulkErrorExternalContact: Codable {













    public var code: String?
    public var message: String?
    public var status: Int?
    public var retryable: Bool?
    public var entity: ExternalContact?
    public var details: [BulkErrorDetail]?

    public init(code: String?, message: String?, status: Int?, retryable: Bool?, entity: ExternalContact?, details: [BulkErrorDetail]?) {
        self.code = code
        self.message = message
        self.status = status
        self.retryable = retryable
        self.entity = entity
        self.details = details
    }


}




public class BulkErrorNote: Codable {













    public var code: String?
    public var message: String?
    public var status: Int?
    public var retryable: Bool?
    public var entity: Note?
    public var details: [BulkErrorDetail]?

    public init(code: String?, message: String?, status: Int?, retryable: Bool?, entity: Note?, details: [BulkErrorDetail]?) {
        self.code = code
        self.message = message
        self.status = status
        self.retryable = retryable
        self.entity = entity
        self.details = details
    }


}




public class BulkErrorRelationship: Codable {













    public var code: String?
    public var message: String?
    public var status: Int?
    public var retryable: Bool?
    public var entity: Relationship?
    public var details: [BulkErrorDetail]?

    public init(code: String?, message: String?, status: Int?, retryable: Bool?, entity: Relationship?, details: [BulkErrorDetail]?) {
        self.code = code
        self.message = message
        self.status = status
        self.retryable = retryable
        self.entity = entity
        self.details = details
    }


}




public class BulkFetchContactsResponse: Codable {







    public var results: [BulkResponseResultExternalContactEntity]?
    public var errorCount: Int?
    public var errorIndexes: [Int]?

    public init(results: [BulkResponseResultExternalContactEntity]?, errorCount: Int?, errorIndexes: [Int]?) {
        self.results = results
        self.errorCount = errorCount
        self.errorIndexes = errorIndexes
    }


}




public class BulkFetchNotesResponse: Codable {







    public var results: [BulkResponseResultNoteEntity]?
    public var errorCount: Int?
    public var errorIndexes: [Int]?

    public init(results: [BulkResponseResultNoteEntity]?, errorCount: Int?, errorIndexes: [Int]?) {
        self.results = results
        self.errorCount = errorCount
        self.errorIndexes = errorIndexes
    }


}




public class BulkFetchRelationshipsResponse: Codable {







    public var results: [BulkResponseResultRelationshipEntity]?
    public var errorCount: Int?
    public var errorIndexes: [Int]?

    public init(results: [BulkResponseResultRelationshipEntity]?, errorCount: Int?, errorIndexes: [Int]?) {
        self.results = results
        self.errorCount = errorCount
        self.errorIndexes = errorIndexes
    }


}




public class BulkIdsRequest: Codable {



    public var entities: [WritableEntity]?

    public init(entities: [WritableEntity]?) {
        self.entities = entities
    }


}




public class BulkNotesResponse: Codable {







    public var results: [BulkResponseResultNoteNote]?
    public var errorCount: Int?
    public var errorIndexes: [Int]?

    public init(results: [BulkResponseResultNoteNote]?, errorCount: Int?, errorIndexes: [Int]?) {
        self.results = results
        self.errorCount = errorCount
        self.errorIndexes = errorIndexes
    }


}




public class BulkRelationshipsResponse: Codable {







    public var results: [BulkResponseResultRelationshipRelationship]?
    public var errorCount: Int?
    public var errorIndexes: [Int]?

    public init(results: [BulkResponseResultRelationshipRelationship]?, errorCount: Int?, errorIndexes: [Int]?) {
        self.results = results
        self.errorCount = errorCount
        self.errorIndexes = errorIndexes
    }


}




public class BulkResponseResultExternalContactExternalContact: Codable {









    public var _id: String?
    public var success: Bool?
    public var entity: ExternalContact?
    public var error: BulkErrorExternalContact?

    public init(_id: String?, success: Bool?, entity: ExternalContact?, error: BulkErrorExternalContact?) {
        self._id = _id
        self.success = success
        self.entity = entity
        self.error = error
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case success
        case entity
        case error
    }


}




public class BulkResponseResultNoteNote: Codable {









    public var _id: String?
    public var success: Bool?
    public var entity: Note?
    public var error: BulkErrorNote?

    public init(_id: String?, success: Bool?, entity: Note?, error: BulkErrorNote?) {
        self._id = _id
        self.success = success
        self.entity = entity
        self.error = error
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case success
        case entity
        case error
    }


}




public class BulkResponseResultRelationshipRelationship: Codable {









    public var _id: String?
    public var success: Bool?
    public var entity: Relationship?
    public var error: BulkErrorRelationship?

    public init(_id: String?, success: Bool?, entity: Relationship?, error: BulkErrorRelationship?) {
        self._id = _id
        self.success = success
        self.entity = entity
        self.error = error
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case success
        case entity
        case error
    }


}




public class BulkUpdateShiftTradeStateResultItem: Codable {



    public enum State: String, Codable { 
        case unmatched = "Unmatched"
        case matched = "Matched"
        case approved = "Approved"
        case denied = "Denied"
        case expired = "Expired"
        case canceled = "Canceled"
    }





    public enum FailureReason: String, Codable { 
        case initiatingAgentScheduleNotFound = "InitiatingAgentScheduleNotFound"
        case initiatingAgentShiftHasExternalActivities = "InitiatingAgentShiftHasExternalActivities"
        case initiatingAgentShiftNotFound = "InitiatingAgentShiftNotFound"
        case receivingAgentNotFound = "ReceivingAgentNotFound"
        case receivingAgentScheduleNotFound = "ReceivingAgentScheduleNotFound"
        case receivingAgentShiftHasExternalActivities = "ReceivingAgentShiftHasExternalActivities"
        case receivingAgentShiftNotFound = "ReceivingAgentShiftNotFound"
        case scheduleNotPublished = "ScheduleNotPublished"
        case transitionNotAllowed = "TransitionNotAllowed"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The state of the shift trade after the update request is processed */
    public var state: State?
    /** The user who reviewed the request, if applicable */
    public var reviewedBy: UserReference?
    /** The date the request was reviewed, if applicable. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var reviewedDate: Date?
    /** The reason the update failed, if applicable */
    public var failureReason: FailureReason?
    /** Version metadata for the shift trade */
    public var metadata: WfmVersionedEntityMetadata?

    public init(_id: String?, state: State?, reviewedBy: UserReference?, reviewedDate: Date?, failureReason: FailureReason?, metadata: WfmVersionedEntityMetadata?) {
        self._id = _id
        self.state = state
        self.reviewedBy = reviewedBy
        self.reviewedDate = reviewedDate
        self.failureReason = failureReason
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case reviewedBy
        case reviewedDate
        case failureReason
        case metadata
    }


}




public class BusinessUnitListItem: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Whether the user has authorization to interact with this business unit */
    public var authorized: Bool?
    /** The division to which this entity belongs. */
    public var division: DivisionReference?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, authorized: Bool?, division: DivisionReference?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.authorized = authorized
        self.division = division
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case authorized
        case division
        case selfUri
    }


}




public class BusinessUnitReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class BusinessUnitSettingsResponse: Codable {

    public enum StartDayOfWeek: String, Codable { 
        case sunday = "Sunday"
        case monday = "Monday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
        case thursday = "Thursday"
        case friday = "Friday"
        case saturday = "Saturday"
    }









    /** The start day of week for this business unit */
    public var startDayOfWeek: StartDayOfWeek?
    /** The time zone for this business unit, using the Olsen tz database format */
    public var timeZone: String?
    /** Short term forecasting settings */
    public var shortTermForecasting: BuShortTermForecastingSettings?
    /** Scheduling settings */
    public var scheduling: BuSchedulingSettingsResponse?
    /** Version metadata for this business unit */
    public var metadata: WfmVersionedEntityMetadata?

    public init(startDayOfWeek: StartDayOfWeek?, timeZone: String?, shortTermForecasting: BuShortTermForecastingSettings?, scheduling: BuSchedulingSettingsResponse?, metadata: WfmVersionedEntityMetadata?) {
        self.startDayOfWeek = startDayOfWeek
        self.timeZone = timeZone
        self.shortTermForecasting = shortTermForecasting
        self.scheduling = scheduling
        self.metadata = metadata
    }


}




public class CallHistoryConversationEntityListing: Codable {





















    public var entities: [CallHistoryConversation]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CallHistoryConversation]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CallMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case parked = "parked"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDonotdisturb = "endpoint.donotdisturb"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferDonotdisturb = "transfer.donotdisturb"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
    }





































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }















    public enum RecordingState: String, Codable { 
        case _none = "none"
        case active = "active"
        case paused = "paused"
    }



























    /** The unique participant ID. */
    public var _id: String?
    /** The display friendly name of the participant. */
    public var name: String?
    /** The participant address. */
    public var address: String?
    /** The time when this participant first joined the conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startTime: Date?
    /** The time when this participant went connected for this media (eg: video connected time). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** The time when this participant went disconnected for this media (eg: video disconnected time). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?
    /** The time when this participant's hold started. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startHoldTime: Date?
    /** The participant's purpose.  Values can be: 'agent', 'user', 'customer', 'external', 'acd', 'ivr */
    public var purpose: String?
    /** The participant's state.  Values can be: 'alerting', 'connected', 'disconnected', 'dialing', 'contacting */
    public var state: State?
    /** The participant's direction.  Values can be: 'inbound' or 'outbound' */
    public var direction: Direction?
    /** The reason the participant was disconnected from the conversation. */
    public var disconnectType: DisconnectType?
    /** Value is true when the participant is on hold. */
    public var held: Bool?
    /** Value is true when the participant requires wrap-up. */
    public var wrapupRequired: Bool?
    /** The wrap-up prompt indicating the type of wrap-up to be performed. */
    public var wrapupPrompt: String?
    /** List of roles this participant's media has had on the conversation, ie monitor, coach, etc */
    public var mediaRoles: [String]?
    /** The PureCloud user for this participant. */
    public var user: DomainEntityRef?
    /** The PureCloud queue for this participant. */
    public var queue: DomainEntityRef?
    /** The PureCloud team for this participant. */
    public var team: DomainEntityRef?
    /** A list of ad-hoc attributes for the participant. */
    public var attributes: [String:String]?
    /** If the conversation ends in error, contains additional error details. */
    public var errorInfo: ErrorInfo?
    /** The Engage script that should be used by this participant. */
    public var script: DomainEntityRef?
    /** The amount of time the participant has to complete wrap-up. */
    public var wrapupTimeoutMs: Int?
    /** Value is true when the participant has skipped wrap-up. */
    public var wrapupSkipped: Bool?
    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutMs: Int?
    /** The source provider for the communication. */
    public var provider: String?
    /** If this participant represents an external contact, then this will be the reference for the external contact. */
    public var externalContact: DomainEntityRef?
    /** If this participant represents an external org, then this will be the reference for the external org. */
    public var externalOrganization: DomainEntityRef?
    /** Wrapup for this participant, if it has been applied. */
    public var wrapup: Wrapup?
    /** The peer communication corresponding to a matching leg for this communication. */
    public var peer: String?
    /** The reason specifying why participant flagged the conversation. */
    public var flaggedReason: FlaggedReason?
    /** Journey System data/context that is applicable to this communication.  When used for historical purposes, the context should be immutable.  When null, there is no applicable Journey System context. */
    public var journeyContext: JourneyContext?
    /** Information on how a communication should be routed to an agent. */
    public var conversationRoutingData: ConversationRoutingData?
    /** The timestamp when this participant started after-call work. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAcwTime: Date?
    /** The timestamp when this participant ended after-call work. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endAcwTime: Date?
    /** Value is true when the call is muted. */
    public var muted: Bool?
    /** Value is true when the call is confined. */
    public var confined: Bool?
    /** Value is true when the call is being recorded. */
    public var recording: Bool?
    /** The state of the call recording. */
    public var recordingState: RecordingState?
    /** The group involved in the group ring call. */
    public var group: DomainEntityRef?
    /** The call ANI. */
    public var ani: String?
    /** The call DNIS. */
    public var dnis: String?
    /** The ID of the Content Management document if the call is a fax. */
    public var documentId: String?
    /** Extra fax information if the call is a fax. */
    public var faxStatus: FaxStatus?
    /** The ID of the participant being monitored when performing a call monitor. */
    public var monitoredParticipantId: String?
    /** The ID of the participant being coached when performing a call coach. */
    public var coachedParticipantId: String?
    /** If this participant barged in a participant's call, then this will be the id of the targeted participant. */
    public var bargedParticipantId: String?
    /** The ID of the consult transfer target participant when performing a consult transfer. */
    public var consultParticipantId: String?
    /** User-to-User information which maps to a SIP header field defined in RFC7433. UUI data is used in the Public Switched Telephone Network (PSTN) for use cases described in RFC6567. */
    public var uuiData: String?
    /** The timestamp when this participant was connected to the barge conference in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var bargedTime: Date?
    /** True when the recording of this call is in secure pause status. */
    public var securePause: Bool?
    /** Call resolution data for Dialer bulk make calls commands. */
    public var disposition: Disposition?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, mediaRoles: [String]?, user: DomainEntityRef?, queue: DomainEntityRef?, team: DomainEntityRef?, attributes: [String:String]?, errorInfo: ErrorInfo?, script: DomainEntityRef?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, alertingTimeoutMs: Int?, provider: String?, externalContact: DomainEntityRef?, externalOrganization: DomainEntityRef?, wrapup: Wrapup?, peer: String?, flaggedReason: FlaggedReason?, journeyContext: JourneyContext?, conversationRoutingData: ConversationRoutingData?, startAcwTime: Date?, endAcwTime: Date?, muted: Bool?, confined: Bool?, recording: Bool?, recordingState: RecordingState?, group: DomainEntityRef?, ani: String?, dnis: String?, documentId: String?, faxStatus: FaxStatus?, monitoredParticipantId: String?, coachedParticipantId: String?, bargedParticipantId: String?, consultParticipantId: String?, uuiData: String?, bargedTime: Date?, securePause: Bool?, disposition: Disposition?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.mediaRoles = mediaRoles
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.peer = peer
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.conversationRoutingData = conversationRoutingData
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.muted = muted
        self.confined = confined
        self.recording = recording
        self.recordingState = recordingState
        self.group = group
        self.ani = ani
        self.dnis = dnis
        self.documentId = documentId
        self.faxStatus = faxStatus
        self.monitoredParticipantId = monitoredParticipantId
        self.coachedParticipantId = coachedParticipantId
        self.bargedParticipantId = bargedParticipantId
        self.consultParticipantId = consultParticipantId
        self.uuiData = uuiData
        self.bargedTime = bargedTime
        self.securePause = securePause
        self.disposition = disposition
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case mediaRoles
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalOrganization
        case wrapup
        case peer
        case flaggedReason
        case journeyContext
        case conversationRoutingData
        case startAcwTime
        case endAcwTime
        case muted
        case confined
        case recording
        case recordingState
        case group
        case ani
        case dnis
        case documentId
        case faxStatus
        case monitoredParticipantId
        case coachedParticipantId
        case bargedParticipantId
        case consultParticipantId
        case uuiData
        case bargedTime
        case securePause
        case disposition
    }


}




public class CallToAction: Codable {





    public enum Target: String, Codable { 
        case blank = "Blank"
        case _self = "Self"
    }

    /** Text displayed on the call to action button. */
    public var text: String?
    /** URL to open when user clicks on the call to action button. */
    public var url: String?
    /** Where the URL should be opened when the user clicks on the call to action button. */
    public var target: Target?

    public init(text: String?, url: String?, target: Target?) {
        self.text = text
        self.url = url
        self.target = target
    }


}




public class CallableWindow: Codable {





    /** The time interval to place outbound calls, for contacts that can be mapped to a time zone. */
    public var mapped: AtzmTimeSlot?
    /** The time interval and time zone to place outbound calls, for contacts that cannot be mapped to a time zone. */
    public var unmapped: AtzmTimeSlotWithTimeZone?

    public init(mapped: AtzmTimeSlot?, unmapped: AtzmTimeSlotWithTimeZone?) {
        self.mapped = mapped
        self.unmapped = unmapped
    }


}




public class Callback: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case scheduled = "scheduled"
        case _none = "none"
    }





    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }



    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }













































    /** The connection state of this communication. */
    public var state: State?
    /** The initial connection state of this communication. */
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The time line of the participant's callback, divided into activity segments. */
    public var segments: [Segment]?
    /** The direction of the call */
    public var direction: Direction?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the callback was placed on hold in the cloud clock if the callback is currently on hold. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startHoldTime: Date?
    /** The preview data to be used when this callback is a Preview. */
    public var dialerPreview: DialerPreview?
    /** The voicemail data to be used when this callback is an ACD voicemail. */
    public var voicemail: Voicemail?
    /** The phone number(s) to use to place the callback. */
    public var callbackNumbers: [String]?
    /** The name of the user requesting a callback. */
    public var callbackUserName: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** True if the call for the callback uses external dialing. */
    public var externalCampaign: Bool?
    /** True if the ability to skip a callback should be enabled. */
    public var skipEnabled: Bool?
    /** The number of seconds before the system automatically places a call for a callback.  0 means the automatic placement is disabled. */
    public var timeoutSeconds: Int?
    /** The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAlertingTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var disconnectedTime: Date?
    /** The timestamp when this communication is scheduled in the provider clock. If this value is missing it indicates the callback will be placed immediately. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var callbackScheduledTime: Date?
    /** The id of the config for automatically placing the callback (and handling the disposition). If null, the callback will not be placed automatically but routed to an agent as per normal. */
    public var automatedCallbackConfigId: String?
    /** The source provider for the callback. */
    public var provider: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** Call wrap up or disposition data. */
    public var wrapup: Wrapup?
    /** After-call work for the communication. */
    public var afterCallWork: AfterCallWork?
    /** Indicates if after-call work is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** The phone number displayed to recipients of the phone call. The value should conform to the E164 format. */
    public var callerId: String?
    /** The name displayed to recipients of the phone call. */
    public var callerIdName: String?
    /** Represents the queue settings for this media type. */
    public var queueMediaSettings: ConversationQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _id: String?, segments: [Segment]?, direction: Direction?, held: Bool?, disconnectType: DisconnectType?, startHoldTime: Date?, dialerPreview: DialerPreview?, voicemail: Voicemail?, callbackNumbers: [String]?, callbackUserName: String?, scriptId: String?, externalCampaign: Bool?, skipEnabled: Bool?, timeoutSeconds: Int?, startAlertingTime: Date?, connectedTime: Date?, disconnectedTime: Date?, callbackScheduledTime: Date?, automatedCallbackConfigId: String?, provider: String?, peerId: String?, wrapup: Wrapup?, afterCallWork: AfterCallWork?, afterCallWorkRequired: Bool?, callerId: String?, callerIdName: String?, queueMediaSettings: ConversationQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.segments = segments
        self.direction = direction
        self.held = held
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.dialerPreview = dialerPreview
        self.voicemail = voicemail
        self.callbackNumbers = callbackNumbers
        self.callbackUserName = callbackUserName
        self.scriptId = scriptId
        self.externalCampaign = externalCampaign
        self.skipEnabled = skipEnabled
        self.timeoutSeconds = timeoutSeconds
        self.startAlertingTime = startAlertingTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.callbackScheduledTime = callbackScheduledTime
        self.automatedCallbackConfigId = automatedCallbackConfigId
        self.provider = provider
        self.peerId = peerId
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.callerId = callerId
        self.callerIdName = callerIdName
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case segments
        case direction
        case held
        case disconnectType
        case startHoldTime
        case dialerPreview
        case voicemail
        case callbackNumbers
        case callbackUserName
        case scriptId
        case externalCampaign
        case skipEnabled
        case timeoutSeconds
        case startAlertingTime
        case connectedTime
        case disconnectedTime
        case callbackScheduledTime
        case automatedCallbackConfigId
        case provider
        case peerId
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case callerId
        case callerIdName
        case queueMediaSettings
    }


}




public class CallbackConversation: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The list of participants involved in the conversation. */
    public var participants: [CallbackMediaParticipant]?
    /** The list of other media channels involved in the conversation. */
    public var otherMediaUris: [String]?
    /** The list of the most recent 20 transfer commands applied to this conversation. */
    public var recentTransfers: [TransferResponse]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, participants: [CallbackMediaParticipant]?, otherMediaUris: [String]?, recentTransfers: [TransferResponse]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
        self.recentTransfers = recentTransfers
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
        case recentTransfers
        case selfUri
    }


}




public class Callmessage: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** raw SIP message */
    public var message: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, message: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.message = message
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case message
        case selfUri
    }


}




public class CampaignRuleActionEntities: Codable {







    /** The list of campaigns for a CampaignRule to monitor. Required if the CampaignRule has any conditions that run on a campaign. */
    public var campaigns: [DomainEntityRef]?
    /** The list of sequences for a CampaignRule to monitor. Required if the CampaignRule has any conditions that run on a sequence. */
    public var sequences: [DomainEntityRef]?
    /** If true, the CampaignRuleAction will apply to the same entity that triggered the CampaignRuleCondition. */
    public var useTriggeringEntity: Bool?

    public init(campaigns: [DomainEntityRef]?, sequences: [DomainEntityRef]?, useTriggeringEntity: Bool?) {
        self.campaigns = campaigns
        self.sequences = sequences
        self.useTriggeringEntity = useTriggeringEntity
    }


}




public class CategoryCreateRequest: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the category. */
    public var name: String?
    public var parentCategoryId: String?
    /** The description for the category. */
    public var _description: String?
    /** The external id associated with the category. */
    public var externalId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, parentCategoryId: String?, _description: String?, externalId: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.parentCategoryId = parentCategoryId
        self._description = _description
        self.externalId = externalId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case parentCategoryId
        case _description = "description"
        case externalId
        case selfUri
    }


}




public class CategoryReference: Codable {









    /** The globally unique identifier for the category. */
    public var _id: String?
    /** Category name. */
    public var name: String?
    /** The reference to category to which this category belongs to. */
    public var parentCategory: CategoryReference?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, parentCategory: CategoryReference?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.parentCategory = parentCategory
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case parentCategory
        case selfUri
    }


}




public class CategoryUpdateRequest: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the category. */
    public var name: String?
    /** The category to which this category belongs. */
    public var parentCategoryId: String?
    public var _description: String?
    /** The external id associated with the category. */
    public var externalId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, parentCategoryId: String?, _description: String?, externalId: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.parentCategoryId = parentCategoryId
        self._description = _description
        self.externalId = externalId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case parentCategoryId
        case _description = "description"
        case externalId
        case selfUri
    }


}




public class ChangeMyPasswordRequest: Codable {





    /** The new password */
    public var newPassword: String?
    /** Your current password */
    public var oldPassword: String?

    public init(newPassword: String?, oldPassword: String?) {
        self.newPassword = newPassword
        self.oldPassword = oldPassword
    }


}




public class ChatBadgeTopicBadgeEntity: Codable {



    public var jabberId: String?

    public init(jabberId: String?) {
        self.jabberId = jabberId
    }


}




public class ChatConversationEntityListing: Codable {





















    public var entities: [ChatConversation]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ChatConversation]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** Details for a ClientApp */

public class ClientApp: Codable {









    public enum IntendedState: String, Codable { 
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        case deleted = "DELETED"
        case restored = "RESTORED"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the integration, used to distinguish this integration from others of the same type. */
    public var name: String?
    /** Type of the integration */
    public var integrationType: IntegrationType?
    /** Notes about the integration. */
    public var notes: String?
    /** Configured state of the integration. */
    public var intendedState: IntendedState?
    /** Configuration information for the integration. */
    public var config: ClientAppConfigurationInfo?
    /** Last reported status of the integration. */
    public var reportedState: IntegrationStatusInfo?
    /** Read-only attributes for the integration. */
    public var attributes: [String:String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, integrationType: IntegrationType?, notes: String?, intendedState: IntendedState?, config: ClientAppConfigurationInfo?, reportedState: IntegrationStatusInfo?, attributes: [String:String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.integrationType = integrationType
        self.notes = notes
        self.intendedState = intendedState
        self.config = config
        self.reportedState = reportedState
        self.attributes = attributes
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case integrationType
        case notes
        case intendedState
        case config
        case reportedState
        case attributes
        case selfUri
    }


}




public class CloseButtonStyleProperties: Codable {





    /** Color of button. (eg. #FF0000) */
    public var color: String?
    /** Opacity of button. */
    public var opacity: Float?

    public init(color: String?, opacity: Float?) {
        self.color = color
        self.opacity = opacity
    }


}




public class CoachingAppointmentAggregateRequest: Codable {



    public enum Metrics: String, Codable { 
        case nactivities = "nActivities"
        case nplannedactivities = "nPlannedActivities"
        case ninprogressactivities = "nInProgressActivities"
        case ncompleteactivities = "nCompleteActivities"
        case noverdueactivities = "nOverdueActivities"
        case ninvalidscheduleactivities = "nInvalidScheduleActivities"
    }

    public enum GroupBy: String, Codable { 
        case attendeeid = "attendeeId"
    }



    /** Interval to aggregate across. End date is not inclusive. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** A list of metrics to aggregate.  If omitted, all metrics are returned. */
    public var metrics: [Metrics]?
    /** An optional list of items by which to group the result data. */
    public var groupBy: [GroupBy]?
    /** The filter applied to the data */
    public var filter: QueryRequestFilter?

    public init(interval: String?, metrics: [Metrics]?, groupBy: [GroupBy]?, filter: QueryRequestFilter?) {
        self.interval = interval
        self.metrics = metrics
        self.groupBy = groupBy
        self.filter = filter
    }


}




public class CoachingAppointmentStatusResponseList: Codable {











    public var entities: [CoachingAppointmentStatusResponse]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var pageCount: Int?

    public init(entities: [CoachingAppointmentStatusResponse]?, pageSize: Int?, pageNumber: Int?, total: Int64?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.pageCount = pageCount
    }


}




public class CoachingNotification: Codable {







    public enum ActionType: String, Codable { 
        case create = "Create"
        case update = "Update"
        case delete = "Delete"
        case statusChange = "StatusChange"
    }

    public enum Relationship: String, Codable { 
        case attendee = "Attendee"
        case creator = "Creator"
        case facilitator = "Facilitator"
    }





    public enum Status: String, Codable { 
        case scheduled = "Scheduled"
        case inProgress = "InProgress"
        case completed = "Completed"
        case invalidSchedule = "InvalidSchedule"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the appointment for this notification. */
    public var name: String?
    /** Indicates if notification is read or unread */
    public var markedAsRead: Bool?
    /** Action causing the notification. */
    public var actionType: ActionType?
    /** The relationship of this user to this notification's appointment */
    public var relationship: Relationship?
    /** The start time of the appointment relating to this notification. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?
    /** The duration of the appointment on this notification */
    public var lengthInMinutes: Int?
    /** The status of the appointment for this notification */
    public var status: Status?
    /** The user of this notification */
    public var user: UserReference?
    /** The appointment */
    public var appointment: CoachingAppointmentResponse?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, markedAsRead: Bool?, actionType: ActionType?, relationship: Relationship?, dateStart: Date?, lengthInMinutes: Int?, status: Status?, user: UserReference?, appointment: CoachingAppointmentResponse?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.markedAsRead = markedAsRead
        self.actionType = actionType
        self.relationship = relationship
        self.dateStart = dateStart
        self.lengthInMinutes = lengthInMinutes
        self.status = status
        self.user = user
        self.appointment = appointment
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case markedAsRead
        case actionType
        case relationship
        case dateStart
        case lengthInMinutes
        case status
        case user
        case appointment
        case selfUri
    }


}




public class CoachingSlotsResponse: Codable {









    /** List of slots where coaching appointment can be scheduled */
    public var suggestedSlots: [CoachingSlot]?
    /** Periods of availability for attendees to schedule coaching appointment */
    public var attendeeSchedules: [UserAvailableTimes]?
    /** Periods of availability for facilitators to schedule coaching appointment */
    public var facilitatorSchedules: [UserAvailableTimes]?
    /** Detailed data for WFM scheduled activities */
    public var wfmScheduleActivities: [WfmScheduleActivity]?

    public init(suggestedSlots: [CoachingSlot]?, attendeeSchedules: [UserAvailableTimes]?, facilitatorSchedules: [UserAvailableTimes]?, wfmScheduleActivities: [WfmScheduleActivity]?) {
        self.suggestedSlots = suggestedSlots
        self.attendeeSchedules = attendeeSchedules
        self.facilitatorSchedules = facilitatorSchedules
        self.wfmScheduleActivities = wfmScheduleActivities
    }


}




public class CobrowseConversation: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The list of participants involved in the conversation. */
    public var participants: [CobrowseMediaParticipant]?
    /** The list of other media channels involved in the conversation. */
    public var otherMediaUris: [String]?
    /** The list of the most recent 20 transfer commands applied to this conversation. */
    public var recentTransfers: [TransferResponse]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, participants: [CobrowseMediaParticipant]?, otherMediaUris: [String]?, recentTransfers: [TransferResponse]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
        self.recentTransfers = recentTransfers
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
        case recentTransfers
        case selfUri
    }


}




public class ColumnStatus: Codable {



    /** Indicates whether or not an individual contact method column is contactable. */
    public var contactable: Bool?

    public init(contactable: Bool?) {
        self.contactable = contactable
    }


}




public class CommonAlert: Codable {







































    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The user who created the rule that triggered the alert. */
    public var user: UserReference?
    /** The properties of the rule that triggered the alert. */
    public var rule: AlertRuleProperties?
    /** The collection of notification methods and the ids of users who were notified by those methods. */
    public var notifications: [AlertNotification]?
    /** The timestamp of when the alert was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?
    /** The timestamp of when the alert ended. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateEnd: Date?
    /** Indicates if an alert is currently active. */
    public var active: Bool?
    /** Indicates if an alert has not been read. */
    public var unread: Bool?
    /** The amount of time to wait between notification. Time is in milliseconds. */
    public var waitBetweenNotificationMs: Int64?
    /** Flag indicating if the alert is in a muted state. */
    public var muted: Bool?
    /** Flag indicating if the alert is in a snoozed state. */
    public var snoozed: Bool?
    /** Timestamp of when the mute status of the alert should end. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateMutedUntil: Date?
    /** Timestamp of when the snooze status of the alert should end. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateSnoozedUntil: Date?
    /** The conditions that make up the rule. */
    public var conditions: CommonRuleConditions?
    /** The id of the conversation instance that caused the alert to trigger. */
    public var conversationId: String?
    /** Summary of the alert status of the entities defined in the conditions.  Is set when rule has instance-based or team member based rule predicates */
    public var alertSummary: AlertSummary?
    public var ruleUri: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, user: UserReference?, rule: AlertRuleProperties?, notifications: [AlertNotification]?, dateStart: Date?, dateEnd: Date?, active: Bool?, unread: Bool?, waitBetweenNotificationMs: Int64?, muted: Bool?, snoozed: Bool?, dateMutedUntil: Date?, dateSnoozedUntil: Date?, conditions: CommonRuleConditions?, conversationId: String?, alertSummary: AlertSummary?, ruleUri: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.user = user
        self.rule = rule
        self.notifications = notifications
        self.dateStart = dateStart
        self.dateEnd = dateEnd
        self.active = active
        self.unread = unread
        self.waitBetweenNotificationMs = waitBetweenNotificationMs
        self.muted = muted
        self.snoozed = snoozed
        self.dateMutedUntil = dateMutedUntil
        self.dateSnoozedUntil = dateSnoozedUntil
        self.conditions = conditions
        self.conversationId = conversationId
        self.alertSummary = alertSummary
        self.ruleUri = ruleUri
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case user
        case rule
        case notifications
        case dateStart
        case dateEnd
        case active
        case unread
        case waitBetweenNotificationMs
        case muted
        case snoozed
        case dateMutedUntil
        case dateSnoozedUntil
        case conditions
        case conversationId
        case alertSummary
        case ruleUri
        case selfUri
    }


}




public class CommonRuleContainer: Codable {





















    public var entities: [CommonRule]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CommonRule]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CommunicationDispositionAppliedEvent: Codable {















    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication */
    public var communicationId: String?
    /** The wrapup-code (V4 UUID) used to disposition this interaction. If this value is not provided the disposition is considered skipped. */
    public var code: String?
    /** Text entered by the agent to describe the interaction or disposition. Ignored if the disposition is considered skipped. */
    public var notes: String?
    /** The list of tags selected by the agent to describe the interaction or disposition. Ignored if the disposition is considered skipped. */
    public var tags: [String]?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, code: String?, notes: String?, tags: [String]?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.code = code
        self.notes = notes
        self.tags = tags
    }


}




public class ComplianceResponse: Codable {



    /** Message response */
    public var message: String?

    public init(message: String?) {
        self.message = message
    }


}




public class ConsultTransfer: Codable {

    public enum SpeakTo: String, Codable { 
        case destination = "DESTINATION"
        case object = "OBJECT"
        case both = "BOTH"
        case conference = "CONFERENCE"
    }





    /** Determines to whom the initiating participant is speaking. Defaults to DESTINATION */
    public var speakTo: SpeakTo?
    /** The user ID of the person who wants to talk before completing the transfer. Could be the same of the context user ID */
    public var consultingUserId: String?
    /** Destination phone number and name. */
    public var destination: Destination?

    public init(speakTo: SpeakTo?, consultingUserId: String?, destination: Destination?) {
        self.speakTo = speakTo
        self.consultingUserId = consultingUserId
        self.destination = destination
    }


}




public class ConsultTransferToAgent: Codable {

    public enum SpeakTo: String, Codable { 
        case destination = "DESTINATION"
        case object = "OBJECT"
        case both = "BOTH"
        case conference = "CONFERENCE"
    }







    /** Determines to whom the initiating participant is speaking. Defaults to DESTINATION */
    public var speakTo: SpeakTo?
    /** The user ID of the person who wants to talk before completing the transfer. Could be the same of the context user ID */
    public var consultingUserId: String?
    /** The id of the internal user. */
    public var userId: String?
    /** The name of the internal user. */
    public var userDisplayName: String?

    public init(speakTo: SpeakTo?, consultingUserId: String?, userId: String?, userDisplayName: String?) {
        self.speakTo = speakTo
        self.consultingUserId = consultingUserId
        self.userId = userId
        self.userDisplayName = userDisplayName
    }


}




public class ConsultTransferToExternal: Codable {

    public enum SpeakTo: String, Codable { 
        case destination = "DESTINATION"
        case object = "OBJECT"
        case both = "BOTH"
        case conference = "CONFERENCE"
    }





    /** Determines to whom the initiating participant is speaking. Defaults to DESTINATION */
    public var speakTo: SpeakTo?
    /** The user ID of the person who wants to talk before completing the transfer. Could be the same of the context user ID */
    public var consultingUserId: String?
    /** The address (like phone number) of the external contact. */
    public var address: String?

    public init(speakTo: SpeakTo?, consultingUserId: String?, address: String?) {
        self.speakTo = speakTo
        self.consultingUserId = consultingUserId
        self.address = address
    }


}




public class Contact: Codable {





    public enum MediaType: String, Codable { 
        case phone = "PHONE"
        case email = "EMAIL"
        case sms = "SMS"
    }

    public enum ModelType: String, Codable { 
        case primary = "PRIMARY"
        case work = "WORK"
        case work2 = "WORK2"
        case work3 = "WORK3"
        case work4 = "WORK4"
        case home = "HOME"
        case mobile = "MOBILE"
        case main = "MAIN"
        case other = "OTHER"
    }







    /** Email address or phone number for this contact type */
    public var address: String?
    /** Formatted version of the address property */
    public var display: String?
    public var mediaType: MediaType?
    public var type: ModelType?
    /** Use internal extension instead of address. Mutually exclusive with the address field. */
    public var _extension: String?
    public var countryCode: String?
    /** Integration tag value if this number is associated with an external integration. */
    public var integration: String?

    public init(address: String?, display: String?, mediaType: MediaType?, type: ModelType?, _extension: String?, countryCode: String?, integration: String?) {
        self.address = address
        self.display = display
        self.mediaType = mediaType
        self.type = type
        self._extension = _extension
        self.countryCode = countryCode
        self.integration = integration
    }

    public enum CodingKeys: String, CodingKey { 
        case address
        case display
        case mediaType
        case type
        case _extension = "extension"
        case countryCode
        case integration
    }


}




public class ContactAddress: Codable {













    public var address1: String?
    public var address2: String?
    public var city: String?
    public var state: String?
    public var postalCode: String?
    public var countryCode: String?

    public init(address1: String?, address2: String?, city: String?, state: String?, postalCode: String?, countryCode: String?) {
        self.address1 = address1
        self.address2 = address2
        self.city = city
        self.state = state
        self.postalCode = postalCode
        self.countryCode = countryCode
    }


}




public class ContactBulkSearchCriteria: Codable {



    public enum FilterType: String, Codable { 
        case and = "AND"
        case or = "OR"
    }

    /** Groups of conditions to filter the contacts by. */
    public var clauses: [ContactListFilterClause]?
    /** How to join clauses together. */
    public var filterType: FilterType?

    public init(clauses: [ContactListFilterClause]?, filterType: FilterType?) {
        self.clauses = clauses
        self.filterType = filterType
    }


}




public class ContactListDivisionView: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The names of the contact data columns. */
    public var columnNames: [String]?
    /** Indicates which columns are phone numbers. */
    public var phoneColumns: [ContactPhoneNumberColumn]?
    /** Indicates which columns are email addresses. */
    public var emailColumns: [EmailColumn]?
    /** The status of the import process. */
    public var importStatus: ImportStatus?
    /** The number of contacts in the ContactList. */
    public var size: Int64?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, columnNames: [String]?, phoneColumns: [ContactPhoneNumberColumn]?, emailColumns: [EmailColumn]?, importStatus: ImportStatus?, size: Int64?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.columnNames = columnNames
        self.phoneColumns = phoneColumns
        self.emailColumns = emailColumns
        self.importStatus = importStatus
        self.size = size
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case columnNames
        case phoneColumns
        case emailColumns
        case importStatus
        case size
        case selfUri
    }


}




public class ContactListDivisionViewListing: Codable {





















    public var entities: [ContactListDivisionView]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ContactListDivisionView]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ContactListFilterBulkRetrieveBody: Codable {



    /** The IDs of the Contact List Filters to retrieve. */
    public var ids: [String]?

    public init(ids: [String]?) {
        self.ids = ids
    }


}




public class ContactListTemplate: Codable {

































    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** The names of the contact data columns. */
    public var columnNames: [String]?
    /** Indicates which columns are phone numbers. */
    public var phoneColumns: [ContactPhoneNumberColumn]?
    /** Indicates which columns are email addresses */
    public var emailColumns: [EmailColumn]?
    /** A column to check if a contact should always be dialed in preview mode. */
    public var previewModeColumnName: String?
    /** The values in the previewModeColumnName column that indicate a contact should always be dialed in preview mode. */
    public var previewModeAcceptedValues: [String]?
    /** AttemptLimits for this ContactListTemplate. */
    public var attemptLimits: DomainEntityRef?
    /** Indicates if automatic time zone mapping is to be used for this ContactListTemplate. */
    public var automaticTimeZoneMapping: Bool?
    /** The name of ContactListTemplate column containing the zip code for use with automatic time zone mapping. Only allowed if 'automaticTimeZoneMapping' is set to true. */
    public var zipCodeColumnName: String?
    /** The settings of the columns selected for dynamic queueing */
    public var columnDataTypeSpecifications: [ColumnDataTypeSpecification]?
    /** Whether to trim white space when importing a ContactListTemplate csv file, default value = true */
    public var trimWhitespace: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, columnNames: [String]?, phoneColumns: [ContactPhoneNumberColumn]?, emailColumns: [EmailColumn]?, previewModeColumnName: String?, previewModeAcceptedValues: [String]?, attemptLimits: DomainEntityRef?, automaticTimeZoneMapping: Bool?, zipCodeColumnName: String?, columnDataTypeSpecifications: [ColumnDataTypeSpecification]?, trimWhitespace: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.columnNames = columnNames
        self.phoneColumns = phoneColumns
        self.emailColumns = emailColumns
        self.previewModeColumnName = previewModeColumnName
        self.previewModeAcceptedValues = previewModeAcceptedValues
        self.attemptLimits = attemptLimits
        self.automaticTimeZoneMapping = automaticTimeZoneMapping
        self.zipCodeColumnName = zipCodeColumnName
        self.columnDataTypeSpecifications = columnDataTypeSpecifications
        self.trimWhitespace = trimWhitespace
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case columnNames
        case phoneColumns
        case emailColumns
        case previewModeColumnName
        case previewModeAcceptedValues
        case attemptLimits
        case automaticTimeZoneMapping
        case zipCodeColumnName
        case columnDataTypeSpecifications
        case trimWhitespace
        case selfUri
    }


}




public class ContactListing: Codable {























    public var entities: [ExternalContact]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var partialResults: Bool?
    public var firstUri: String?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var pageCount: Int?

    public init(entities: [ExternalContact]?, pageSize: Int?, pageNumber: Int?, total: Int64?, partialResults: Bool?, firstUri: String?, nextUri: String?, selfUri: String?, previousUri: String?, lastUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.partialResults = partialResults
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.pageCount = pageCount
    }


}




public class ContactPhoneNumberColumn: Codable {







    /** The name of the phone column. */
    public var columnName: String?
    /** Indicates the type of the phone column. For example, 'cell' or 'home'. */
    public var type: String?
    /** A column that indicates the timezone to use for a given contact when checking callable times. Not allowed if 'automaticTimeZoneMapping' is set to true. */
    public var callableTimeColumn: String?

    public init(columnName: String?, type: String?, callableTimeColumn: String?) {
        self.columnName = columnName
        self.type = type
        self.callableTimeColumn = callableTimeColumn
    }


}




public class ContactlistDownloadReadyExportUri: Codable {







    public var uri: String?
    public var exportTimestamp: String?
    public var additionalProperties: [String:JSON]?

    public init(uri: String?, exportTimestamp: String?, additionalProperties: [String:JSON]?) {
        self.uri = uri
        self.exportTimestamp = exportTimestamp
        self.additionalProperties = additionalProperties
    }


}



/** Carousel content object. */

public class ContentCarousel: Codable {



    /** An array of card objects. */
    public var cards: [ContentCard]?

    public init(cards: [ContentCard]?) {
        self.cards = cards
    }


}



/** Location object. */

public class ContentLocation: Codable {











    /** URL of the Location. */
    public var url: String?
    /** Location postal address. */
    public var address: String?
    /** Location name. */
    public var text: String?
    /** Latitude of the location. */
    public var latitude: Double?
    /** Longitude of the location. */
    public var longitude: Double?

    public init(url: String?, address: String?, text: String?, latitude: Double?, longitude: Double?) {
        self.url = url
        self.address = address
        self.text = text
        self.latitude = latitude
        self.longitude = longitude
    }


}



/** An ephemeral story. */

public class ContentStory: Codable {

    public enum ModelType: String, Codable { 
        case mention = "Mention"
        case reply = "Reply"
    }





    /** Type of ephemeral story attachment. */
    public var type: ModelType?
    /** URL to the ephemeral story. */
    public var url: String?
    /** ID of the ephemeral story being replied to. */
    public var replyToId: String?

    public init(type: ModelType?, url: String?, replyToId: String?) {
        self.type = type
        self.url = url
        self.replyToId = replyToId
    }


}




public class Context: Codable {



    /** A list of one or more patterns to match. */
    public var patterns: [ContextPattern]?

    public init(patterns: [ContextPattern]?) {
        self.patterns = patterns
    }


}




public class ConversationAggregateQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [ConversationAggregateQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [ConversationAggregateQueryPredicate]?

    public init(type: ModelType?, clauses: [ConversationAggregateQueryClause]?, predicates: [ConversationAggregateQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class ConversationCallEventTopicCallMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case timeout = "timeout"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }







































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }

















    public enum RecordingState: String, Codable { 
        case _none = "none"
        case active = "active"
        case paused = "paused"
    }























    public var _id: String?
    public var name: String?
    public var address: String?
    public var startTime: Date?
    public var connectedTime: Date?
    public var endTime: Date?
    public var startHoldTime: Date?
    public var purpose: String?
    public var state: State?
    public var initialState: InitialState?
    public var direction: Direction?
    public var disconnectType: DisconnectType?
    public var held: Bool?
    public var wrapupRequired: Bool?
    public var wrapupPrompt: String?
    public var user: ConversationCallEventTopicUriReference?
    public var queue: ConversationCallEventTopicUriReference?
    public var team: ConversationCallEventTopicUriReference?
    public var attributes: [String:String]?
    public var errorInfo: ConversationCallEventTopicErrorBody?
    public var script: ConversationCallEventTopicUriReference?
    public var wrapupTimeoutMs: Int?
    public var wrapupSkipped: Bool?
    public var alertingTimeoutMs: Int?
    public var provider: String?
    public var externalContact: ConversationCallEventTopicUriReference?
    public var externalOrganization: ConversationCallEventTopicUriReference?
    public var wrapup: ConversationCallEventTopicWrapup?
    public var conversationRoutingData: ConversationCallEventTopicConversationRoutingData?
    public var peer: String?
    public var screenRecordingState: String?
    public var flaggedReason: FlaggedReason?
    public var journeyContext: ConversationCallEventTopicJourneyContext?
    public var startAcwTime: Date?
    public var endAcwTime: Date?
    public var mediaRoles: [String]?
    public var queueMediaSettings: ConversationCallEventTopicQueueMediaSettings?
    public var muted: Bool?
    public var confined: Bool?
    public var recording: Bool?
    public var recordingState: RecordingState?
    public var securePause: Bool?
    public var group: ConversationCallEventTopicUriReference?
    public var ani: String?
    public var dnis: String?
    public var documentId: String?
    public var monitoredParticipantId: String?
    public var coachedParticipantId: String?
    public var bargedParticipantId: String?
    public var bargedTime: Date?
    public var consultParticipantId: String?
    public var faxStatus: ConversationCallEventTopicFaxStatus?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, initialState: InitialState?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, user: ConversationCallEventTopicUriReference?, queue: ConversationCallEventTopicUriReference?, team: ConversationCallEventTopicUriReference?, attributes: [String:String]?, errorInfo: ConversationCallEventTopicErrorBody?, script: ConversationCallEventTopicUriReference?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, alertingTimeoutMs: Int?, provider: String?, externalContact: ConversationCallEventTopicUriReference?, externalOrganization: ConversationCallEventTopicUriReference?, wrapup: ConversationCallEventTopicWrapup?, conversationRoutingData: ConversationCallEventTopicConversationRoutingData?, peer: String?, screenRecordingState: String?, flaggedReason: FlaggedReason?, journeyContext: ConversationCallEventTopicJourneyContext?, startAcwTime: Date?, endAcwTime: Date?, mediaRoles: [String]?, queueMediaSettings: ConversationCallEventTopicQueueMediaSettings?, muted: Bool?, confined: Bool?, recording: Bool?, recordingState: RecordingState?, securePause: Bool?, group: ConversationCallEventTopicUriReference?, ani: String?, dnis: String?, documentId: String?, monitoredParticipantId: String?, coachedParticipantId: String?, bargedParticipantId: String?, bargedTime: Date?, consultParticipantId: String?, faxStatus: ConversationCallEventTopicFaxStatus?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.conversationRoutingData = conversationRoutingData
        self.peer = peer
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.mediaRoles = mediaRoles
        self.queueMediaSettings = queueMediaSettings
        self.muted = muted
        self.confined = confined
        self.recording = recording
        self.recordingState = recordingState
        self.securePause = securePause
        self.group = group
        self.ani = ani
        self.dnis = dnis
        self.documentId = documentId
        self.monitoredParticipantId = monitoredParticipantId
        self.coachedParticipantId = coachedParticipantId
        self.bargedParticipantId = bargedParticipantId
        self.bargedTime = bargedTime
        self.consultParticipantId = consultParticipantId
        self.faxStatus = faxStatus
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case initialState
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalOrganization
        case wrapup
        case conversationRoutingData
        case peer
        case screenRecordingState
        case flaggedReason
        case journeyContext
        case startAcwTime
        case endAcwTime
        case mediaRoles
        case queueMediaSettings
        case muted
        case confined
        case recording
        case recordingState
        case securePause
        case group
        case ani
        case dnis
        case documentId
        case monitoredParticipantId
        case coachedParticipantId
        case bargedParticipantId
        case bargedTime
        case consultParticipantId
        case faxStatus
    }


}




public class ConversationCallEventTopicFaxStatus: Codable {

















    public var direction: String?
    public var expectedPages: Int?
    public var activePage: Int?
    public var linesTransmitted: Int?
    public var bytesTransmitted: Int?
    public var dataRate: Int?
    public var pageErrors: Int?
    public var lineErrors: Int?

    public init(direction: String?, expectedPages: Int?, activePage: Int?, linesTransmitted: Int?, bytesTransmitted: Int?, dataRate: Int?, pageErrors: Int?, lineErrors: Int?) {
        self.direction = direction
        self.expectedPages = expectedPages
        self.activePage = activePage
        self.linesTransmitted = linesTransmitted
        self.bytesTransmitted = bytesTransmitted
        self.dataRate = dataRate
        self.pageErrors = pageErrors
        self.lineErrors = lineErrors
    }


}




public class ConversationCallEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}




public class ConversationCallbackEventTopicDetail: Codable {









    public var errorCode: String?
    public var fieldName: String?
    public var entityId: String?
    public var entityName: String?

    public init(errorCode: String?, fieldName: String?, entityId: String?, entityName: String?) {
        self.errorCode = errorCode
        self.fieldName = fieldName
        self.entityId = entityId
        self.entityName = entityName
    }


}




public class ConversationCallbackEventTopicErrorBody: Codable {





















    public var message: String?
    public var code: String?
    public var status: Int?
    public var entityId: String?
    public var entityName: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var contextId: String?
    public var details: [ConversationCallbackEventTopicDetail]?
    public var errors: [ConversationCallbackEventTopicErrorBody]?

    public init(message: String?, code: String?, status: Int?, entityId: String?, entityName: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, details: [ConversationCallbackEventTopicDetail]?, errors: [ConversationCallbackEventTopicErrorBody]?) {
        self.message = message
        self.code = code
        self.status = status
        self.entityId = entityId
        self.entityName = entityName
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.details = details
        self.errors = errors
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class ConversationCallbackEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int?

    public init(_id: String?, version: Int?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}




public class ConversationCallbackEventTopicPhoneNumberColumn: Codable {





    public var columnName: String?
    public var type: String?

    public init(columnName: String?, type: String?) {
        self.columnName = columnName
        self.type = type
    }


}




public class ConversationCallbackEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class ConversationChatEventTopicConversationRoutingData: Codable {











    /** A UriReference for a resource */
    public var queue: ConversationChatEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: ConversationChatEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int?
    /** The skills to use for routing decisions */
    public var skills: [ConversationChatEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [ConversationChatEventTopicScoredAgent]?

    public init(queue: ConversationChatEventTopicUriReference?, language: ConversationChatEventTopicUriReference?, priority: Int?, skills: [ConversationChatEventTopicUriReference]?, scoredAgents: [ConversationChatEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}




public class ConversationClearSettings: Codable {



    /** whether or not conversation clear setting is enabled */
    public var enabled: Bool?

    public init(enabled: Bool?) {
        self.enabled = enabled
    }


}




public class ConversationCobrowseEventTopicDetail: Codable {









    public var errorCode: String?
    public var fieldName: String?
    public var entityId: String?
    public var entityName: String?

    public init(errorCode: String?, fieldName: String?, entityId: String?, entityName: String?) {
        self.errorCode = errorCode
        self.fieldName = fieldName
        self.entityId = entityId
        self.entityName = entityName
    }


}




public class ConversationCobrowseEventTopicErrorBody: Codable {





















    public var message: String?
    public var code: String?
    public var status: Int?
    public var entityId: String?
    public var entityName: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var contextId: String?
    public var details: [ConversationCobrowseEventTopicDetail]?
    public var errors: [ConversationCobrowseEventTopicErrorBody]?

    public init(message: String?, code: String?, status: Int?, entityId: String?, entityName: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, details: [ConversationCobrowseEventTopicDetail]?, errors: [ConversationCobrowseEventTopicErrorBody]?) {
        self.message = message
        self.code = code
        self.status = status
        self.entityId = entityId
        self.entityName = entityName
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.details = details
        self.errors = errors
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class ConversationCobrowseEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int?

    public init(_id: String?, version: Int?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}




public class ConversationCobrowseEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}



/** Carousel content object. */

public class ConversationContentCarousel: Codable {



    /** An array of card objects. */
    public var cards: [ConversationContentCard]?

    public init(cards: [ConversationContentCard]?) {
        self.cards = cards
    }


}



/** Location object. */

public class ConversationContentLocation: Codable {











    /** URL of the Location. */
    public var url: String?
    /** Location postal address. */
    public var address: String?
    /** Location name. */
    public var text: String?
    /** Latitude of the location. */
    public var latitude: Double?
    /** Longitude of the location. */
    public var longitude: Double?

    public init(url: String?, address: String?, text: String?, latitude: Double?, longitude: Double?) {
        self.url = url
        self.address = address
        self.text = text
        self.latitude = latitude
        self.longitude = longitude
    }


}



/** An ephemeral story. */

public class ConversationContentStory: Codable {

    public enum ModelType: String, Codable { 
        case mention = "Mention"
        case reply = "Reply"
    }





    /** Type of ephemeral story attachment. */
    public var type: ModelType?
    /** URL to the ephemeral story. */
    public var url: String?
    /** ID of the ephemeral story being replied to. */
    public var replyToId: String?

    public init(type: ModelType?, url: String?, replyToId: String?) {
        self.type = type
        self.url = url
        self.replyToId = replyToId
    }


}




public class ConversationEmailEventTopicAttachment: Codable {











    /** The unique identifier for the attachment. */
    public var attachmentId: String?
    /** The name of the attachment. */
    public var name: String?
    /** The content uri of the attachment. If set, this is commonly a public api download location. */
    public var contentUri: String?
    /** The type of file the attachment is. */
    public var contentType: String?
    /** The length of the attachment file. */
    public var contentLength: Int?

    public init(attachmentId: String?, name: String?, contentUri: String?, contentType: String?, contentLength: Int?) {
        self.attachmentId = attachmentId
        self.name = name
        self.contentUri = contentUri
        self.contentType = contentType
        self.contentLength = contentLength
    }


}




public class ConversationEmailEventTopicEmailConversation: Codable {









    public var _id: String?
    public var name: String?
    public var participants: [ConversationEmailEventTopicEmailMediaParticipant]?
    public var otherMediaUris: [String]?

    public init(_id: String?, name: String?, participants: [ConversationEmailEventTopicEmailMediaParticipant]?, otherMediaUris: [String]?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationEmailEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationEmailEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}




public class ConversationEmailEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: ConversationEmailEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int?

    public init(agent: ConversationEmailEventTopicUriReference?, score: Int?) {
        self.agent = agent
        self.score = score
    }


}




public class ConversationEventTopicCallback: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case scheduled = "scheduled"
        case uploading = "uploading"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case scheduled = "scheduled"
        case uploading = "uploading"
        case _none = "none"
    }



    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }



    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferForward = "transfer.forward"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }











































    public var state: State?
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The direction of the call */
    public var direction: Direction?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the callback was placed on hold in the cloud clock if the callback is currently on hold. */
    public var startHoldTime: Date?
    public var dialerPreview: ConversationEventTopicDialerPreview?
    public var voicemail: ConversationEventTopicVoicemail?
    /** The phone number(s) to use to place the callback. */
    public var callbackNumbers: [String]?
    /** The name of the user requesting a callback. */
    public var callbackUserName: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** True if the call for the callback uses external dialing. */
    public var externalCampaign: Bool?
    /** True if the ability to skip a callback should be enabled. */
    public var skipEnabled: Bool?
    /** The source provider of the callback. */
    public var provider: String?
    /** The number of seconds before the system automatically places a call for a callback.  0 means the automatic placement is disabled. */
    public var timeoutSeconds: Int?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** The timestamp when this communication is scheduled in the provider clock. If this value is missing it indicates the callback will be placed immediately. */
    public var callbackScheduledTime: Date?
    /** The id of the config for automatically placing the callback (and handling the disposition). If null, the callback will not be placed automatically but routed to an agent as per normal. */
    public var automatedCallbackConfigId: String?
    /** Call wrap up or disposition data. */
    public var wrapup: ConversationEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: ConversationEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** The phone number displayed to recipients of the phone call. The value should conform to the E164 format. */
    public var callerId: String?
    /** The name displayed to recipients of the phone call. */
    public var callerIdName: String?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: ConversationEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _id: String?, direction: Direction?, held: Bool?, disconnectType: DisconnectType?, startHoldTime: Date?, dialerPreview: ConversationEventTopicDialerPreview?, voicemail: ConversationEventTopicVoicemail?, callbackNumbers: [String]?, callbackUserName: String?, scriptId: String?, peerId: String?, externalCampaign: Bool?, skipEnabled: Bool?, provider: String?, timeoutSeconds: Int?, connectedTime: Date?, disconnectedTime: Date?, callbackScheduledTime: Date?, automatedCallbackConfigId: String?, wrapup: ConversationEventTopicWrapup?, afterCallWork: ConversationEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, callerId: String?, callerIdName: String?, queueMediaSettings: ConversationEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.direction = direction
        self.held = held
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.dialerPreview = dialerPreview
        self.voicemail = voicemail
        self.callbackNumbers = callbackNumbers
        self.callbackUserName = callbackUserName
        self.scriptId = scriptId
        self.peerId = peerId
        self.externalCampaign = externalCampaign
        self.skipEnabled = skipEnabled
        self.provider = provider
        self.timeoutSeconds = timeoutSeconds
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.callbackScheduledTime = callbackScheduledTime
        self.automatedCallbackConfigId = automatedCallbackConfigId
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.callerId = callerId
        self.callerIdName = callerIdName
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case direction
        case held
        case disconnectType
        case startHoldTime
        case dialerPreview
        case voicemail
        case callbackNumbers
        case callbackUserName
        case scriptId
        case peerId
        case externalCampaign
        case skipEnabled
        case provider
        case timeoutSeconds
        case connectedTime
        case disconnectedTime
        case callbackScheduledTime
        case automatedCallbackConfigId
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case callerId
        case callerIdName
        case queueMediaSettings
    }


}




public class ConversationEventTopicCobrowse: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }



































    public var state: State?
    public var initialState: InitialState?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** Address and name data for a call endpoint. */
    public var _self: ConversationEventTopicAddress?
    /** The room id for the chat. */
    public var roomId: String?
    /** The co-browse session ID. */
    public var cobrowseSessionId: String?
    /** This value identifies the role of the co-browse client within the co-browse session (a client is a sharer or a viewer). */
    public var cobrowseRole: String?
    /** ID of co-browse participants for which this client has been granted control (list is empty if this client cannot control any shared pages). */
    public var controlling: [String]?
    /** The URL that can be used to open co-browse session in web browser. */
    public var viewerUrl: String?
    /** The source provider of the co-browse communication. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The time when the provider event which triggered this conversation update happened in the corrected provider clock (milliseconds since 1970-01-01 00:00:00 UTC). */
    public var providerEventTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** Call wrap up or disposition data. */
    public var wrapup: ConversationEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: ConversationEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: ConversationEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, disconnectType: DisconnectType?, _id: String?, _self: ConversationEventTopicAddress?, roomId: String?, cobrowseSessionId: String?, cobrowseRole: String?, controlling: [String]?, viewerUrl: String?, provider: String?, scriptId: String?, peerId: String?, providerEventTime: Date?, connectedTime: Date?, disconnectedTime: Date?, wrapup: ConversationEventTopicWrapup?, afterCallWork: ConversationEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: ConversationEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self.disconnectType = disconnectType
        self._id = _id
        self._self = _self
        self.roomId = roomId
        self.cobrowseSessionId = cobrowseSessionId
        self.cobrowseRole = cobrowseRole
        self.controlling = controlling
        self.viewerUrl = viewerUrl
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.providerEventTime = providerEventTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case disconnectType
        case _id = "id"
        case _self = "self"
        case roomId
        case cobrowseSessionId
        case cobrowseRole
        case controlling
        case viewerUrl
        case provider
        case scriptId
        case peerId
        case providerEventTime
        case connectedTime
        case disconnectedTime
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}



/** The preview data to be used when this callback is a Preview. */

public class ConversationEventTopicDialerPreview: Codable {











    public var _id: String?
    /** The contact associated with this preview data pop */
    public var contactId: String?
    /** The contactList associated with this preview data pop. */
    public var contactListId: String?
    /** The campaignId associated with this preview data pop. */
    public var campaignId: String?
    /** The phone number columns associated with this campaign */
    public var phoneNumberColumns: [ConversationEventTopicPhoneNumberColumn]?

    public init(_id: String?, contactId: String?, contactListId: String?, campaignId: String?, phoneNumberColumns: [ConversationEventTopicPhoneNumberColumn]?) {
        self._id = _id
        self.contactId = contactId
        self.contactListId = contactListId
        self.campaignId = campaignId
        self.phoneNumberColumns = phoneNumberColumns
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case contactId
        case contactListId
        case campaignId
        case phoneNumberColumns
    }


}



/** Extra information on fax transmission. */

public class ConversationEventTopicFaxStatus: Codable {

















    /** The fax direction, either \"send\" or \"receive\". */
    public var direction: String?
    /** Total number of expected pages, if known. */
    public var expectedPages: Int?
    /** Active page of the transmission. */
    public var activePage: Int?
    /** Number of lines that have completed transmission. */
    public var linesTransmitted: Int?
    /** Number of bytes that have competed transmission. */
    public var bytesTransmitted: Int?
    /** Current signaling rate of transmission, baud rate. */
    public var baudRate: Int?
    /** Number of page errors. */
    public var pageErrors: Int?
    /** Number of line errors. */
    public var lineErrors: Int?

    public init(direction: String?, expectedPages: Int?, activePage: Int?, linesTransmitted: Int?, bytesTransmitted: Int?, baudRate: Int?, pageErrors: Int?, lineErrors: Int?) {
        self.direction = direction
        self.expectedPages = expectedPages
        self.activePage = activePage
        self.linesTransmitted = linesTransmitted
        self.bytesTransmitted = bytesTransmitted
        self.baudRate = baudRate
        self.pageErrors = pageErrors
        self.lineErrors = lineErrors
    }


}




public class ConversationEventTopicMessageMetadataContent: Codable {





    /** Type of this content element. */
    public var contentType: String?
    /** Content subtype, if any */
    public var subType: String?

    public init(contentType: String?, subType: String?) {
        self.contentType = contentType
        self.subType = subType
    }


}




public class ConversationEventTopicParticipant: Codable {





















































    public enum ScreenRecordingState: String, Codable { 
        case requested = "requested"
        case active = "active"
        case paused = "paused"
        case stopped = "stopped"
        case error = "error"
        case timeout = "timeout"
    }

























    /** A globally unique identifier for this conversation. */
    public var _id: String?
    /** The timestamp when this participant was connected to the conversation in the provider clock. */
    public var connectedTime: Date?
    /** The timestamp when this participant disconnected from the conversation in the provider clock. */
    public var endTime: Date?
    /** If this participant represents a user, then this will be the globally unique identifier for the user. */
    public var userId: String?
    /** If this participant represents an external contact, then this will be the globally unique identifier for the external contact. */
    public var externalContactId: String?
    /** If this participant represents an external org, then this will be the globally unique identifier for the external org. */
    public var externalOrganizationId: String?
    /** A human readable name identifying the participant. */
    public var name: String?
    /** If present, the queue id that the communication channel came in on. */
    public var queueId: String?
    /** If present, the group id that the participant represents. */
    public var groupId: String?
    /** The team id that this participant is a member of when added to the conversation. */
    public var teamId: String?
    /** A well known string that specifies the purpose or type of this participant. */
    public var purpose: String?
    /** If this participant is part of a consult transfer, then this will be the participant id of the participant being transferred. */
    public var consultParticipantId: String?
    /** The address for the this participant. For a phone call this will be the ANI. */
    public var address: String?
    /** True iff this participant is required to enter wrapup for this conversation. */
    public var wrapupRequired: Bool?
    /** True when a participant is expected to enter a wrapup code once the call connects. */
    public var wrapupExpected: Bool?
    /** This field controls how the UI prompts the agent for a wrapup. */
    public var wrapupPrompt: String?
    /** Specifies how long a timed ACW session will last. */
    public var wrapupTimeoutMs: Int?
    public var wrapup: ConversationEventTopicWrapup?
    /** The timestamp when this participant started after-call work. */
    public var startAcwTime: Date?
    /** The timestamp when this participant ended after-call work. */
    public var endAcwTime: Date?
    public var conversationRoutingData: ConversationEventTopicConversationRoutingData?
    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutMs: Int?
    /** If this participant is a monitor, then this will be the id of the participant that is being monitored. */
    public var monitoredParticipantId: String?
    /** If this participant is a coach, then this will be the id of the participant that is being coached. */
    public var coachedParticipantId: String?
    /** If this participant created a barge in conference, then this will be the id of the participant that is barged in. */
    public var bargedParticipantId: String?
    /** List of roles this participant's media has had on the conversation, ie monitor, coach, etc. */
    public var mediaRoles: [String]?
    /** The current screen recording state for this participant. */
    public var screenRecordingState: ScreenRecordingState?
    /** If this participant has flagged the conversation, the reason code given. */
    public var flaggedReason: String?
    /** Additional participant attributes */
    public var attributes: [String:String]?
    public var calls: [ConversationEventTopicCall]?
    public var callbacks: [ConversationEventTopicCallback]?
    public var chats: [ConversationEventTopicChat]?
    public var cobrowsesessions: [ConversationEventTopicCobrowse]?
    public var emails: [ConversationEventTopicEmail]?
    public var messages: [ConversationEventTopicMessage]?
    public var screenshares: [ConversationEventTopicScreenshare]?
    public var socialExpressions: [ConversationEventTopicSocialExpression]?
    public var videos: [ConversationEventTopicVideo]?
    public var workflow: ConversationEventTopicWorkflow?

    public init(_id: String?, connectedTime: Date?, endTime: Date?, userId: String?, externalContactId: String?, externalOrganizationId: String?, name: String?, queueId: String?, groupId: String?, teamId: String?, purpose: String?, consultParticipantId: String?, address: String?, wrapupRequired: Bool?, wrapupExpected: Bool?, wrapupPrompt: String?, wrapupTimeoutMs: Int?, wrapup: ConversationEventTopicWrapup?, startAcwTime: Date?, endAcwTime: Date?, conversationRoutingData: ConversationEventTopicConversationRoutingData?, alertingTimeoutMs: Int?, monitoredParticipantId: String?, coachedParticipantId: String?, bargedParticipantId: String?, mediaRoles: [String]?, screenRecordingState: ScreenRecordingState?, flaggedReason: String?, attributes: [String:String]?, calls: [ConversationEventTopicCall]?, callbacks: [ConversationEventTopicCallback]?, chats: [ConversationEventTopicChat]?, cobrowsesessions: [ConversationEventTopicCobrowse]?, emails: [ConversationEventTopicEmail]?, messages: [ConversationEventTopicMessage]?, screenshares: [ConversationEventTopicScreenshare]?, socialExpressions: [ConversationEventTopicSocialExpression]?, videos: [ConversationEventTopicVideo]?, workflow: ConversationEventTopicWorkflow?) {
        self._id = _id
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.userId = userId
        self.externalContactId = externalContactId
        self.externalOrganizationId = externalOrganizationId
        self.name = name
        self.queueId = queueId
        self.groupId = groupId
        self.teamId = teamId
        self.purpose = purpose
        self.consultParticipantId = consultParticipantId
        self.address = address
        self.wrapupRequired = wrapupRequired
        self.wrapupExpected = wrapupExpected
        self.wrapupPrompt = wrapupPrompt
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapup = wrapup
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.conversationRoutingData = conversationRoutingData
        self.alertingTimeoutMs = alertingTimeoutMs
        self.monitoredParticipantId = monitoredParticipantId
        self.coachedParticipantId = coachedParticipantId
        self.bargedParticipantId = bargedParticipantId
        self.mediaRoles = mediaRoles
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.attributes = attributes
        self.calls = calls
        self.callbacks = callbacks
        self.chats = chats
        self.cobrowsesessions = cobrowsesessions
        self.emails = emails
        self.messages = messages
        self.screenshares = screenshares
        self.socialExpressions = socialExpressions
        self.videos = videos
        self.workflow = workflow
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case connectedTime
        case endTime
        case userId
        case externalContactId
        case externalOrganizationId
        case name
        case queueId
        case groupId
        case teamId
        case purpose
        case consultParticipantId
        case address
        case wrapupRequired
        case wrapupExpected
        case wrapupPrompt
        case wrapupTimeoutMs
        case wrapup
        case startAcwTime
        case endAcwTime
        case conversationRoutingData
        case alertingTimeoutMs
        case monitoredParticipantId
        case coachedParticipantId
        case bargedParticipantId
        case mediaRoles
        case screenRecordingState
        case flaggedReason
        case attributes
        case calls
        case callbacks
        case chats
        case cobrowsesessions
        case emails
        case messages
        case screenshares
        case socialExpressions
        case videos
        case workflow
    }


}



/** Represents the queue setting for this media. */

public class ConversationEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}




public class ConversationEventTopicRecentTransfer: Codable {



    public enum State: String, Codable { 
        case pending = "pending"
        case active = "active"
        case complete = "complete"
        case canceled = "canceled"
        case failed = "failed"
        case timeout = "timeout"
        case unknown = "unknown"
    }









    public enum TransferType: String, Codable { 
        case attended = "attended"
        case unattended = "unattended"
    }

    /** The id of the command. */
    public var _id: String?
    public var state: State?
    /** The date/time that this command was issued. */
    public var dateIssued: Date?
    public var initiator: ConversationEventTopicInitiator?
    public var modifiedBy: ConversationEventTopicModifiedBy?
    public var destination: ConversationEventTopicDestination?
    /** The type of transfer to perform. */
    public var transferType: TransferType?

    public init(_id: String?, state: State?, dateIssued: Date?, initiator: ConversationEventTopicInitiator?, modifiedBy: ConversationEventTopicModifiedBy?, destination: ConversationEventTopicDestination?, transferType: TransferType?) {
        self._id = _id
        self.state = state
        self.dateIssued = dateIssued
        self.initiator = initiator
        self.modifiedBy = modifiedBy
        self.destination = destination
        self.transferType = transferType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case dateIssued
        case initiator
        case modifiedBy
        case destination
        case transferType
    }


}



/** The voicemail data to be used when this callback is an ACD voicemail. */

public class ConversationEventTopicVoicemail: Codable {



    public enum UploadStatus: String, Codable { 
        case pending = "pending"
        case complete = "complete"
        case failed = "failed"
        case timeout = "timeout"
        case _none = "none"
    }

    /** The voicemail id */
    public var _id: String?
    /** current state of the voicemail upload */
    public var uploadStatus: UploadStatus?

    public init(_id: String?, uploadStatus: UploadStatus?) {
        self._id = _id
        self.uploadStatus = uploadStatus
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case uploadStatus
    }


}




public class ConversationMessageEventTopicConversationRoutingData: Codable {











    /** A UriReference for a resource */
    public var queue: ConversationMessageEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: ConversationMessageEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int?
    /** The skills to use for routing decisions */
    public var skills: [ConversationMessageEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [ConversationMessageEventTopicScoredAgent]?

    public init(queue: ConversationMessageEventTopicUriReference?, language: ConversationMessageEventTopicUriReference?, priority: Int?, skills: [ConversationMessageEventTopicUriReference]?, scoredAgents: [ConversationMessageEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}




public class ConversationMessageEventTopicErrorDetails: Codable {















    /** The HTTP status code for this message (400, 401, 403, 404, 500, etc. */
    public var status: Int?
    /** A code unique to this error. */
    public var code: String?
    /** Friendly description of this error. */
    public var message: String?
    /** This is the same as message except it uses template fields for variable replacement. For instance: 'User {username} was not found' */
    public var messageWithParams: String?
    /** Used in conjunction with messageWithParams. These are the template parameters. For instance: UserParam.key = 'username', UserParam.value = 'john.doe' */
    public var messageParams: [String:String]?
    /** The correlation Id or context Id for this message. If left blank the Public API will look at the HTTP response header 'ININ-Correlation-Id' instead. */
    public var contextId: String?
    public var uri: String?

    public init(status: Int?, code: String?, message: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, uri: String?) {
        self.status = status
        self.code = code
        self.message = message
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.uri = uri
    }


}



/** Metadata information about a message content. */

public class ConversationMessageMetadataContent: Codable {

    public enum ContentType: String, Codable { 
        case attachment = "Attachment"
        case location = "Location"
        case quickReply = "QuickReply"
        case notification = "Notification"
        case buttonResponse = "ButtonResponse"
        case story = "Story"
        case mention = "Mention"
        case card = "Card"
        case carousel = "Carousel"
        case text = "Text"
        case quickReplyV2 = "QuickReplyV2"
        case unknown = "Unknown"
    }

    public enum SubType: String, Codable { 
        case image = "Image"
        case video = "Video"
        case audio = "Audio"
        case file = "File"
        case link = "Link"
        case mention = "Mention"
        case reply = "Reply"
        case button = "Button"
        case quickReply = "QuickReply"
        case postback = "Postback"
        case unknown = "Unknown"
    }

    /** Type of this content element. */
    public var contentType: ContentType?
    /** Content subtype */
    public var subType: SubType?

    public init(contentType: ContentType?, subType: SubType?) {
        self.contentType = contentType
        self.subType = subType
    }


}



/** Information about the recipient the message is received from. */

public class ConversationMessagingFromRecipient: Codable {





    public enum IdType: String, Codable { 
        case email = "Email"
        case phone = "Phone"
        case opaque = "Opaque"
    }











    /** Nickname or display name of the recipient. */
    public var nickname: String?
    /** The recipient ID specific to the provider. */
    public var _id: String?
    /** The recipient ID type. This is used to indicate the format used for the ID. */
    public var idType: IdType?
    /** URL of an image that represents the recipient. */
    public var image: String?
    /** First name of the recipient. */
    public var firstName: String?
    /** Last name of the recipient. */
    public var lastName: String?
    /** E-mail address of the recipient. */
    public var email: String?
    /** List of recipient additional identifiers */
    public var additionalIds: [ConversationRecipientAdditionalIdentifier]?

    public init(nickname: String?, _id: String?, idType: IdType?, image: String?, firstName: String?, lastName: String?, email: String?, additionalIds: [ConversationRecipientAdditionalIdentifier]?) {
        self.nickname = nickname
        self._id = _id
        self.idType = idType
        self.image = image
        self.firstName = firstName
        self.lastName = lastName
        self.email = email
        self.additionalIds = additionalIds
    }

    public enum CodingKeys: String, CodingKey { 
        case nickname
        case _id = "id"
        case idType
        case image
        case firstName
        case lastName
        case email
        case additionalIds
    }


}




public class ConversationMetricsTopicConversationScoredAgent: Codable {





    /** Assigned agent score for this conversation (0 - 100, higher being better) */
    public var agentScore: Int?
    /** Unique identifier for the agent that was scored for this conversation */
    public var scoredAgentId: String?

    public init(agentScore: Int?, scoredAgentId: String?) {
        self.agentScore = agentScore
        self.scoredAgentId = scoredAgentId
    }


}



/** Template body object. */

public class ConversationNotificationTemplateBody: Codable {





    /** Body text. For WhatsApp, ignored. */
    public var text: String?
    /** Template parameters for placeholders in template. */
    public var parameters: [ConversationNotificationTemplateParameter]?

    public init(text: String?, parameters: [ConversationNotificationTemplateParameter]?) {
        self.text = text
        self.parameters = parameters
    }


}



/** Template footer object. */

public class ConversationNotificationTemplateFooter: Codable {



    /** Footer text. For WhatsApp, ignored. */
    public var text: String?

    public init(text: String?) {
        self.text = text
    }


}




public class ConversationQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions. */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}



/** Reasons for a failed message receipt. */

public class ConversationReason: Codable {

    public enum Code: String, Codable { 
        case messageExpired = "MessageExpired"
        case rateLimited = "RateLimited"
        case messageNotAllowed = "MessageNotAllowed"
        case generalError = "GeneralError"
        case unsupportedMessage = "UnsupportedMessage"
        case unknownMessage = "UnknownMessage"
        case invalidMessageStructure = "InvalidMessageStructure"
        case invalidDestination = "InvalidDestination"
        case serverError = "ServerError"
        case mediaTypeNotAllowed = "MediaTypeNotAllowed"
        case invalidMediaContentLength = "InvalidMediaContentLength"
        case recipientOptedOut = "RecipientOptedOut"
    }



    /** The reason code for the failed message receipt. */
    public var code: Code?
    /** Description of the reason for the failed message receipt. */
    public var message: String?

    public init(code: Code?, message: String?) {
        self.code = code
        self.message = message
    }


}




public class ConversationReference: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class ConversationScreenShareEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: ConversationScreenShareEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: ConversationScreenShareEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}




public class ConversationScreenShareEventTopicJourneyContext: Codable {







    public var customer: ConversationScreenShareEventTopicJourneyCustomer?
    public var customerSession: ConversationScreenShareEventTopicJourneyCustomerSession?
    public var triggeringAction: ConversationScreenShareEventTopicJourneyAction?

    public init(customer: ConversationScreenShareEventTopicJourneyCustomer?, customerSession: ConversationScreenShareEventTopicJourneyCustomerSession?, triggeringAction: ConversationScreenShareEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class ConversationScreenShareEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}




public class ConversationSocialExpressionEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationVideoEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationVideoEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}




public class ConversationVideoEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: ConversationVideoEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int?

    public init(agent: ConversationVideoEventTopicUriReference?, score: Int?) {
        self.agent = agent
        self.score = score
    }


}




public class ConversationVideoEventTopicVideoConversation: Codable {









    public var _id: String?
    public var name: String?
    public var participants: [ConversationVideoEventTopicVideoMediaParticipant]?
    public var otherMediaUris: [String]?

    public init(_id: String?, name: String?, participants: [ConversationVideoEventTopicVideoMediaParticipant]?, otherMediaUris: [String]?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
    }


}



/** Used to copy a VoicemailMessage to either a User or a Group */

public class CopyVoicemailMessage: Codable {







    /** The id of the VoicemailMessage to copy */
    public var voicemailMessageId: String?
    /** The id of the User to copy the VoicemailMessage to */
    public var userId: String?
    /** The id of the Group to copy the VoicemailMessage to */
    public var groupId: String?

    public init(voicemailMessageId: String?, userId: String?, groupId: String?) {
        self.voicemailMessageId = voicemailMessageId
        self.userId = userId
        self.groupId = groupId
    }


}




public class CoverSheet: Codable {





    /** Text to be added to the coversheet */
    public var notes: String?
    /** Locale, e.g. = en-US */
    public var locale: String?

    public init(notes: String?, locale: String?) {
        self.notes = notes
        self.locale = locale
    }


}




public class CreateBusinessUnitRequest: Codable {







    /** The name of the business unit */
    public var name: String?
    /** The ID of the division to which the business unit should be added */
    public var divisionId: String?
    /** Configuration for the business unit */
    public var settings: CreateBusinessUnitSettingsRequest?

    public init(name: String?, divisionId: String?, settings: CreateBusinessUnitSettingsRequest?) {
        self.name = name
        self.divisionId = divisionId
        self.settings = settings
    }


}




public class CreateCallRequest: Codable {





























    /** The phone number to dial. */
    public var phoneNumber: String?
    /** The caller id phone number for this outbound call. */
    public var callerId: String?
    /** The caller id name for this outbound call. */
    public var callerIdName: String?
    /** The queue ID to call on behalf of. */
    public var callFromQueueId: String?
    /** The queue ID to call. */
    public var callQueueId: String?
    /** The user ID to call. */
    public var callUserId: String?
    /** The priority to assign to this call (if calling a queue). */
    public var priority: Int?
    /** The language skill ID to use for routing this call (if calling a queue). */
    public var languageId: String?
    /** The skill ID's to use for routing this call (if calling a queue). */
    public var routingSkillsIds: [String]?
    /** The list of existing call conversations to merge into a new ad-hoc conference. */
    public var conversationIds: [String]?
    /** The list of participants to call to create a new ad-hoc conference. */
    public var participants: [Destination]?
    /** User to User Information (UUI) data managed by SIP session application. */
    public var uuiData: String?
    /** The external contact with which to associate the call. */
    public var externalContactId: String?
    /** An optional label that categorizes the conversation.  Max-utilization settings can be configured at a per-label level */
    public var label: String?

    public init(phoneNumber: String?, callerId: String?, callerIdName: String?, callFromQueueId: String?, callQueueId: String?, callUserId: String?, priority: Int?, languageId: String?, routingSkillsIds: [String]?, conversationIds: [String]?, participants: [Destination]?, uuiData: String?, externalContactId: String?, label: String?) {
        self.phoneNumber = phoneNumber
        self.callerId = callerId
        self.callerIdName = callerIdName
        self.callFromQueueId = callFromQueueId
        self.callQueueId = callQueueId
        self.callUserId = callUserId
        self.priority = priority
        self.languageId = languageId
        self.routingSkillsIds = routingSkillsIds
        self.conversationIds = conversationIds
        self.participants = participants
        self.uuiData = uuiData
        self.externalContactId = externalContactId
        self.label = label
    }


}




public class CreatePredictorRequest: Codable {











    /** The queue IDs associated with the predictor. */
    public var queueIds: [String]?
    /** The KPI that the predictor attempts to maximize/minimize. */
    public var kpi: String?
    /** Number of seconds allocated to predictive routing before attempting a different routing method. This is a value between 12 and 900 seconds. */
    public var routingTimeoutSeconds: Int?
    /** The predictor schedule that determines when the predictor is used for routing interactions. */
    public var schedule: PredictorSchedule?
    /** The predictor balancing configuration to enable workload balancing */
    public var workloadBalancingConfig: PredictorWorkloadBalancing?

    public init(queueIds: [String]?, kpi: String?, routingTimeoutSeconds: Int?, schedule: PredictorSchedule?, workloadBalancingConfig: PredictorWorkloadBalancing?) {
        self.queueIds = queueIds
        self.kpi = kpi
        self.routingTimeoutSeconds = routingTimeoutSeconds
        self.schedule = schedule
        self.workloadBalancingConfig = workloadBalancingConfig
    }


}




public class CreateSecureSession: Codable {









    /** requesting participant */
    public var sourceParticipantId: String?
    /** the flow id to execute in the secure session */
    public var flowId: String?
    /** user data for the secure session */
    public var userData: String?
    /** if true, disconnect the agent after creating the session */
    public var disconnect: Bool?

    public init(sourceParticipantId: String?, flowId: String?, userData: String?, disconnect: Bool?) {
        self.sourceParticipantId = sourceParticipantId
        self.flowId = flowId
        self.userData = userData
        self.disconnect = disconnect
    }


}




public class CreateUser: Codable {















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }

    /** User's full name */
    public var name: String?
    public var department: String?
    /** User's email and username */
    public var email: String?
    /** Email addresses and phone numbers for this user */
    public var addresses: [Contact]?
    public var title: String?
    /** User's password */
    public var password: String?
    /** The division to which this user will belong */
    public var divisionId: String?
    /** Optional initialized state of the user. If not specified, state will be Active if invites are sent, otherwise Inactive. */
    public var state: State?

    public init(name: String?, department: String?, email: String?, addresses: [Contact]?, title: String?, password: String?, divisionId: String?, state: State?) {
        self.name = name
        self.department = department
        self.email = email
        self.addresses = addresses
        self.title = title
        self.password = password
        self.divisionId = divisionId
        self.state = state
    }


}




public class CreateWebChatConversationRequest: Codable {













    /** The organization identifier. */
    public var organizationId: String?
    /** The web chat Deployment ID which contains the appropriate settings for this chat conversation. */
    public var deploymentId: String?
    /** The routing information to use for the new chat conversation. */
    public var routingTarget: WebChatRoutingTarget?
    /** The guest member info to use for the new chat conversation. */
    public var memberInfo: GuestMemberInfo?
    /** If the guest member is an authenticated member (ie, not anonymous) his JWT is provided here. The token will have been previously generated with the \"POST /api/v2/signeddata\" resource. */
    public var memberAuthToken: String?
    /** A subset of the Journey System's data relevant to this conversation/session request (for external linkage and internal usage/context). */
    public var journeyContext: JourneyContext?

    public init(organizationId: String?, deploymentId: String?, routingTarget: WebChatRoutingTarget?, memberInfo: GuestMemberInfo?, memberAuthToken: String?, journeyContext: JourneyContext?) {
        self.organizationId = organizationId
        self.deploymentId = deploymentId
        self.routingTarget = routingTarget
        self.memberInfo = memberInfo
        self.memberAuthToken = memberAuthToken
        self.journeyContext = journeyContext
    }


}




public class CreateWebChatRequest: Codable {















    /** The ID of the queue to use for routing the chat conversation. */
    public var queueId: String?
    /** The name of the provider that is sourcing the web chat. */
    public var provider: String?
    /** The list of skill ID's to use for routing. */
    public var skillIds: [String]?
    /** The ID of the langauge to use for routing. */
    public var languageId: String?
    /** The priority to assign to the conversation for routing. */
    public var priority: Int64?
    /** The list of attributes to associate with the customer participant. */
    public var attributes: [String:String]?
    /** The name of the customer participating in the web chat. */
    public var customerName: String?

    public init(queueId: String?, provider: String?, skillIds: [String]?, languageId: String?, priority: Int64?, attributes: [String:String]?, customerName: String?) {
        self.queueId = queueId
        self.provider = provider
        self.skillIds = skillIds
        self.languageId = languageId
        self.priority = priority
        self.attributes = attributes
        self.customerName = customerName
    }


}




public class CrossPlatformEmailMediaPolicy: Codable {





    /** Actions applied when specified conditions are met */
    public var actions: CrossPlatformPolicyActions?
    /** Conditions for when actions should be applied */
    public var conditions: EmailMediaPolicyConditions?

    public init(actions: CrossPlatformPolicyActions?, conditions: EmailMediaPolicyConditions?) {
        self.actions = actions
        self.conditions = conditions
    }


}




public class CurrentUserTimeOffIntegrationStatusRequest: Codable {



    /** A list of time off request IDs */
    public var timeOffRequestIds: [String]?

    public init(timeOffRequestIds: [String]?) {
        self.timeOffRequestIds = timeOffRequestIds
    }


}




public class CustomerInteractionCenter: Codable {























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var disabled: Bool?
    public var issuerURI: String?
    public var ssoTargetURI: String?
    public var sloURI: String?
    public var sloBinding: String?
    public var relyingPartyIdentifier: String?
    public var certificate: String?
    public var certificates: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, disabled: Bool?, issuerURI: String?, ssoTargetURI: String?, sloURI: String?, sloBinding: String?, relyingPartyIdentifier: String?, certificate: String?, certificates: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.disabled = disabled
        self.issuerURI = issuerURI
        self.ssoTargetURI = ssoTargetURI
        self.sloURI = sloURI
        self.sloBinding = sloBinding
        self.relyingPartyIdentifier = relyingPartyIdentifier
        self.certificate = certificate
        self.certificates = certificates
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case disabled
        case issuerURI
        case ssoTargetURI
        case sloURI
        case sloBinding
        case relyingPartyIdentifier
        case certificate
        case certificates
        case selfUri
    }


}




public class CustomerStartDetailEventTopicCustomerStartEvent: Codable {









    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
    }







    public enum Direction: String, Codable { 
        case unknown = "UNKNOWN"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }

















    public enum MessageType: String, Codable { 
        case unknown = "UNKNOWN"
        case sms = "SMS"
        case twitter = "TWITTER"
        case facebook = "FACEBOOK"
        case line = "LINE"
        case whatsapp = "WHATSAPP"
        case webmessaging = "WEBMESSAGING"
        case _open = "OPEN"
        case instagram = "INSTAGRAM"
    }







    public var eventTime: Int?
    public var conversationId: String?
    public var participantId: String?
    public var sessionId: String?
    public var mediaType: MediaType?
    public var externalOrganizationId: String?
    public var externalContactId: String?
    public var provider: String?
    public var direction: Direction?
    public var ani: String?
    public var dnis: String?
    public var addressTo: String?
    public var addressFrom: String?
    public var callbackUserName: String?
    public var callbackNumbers: [String]?
    public var callbackScheduledTime: Int?
    public var subject: String?
    public var messageType: MessageType?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?
    public var journeyContext: CustomerStartDetailEventTopicJourneyContext?

    public init(eventTime: Int?, conversationId: String?, participantId: String?, sessionId: String?, mediaType: MediaType?, externalOrganizationId: String?, externalContactId: String?, provider: String?, direction: Direction?, ani: String?, dnis: String?, addressTo: String?, addressFrom: String?, callbackUserName: String?, callbackNumbers: [String]?, callbackScheduledTime: Int?, subject: String?, messageType: MessageType?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?, journeyContext: CustomerStartDetailEventTopicJourneyContext?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.sessionId = sessionId
        self.mediaType = mediaType
        self.externalOrganizationId = externalOrganizationId
        self.externalContactId = externalContactId
        self.provider = provider
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.addressTo = addressTo
        self.addressFrom = addressFrom
        self.callbackUserName = callbackUserName
        self.callbackNumbers = callbackNumbers
        self.callbackScheduledTime = callbackScheduledTime
        self.subject = subject
        self.messageType = messageType
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
        self.journeyContext = journeyContext
    }


}




public class DIDEntityListing: Codable {





















    public var entities: [DID]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DID]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** Represents an unassigned or assigned DID in a DID Pool. */

public class DIDNumber: Codable {













    public enum OwnerType: String, Codable { 
        case user = "USER"
        case phone = "PHONE"
        case ivrConfig = "IVR_CONFIG"
        case group = "GROUP"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The number of the DID formatted as E164. */
    public var number: String?
    /** True if this DID is assigned to an entity.  False otherwise. */
    public var assigned: Bool?
    /** A Uri reference to the DID Pool this DID is a part of. */
    public var didPool: AddressableEntityRef?
    /** A Uri reference to the owner of this DID.  The owner's type can be found in ownerType.  If the DID is unassigned, this will be NULL. */
    public var owner: DomainEntityRef?
    /** The type of the entity that owns this DID.  If the DID is unassigned, this will be NULL. */
    public var ownerType: OwnerType?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, number: String?, assigned: Bool?, didPool: AddressableEntityRef?, owner: DomainEntityRef?, ownerType: OwnerType?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.number = number
        self.assigned = assigned
        self.didPool = didPool
        self.owner = owner
        self.ownerType = ownerType
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case number
        case assigned
        case didPool
        case owner
        case ownerType
        case selfUri
    }


}




public class DIDPoolEntityListing: Codable {





















    public var entities: [DIDPool]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DIDPool]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DataSchema: Codable {







    public enum AppliesTo: String, Codable { 
        case contact = "CONTACT"
        case externalOrganization = "EXTERNAL_ORGANIZATION"
        case openAction = "OPEN_ACTION"
        case workitem = "WORKITEM"
    }











    /** The globally unique identifier for the schema.  Only required if a schema is used for custom fields during external entity creation or updates. */
    public var _id: String?
    public var name: String?
    /** The schema's version, a positive integer. Required for updates. */
    public var version: Int?
    /** One of \"CONTACT\" or \"EXTERNAL_ORGANIZATION\".  Indicates the built-in entity type to which this schema applies. */
    public var appliesTo: [AppliesTo]?
    /** The schema's enabled/disabled status. A disabled schema cannot be assigned to any other entities, but the data on those entities from the schema still exists. */
    public var enabled: Bool?
    /** The URI of the user that created this schema. */
    public var createdBy: DomainEntityRef?
    /** The date and time this schema was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** A JSON schema defining the extension to the built-in entity type. */
    public var jsonSchema: JsonSchemaDocument?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, version: Int?, appliesTo: [AppliesTo]?, enabled: Bool?, createdBy: DomainEntityRef?, dateCreated: Date?, jsonSchema: JsonSchemaDocument?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.version = version
        self.appliesTo = appliesTo
        self.enabled = enabled
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.jsonSchema = jsonSchema
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case version
        case appliesTo
        case enabled
        case createdBy
        case dateCreated
        case jsonSchema
        case selfUri
    }


}




public class DataSchemaListing: Codable {







    public var total: Int64?
    public var entities: [DataSchema]?
    public var selfUri: String?

    public init(total: Int64?, entities: [DataSchema]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}



/** Contains a metadata representation for a JSON schema stored in DataTables along with an optional field for the schema itself */

public class DataTable: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    /** The description from the JSON schema (equates to the Description field on the JSON schema.) */
    public var _description: String?
    /** the schema as stored in the system. */
    public var schema: JsonSchemaDocument?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, _description: String?, schema: JsonSchemaDocument?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.schema = schema
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case schema
        case selfUri
    }


}



/** State information for an export job of rows from a datatable */

public class DataTableExportJob: Codable {







    public enum Status: String, Codable { 
        case processing = "Processing"
        case failed = "Failed"
        case succeeded = "Succeeded"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The PureCloud user who started the export job */
    public var owner: AddressableEntityRef?
    /** The status of the export job */
    public var status: Status?
    /** The timestamp of when the export began. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The timestamp of when the export stopped (either successfully or unsuccessfully). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCompleted: Date?
    /** The URL of the location at which the caller can download the export file, when available */
    public var downloadURI: String?
    /** Any error information, or null of the processing is not in an error state */
    public var errorInformation: ErrorBody?
    /** The current count of the number of records processed */
    public var countRecordsProcessed: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, owner: AddressableEntityRef?, status: Status?, dateCreated: Date?, dateCompleted: Date?, downloadURI: String?, errorInformation: ErrorBody?, countRecordsProcessed: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.owner = owner
        self.status = status
        self.dateCreated = dateCreated
        self.dateCompleted = dateCompleted
        self.downloadURI = downloadURI
        self.errorInformation = errorInformation
        self.countRecordsProcessed = countRecordsProcessed
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case owner
        case status
        case dateCreated
        case dateCompleted
        case downloadURI
        case errorInformation
        case countRecordsProcessed
        case selfUri
    }


}




public class DependencyType: Codable {









    /** The dependency type identifier */
    public var _id: String?
    public var name: String?
    public var versioned: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, versioned: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.versioned = versioned
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case versioned
        case selfUri
    }


}




public class DevelopmentActivityAggregateQueryRequestFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "And"
        case or = "Or"
    }



    /** The logic used to combine the clauses */
    public var type: ModelType?
    /** The list of clauses used to filter the data. Note that clauses must filter by attendeeId and a maximum of 100 user IDs are allowed */
    public var clauses: [DevelopmentActivityAggregateQueryRequestClause]?

    public init(type: ModelType?, clauses: [DevelopmentActivityAggregateQueryRequestClause]?) {
        self.type = type
        self.clauses = clauses
    }


}




public class DevelopmentActivityAggregateQueryResponseMetric: Codable {

    public enum Metric: String, Codable { 
        case nactivities = "nActivities"
        case nplannedactivities = "nPlannedActivities"
        case ninprogressactivities = "nInProgressActivities"
        case ncompleteactivities = "nCompleteActivities"
        case noverdueactivities = "nOverdueActivities"
        case ninvalidscheduleactivities = "nInvalidScheduleActivities"
        case npassedactivities = "nPassedActivities"
        case nfailedactivities = "nFailedActivities"
        case oactivityscore = "oActivityScore"
        case nnotcompletedactivities = "nNotCompletedActivities"
    }



    /** The metric this applies to */
    public var metric: Metric?
    /** The aggregated values for this metric */
    public var stats: DevelopmentActivityAggregateQueryResponseStatistics?

    public init(metric: Metric?, stats: DevelopmentActivityAggregateQueryResponseStatistics?) {
        self.metric = metric
        self.stats = stats
    }


}




public class DevelopmentActivityAggregateQueryResponseStatistics: Codable {









    /** The count for this metric */
    public var count: Int?
    /** The minimum value in this metric */
    public var min: Double?
    /** The maximum value in this metric */
    public var max: Double?
    /** The total of the values for this metric */
    public var sum: Double?

    public init(count: Int?, min: Double?, max: Double?, sum: Double?) {
        self.count = count
        self.min = min
        self.max = max
        self.sum = sum
    }


}




public class DialerAuditRequest: Codable {









    /** The word or words to search for. */
    public var queryPhrase: String?
    /** The fields in which to search for the queryPhrase. */
    public var queryFields: [String]?
    /** The fields to facet on. */
    public var facets: [AuditFacet]?
    /** The fields to filter on. */
    public var filters: [AuditFilter]?

    public init(queryPhrase: String?, queryFields: [String]?, facets: [AuditFacet]?, filters: [AuditFilter]?) {
        self.queryPhrase = queryPhrase
        self.queryFields = queryFields
        self.facets = facets
        self.filters = filters
    }


}




public class DialerCampaignConfigChangePhoneColumn: Codable {







    /** The name of the phone column */
    public var columnName: String?
    /** The type of the phone column, for example, 'cell' or 'home' */
    public var type: String?
    public var additionalProperties: [String:JSON]?

    public init(columnName: String?, type: String?, additionalProperties: [String:JSON]?) {
        self.columnName = columnName
        self.type = type
        self.additionalProperties = additionalProperties
    }


}




public class DialerCampaignRuleConfigChangeCampaignRuleEntities: Codable {





    /** A list of campaignIds to act on */
    public var campaigns: [DialerCampaignRuleConfigChangeUriReference]?
    /** A list of sequenceIds to act on */
    public var sequences: [DialerCampaignRuleConfigChangeUriReference]?

    public init(campaigns: [DialerCampaignRuleConfigChangeUriReference]?, sequences: [DialerCampaignRuleConfigChangeUriReference]?) {
        self.campaigns = campaigns
        self.sequences = sequences
    }


}




public class DialerCampaignRuleConfigChangeUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class DialerCampaignScheduleConfigChangeScheduleInterval: Codable {







    /** scheduled start time represented as an ISO-8601 string; for example, yyyy-MM-ddTHH:mm:ss.SSSZ */
    public var start: String?
    /** scheduled end time represented as an ISO-8601 string; for example, yyyy-MM-ddTHH:mm:ss.SSSZ */
    public var end: String?
    public var additionalProperties: [String:JSON]?

    public init(start: String?, end: String?, additionalProperties: [String:JSON]?) {
        self.start = start
        self.end = end
        self.additionalProperties = additionalProperties
    }


}



/** A UriReference for a resource */

public class DialerCampaignScheduleConfigChangeUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class DialerContactlistConfigChangeContactList: Codable {



































    /** the contact column names */
    public var columnNames: [String]?
    /** the columns containing phone numbers */
    public var phoneColumns: [DialerContactlistConfigChangeContactPhoneNumberColumn]?
    /** the columns containing email addresses */
    public var emailColumns: [DialerContactlistConfigChangeEmailColumn]?
    public var importStatus: DialerContactlistConfigChangeImportStatus?
    /** the name of the column that holds the indicators for contacts that are to be dialed in preview mode only */
    public var previewModeColumnName: String?
    /** list of user-defined values indicating the contact is to be dialed in preview mode only */
    public var previewModeAcceptedValues: [String]?
    /** the number of contacts in the contact list */
    public var size: Int?
    public var attemptLimits: DialerContactlistConfigChangeUriReference?
    /** whether or not automatic time zone mapping is enabled on the list */
    public var automaticTimeZoneMapping: Bool?
    /** zip code column from the contact list to be used optionally with automatic time zone mapping */
    public var zipCodeColumnName: String?
    /** A UriReference for a resource */
    public var division: DialerContactlistConfigChangeUriReference?
    public var additionalProperties: [String:JSON]?
    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The UI-visible name of the object */
    public var name: String?
    /** Creation time of the entity */
    public var dateCreated: Date?
    /** Last modified time of the entity */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?

    public init(columnNames: [String]?, phoneColumns: [DialerContactlistConfigChangeContactPhoneNumberColumn]?, emailColumns: [DialerContactlistConfigChangeEmailColumn]?, importStatus: DialerContactlistConfigChangeImportStatus?, previewModeColumnName: String?, previewModeAcceptedValues: [String]?, size: Int?, attemptLimits: DialerContactlistConfigChangeUriReference?, automaticTimeZoneMapping: Bool?, zipCodeColumnName: String?, division: DialerContactlistConfigChangeUriReference?, additionalProperties: [String:JSON]?, _id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?) {
        self.columnNames = columnNames
        self.phoneColumns = phoneColumns
        self.emailColumns = emailColumns
        self.importStatus = importStatus
        self.previewModeColumnName = previewModeColumnName
        self.previewModeAcceptedValues = previewModeAcceptedValues
        self.size = size
        self.attemptLimits = attemptLimits
        self.automaticTimeZoneMapping = automaticTimeZoneMapping
        self.zipCodeColumnName = zipCodeColumnName
        self.division = division
        self.additionalProperties = additionalProperties
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case columnNames
        case phoneColumns
        case emailColumns
        case importStatus
        case previewModeColumnName
        case previewModeAcceptedValues
        case size
        case attemptLimits
        case automaticTimeZoneMapping
        case zipCodeColumnName
        case division
        case additionalProperties
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
    }


}




public class DialerContactlistfilterConfigChangeContactListFilter: Codable {







    public enum FilterType: String, Codable { 
        case and = "AND"
        case or = "OR"
    }













    public var contactList: DialerContactlistfilterConfigChangeUriReference?
    /** The list of contact list columns */
    public var contactListColumns: [String]?
    public var clauses: [DialerContactlistfilterConfigChangeFilterClause]?
    /** Contact list filter type */
    public var filterType: FilterType?
    public var additionalProperties: [String:JSON]?
    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The UI-visible name of the object */
    public var name: String?
    /** Creation time of the entity */
    public var dateCreated: Date?
    /** Last modified time of the entity */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?

    public init(contactList: DialerContactlistfilterConfigChangeUriReference?, contactListColumns: [String]?, clauses: [DialerContactlistfilterConfigChangeFilterClause]?, filterType: FilterType?, additionalProperties: [String:JSON]?, _id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?) {
        self.contactList = contactList
        self.contactListColumns = contactListColumns
        self.clauses = clauses
        self.filterType = filterType
        self.additionalProperties = additionalProperties
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case contactList
        case contactListColumns
        case clauses
        case filterType
        case additionalProperties
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
    }


}




public class DialerContactlistfilterConfigChangeFilterPredicate: Codable {



    public enum ColumnType: String, Codable { 
        case numeric = "numeric"
        case alphabetic = "alphabetic"
    }

    public enum Operator: String, Codable { 
        case equals = "EQUALS"
        case lessThan = "LESS_THAN"
        case lessThanEquals = "LESS_THAN_EQUALS"
        case greaterThan = "GREATER_THAN"
        case greaterThanEquals = "GREATER_THAN_EQUALS"
        case contains = "CONTAINS"
        case beginsWith = "BEGINS_WITH"
        case endsWith = "ENDS_WITH"
        case before = "BEFORE"
        case after = "AFTER"
        case between = "BETWEEN"
        case _in = "IN"
    }









    /** The contact list column */
    public var column: String?
    /** Whether a contact column is numeric or alphabetic */
    public var columnType: ColumnType?
    /** The comparison operator */
    public var _operator: Operator?
    /** The value the predicate applies to */
    public var value: String?
    public var range: DialerContactlistfilterConfigChangeRange?
    /** Whether or not to invert to result of evaluating the predicate */
    public var inverted: Bool?
    public var additionalProperties: [String:JSON]?

    public init(column: String?, columnType: ColumnType?, _operator: Operator?, value: String?, range: DialerContactlistfilterConfigChangeRange?, inverted: Bool?, additionalProperties: [String:JSON]?) {
        self.column = column
        self.columnType = columnType
        self._operator = _operator
        self.value = value
        self.range = range
        self.inverted = inverted
        self.additionalProperties = additionalProperties
    }

    public enum CodingKeys: String, CodingKey { 
        case column
        case columnType
        case _operator = "operator"
        case value
        case range
        case inverted
        case additionalProperties
    }


}



/** The settings for automatic time zone mapping */

public class DialerOutboundSettingsConfigChangeAutomaticTimeZoneMappingSettings: Codable {



    /** The time intervals to use for automatic time zone mapping */
    public var callableWindows: [DialerOutboundSettingsConfigChangeCallableWindow]?

    public init(callableWindows: [DialerOutboundSettingsConfigChangeCallableWindow]?) {
        self.callableWindows = callableWindows
    }


}




public class DialerOutboundSettingsConfigChangeCallableWindow: Codable {





    public var mapped: DialerOutboundSettingsConfigChangeAtzmTimeSlot?
    public var unmapped: DialerOutboundSettingsConfigChangeAtzmTimeSlotWithTimeZone?

    public init(mapped: DialerOutboundSettingsConfigChangeAtzmTimeSlot?, unmapped: DialerOutboundSettingsConfigChangeAtzmTimeSlotWithTimeZone?) {
        self.mapped = mapped
        self.unmapped = unmapped
    }


}




public class DialerPreview: Codable {











    public var _id: String?
    /** The contact associated with this preview data pop */
    public var contactId: String?
    /** The contactList associated with this preview data pop. */
    public var contactListId: String?
    /** The campaignId associated with this preview data pop. */
    public var campaignId: String?
    /** The phone number columns associated with this campaign */
    public var phoneNumberColumns: [PhoneNumberColumn]?

    public init(_id: String?, contactId: String?, contactListId: String?, campaignId: String?, phoneNumberColumns: [PhoneNumberColumn]?) {
        self._id = _id
        self.contactId = contactId
        self.contactListId = contactListId
        self.campaignId = campaignId
        self.phoneNumberColumns = phoneNumberColumns
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case contactId
        case contactListId
        case campaignId
        case phoneNumberColumns
    }


}




public class DialerRule: Codable {







    public enum Category: String, Codable { 
        case dialerPrecall = "DIALER_PRECALL"
        case dialerWrapup = "DIALER_WRAPUP"
    }





    /** The identifier of the rule. */
    public var _id: String?
    /** The name of the rule. */
    public var name: String?
    /** The ranked order of the rule. Rules are processed from lowest number to highest. */
    public var order: Int?
    /** The category of the rule. */
    public var category: Category?
    /** A list of Conditions. All of the Conditions must evaluate to true to trigger the actions. */
    public var conditions: [Condition]?
    /** The list of actions to be taken if the conditions are true. */
    public var actions: [DialerAction]?

    public init(_id: String?, name: String?, order: Int?, category: Category?, conditions: [Condition]?, actions: [DialerAction]?) {
        self._id = _id
        self.name = name
        self.order = order
        self.category = category
        self.conditions = conditions
        self.actions = actions
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case order
        case category
        case conditions
        case actions
    }


}




public class DialerRulesetConfigChangeRule: Codable {











    public enum Category: String, Codable { 
        case dialerPrecall = "DIALER_PRECALL"
        case dialerWrapup = "DIALER_WRAPUP"
    }



    /** The list of rule conditions; all must evaluate to true to trigger the rule actions */
    public var conditions: [DialerRulesetConfigChangeCondition]?
    public var additionalProperties: [String:JSON]?
    /** The identifier of the rule */
    public var _id: String?
    /** The name of the rule */
    public var name: String?
    /** The ranked order of the rule; rules are processed from lowest number to highest */
    public var order: Int?
    /** The category of the rule */
    public var category: Category?
    /** The list of rule actions to be taken if the conditions are true */
    public var actions: [DialerRulesetConfigChangeAction]?

    public init(conditions: [DialerRulesetConfigChangeCondition]?, additionalProperties: [String:JSON]?, _id: String?, name: String?, order: Int?, category: Category?, actions: [DialerRulesetConfigChangeAction]?) {
        self.conditions = conditions
        self.additionalProperties = additionalProperties
        self._id = _id
        self.name = name
        self.order = order
        self.category = category
        self.actions = actions
    }

    public enum CodingKeys: String, CodingKey { 
        case conditions
        case additionalProperties
        case _id = "id"
        case name
        case order
        case category
        case actions
    }


}




public class DialerRulesetConfigChangeRuleSet: Codable {



















    public var contactList: DialerRulesetConfigChangeUriReference?
    /** A UriReference for a resource */
    public var queue: DialerRulesetConfigChangeUriReference?
    public var rules: [DialerRulesetConfigChangeRule]?
    public var additionalProperties: [String:JSON]?
    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The UI-visible name of the object */
    public var name: String?
    /** Creation time of the entity */
    public var dateCreated: Date?
    /** Last modified time of the entity */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?

    public init(contactList: DialerRulesetConfigChangeUriReference?, queue: DialerRulesetConfigChangeUriReference?, rules: [DialerRulesetConfigChangeRule]?, additionalProperties: [String:JSON]?, _id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?) {
        self.contactList = contactList
        self.queue = queue
        self.rules = rules
        self.additionalProperties = additionalProperties
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case contactList
        case queue
        case rules
        case additionalProperties
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
    }


}




public class DialerSequenceScheduleConfigChangeScheduleInterval: Codable {







    /** scheduled start time represented as an ISO-8601 string; for example, yyyy-MM-ddTHH:mm:ss.SSSZ */
    public var start: String?
    /** scheduled end time represented as an ISO-8601 string; for example, yyyy-MM-ddTHH:mm:ss.SSSZ */
    public var end: String?
    public var additionalProperties: [String:JSON]?

    public init(start: String?, end: String?, additionalProperties: [String:JSON]?) {
        self.start = start
        self.end = end
        self.additionalProperties = additionalProperties
    }


}



/** A UriReference for a resource */

public class DialerSequenceScheduleConfigChangeUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class DialogflowParameter: Codable {





    /** The parameter name */
    public var name: String?
    /** The parameter type */
    public var type: String?

    public init(name: String?, type: String?) {
        self.name = name
        self.type = type
    }


}




public class DictionaryFeedbackEntityListing: Codable {













    public var entities: [ListedDictionaryFeedback]?
    public var pageSize: Int?
    public var pageCount: Int?
    public var total: Int?
    public var selfUri: String?
    public var nextUri: String?

    public init(entities: [ListedDictionaryFeedback]?, pageSize: Int?, pageCount: Int?, total: Int?, selfUri: String?, nextUri: String?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageCount = pageCount
        self.total = total
        self.selfUri = selfUri
        self.nextUri = nextUri
    }


}




public class DictionaryFeedbackExamplePhrase: Codable {



    public enum Source: String, Codable { 
        case manual = "Manual"
    }

    /** The Example Phrase text. At least 3 words and up to 20 words */
    public var phrase: String?
    /** The source of the given Example Phrase */
    public var source: Source?

    public init(phrase: String?, source: Source?) {
        self.phrase = phrase
        self.source = source
    }


}




public class DirectRoutingMediaSettings: Codable {



    /** Toggle that enables using an agent's Direct Routing address outbound on behalf of queue for this media type. */
    public var useAgentAddressOutbound: Bool?

    public init(useAgentAddressOutbound: Bool?) {
        self.useAgentAddressOutbound = useAgentAddressOutbound
    }


}




public class DirectoryUserDevicesListing: Codable {





















    public var entities: [UserDevice]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [UserDevice]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DncListEntityListing: Codable {





















    public var entities: [DncList]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DncList]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DncPatchEmailsRequest: Codable {

    public enum Action: String, Codable { 
        case add = "Add"
        case remove = "Remove"
    }





    /** The action to perform */
    public var action: Action?
    /** The list of email addresses to Add to / Remove from the DNC list  */
    public var emailAddresses: [String]?
    /** Expiration date for DNC email addresses in yyyy-MM-ddTHH:mmZ format */
    public var expirationDateTime: String?

    public init(action: Action?, emailAddresses: [String]?, expirationDateTime: String?) {
        self.action = action
        self.emailAddresses = emailAddresses
        self.expirationDateTime = expirationDateTime
    }


}




public class DncPatchPhoneNumbersRequest: Codable {

    public enum Action: String, Codable { 
        case add = "Add"
        case remove = "Remove"
    }





    /** The action to perform */
    public var action: Action?
    /** The list of phone numbers to Add to / Remove from the DNC list  */
    public var phoneNumbers: [String]?
    /** Expiration date for DNC phone numbers in yyyy-MM-ddTHH:mmZ format */
    public var expirationDateTime: String?

    public init(action: Action?, phoneNumbers: [String]?, expirationDateTime: String?) {
        self.action = action
        self.phoneNumbers = phoneNumbers
        self.expirationDateTime = expirationDateTime
    }


}




public class Document: Codable {



























    public enum SystemType: String, Codable { 
        case document = "DOCUMENT"
        case fax = "FAX"
        case recording = "RECORDING"
    }























    public enum UploadMethod: String, Codable { 
        case singlePut = "SINGLE_PUT"
        case multipartPost = "MULTIPART_POST"
    }





    public enum SharingStatus: String, Codable { 
        case _none = "NONE"
        case limited = "LIMITED"
        case _public = "PUBLIC"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var changeNumber: Int?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateUploaded: Date?
    public var contentUri: String?
    public var workspace: DomainEntityRef?
    public var createdBy: DomainEntityRef?
    public var uploadedBy: DomainEntityRef?
    public var sharingUri: String?
    public var contentType: String?
    public var contentLength: Int64?
    public var systemType: SystemType?
    public var filename: String?
    public var pageCount: Int64?
    public var read: Bool?
    public var callerAddress: String?
    public var receiverAddress: String?
    public var tags: [String]?
    public var tagValues: [TagValue]?
    public var attributes: [DocumentAttribute]?
    public var thumbnails: [DocumentThumbnail]?
    public var uploadStatus: DomainEntityRef?
    public var uploadDestinationUri: String?
    public var uploadMethod: UploadMethod?
    public var lockInfo: LockInfo?
    /** A list of permitted action rights for the user making the request */
    public var acl: [String]?
    public var sharingStatus: SharingStatus?
    public var downloadSharingUri: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, changeNumber: Int?, dateCreated: Date?, dateModified: Date?, dateUploaded: Date?, contentUri: String?, workspace: DomainEntityRef?, createdBy: DomainEntityRef?, uploadedBy: DomainEntityRef?, sharingUri: String?, contentType: String?, contentLength: Int64?, systemType: SystemType?, filename: String?, pageCount: Int64?, read: Bool?, callerAddress: String?, receiverAddress: String?, tags: [String]?, tagValues: [TagValue]?, attributes: [DocumentAttribute]?, thumbnails: [DocumentThumbnail]?, uploadStatus: DomainEntityRef?, uploadDestinationUri: String?, uploadMethod: UploadMethod?, lockInfo: LockInfo?, acl: [String]?, sharingStatus: SharingStatus?, downloadSharingUri: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.changeNumber = changeNumber
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.dateUploaded = dateUploaded
        self.contentUri = contentUri
        self.workspace = workspace
        self.createdBy = createdBy
        self.uploadedBy = uploadedBy
        self.sharingUri = sharingUri
        self.contentType = contentType
        self.contentLength = contentLength
        self.systemType = systemType
        self.filename = filename
        self.pageCount = pageCount
        self.read = read
        self.callerAddress = callerAddress
        self.receiverAddress = receiverAddress
        self.tags = tags
        self.tagValues = tagValues
        self.attributes = attributes
        self.thumbnails = thumbnails
        self.uploadStatus = uploadStatus
        self.uploadDestinationUri = uploadDestinationUri
        self.uploadMethod = uploadMethod
        self.lockInfo = lockInfo
        self.acl = acl
        self.sharingStatus = sharingStatus
        self.downloadSharingUri = downloadSharingUri
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case changeNumber
        case dateCreated
        case dateModified
        case dateUploaded
        case contentUri
        case workspace
        case createdBy
        case uploadedBy
        case sharingUri
        case contentType
        case contentLength
        case systemType
        case filename
        case pageCount
        case read
        case callerAddress
        case receiverAddress
        case tags
        case tagValues
        case attributes
        case thumbnails
        case uploadStatus
        case uploadDestinationUri
        case uploadMethod
        case lockInfo
        case acl
        case sharingStatus
        case downloadSharingUri
        case selfUri
    }


}




public class DocumentBodyImageProperties: Codable {



    public enum Align: String, Codable { 
        case center = "Center"
        case _left = "Left"
        case _right = "Right"
        case justify = "Justify"
    }



    /** The background color property for the image. The valid values in hex color code representation. For example black color - #000000 */
    public var backgroundColor: String?
    /** The align property for the image. */
    public var align: Align?
    /** The indentation property for the image. The valid values in 'em'. */
    public var indentation: Float?

    public init(backgroundColor: String?, align: Align?, indentation: Float?) {
        self.backgroundColor = backgroundColor
        self.align = align
        self.indentation = indentation
    }


}




public class DocumentBodyList: Codable {





    /** The list of items for an OrderedList or an UnorderedList. */
    public var blocks: [DocumentBodyListBlock]?
    /** Properties for the UnorderedList or OrderedList. */
    public var properties: DocumentBodyListBlockProperties?

    public init(blocks: [DocumentBodyListBlock]?, properties: DocumentBodyListBlockProperties?) {
        self.blocks = blocks
        self.properties = properties
    }


}




public class DocumentBodyListBlockProperties: Codable {

    public enum UnorderedType: String, Codable { 
        case normal = "Normal"
        case square = "Square"
        case circle = "Circle"
        case _none = "None"
    }

    public enum OrderedType: String, Codable { 
        case number = "Number"
        case lowerAlpha = "LowerAlpha"
        case lowerGreek = "LowerGreek"
        case lowerRoman = "LowerRoman"
        case upperAlpha = "UpperAlpha"
        case upperRoman = "UpperRoman"
        case _none = "None"
    }

    /** The type of icon for the unordered list. */
    public var unorderedType: UnorderedType?
    /** The type of icon for the ordered list. */
    public var orderedType: OrderedType?

    public init(unorderedType: UnorderedType?, orderedType: OrderedType?) {
        self.unorderedType = unorderedType
        self.orderedType = orderedType
    }


}




public class DocumentBodyParagraphProperties: Codable {

    public enum FontSize: String, Codable { 
        case xxSmall = "XxSmall"
        case xsmall = "XSmall"
        case small = "Small"
        case medium = "Medium"
        case large = "Large"
        case xlarge = "XLarge"
        case xxLarge = "XxLarge"
        case xxxLarge = "XxxLarge"
    }

    public enum FontType: String, Codable { 
        case paragraph = "Paragraph"
        case heading1 = "Heading1"
        case heading2 = "Heading2"
        case heading3 = "Heading3"
        case heading4 = "Heading4"
        case heading5 = "Heading5"
        case heading6 = "Heading6"
        case preformatted = "Preformatted"
    }





    public enum Align: String, Codable { 
        case center = "Center"
        case _left = "Left"
        case _right = "Right"
        case justify = "Justify"
    }



    /** The font size for the paragraph. The valid values in 'em'. */
    public var fontSize: FontSize?
    /** The font type for the paragraph. */
    public var fontType: FontType?
    /** The text color for the paragraph. The valid values in hex color code representation. For example black color - #000000 */
    public var textColor: String?
    /** The background color for the paragraph. The valid values in hex color code representation. For example black color - #000000 */
    public var backgroundColor: String?
    /** The align type for the paragraph. */
    public var align: Align?
    /** The indentation color for the paragraph. The valid values in 'em'. */
    public var indentation: Float?

    public init(fontSize: FontSize?, fontType: FontType?, textColor: String?, backgroundColor: String?, align: Align?, indentation: Float?) {
        self.fontSize = fontSize
        self.fontType = fontType
        self.textColor = textColor
        self.backgroundColor = backgroundColor
        self.align = align
        self.indentation = indentation
    }


}




public class DocumentBodyTableCaptionBlock: Codable {



    /** The list of building blocks for the caption property. */
    public var blocks: [DocumentBodyTableCaptionItem]?

    public init(blocks: [DocumentBodyTableCaptionItem]?) {
        self.blocks = blocks
    }


}




public class DocumentBodyTableCellBlockProperties: Codable {

    public enum CellType: String, Codable { 
        case cell = "Cell"
        case headerCell = "HeaderCell"
    }





    public enum HorizontalAlign: String, Codable { 
        case center = "Center"
        case _left = "Left"
        case _right = "Right"
    }

    public enum VerticalAlign: String, Codable { 
        case top = "Top"
        case middle = "Middle"
        case bottom = "Bottom"
    }



    public enum BorderStyle: String, Codable { 
        case solid = "Solid"
        case dotted = "Dotted"
        case dashed = "Dashed"
        case double = "Double"
        case groove = "Groove"
        case ridge = "Ridge"
        case inset = "Inset"
        case outset = "Outset"
        case hidden = "Hidden"
        case _none = "None"
    }





    public enum Scope: String, Codable { 
        case row = "Row"
        case column = "Column"
        case rowGroup = "RowGroup"
        case columnGroup = "ColumnGroup"
        case _none = "None"
    }





    /** The type of the table cell. */
    public var cellType: CellType?
    /** The width for the table cell. */
    public var width: Float?
    /** The height for the table cell. */
    public var height: Float?
    /** The horizontal alignment for the table cell. */
    public var horizontalAlign: HorizontalAlign?
    /** The vertical alignment for the table cell. */
    public var verticalAlign: VerticalAlign?
    /** The border width for the table cell. The valid values in 'em' */
    public var borderWidth: Float?
    /** The border style for the table cell. */
    public var borderStyle: BorderStyle?
    /** The border color for the table cell. For example black color - #000000 */
    public var borderColor: String?
    /** The background color for the table cell. For example black color - #000000 */
    public var backgroundColor: String?
    /** The scope for the table cell. */
    public var scope: Scope?
    /** The colSpan for the table cell. */
    public var colSpan: Int?
    /** The rowSpan for the table cell. */
    public var rowSpan: Int?

    public init(cellType: CellType?, width: Float?, height: Float?, horizontalAlign: HorizontalAlign?, verticalAlign: VerticalAlign?, borderWidth: Float?, borderStyle: BorderStyle?, borderColor: String?, backgroundColor: String?, scope: Scope?, colSpan: Int?, rowSpan: Int?) {
        self.cellType = cellType
        self.width = width
        self.height = height
        self.horizontalAlign = horizontalAlign
        self.verticalAlign = verticalAlign
        self.borderWidth = borderWidth
        self.borderStyle = borderStyle
        self.borderColor = borderColor
        self.backgroundColor = backgroundColor
        self.scope = scope
        self.colSpan = colSpan
        self.rowSpan = rowSpan
    }


}




public class DocumentBodyTableProperties: Codable {











    public enum Alignment: String, Codable { 
        case center = "Center"
        case _left = "Left"
        case _right = "Right"
    }

    public enum BorderStyle: String, Codable { 
        case solid = "Solid"
        case dotted = "Dotted"
        case dashed = "Dashed"
        case double = "Double"
        case groove = "Groove"
        case ridge = "Ridge"
        case inset = "Inset"
        case outset = "Outset"
        case hidden = "Hidden"
        case _none = "None"
    }







    /** The width for the table. The valid values in 'em'. */
    public var width: Float?
    /** The height for the table. */
    public var height: Float?
    /** The cell spacing for the table. The valid values in 'em'. */
    public var cellSpacing: Float?
    /** The cell padding for the table. The valid values in 'em'. */
    public var cellPadding: Float?
    /** The border width for the table. The valid values in 'em' */
    public var borderWidth: Float?
    /** The alignment for the table. */
    public var alignment: Alignment?
    /** The border style for the table. */
    public var borderStyle: BorderStyle?
    /** The border color for the table. The valid values in hex color code representation. For example black color - #000000 */
    public var borderColor: String?
    /** The background color for the table. The valid values in hex color code representation. For example black color - #000000 */
    public var backgroundColor: String?
    /** The caption for the table. The valid values in hex color code representation. For example black color - #000000 */
    public var caption: DocumentBodyTableCaptionBlock?

    public init(width: Float?, height: Float?, cellSpacing: Float?, cellPadding: Float?, borderWidth: Float?, alignment: Alignment?, borderStyle: BorderStyle?, borderColor: String?, backgroundColor: String?, caption: DocumentBodyTableCaptionBlock?) {
        self.width = width
        self.height = height
        self.cellSpacing = cellSpacing
        self.cellPadding = cellPadding
        self.borderWidth = borderWidth
        self.alignment = alignment
        self.borderStyle = borderStyle
        self.borderColor = borderColor
        self.backgroundColor = backgroundColor
        self.caption = caption
    }


}




public class DocumentBodyVideoProperties: Codable {



    public enum Align: String, Codable { 
        case center = "Center"
        case _left = "Left"
        case _right = "Right"
        case justify = "Justify"
    }



    /** The background color for the video. The valid values in hex color code representation. For example black color - #000000 */
    public var backgroundColor: String?
    /** The align type for the video. */
    public var align: Align?
    /** The indentation for the video. The valid values in 'em'. */
    public var indentation: Float?

    public init(backgroundColor: String?, align: Align?, indentation: Float?) {
        self.backgroundColor = backgroundColor
        self.align = align
        self.indentation = indentation
    }


}




public class DocumentFaq: Codable {







    /** The question for this FAQ */
    public var question: String?
    /** The answer for this FAQ */
    public var answer: String?
    /** List of Alternative questions related to the answer which helps in improving the likelihood of a match to user query */
    public var alternatives: [String]?

    public init(question: String?, answer: String?, alternatives: [String]?) {
        self.question = question
        self.answer = answer
        self.alternatives = alternatives
    }


}




public class DocumentListing: Codable {









    public var entities: [KnowledgeDocument]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [KnowledgeDocument]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class DocumentTableContentBlock: Codable {

    public enum ModelType: String, Codable { 
        case paragraph = "Paragraph"
        case text = "Text"
        case image = "Image"
        case video = "Video"
        case orderedList = "OrderedList"
        case unorderedList = "UnorderedList"
        case table = "Table"
    }













    /** The type of the block for the table cell. This determines which body block object (paragraph, list, video, image or table) would have a value. */
    public var type: ModelType?
    /** Paragraph. It must contain a value if the type of the block is Paragraph. */
    public var paragraph: DocumentBodyParagraph?
    /** Text. It must contain a value if the type of the block is Text. */
    public var text: DocumentText?
    /** Image. It must contain a value if the type of the block is Image. */
    public var image: DocumentBodyImage?
    /** Video. It must contain a value if the type of the block is Video. */
    public var video: DocumentBodyVideo?
    /** List. It must contain a value if the type of the block is UnorderedList or OrderedList. */
    public var list: DocumentBodyList?
    /** Table. It must contain a value if the type of the block is Table. */
    public var table: DocumentBodyTable?

    public init(type: ModelType?, paragraph: DocumentBodyParagraph?, text: DocumentText?, image: DocumentBodyImage?, video: DocumentBodyVideo?, list: DocumentBodyList?, table: DocumentBodyTable?) {
        self.type = type
        self.paragraph = paragraph
        self.text = text
        self.image = image
        self.video = video
        self.list = list
        self.table = table
    }


}




public class DocumentTextProperties: Codable {

    public enum FontSize: String, Codable { 
        case xxSmall = "XxSmall"
        case xsmall = "XSmall"
        case small = "Small"
        case medium = "Medium"
        case large = "Large"
        case xlarge = "XLarge"
        case xxLarge = "XxLarge"
        case xxxLarge = "XxxLarge"
    }





    /** The font size for the text. The valid values in 'em'. */
    public var fontSize: FontSize?
    /** The text color for the text. The valid values in hex color code representation. For example black color - #000000 */
    public var textColor: String?
    /** The background color for the text. The valid values in hex color code representation. For example black color - #000000 */
    public var backgroundColor: String?

    public init(fontSize: FontSize?, textColor: String?, backgroundColor: String?) {
        self.fontSize = fontSize
        self.textColor = textColor
        self.backgroundColor = backgroundColor
    }


}




public class DomainCapabilities: Codable {













    /** True if this address family on the interface is enabled. */
    public var enabled: Bool?
    /** True if this address family on the interface is using DHCP. */
    public var dhcp: Bool?
    /** The metric being used for the address family on this interface. Lower values will have a higher priority. If autoMetric is true, this value will be the automatically calculated metric. To set this value be sure autoMetric is false. If no value is returned, metric configuration is not supported on this Edge. */
    public var metric: Int?
    /** True if the metric is being calculated automatically for the address family on this interface. */
    public var autoMetric: Bool?
    /** True if metric configuration is supported. */
    public var supportsMetric: Bool?
    /** Set to true to enable this address family on this interface to respond to ping requests. */
    public var pingEnabled: Bool?

    public init(enabled: Bool?, dhcp: Bool?, metric: Int?, autoMetric: Bool?, supportsMetric: Bool?, pingEnabled: Bool?) {
        self.enabled = enabled
        self.dhcp = dhcp
        self.metric = metric
        self.autoMetric = autoMetric
        self.supportsMetric = supportsMetric
        self.pingEnabled = pingEnabled
    }


}




public class DomainNetworkAddress: Codable {

    public enum ModelType: String, Codable { 
        case ip = "ip"
        case dns = "dns"
        case gateway = "gateway"
        case tdm = "tdm"
    }





    public enum Family: Int, Codable { 
        case _2 = 2
        case _23 = 23
    }

    /** The type of address. */
    public var type: ModelType?
    /** An IPv4 or IPv6 IP address. When specifying an address of type \"ip\", use CIDR format for the subnet mask. */
    public var address: String?
    /** True if this address will persist on Edge restart.  Addresses assigned by DHCP will be returned as false. */
    public var persistent: Bool?
    /** The address family for this address. */
    public var family: Family?

    public init(type: ModelType?, address: String?, persistent: Bool?, family: Family?) {
        self.type = type
        self.address = address
        self.persistent = persistent
        self.family = family
    }


}




public class DomainNetworkCommandResponse: Codable {









    public var correlationId: String?
    public var commandName: String?
    public var acknowledged: Bool?
    public var errorInfo: ErrorDetails?

    public init(correlationId: String?, commandName: String?, acknowledged: Bool?, errorInfo: ErrorDetails?) {
        self.correlationId = correlationId
        self.commandName = commandName
        self.acknowledged = acknowledged
        self.errorInfo = errorInfo
    }


}




public class DomainOrgRoleDifference: Codable {











    public var removedPermissionPolicies: [DomainPermissionPolicy]?
    public var addedPermissionPolicies: [DomainPermissionPolicy]?
    public var samePermissionPolicies: [DomainPermissionPolicy]?
    public var userOrgRole: DomainOrganizationRole?
    public var roleFromDefault: DomainOrganizationRole?

    public init(removedPermissionPolicies: [DomainPermissionPolicy]?, addedPermissionPolicies: [DomainPermissionPolicy]?, samePermissionPolicies: [DomainPermissionPolicy]?, userOrgRole: DomainOrganizationRole?, roleFromDefault: DomainOrganizationRole?) {
        self.removedPermissionPolicies = removedPermissionPolicies
        self.addedPermissionPolicies = addedPermissionPolicies
        self.samePermissionPolicies = samePermissionPolicies
        self.userOrgRole = userOrgRole
        self.roleFromDefault = roleFromDefault
    }


}




public class DomainOrganizationProduct: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class DomainOrganizationRole: Codable {

























    /** role id */
    public var _id: String?
    public var name: String?
    public var _description: String?
    public var defaultRoleId: String?
    public var permissions: [String]?
    /** A collection of the permissions the role is not using */
    public var unusedPermissions: [String]?
    public var permissionPolicies: [DomainPermissionPolicy]?
    public var userCount: Int?
    /** Optional unless patch operation. */
    public var roleNeedsUpdate: Bool?
    public var base: Bool?
    public var _default: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, defaultRoleId: String?, permissions: [String]?, unusedPermissions: [String]?, permissionPolicies: [DomainPermissionPolicy]?, userCount: Int?, roleNeedsUpdate: Bool?, base: Bool?, _default: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.defaultRoleId = defaultRoleId
        self.permissions = permissions
        self.unusedPermissions = unusedPermissions
        self.permissionPolicies = permissionPolicies
        self.userCount = userCount
        self.roleNeedsUpdate = roleNeedsUpdate
        self.base = base
        self._default = _default
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case defaultRoleId
        case permissions
        case unusedPermissions
        case permissionPolicies
        case userCount
        case roleNeedsUpdate
        case base
        case _default = "default"
        case selfUri
    }


}




public class DomainPermissionCollection: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var domain: String?
    public var permissionMap: [String:[DomainPermission]]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, domain: String?, permissionMap: [String:[DomainPermission]]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.domain = domain
        self.permissionMap = permissionMap
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case domain
        case permissionMap
        case selfUri
    }


}




public class DownloadResponse: Codable {







    public var contentLocationUri: String?
    public var imageUri: String?
    public var thumbnails: [DocumentThumbnail]?

    public init(contentLocationUri: String?, imageUri: String?, thumbnails: [DocumentThumbnail]?) {
        self.contentLocationUri = contentLocationUri
        self.imageUri = imageUri
        self.thumbnails = thumbnails
    }


}



/** Validation results */

public class DraftValidationResult: Codable {





    /** Indicates if configuration is valid */
    public var valid: Bool?
    /** List of errors causing validation failure */
    public var errors: [ErrorBody]?

    public init(valid: Bool?, errors: [ErrorBody]?) {
        self.valid = valid
        self.errors = errors
    }


}




public class EdgeAutoUpdateConfig: Codable {









    /** The timezone of the window in which any updates to the edges assigned to the site can be applied. The minimum size of the window is 2 hours. */
    public var timeZone: String?
    /** The recurrence rule for updating the Edges assigned to the site. The only supported frequencies are daily and weekly. Weekly frequencies require a day list with at least oneday specified. All other configurations are not supported. */
    public var rrule: String?
    /** Date time is represented as an ISO-8601 string without a timezone. For example: yyyy-MM-ddTHH:mm:ss.SSS */
    public var start: String?
    /** Date time is represented as an ISO-8601 string without a timezone. For example: yyyy-MM-ddTHH:mm:ss.SSS */
    public var end: String?

    public init(timeZone: String?, rrule: String?, start: String?, end: String?) {
        self.timeZone = timeZone
        self.rrule = rrule
        self.start = start
        self.end = end
    }


}




public class EdgeInterface: Codable {













    public enum LineTypes: String, Codable { 
        case tie = "TIE"
        case network = "NETWORK"
        case trunk = "TRUNK"
        case station = "STATION"
    }



    public var type: String?
    public var ipAddress: String?
    public var name: String?
    public var macAddress: String?
    public var ifName: String?
    public var endpoints: [DomainEntityRef]?
    public var lineTypes: [LineTypes]?
    public var addressFamilyId: String?

    public init(type: String?, ipAddress: String?, name: String?, macAddress: String?, ifName: String?, endpoints: [DomainEntityRef]?, lineTypes: [LineTypes]?, addressFamilyId: String?) {
        self.type = type
        self.ipAddress = ipAddress
        self.name = name
        self.macAddress = macAddress
        self.ifName = ifName
        self.endpoints = endpoints
        self.lineTypes = lineTypes
        self.addressFamilyId = addressFamilyId
    }


}




public class EdgeLogicalInterfacesChangeTopicErrorInfo: Codable {









    public var message: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var code: String?

    public init(message: String?, messageWithParams: String?, messageParams: [String:String]?, code: String?) {
        self.message = message
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.code = code
    }


}




public class EdgeLogsJob: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** The files available to upload from the Edge to the cloud. */
    public var files: [EdgeLogsJobFile]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, files: [EdgeLogsJobFile]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.files = files
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case files
        case selfUri
    }


}




public class EdgeLogsJobRequest: Codable {







    /** A relative directory to the root Edge log folder to query from. */
    public var path: String?
    /** The pattern to use when searching for logs, which may include the wildcards {*, ?}.  Multiple search patterns may be combined using a pipe '|' as a delimiter. */
    public var query: String?
    /** Boolean whether or not to recurse into directories. */
    public var recurse: Bool?

    public init(path: String?, query: String?, recurse: Bool?) {
        self.path = path
        self.query = query
        self.recurse = recurse
    }


}




public class EdgeMetricsNetwork: Codable {











    /** Identifier for the network adapter. */
    public var ifname: String?
    /** Number of byes sent per second. */
    public var sentBytesPerSec: Int?
    /** Number of byes received per second. */
    public var receivedBytesPerSec: Int?
    /** Total bandwidth of the adapter in bits per second. */
    public var bandwidthBitsPerSec: Double?
    /** Percent utilization of the network adapter. */
    public var utilizationPct: Double?

    public init(ifname: String?, sentBytesPerSec: Int?, receivedBytesPerSec: Int?, bandwidthBitsPerSec: Double?, utilizationPct: Double?) {
        self.ifname = ifname
        self.sentBytesPerSec = sentBytesPerSec
        self.receivedBytesPerSec = receivedBytesPerSec
        self.bandwidthBitsPerSec = bandwidthBitsPerSec
        self.utilizationPct = utilizationPct
    }


}




public class EdgeMetricsTopicEdgeMetricDisk: Codable {







    public var partitionName: String?
    public var availableBytes: Int?
    public var totalBytes: Int?

    public init(partitionName: String?, availableBytes: Int?, totalBytes: Int?) {
        self.partitionName = partitionName
        self.availableBytes = availableBytes
        self.totalBytes = totalBytes
    }


}




public class EdgeMetricsTopicEdgeMetricProcessor: Codable {











    public var cpuId: String?
    public var idleTimePct: Int?
    public var activeTimePct: Int?
    public var privilegedTimePct: Int?
    public var userTimePct: Int?

    public init(cpuId: String?, idleTimePct: Int?, activeTimePct: Int?, privilegedTimePct: Int?, userTimePct: Int?) {
        self.cpuId = cpuId
        self.idleTimePct = idleTimePct
        self.activeTimePct = activeTimePct
        self.privilegedTimePct = privilegedTimePct
        self.userTimePct = userTimePct
    }


}




public class EdgeMetricsTopicEdgeMetricSubsystem: Codable {







    public var processName: String?
    public var delayMs: Int?
    public var mediaSubsystem: EdgeMetricsTopicEdgeMetricSubsystemMedia?

    public init(processName: String?, delayMs: Int?, mediaSubsystem: EdgeMetricsTopicEdgeMetricSubsystemMedia?) {
        self.processName = processName
        self.delayMs = delayMs
        self.mediaSubsystem = mediaSubsystem
    }


}




public class EdgeMetricsTopicEdgeMetricSubsystemMedia: Codable {





    public var processName: String?
    public var delayMs: Int?

    public init(processName: String?, delayMs: Int?) {
        self.processName = processName
        self.delayMs = delayMs
    }


}




public class EdgeMetricsTopicEdgeMetrics: Codable {

















    public var edge: EdgeMetricsTopicUriReference?
    public var eventTime: Date?
    public var upTimeMsec: Int?
    public var processors: [EdgeMetricsTopicEdgeMetricProcessor]?
    public var memory: [EdgeMetricsTopicEdgeMetricMemory]?
    public var disks: [EdgeMetricsTopicEdgeMetricDisk]?
    public var subsystems: [EdgeMetricsTopicEdgeMetricSubsystem]?
    public var networks: [EdgeMetricsTopicEdgeMetricNetworks]?

    public init(edge: EdgeMetricsTopicUriReference?, eventTime: Date?, upTimeMsec: Int?, processors: [EdgeMetricsTopicEdgeMetricProcessor]?, memory: [EdgeMetricsTopicEdgeMetricMemory]?, disks: [EdgeMetricsTopicEdgeMetricDisk]?, subsystems: [EdgeMetricsTopicEdgeMetricSubsystem]?, networks: [EdgeMetricsTopicEdgeMetricNetworks]?) {
        self.edge = edge
        self.eventTime = eventTime
        self.upTimeMsec = upTimeMsec
        self.processors = processors
        self.memory = memory
        self.disks = disks
        self.subsystems = subsystems
        self.networks = networks
    }


}




public class EdgeMetricsTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class EdgeRebootParameters: Codable {



    /** The number of seconds to wait for call draining to complete before initiating the reboot. A value of 0 will prevent call draining and all calls will disconnect immediately. */
    public var callDrainingWaitTimeSeconds: Int?

    public init(callDrainingWaitTimeSeconds: Int?) {
        self.callDrainingWaitTimeSeconds = callDrainingWaitTimeSeconds
    }


}




public class EdgeVersionReport: Codable {





    public var oldestVersion: EdgeVersionInformation?
    public var newestVersion: EdgeVersionInformation?

    public init(oldestVersion: EdgeVersionInformation?, newestVersion: EdgeVersionInformation?) {
        self.oldestVersion = oldestVersion
        self.newestVersion = newestVersion
    }


}



/** Effective Configuration for an ClientApp. This is comprised of the integration specific configuration along with overrides specified in the integration type. */

public class EffectiveConfiguration: Codable {











    /** Key-value configuration settings described by the schema in the propertiesSchemaUri field. */
    public var properties: [String:JSON]?
    /** Advanced configuration described by the schema in the advancedSchemaUri field. */
    public var advanced: [String:JSON]?
    /** The name of the integration, used to distinguish this integration from others of the same type. */
    public var name: String?
    /** Notes about the integration. */
    public var notes: String?
    /** Credentials required by the integration. The required keys are indicated in the credentials property of the Integration Type */
    public var credentials: [String:CredentialInfo]?

    public init(properties: [String:JSON]?, advanced: [String:JSON]?, name: String?, notes: String?, credentials: [String:CredentialInfo]?) {
        self.properties = properties
        self.advanced = advanced
        self.name = name
        self.notes = notes
        self.credentials = credentials
    }


}




public class EmailAttachment: Codable {











    public var name: String?
    public var contentPath: String?
    public var contentType: String?
    public var attachmentId: String?
    public var contentLength: Int?

    public init(name: String?, contentPath: String?, contentType: String?, attachmentId: String?, contentLength: Int?) {
        self.name = name
        self.contentPath = contentPath
        self.contentType = contentType
        self.attachmentId = attachmentId
        self.contentLength = contentLength
    }


}




public class EmailBeginTransmittingEvent: Codable {









    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication. */
    public var communicationId: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
    }


}




public class EmailCampaignSchedule: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** A list of intervals during which to run the associated Campaign. */
    public var intervals: [ScheduleInterval]?
    /** The time zone for this email campaign schedule. */
    public var timeZone: String?
    /** The Campaign that this email campaign schedule is for. */
    public var emailCampaign: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, intervals: [ScheduleInterval]?, timeZone: String?, emailCampaign: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.intervals = intervals
        self.timeZone = timeZone
        self.emailCampaign = emailCampaign
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case intervals
        case timeZone
        case emailCampaign
        case selfUri
    }


}




public class EmailConfig: Codable {









    /** The contact list columns specifying the email address(es) of the contact. */
    public var emailColumns: [String]?
    /** The content template used to formulate the email to send to the contact. */
    public var contentTemplate: DomainEntityRef?
    /** The email address that will be used as the sender of the email. */
    public var fromAddress: FromEmailAddress?
    /** The email address from which any reply will be sent. */
    public var replyToAddress: ReplyToEmailAddress?

    public init(emailColumns: [String]?, contentTemplate: DomainEntityRef?, fromAddress: FromEmailAddress?, replyToAddress: ReplyToEmailAddress?) {
        self.emailColumns = emailColumns
        self.contentTemplate = contentTemplate
        self.fromAddress = fromAddress
        self.replyToAddress = replyToAddress
    }


}




public class EmailMessageReply: Codable {



























    /** The recipients of the email message. */
    public var to: [EmailAddress]?
    /** The recipients that were copied on the email message. */
    public var cc: [EmailAddress]?
    /** The recipients that were blind copied on the email message. */
    public var bcc: [EmailAddress]?
    /** The sender of the email message. */
    public var from: EmailAddress?
    /** The receiver of the reply email message. */
    public var replyTo: EmailAddress?
    /** The subject of the email message. */
    public var subject: String?
    /** The attachments of the email message. */
    public var attachments: [Attachment]?
    /** The text body of the email message. */
    public var textBody: String?
    /** The html body of the email message. */
    public var htmlBody: String?
    /** The time when the message was received or sent. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var time: Date?
    /** Indicates whether the history of previous emails of the conversation is included within the email bodies of this message. */
    public var historyIncluded: Bool?
    /** Indicates an estimation of the size of the current email as a whole, in its final, ready to be sent form. */
    public var emailSizeBytes: Int?
    /** Indicates the maximum allowed size for an email to be send via SMTP server, based on the email domain configuration */
    public var maxEmailSizeBytes: Int?

    public init(to: [EmailAddress]?, cc: [EmailAddress]?, bcc: [EmailAddress]?, from: EmailAddress?, replyTo: EmailAddress?, subject: String?, attachments: [Attachment]?, textBody: String?, htmlBody: String?, time: Date?, historyIncluded: Bool?, emailSizeBytes: Int?, maxEmailSizeBytes: Int?) {
        self.to = to
        self.cc = cc
        self.bcc = bcc
        self.from = from
        self.replyTo = replyTo
        self.subject = subject
        self.attachments = attachments
        self.textBody = textBody
        self.htmlBody = htmlBody
        self.time = time
        self.historyIncluded = historyIncluded
        self.emailSizeBytes = emailSizeBytes
        self.maxEmailSizeBytes = maxEmailSizeBytes
    }


}




public class EmpathyScore: Codable {





    /** Empathy score of the agent involved in the conversation */
    public var score: Double?
    /** UserId of the agent involved in the conversation */
    public var userId: String?

    public init(score: Double?, userId: String?) {
        self.score = score
        self.userId = userId
    }


}




public class EmployerInfo: Codable {









    public var officialName: String?
    public var employeeId: String?
    public var employeeType: String?
    public var dateHire: String?

    public init(officialName: String?, employeeId: String?, employeeType: String?, dateHire: String?) {
        self.officialName = officialName
        self.employeeId = employeeId
        self.employeeType = employeeType
        self.dateHire = dateHire
    }


}




public class EncryptionKeyEntityListing: Codable {





















    public var entities: [EncryptionKey]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [EncryptionKey]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class EstimateAvailableFullDayTimeOffRequest: Codable {





    /** Date in yyyy-MM-dd format for full day request. Should be interpreted in the business unit's configured time zone. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var date: Date?
    /** A requested length of time off request in minutes. If the value is null, then the system will use activity code length setting */
    public var requestedDurationMinutes: Int?

    public init(date: Date?, requestedDurationMinutes: Int?) {
        self.date = date
        self.requestedDurationMinutes = requestedDurationMinutes
    }


}




public class EvaluationCreateQueue: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class EvaluationDetailQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [EvaluationDetailQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [EvaluationDetailQueryPredicate]?

    public init(type: ModelType?, clauses: [EvaluationDetailQueryClause]?, predicates: [EvaluationDetailQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class EvaluationFormResponseEntityListing: Codable {





















    public var entities: [EvaluationFormResponse]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [EvaluationFormResponse]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class EventError: Codable {







    /** The eventId (V4 UUID) for the event that encountered an error. */
    public var eventId: String?
    /** A message describing the error. */
    public var message: String?
    /** The event for this eventId can be resubmitted if this value is true. */
    public var retryable: Bool?

    public init(eventId: String?, message: String?, retryable: Bool?) {
        self.eventId = eventId
        self.message = message
        self.retryable = retryable
    }


}



/** Used to retrieve a set of executionData history by the respective ids */

public class ExecutionDataRequest: Codable {



    /** A list of ids to retrieve */
    public var ids: [String]?

    public init(ids: [String]?) {
        self.ids = ids
    }


}



/** Creating an exported script via Download Service */

public class ExportScriptRequest: Codable {





    /** The final file name (no extension) of the script download: <fileName>.script */
    public var fileName: String?
    /** The UUID version of the script to be exported.  Defaults to the current editable version. */
    public var versionId: String?

    public init(fileName: String?, versionId: String?) {
        self.fileName = fileName
        self.versionId = versionId
    }


}




public class ExportUri: Codable {





    public var uri: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var exportTimestamp: Date?

    public init(uri: String?, exportTimestamp: Date?) {
        self.uri = uri
        self.exportTimestamp = exportTimestamp
    }


}




public class ExternalContact: Codable {





















































    public enum ModelType: String, Codable { 
        case ephemeral = "Ephemeral"
        case identified = "Identified"
        case curated = "Curated"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The first name of the contact. */
    public var firstName: String?
    public var middleName: String?
    /** The last name of the contact. */
    public var lastName: String?
    public var salutation: String?
    public var title: String?
    public var workPhone: PhoneNumber?
    public var cellPhone: PhoneNumber?
    public var homePhone: PhoneNumber?
    public var otherPhone: PhoneNumber?
    public var workEmail: String?
    public var personalEmail: String?
    public var otherEmail: String?
    public var address: ContactAddress?
    public var twitterId: TwitterId?
    public var lineId: LineId?
    public var whatsAppId: WhatsAppId?
    public var facebookId: FacebookId?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifyDate: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createDate: Date?
    public var externalOrganization: ExternalOrganization?
    public var surveyOptOut: Bool?
    /** A string that identifies an external system-of-record resource that may have more detailed information on the contact. It should be a valid URL (including the http/https protocol, port, and path [if any]). The value is automatically trimmed of any leading and trailing whitespace. */
    public var externalSystemUrl: String?
    /** The schema defining custom fields for this contact */
    public var schema: DataSchema?
    /** Custom fields defined in the schema referenced by schemaId and schemaVersion. */
    public var customFields: [String:JSON]?
    /** Links to the sources of data (e.g. one source might be a CRM) that contributed data to this record.  Read-only, and only populated when requested via expand param. */
    public var externalDataSources: [ExternalDataSource]?
    /** The type of contact */
    public var type: ModelType?
    /** The contact at the head of the merge tree. If null, this contact is not a part of any merge. */
    public var canonicalContact: ContactAddressableEntityRef?
    /** The set of all contacts that are a part of the merge tree. If null, this contact is not a part of any merge. */
    public var mergeSet: [ContactAddressableEntityRef]?
    /** Information about the merge history of this contact. If null, this contact is not a part of any merge. */
    public var mergeOperation: MergeOperation?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, firstName: String?, middleName: String?, lastName: String?, salutation: String?, title: String?, workPhone: PhoneNumber?, cellPhone: PhoneNumber?, homePhone: PhoneNumber?, otherPhone: PhoneNumber?, workEmail: String?, personalEmail: String?, otherEmail: String?, address: ContactAddress?, twitterId: TwitterId?, lineId: LineId?, whatsAppId: WhatsAppId?, facebookId: FacebookId?, modifyDate: Date?, createDate: Date?, externalOrganization: ExternalOrganization?, surveyOptOut: Bool?, externalSystemUrl: String?, schema: DataSchema?, customFields: [String:JSON]?, externalDataSources: [ExternalDataSource]?, type: ModelType?, canonicalContact: ContactAddressableEntityRef?, mergeSet: [ContactAddressableEntityRef]?, mergeOperation: MergeOperation?, selfUri: String?) {
        self._id = _id
        self.firstName = firstName
        self.middleName = middleName
        self.lastName = lastName
        self.salutation = salutation
        self.title = title
        self.workPhone = workPhone
        self.cellPhone = cellPhone
        self.homePhone = homePhone
        self.otherPhone = otherPhone
        self.workEmail = workEmail
        self.personalEmail = personalEmail
        self.otherEmail = otherEmail
        self.address = address
        self.twitterId = twitterId
        self.lineId = lineId
        self.whatsAppId = whatsAppId
        self.facebookId = facebookId
        self.modifyDate = modifyDate
        self.createDate = createDate
        self.externalOrganization = externalOrganization
        self.surveyOptOut = surveyOptOut
        self.externalSystemUrl = externalSystemUrl
        self.schema = schema
        self.customFields = customFields
        self.externalDataSources = externalDataSources
        self.type = type
        self.canonicalContact = canonicalContact
        self.mergeSet = mergeSet
        self.mergeOperation = mergeOperation
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case firstName
        case middleName
        case lastName
        case salutation
        case title
        case workPhone
        case cellPhone
        case homePhone
        case otherPhone
        case workEmail
        case personalEmail
        case otherEmail
        case address
        case twitterId
        case lineId
        case whatsAppId
        case facebookId
        case modifyDate
        case createDate
        case externalOrganization
        case surveyOptOut
        case externalSystemUrl
        case schema
        case customFields
        case externalDataSources
        case type
        case canonicalContact
        case mergeSet
        case mergeOperation
        case selfUri
    }


}




public class ExternalContactsContactChangedTopicContact: Codable {







    public enum ModelType: String, Codable { 
        case ephemeral = "Ephemeral"
        case identified = "Identified"
        case curated = "Curated"
    }

















































    public var _id: String?
    public var division: ExternalContactsContactChangedTopicDivision?
    public var externalOrganization: ExternalContactsContactChangedTopicExternalOrganization?
    public var type: ModelType?
    public var firstName: String?
    public var middleName: String?
    public var lastName: String?
    public var salutation: String?
    public var title: String?
    public var workPhone: ExternalContactsContactChangedTopicPhoneNumber?
    public var cellPhone: ExternalContactsContactChangedTopicPhoneNumber?
    public var homePhone: ExternalContactsContactChangedTopicPhoneNumber?
    public var otherPhone: ExternalContactsContactChangedTopicPhoneNumber?
    public var workEmail: String?
    public var personalEmail: String?
    public var otherEmail: String?
    public var address: ExternalContactsContactChangedTopicContactAddress?
    public var surveyOptOut: Bool?
    public var externalSystemUrl: String?
    public var twitterId: ExternalContactsContactChangedTopicTwitterId?
    public var lineId: ExternalContactsContactChangedTopicLineId?
    public var whatsAppId: ExternalContactsContactChangedTopicWhatsAppId?
    public var facebookId: ExternalContactsContactChangedTopicFacebookId?
    public var instagramId: ExternalContactsContactChangedTopicInstagramId?
    public var schema: ExternalContactsContactChangedTopicDataSchema?
    public var customFields: [String:JSON]?
    public var createDate: Date?
    public var modifyDate: Date?

    public init(_id: String?, division: ExternalContactsContactChangedTopicDivision?, externalOrganization: ExternalContactsContactChangedTopicExternalOrganization?, type: ModelType?, firstName: String?, middleName: String?, lastName: String?, salutation: String?, title: String?, workPhone: ExternalContactsContactChangedTopicPhoneNumber?, cellPhone: ExternalContactsContactChangedTopicPhoneNumber?, homePhone: ExternalContactsContactChangedTopicPhoneNumber?, otherPhone: ExternalContactsContactChangedTopicPhoneNumber?, workEmail: String?, personalEmail: String?, otherEmail: String?, address: ExternalContactsContactChangedTopicContactAddress?, surveyOptOut: Bool?, externalSystemUrl: String?, twitterId: ExternalContactsContactChangedTopicTwitterId?, lineId: ExternalContactsContactChangedTopicLineId?, whatsAppId: ExternalContactsContactChangedTopicWhatsAppId?, facebookId: ExternalContactsContactChangedTopicFacebookId?, instagramId: ExternalContactsContactChangedTopicInstagramId?, schema: ExternalContactsContactChangedTopicDataSchema?, customFields: [String:JSON]?, createDate: Date?, modifyDate: Date?) {
        self._id = _id
        self.division = division
        self.externalOrganization = externalOrganization
        self.type = type
        self.firstName = firstName
        self.middleName = middleName
        self.lastName = lastName
        self.salutation = salutation
        self.title = title
        self.workPhone = workPhone
        self.cellPhone = cellPhone
        self.homePhone = homePhone
        self.otherPhone = otherPhone
        self.workEmail = workEmail
        self.personalEmail = personalEmail
        self.otherEmail = otherEmail
        self.address = address
        self.surveyOptOut = surveyOptOut
        self.externalSystemUrl = externalSystemUrl
        self.twitterId = twitterId
        self.lineId = lineId
        self.whatsAppId = whatsAppId
        self.facebookId = facebookId
        self.instagramId = instagramId
        self.schema = schema
        self.customFields = customFields
        self.createDate = createDate
        self.modifyDate = modifyDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case division
        case externalOrganization
        case type
        case firstName
        case middleName
        case lastName
        case salutation
        case title
        case workPhone
        case cellPhone
        case homePhone
        case otherPhone
        case workEmail
        case personalEmail
        case otherEmail
        case address
        case surveyOptOut
        case externalSystemUrl
        case twitterId
        case lineId
        case whatsAppId
        case facebookId
        case instagramId
        case schema
        case customFields
        case createDate
        case modifyDate
    }


}




public class ExternalContactsContactChangedTopicContactAddress: Codable {













    public var address1: String?
    public var address2: String?
    public var city: String?
    public var state: String?
    public var postalCode: String?
    public var countryCode: String?

    public init(address1: String?, address2: String?, city: String?, state: String?, postalCode: String?, countryCode: String?) {
        self.address1 = address1
        self.address2 = address2
        self.city = city
        self.state = state
        self.postalCode = postalCode
        self.countryCode = countryCode
    }


}




public class ExternalContactsContactChangedTopicDataSchema: Codable {





    public var _id: String?
    public var version: Int?

    public init(_id: String?, version: Int?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}




public class ExternalContactsContactChangedTopicWhatsAppId: Codable {





    public var phoneNumber: ExternalContactsContactChangedTopicPhoneNumber?
    public var displayName: String?

    public init(phoneNumber: ExternalContactsContactChangedTopicPhoneNumber?, displayName: String?) {
        self.phoneNumber = phoneNumber
        self.displayName = displayName
    }


}




public class ExternalContactsUnresolvedContactChangedTopicFacebookScopedId: Codable {



    public var scopedId: String?

    public init(scopedId: String?) {
        self.scopedId = scopedId
    }


}




public class ExternalContactsUnresolvedContactChangedTopicInstagramScopedId: Codable {



    public var scopedId: String?

    public init(scopedId: String?) {
        self.scopedId = scopedId
    }


}




public class ExternalContactsUnresolvedContactChangedTopicPhoneNumber: Codable {















    public var display: String?
    public var _extension: Int?
    public var acceptsSMS: Bool?
    public var userInput: String?
    public var e164: String?
    public var countryCode: String?
    public var normalizationCountryCode: String?

    public init(display: String?, _extension: Int?, acceptsSMS: Bool?, userInput: String?, e164: String?, countryCode: String?, normalizationCountryCode: String?) {
        self.display = display
        self._extension = _extension
        self.acceptsSMS = acceptsSMS
        self.userInput = userInput
        self.e164 = e164
        self.countryCode = countryCode
        self.normalizationCountryCode = normalizationCountryCode
    }

    public enum CodingKeys: String, CodingKey { 
        case display
        case _extension = "extension"
        case acceptsSMS
        case userInput
        case e164
        case countryCode
        case normalizationCountryCode
    }


}




public class ExternalContactsUnresolvedContactChangedTopicTwitterId: Codable {











    public var _id: String?
    public var name: String?
    public var screenName: String?
    public var verified: Bool?
    public var profileUrl: String?

    public init(_id: String?, name: String?, screenName: String?, verified: Bool?, profileUrl: String?) {
        self._id = _id
        self.name = name
        self.screenName = screenName
        self.verified = verified
        self.profileUrl = profileUrl
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case screenName
        case verified
        case profileUrl
    }


}




public class ExternalMetricDefinitionCreateRequest: Codable {



    public enum Unit: String, Codable { 
        case seconds = "Seconds"
        case percent = "Percent"
        case number = "Number"
        case currency = "Currency"
    }





    public enum DefaultObjectiveType: String, Codable { 
        case higherIsBetter = "HigherIsBetter"
        case lowerIsBetter = "LowerIsBetter"
        case targetArea = "TargetArea"
    }



    /** The name of the External Metric Definition */
    public var name: String?
    /** The unit of the External Metric Definition */
    public var unit: Unit?
    /** The unit definition of the External Metric Definition */
    public var unitDefinition: String?
    /** The decimal precision of the External Metric Definition. Must be at least 0 and at most 5 */
    public var precision: Int?
    /** The default objective type of the External Metric Definition */
    public var defaultObjectiveType: DefaultObjectiveType?
    /** True if the External Metric Definition is enabled */
    public var enabled: Bool?

    public init(name: String?, unit: Unit?, unitDefinition: String?, precision: Int?, defaultObjectiveType: DefaultObjectiveType?, enabled: Bool?) {
        self.name = name
        self.unit = unit
        self.unitDefinition = unitDefinition
        self.precision = precision
        self.defaultObjectiveType = defaultObjectiveType
        self.enabled = enabled
    }


}




public class ExternalMetricDefinitionUpdateRequest: Codable {





    public enum DefaultObjectiveType: String, Codable { 
        case higherIsBetter = "HigherIsBetter"
        case lowerIsBetter = "LowerIsBetter"
        case targetArea = "TargetArea"
    }



    /** The name of the External Metric Definition */
    public var name: String?
    /** The decimal precision of the External Metric Definition. Must be at least 0 and at most 5 */
    public var precision: Int?
    /** The default objective type of the External Metric Definition */
    public var defaultObjectiveType: DefaultObjectiveType?
    /** True if the External Metric Definition is enabled */
    public var enabled: Bool?

    public init(name: String?, precision: Int?, defaultObjectiveType: DefaultObjectiveType?, enabled: Bool?) {
        self.name = name
        self.precision = precision
        self.defaultObjectiveType = defaultObjectiveType
        self.enabled = enabled
    }


}




public class FacebookIntegrationUpdateRequest: Codable {















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the Facebook Integration */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    /** Defines the message settings to be applied for this integration */
    public var messagingSetting: MessagingSettingRequestReference?
    /** The long-lived Page Access Token of Facebook page.  See https://developers.facebook.com/docs/facebook-login/access-tokens.  Either pageAccessToken or userAccessToken should be provided. */
    public var pageAccessToken: String?
    /** The short-lived User Access Token of the Facebook user logged into the Facebook app.  See https://developers.facebook.com/docs/facebook-login/access-tokens.  Either pageAccessToken or userAccessToken should be provided. */
    public var userAccessToken: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingRequestReference?, pageAccessToken: String?, userAccessToken: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.pageAccessToken = pageAccessToken
        self.userAccessToken = userAccessToken
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case pageAccessToken
        case userAccessToken
        case selfUri
    }


}




public class FacetTerm: Codable {













    public var term: String?
    public var key: Int64?
    public var _id: String?
    public var name: String?
    public var count: Int64?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var time: Date?

    public init(term: String?, key: Int64?, _id: String?, name: String?, count: Int64?, time: Date?) {
        self.term = term
        self.key = key
        self._id = _id
        self.name = name
        self.count = count
        self.time = time
    }

    public enum CodingKeys: String, CodingKey { 
        case term
        case key
        case _id = "id"
        case name
        case count
        case time
    }


}




public class FaxSendRequest: Codable {









    public enum ContentType: String, Codable { 
        case applicationPdf = "application/pdf"
        case imageTiff = "image/tiff"
        case applicationMsword = "application/msword"
        case applicationVndOasisOpendocumentText = "application/vnd.oasis.opendocument.text"
        case applicationVndOpenxmlformatsOfficedocumentWordprocessingmlDocument = "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** A list of outbound fax dialing addresses. E.g. +13175555555 or 3175555555 */
    public var addresses: [String]?
    /** DocumentId of Content Management artifact. If Content Management document is not used for faxing, documentId should be null */
    public var documentId: String?
    /** The content type that is going to be uploaded. If Content Management document is used for faxing, contentType will be ignored */
    public var contentType: ContentType?
    /** Workspace in which the document should be stored. If Content Management document is used for faxing, workspace will be ignored */
    public var workspace: Workspace?
    /** Data for coversheet generation. */
    public var coverSheet: CoverSheet?
    /** Time zone offset minutes from GMT */
    public var timeZoneOffsetMinutes: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, addresses: [String]?, documentId: String?, contentType: ContentType?, workspace: Workspace?, coverSheet: CoverSheet?, timeZoneOffsetMinutes: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.addresses = addresses
        self.documentId = documentId
        self.contentType = contentType
        self.workspace = workspace
        self.coverSheet = coverSheet
        self.timeZoneOffsetMinutes = timeZoneOffsetMinutes
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case addresses
        case documentId
        case contentType
        case workspace
        case coverSheet
        case timeZoneOffsetMinutes
        case selfUri
    }


}




public class FaxStatus: Codable {

















    /** The fax direction, either \"send\" or \"receive\". */
    public var direction: String?
    /** Total number of expected pages, if known. */
    public var expectedPages: Int64?
    /** Active page of the transmission. */
    public var activePage: Int64?
    /** Number of lines that have completed transmission. */
    public var linesTransmitted: Int64?
    /** Number of bytes that have competed transmission. */
    public var bytesTransmitted: Int64?
    /** Current signaling rate of transmission, baud rate. */
    public var baudRate: Int64?
    /** Number of page errors. */
    public var pageErrors: Int64?
    /** Number of line errors. */
    public var lineErrors: Int64?

    public init(direction: String?, expectedPages: Int64?, activePage: Int64?, linesTransmitted: Int64?, bytesTransmitted: Int64?, baudRate: Int64?, pageErrors: Int64?, lineErrors: Int64?) {
        self.direction = direction
        self.expectedPages = expectedPages
        self.activePage = activePage
        self.linesTransmitted = linesTransmitted
        self.bytesTransmitted = bytesTransmitted
        self.baudRate = baudRate
        self.pageErrors = pageErrors
        self.lineErrors = lineErrors
    }


}




public class FaxTopicUserData: Codable {





    public var _id: String?
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class FieldList: Codable {





















    public var customLabels: Bool?
    public var instructionText: String?
    public var key: String?
    public var labelKeys: [String]?
    public var params: [String:JSON]?
    public var repeatable: Bool?
    public var state: String?
    public var type: String?
    public var _required: Bool?
    public var gdpr: Bool?

    public init(customLabels: Bool?, instructionText: String?, key: String?, labelKeys: [String]?, params: [String:JSON]?, repeatable: Bool?, state: String?, type: String?, _required: Bool?, gdpr: Bool?) {
        self.customLabels = customLabels
        self.instructionText = instructionText
        self.key = key
        self.labelKeys = labelKeys
        self.params = params
        self.repeatable = repeatable
        self.state = state
        self.type = type
        self._required = _required
        self.gdpr = gdpr
    }

    public enum CodingKeys: String, CodingKey { 
        case customLabels
        case instructionText
        case key
        case labelKeys
        case params
        case repeatable
        case state
        case type
        case _required = "required"
        case gdpr
    }


}




public class FileUploadMode: Codable {

    public enum FileTypes: String, Codable { 
        case imageJpeg = "image/jpeg"
        case imageGif = "image/gif"
        case imagePng = "image/png"
    }



    /** A list of supported content types for uploading files */
    public var fileTypes: [FileTypes]?
    /** The maximum file size for file uploads in kilobytes. Default is 10240 (10 MB) */
    public var maxFileSizeKB: Int64?

    public init(fileTypes: [FileTypes]?, maxFileSizeKB: Int64?) {
        self.fileTypes = fileTypes
        self.maxFileSizeKB = maxFileSizeKB
    }


}



/** File upload settings for messenger */

public class FileUploadSettings: Codable {







    /** whether or not attachments is enabled */
    public var enableAttachments: Bool?
    /** whether or not supported content profile is enabled */
    public var useSupportedContentProfile: Bool?
    /** The list of supported file upload modes */
    public var modes: [FileUploadMode]?

    public init(enableAttachments: Bool?, useSupportedContentProfile: Bool?, modes: [FileUploadMode]?) {
        self.enableAttachments = enableAttachments
        self.useSupportedContentProfile = useSupportedContentProfile
        self.modes = modes
    }


}




public class FlowDivisionView: Codable {







    public enum ModelType: String, Codable { 
        case bot = "BOT"
        case commonmodule = "COMMONMODULE"
        case digitalbot = "DIGITALBOT"
        case inboundcall = "INBOUNDCALL"
        case inboundchat = "INBOUNDCHAT"
        case inboundemail = "INBOUNDEMAIL"
        case inboundshortmessage = "INBOUNDSHORTMESSAGE"
        case inqueuecall = "INQUEUECALL"
        case inqueueemail = "INQUEUEEMAIL"
        case inqueueshortmessage = "INQUEUESHORTMESSAGE"
        case outboundcall = "OUTBOUNDCALL"
        case securecall = "SECURECALL"
        case speech = "SPEECH"
        case surveyinvite = "SURVEYINVITE"
        case voice = "VOICE"
        case voicemail = "VOICEMAIL"
        case voicesurvey = "VOICESURVEY"
        case workflow = "WORKFLOW"
        case workitem = "WORKITEM"
    }















    /** The flow identifier */
    public var _id: String?
    /** The flow name */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    public var type: ModelType?
    /** the flow description */
    public var _description: String?
    /** json schema describing the inputs for the flow */
    public var inputSchema: JsonSchemaDocument?
    /** json schema describing the outputs for the flow */
    public var outputSchema: JsonSchemaDocument?
    /** List of supported languages for the published version of the flow. */
    public var supportedLanguages: [SupportedLanguage]?
    /** published version information if there is a published version */
    public var publishedVersion: FlowVersion?
    /** debug version information if there is a debug version */
    public var debugVersion: FlowVersion?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, type: ModelType?, _description: String?, inputSchema: JsonSchemaDocument?, outputSchema: JsonSchemaDocument?, supportedLanguages: [SupportedLanguage]?, publishedVersion: FlowVersion?, debugVersion: FlowVersion?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.type = type
        self._description = _description
        self.inputSchema = inputSchema
        self.outputSchema = outputSchema
        self.supportedLanguages = supportedLanguages
        self.publishedVersion = publishedVersion
        self.debugVersion = debugVersion
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case type
        case _description = "description"
        case inputSchema
        case outputSchema
        case supportedLanguages
        case publishedVersion
        case debugVersion
        case selfUri
    }


}




public class FlowExecutionAggregateQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case divisionid = "divisionId"
        case flowid = "flowId"
        case flowobjectid = "flowObjectId"
        case flowversion = "flowVersion"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension predicates */
    public var value: String?
    /** Right hand side for dimension predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case _operator = "operator"
        case value
        case range
    }


}



/** Response object from launching a flow. */

public class FlowExecutionLaunchResponse: Codable {









    /** The flow execution ID */
    public var _id: String?
    /** The flow execution name. */
    public var name: String?
    /** The version of the flow that launched */
    public var flowVersion: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, flowVersion: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.flowVersion = flowVersion
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case flowVersion
        case selfUri
    }


}




public class FlowHealth: Codable {









    /** Info about given flow version. */
    public var flowVersionInfo: FlowHealthVersionInfo?
    /** Each language's status about its health computation. */
    public var languageInfo: [String:LocaleInfo]?
    /** Health metrics information for the intents. */
    public var intents: [FlowHealthIntentInfo]?
    /** The URI for this object */
    public var selfUri: String?

    public init(flowVersionInfo: FlowHealthVersionInfo?, languageInfo: [String:LocaleInfo]?, intents: [FlowHealthIntentInfo]?, selfUri: String?) {
        self.flowVersionInfo = flowVersionInfo
        self.languageInfo = languageInfo
        self.intents = intents
        self.selfUri = selfUri
    }


}




public class FlowHealthIntentUtterance: Codable {







    public enum StaticValidationResults: String, Codable { 
        case tooFewUtterances = "TooFewUtterances"
        case tooManyUtterances = "TooManyUtterances"
        case utteranceTooShort = "UtteranceTooShort"
        case utteranceTooLong = "UtteranceTooLong"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Utterance Text. */
    public var text: String?
    /** Number of issues found for this utterance. */
    public var issueCount: Int64?
    /** Validation results for this utterance. */
    public var staticValidationResults: [StaticValidationResults]?
    /** Details about this utterance being an outlier or not. */
    public var outlierInfo: OutlierInfo?
    /** Confusion details with other utterances. */
    public var confusionInfo: ConfusionInfo?

    public init(_id: String?, text: String?, issueCount: Int64?, staticValidationResults: [StaticValidationResults]?, outlierInfo: OutlierInfo?, confusionInfo: ConfusionInfo?) {
        self._id = _id
        self.text = text
        self.issueCount = issueCount
        self.staticValidationResults = staticValidationResults
        self.outlierInfo = outlierInfo
        self.confusionInfo = confusionInfo
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case text
        case issueCount
        case staticValidationResults
        case outlierInfo
        case confusionInfo
    }


}




public class FlowMetricsTopicFlowOutcome: Codable {







    /** Combination of unique flow outcome identifier and its value separated by colon */
    public var flowOutcome: String?
    /** Unique identifier of a flow outcome */
    public var flowOutcomeId: String?
    /** Flow outcome value, e.g. SUCCESS */
    public var flowOutcomeValue: String?

    public init(flowOutcome: String?, flowOutcomeId: String?, flowOutcomeValue: String?) {
        self.flowOutcome = flowOutcome
        self.flowOutcomeId = flowOutcomeId
        self.flowOutcomeValue = flowOutcomeValue
    }


}




public class FlowObservationDataContainer: Codable {





    /** A mapping from dimension to value */
    public var group: [String:String]?
    public var data: [ObservationMetricData]?

    public init(group: [String:String]?, data: [ObservationMetricData]?) {
        self.group = group
        self.data = data
    }


}




public class FlowObservationQuery: Codable {



    public enum Metrics: String, Codable { 
        case oflow = "oFlow"
    }

    public enum DetailMetrics: String, Codable { 
        case oflow = "oFlow"
    }

    /** Filter to return a subset of observations. Expresses boolean logical predicates as well as dimensional filters */
    public var filter: FlowObservationQueryFilter?
    /** Behaves like a SQL SELECT clause. Only named metrics will be retrieved. */
    public var metrics: [Metrics]?
    /** Metrics for which to include additional detailed observations */
    public var detailMetrics: [DetailMetrics]?

    public init(filter: FlowObservationQueryFilter?, metrics: [Metrics]?, detailMetrics: [DetailMetrics]?) {
        self.filter = filter
        self.metrics = metrics
        self.detailMetrics = detailMetrics
    }


}




public class FlowObservationQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [FlowObservationQueryPredicate]?

    public init(type: ModelType?, predicates: [FlowObservationQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}



/** Details about the current state of a Flow execution */

public class FlowRuntimeExecution: Codable {









    public enum Status: String, Codable { 
        case unknown = "UNKNOWN"
        case running = "RUNNING"
        case error = "ERROR"
        case terminated = "TERMINATED"
        case completed = "COMPLETED"
        case failed = "FAILED"
    }













    /** The flow execution ID */
    public var _id: String?
    /** The flow execution name. */
    public var name: String?
    /** The Version of the flow definition of the flow execution. */
    public var flowVersion: FlowVersion?
    /** The time the flow was launched. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateLaunched: Date?
    /** The flow's running status, which indicates whether the flow is running normally or completed, etc. */
    public var status: Status?
    /** The time the flow completed, if applicable. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCompleted: Date?
    /** The completion reason set at the flow completion time, if applicable. */
    public var completionReason: String?
    /** Additional information if the flow is in error */
    public var flowErrorInfo: ErrorBody?
    /** List of the flow's output variables, if any. Output variables are only supplied for Completed flows. */
    public var outputData: [String:JSON]?
    /** The conversation to which this Flow execution is related */
    public var conversation: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, flowVersion: FlowVersion?, dateLaunched: Date?, status: Status?, dateCompleted: Date?, completionReason: String?, flowErrorInfo: ErrorBody?, outputData: [String:JSON]?, conversation: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.flowVersion = flowVersion
        self.dateLaunched = dateLaunched
        self.status = status
        self.dateCompleted = dateCompleted
        self.completionReason = completionReason
        self.flowErrorInfo = flowErrorInfo
        self.outputData = outputData
        self.conversation = conversation
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case flowVersion
        case dateLaunched
        case status
        case dateCompleted
        case completionReason
        case flowErrorInfo
        case outputData
        case conversation
        case selfUri
    }


}



/** The Footer template identifies the Footer type and its footerUsage */

public class FooterTemplate: Codable {

    public enum ModelType: String, Codable { 
        case signature = "Signature"
    }

    public enum ApplicableResources: String, Codable { 
        case campaign = "Campaign"
    }

    /** Specifies the type represented by Footer. */
    public var type: ModelType?
    /** Specifies the canned response template where the footer can be used. */
    public var applicableResources: [ApplicableResources]?

    public init(type: ModelType?, applicableResources: [ApplicableResources]?) {
        self.type = type
        self.applicableResources = applicableResources
    }


}




public class ForecastAverageSpeedOfAnswerResponse: Codable {



    /** the average speed of answer goal in seconds */
    public var seconds: Int?

    public init(seconds: Int?) {
        self.seconds = seconds
    }


}




public class ForecastServiceGoalTemplateResponse: Codable {









    /** The service level goal for this forecast */
    public var serviceLevel: ForecastServiceLevelResponse?
    /** The average speed of answer goal for this forecast */
    public var averageSpeedOfAnswer: ForecastAverageSpeedOfAnswerResponse?
    /** The abandon rate goal for this forecast */
    public var abandonRate: ForecastAbandonRateResponse?
    /** The service goal impact overrides for this forecast */
    public var impactOverride: ForecastServiceGoalTemplateImpactOverrideResponse?

    public init(serviceLevel: ForecastServiceLevelResponse?, averageSpeedOfAnswer: ForecastAverageSpeedOfAnswerResponse?, abandonRate: ForecastAbandonRateResponse?, impactOverride: ForecastServiceGoalTemplateImpactOverrideResponse?) {
        self.serviceLevel = serviceLevel
        self.averageSpeedOfAnswer = averageSpeedOfAnswer
        self.abandonRate = abandonRate
        self.impactOverride = impactOverride
    }


}




public class ForecastSourceDayPointer: Codable {

    public enum DayOfWeek: String, Codable { 
        case sunday = "Sunday"
        case monday = "Monday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
        case thursday = "Thursday"
        case friday = "Friday"
        case saturday = "Saturday"
        case eighthDay = "EighthDay"
    }









    /** The forecast day of week for this source data */
    public var dayOfWeek: DayOfWeek?
    /** The relative weight to apply to this source data item for weighted averages */
    public var weight: Int?
    /** The date this source data represents, in yyyy-MM-dd format */
    public var date: String?
    /** The name of the source file this data came from if it originated from a data import */
    public var fileName: String?
    /** The key to look up the forecast source data for this source day */
    public var dataKey: String?

    public init(dayOfWeek: DayOfWeek?, weight: Int?, date: String?, fileName: String?, dataKey: String?) {
        self.dayOfWeek = dayOfWeek
        self.weight = weight
        self.date = date
        self.fileName = fileName
        self.dataKey = dataKey
    }


}




public class FullDayTimeOffMarker: Codable {













    /** The date of the time off marker, interpreted in the business unit's time zone. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var businessUnitDate: Date?
    /** The length of the time off marker in minutes */
    public var lengthMinutes: Int?
    /** The description of the time off marker */
    public var _description: String?
    /** The ID of the activity code associated with the time off marker */
    public var activityCodeId: String?
    /** Whether the time off marker is paid */
    public var paid: Bool?
    /** The ID of the time off request */
    public var timeOffRequestId: String?

    public init(businessUnitDate: Date?, lengthMinutes: Int?, _description: String?, activityCodeId: String?, paid: Bool?, timeOffRequestId: String?) {
        self.businessUnitDate = businessUnitDate
        self.lengthMinutes = lengthMinutes
        self._description = _description
        self.activityCodeId = activityCodeId
        self.paid = paid
        self.timeOffRequestId = timeOffRequestId
    }

    public enum CodingKeys: String, CodingKey { 
        case businessUnitDate
        case lengthMinutes
        case _description = "description"
        case activityCodeId
        case paid
        case timeOffRequestId
    }


}




public class GDPRRequest: Codable {









    public enum RequestType: String, Codable { 
        case gdprExport = "GDPR_EXPORT"
        case gdprUpdate = "GDPR_UPDATE"
        case gdprDelete = "GDPR_DELETE"
    }



    public enum Status: String, Codable { 
        case initiated = "INITIATED"
        case searching = "SEARCHING"
        case updating = "UPDATING"
        case deleting = "DELETING"
        case completed = "COMPLETED"
        case error = "ERROR"
        case finalizing = "FINALIZING"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The user that created this request */
    public var createdBy: DomainEntityRef?
    /** The replacement terms for the provided search terms, in the case of a GDPR_UPDATE request */
    public var replacementTerms: [ReplacementTerm]?
    /** The type of GDPR request */
    public var requestType: RequestType?
    /** When the request was submitted. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    /** The status of the request */
    public var status: Status?
    /** The subject of the GDPR request */
    public var subject: GDPRSubject?
    /** The location where the results of the request can be retrieved */
    public var resultsUrl: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, createdBy: DomainEntityRef?, replacementTerms: [ReplacementTerm]?, requestType: RequestType?, createdDate: Date?, status: Status?, subject: GDPRSubject?, resultsUrl: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.createdBy = createdBy
        self.replacementTerms = replacementTerms
        self.requestType = requestType
        self.createdDate = createdDate
        self.status = status
        self.subject = subject
        self.resultsUrl = resultsUrl
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case createdBy
        case replacementTerms
        case requestType
        case createdDate
        case status
        case subject
        case resultsUrl
        case selfUri
    }


}




public class GDPRSubject: Codable {





















    public var name: String?
    public var userId: String?
    public var externalContactId: String?
    public var dialerContactId: DialerContactId?
    public var journeyCustomer: GDPRJourneyCustomer?
    public var socialHandle: SocialHandle?
    public var externalId: String?
    public var addresses: [String]?
    public var phoneNumbers: [String]?
    public var emailAddresses: [String]?

    public init(name: String?, userId: String?, externalContactId: String?, dialerContactId: DialerContactId?, journeyCustomer: GDPRJourneyCustomer?, socialHandle: SocialHandle?, externalId: String?, addresses: [String]?, phoneNumbers: [String]?, emailAddresses: [String]?) {
        self.name = name
        self.userId = userId
        self.externalContactId = externalContactId
        self.dialerContactId = dialerContactId
        self.journeyCustomer = journeyCustomer
        self.socialHandle = socialHandle
        self.externalId = externalId
        self.addresses = addresses
        self.phoneNumbers = phoneNumbers
        self.emailAddresses = emailAddresses
    }


}




public class GKNDocumentationSearchCriteria: Codable {









    public enum Operator: String, Codable { 
        case and = "AND"
        case or = "OR"
        case not = "NOT"
    }





    public enum ModelType: String, Codable { 
        case simple = "SIMPLE"
    }



    /** The end value of the range. This field is used for range search types. */
    public var endValue: String?
    /** A list of values for the search to match against */
    public var values: [String]?
    /** The start value of the range. This field is used for range search types. */
    public var startValue: String?
    /** A value for the search to match against */
    public var value: String?
    /** How to apply this search criteria against other criteria */
    public var _operator: Operator?
    /** Groups multiple conditions */
    public var group: [GKNDocumentationSearchCriteria]?
    /** Set date format for criteria values when using date range search type.  Supports Java date format syntax, example yyyy-MM-dd'T'HH:mm:ss.SSSX. */
    public var dateFormat: String?
    /** Search Type */
    public var type: ModelType?
    /** Field names to search against */
    public var fields: [String]?

    public init(endValue: String?, values: [String]?, startValue: String?, value: String?, _operator: Operator?, group: [GKNDocumentationSearchCriteria]?, dateFormat: String?, type: ModelType?, fields: [String]?) {
        self.endValue = endValue
        self.values = values
        self.startValue = startValue
        self.value = value
        self._operator = _operator
        self.group = group
        self.dateFormat = dateFormat
        self.type = type
        self.fields = fields
    }

    public enum CodingKeys: String, CodingKey { 
        case endValue
        case values
        case startValue
        case value
        case _operator = "operator"
        case group
        case dateFormat
        case type
        case fields
    }


}




public class GamificationScorecardChangeTopicEvaluationDetail: Codable {



















    public var evaluationId: String?
    public var conversationId: String?
    public var conversationDate: String?
    public var formName: String?
    public var points: Int?
    public var maxPoints: Int?
    public var evaluationScore: Int?
    public var evaluationScoreDouble: Double?
    public var mediaTypes: [String]?

    public init(evaluationId: String?, conversationId: String?, conversationDate: String?, formName: String?, points: Int?, maxPoints: Int?, evaluationScore: Int?, evaluationScoreDouble: Double?, mediaTypes: [String]?) {
        self.evaluationId = evaluationId
        self.conversationId = conversationId
        self.conversationDate = conversationDate
        self.formName = formName
        self.points = points
        self.maxPoints = maxPoints
        self.evaluationScore = evaluationScore
        self.evaluationScoreDouble = evaluationScoreDouble
        self.mediaTypes = mediaTypes
    }


}




public class GamificationStatus: Codable {









    /** Gamification status of the organization. */
    public var isActive: Bool?
    /** Gamification start date. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStart: Date?
    /** Automatic assignment of users to the default profile */
    public var automaticUserAssignment: Bool?
    /** Personal best aggregation starting date. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStartPersonalBest: Date?

    public init(isActive: Bool?, dateStart: Date?, automaticUserAssignment: Bool?, dateStartPersonalBest: Date?) {
        self.isActive = isActive
        self.dateStart = dateStart
        self.automaticUserAssignment = automaticUserAssignment
        self.dateStartPersonalBest = dateStartPersonalBest
    }


}




public class GenesysBotConnector: Codable {



    /** User defined name/value parameters passed to the BotConnector bot. */
    public var queryParameters: [String:String]?

    public init(queryParameters: [String:String]?) {
        self.queryParameters = queryParameters
    }


}




public class GetAlertQuery: Codable {

    public enum RuleType: String, Codable { 
        case conversation = "Conversation"
        case presence = "Presence"
        case all = "All"
    }

    public enum QueryType: String, Codable { 
        case info = "Info"
        case count = "Count"
    }

    public enum AlertStatus: String, Codable { 
        case active = "Active"
        case inactive = "Inactive"
        case all = "All"
    }

    public enum ViewedStatus: String, Codable { 
        case unread = "Unread"
        case read = "Read"
        case all = "All"
    }





    public enum SortBy: String, Codable { 
        case name = "Name"
        case dateStart = "DateStart"
    }

    public enum SortOrder: String, Codable { 
        case asc = "Asc"
        case desc = "Desc"
    }

    /** The rule type of the alerts the query will return */
    public var ruleType: RuleType?
    /** The type of query being performed. */
    public var queryType: QueryType?
    /** The status of the alerts the query will return. */
    public var alertStatus: AlertStatus?
    /** The view status of the alerts the query will return. */
    public var viewedStatus: ViewedStatus?
    /** The page number of the queried response */
    public var pageNumber: Int?
    /** The number of entities to return of the queried response.  The max is 25 */
    public var pageSize: Int?
    /** The field to sort responses by.  The accepted choices are Name and DateStart */
    public var sortBy: SortBy?
    /** The order in which response will be sorted.  The accepted choices are Asc and Desc */
    public var sortOrder: SortOrder?

    public init(ruleType: RuleType?, queryType: QueryType?, alertStatus: AlertStatus?, viewedStatus: ViewedStatus?, pageNumber: Int?, pageSize: Int?, sortBy: SortBy?, sortOrder: SortOrder?) {
        self.ruleType = ruleType
        self.queryType = queryType
        self.alertStatus = alertStatus
        self.viewedStatus = viewedStatus
        self.pageNumber = pageNumber
        self.pageSize = pageSize
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }


}




public class GetProfilesResponse: Codable {







    public var total: Int64?
    public var entities: [PerformanceProfile]?
    public var selfUri: String?

    public init(total: Int64?, entities: [PerformanceProfile]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class GoogleDialogflowCustomSettings: Codable {









    /** If set this environment will be used to initiate the dialogflow bot, otherwise the default configuration will be used.  See https://cloud.google.com/dialogflow/docs/agents-versions */
    public var environment: String?
    /** If set this eventName will be used to initiate the dialogflow bot rather than language processing on the input text.  See https://cloud.google.com/dialogflow/es/docs/events-overview */
    public var eventName: String?
    /** Parameters passed to the fulfillment webhook of the bot (if any). */
    public var webhookQueryParameters: [String:String]?
    /** Parameters passed to the event input of the bot. */
    public var eventInputParameters: [String:String]?

    public init(environment: String?, eventName: String?, webhookQueryParameters: [String:String]?, eventInputParameters: [String:String]?) {
        self.environment = environment
        self.eventName = eventName
        self.webhookQueryParameters = webhookQueryParameters
        self.eventInputParameters = eventInputParameters
    }


}




public class Greeting: Codable {





    public enum ModelType: String, Codable { 
        case station = "STATION"
        case voicemail = "VOICEMAIL"
        case name = "NAME"
    }

    public enum OwnerType: String, Codable { 
        case user = "USER"
        case organization = "ORGANIZATION"
        case group = "GROUP"
    }

















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Greeting type */
    public var type: ModelType?
    /** Greeting owner type */
    public var ownerType: OwnerType?
    /** Greeting owner */
    public var owner: DomainEntity?
    public var audioFile: GreetingAudioFile?
    public var audioTTS: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    public var createdBy: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    public var modifiedBy: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, type: ModelType?, ownerType: OwnerType?, owner: DomainEntity?, audioFile: GreetingAudioFile?, audioTTS: String?, createdDate: Date?, createdBy: String?, modifiedDate: Date?, modifiedBy: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.type = type
        self.ownerType = ownerType
        self.owner = owner
        self.audioFile = audioFile
        self.audioTTS = audioTTS
        self.createdDate = createdDate
        self.createdBy = createdBy
        self.modifiedDate = modifiedDate
        self.modifiedBy = modifiedBy
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case type
        case ownerType
        case owner
        case audioFile
        case audioTTS
        case createdDate
        case createdBy
        case modifiedDate
        case modifiedBy
        case selfUri
    }


}




public class GreetingListing: Codable {





















    public var entities: [Greeting]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Greeting]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class GroupContact: Codable {







    public enum ModelType: String, Codable { 
        case groupring = "GROUPRING"
        case groupphone = "GROUPPHONE"
    }

    public enum MediaType: String, Codable { 
        case phone = "PHONE"
    }

    /** Phone number for this contact type */
    public var address: String?
    /** Extension is set if the number is e164 valid */
    public var _extension: String?
    /** Formatted version of the address property */
    public var display: String?
    /** Contact type of the address */
    public var type: ModelType?
    /** Media type of the address */
    public var mediaType: MediaType?

    public init(address: String?, _extension: String?, display: String?, type: ModelType?, mediaType: MediaType?) {
        self.address = address
        self._extension = _extension
        self.display = display
        self.type = type
        self.mediaType = mediaType
    }

    public enum CodingKeys: String, CodingKey { 
        case address
        case _extension = "extension"
        case display
        case type
        case mediaType
    }


}




public class GroupCreate: Codable {











    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }



    public enum ModelType: String, Codable { 
        case official = "official"
        case social = "social"
    }







    public enum Visibility: String, Codable { 
        case _public = "public"
        case owners = "owners"
        case members = "members"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The group name. */
    public var name: String?
    public var _description: String?
    /** Last modified date/time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Number of members. */
    public var memberCount: Int64?
    /** Active, inactive, or deleted state. */
    public var state: State?
    /** Current version for this resource. */
    public var version: Int?
    /** Type of group. */
    public var type: ModelType?
    public var images: [UserImage]?
    public var addresses: [GroupContact]?
    /** Are membership rules visible to the person requesting to view the group */
    public var rulesVisible: Bool?
    /** Who can view this group */
    public var visibility: Visibility?
    /** Allow roles to be assigned to this group */
    public var rolesEnabled: Bool?
    /** Owners of the group */
    public var ownerIds: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, dateModified: Date?, memberCount: Int64?, state: State?, version: Int?, type: ModelType?, images: [UserImage]?, addresses: [GroupContact]?, rulesVisible: Bool?, visibility: Visibility?, rolesEnabled: Bool?, ownerIds: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.dateModified = dateModified
        self.memberCount = memberCount
        self.state = state
        self.version = version
        self.type = type
        self.images = images
        self.addresses = addresses
        self.rulesVisible = rulesVisible
        self.visibility = visibility
        self.rolesEnabled = rolesEnabled
        self.ownerIds = ownerIds
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case dateModified
        case memberCount
        case state
        case version
        case type
        case images
        case addresses
        case rulesVisible
        case visibility
        case rolesEnabled
        case ownerIds
        case selfUri
    }


}




public class GroupGreetingEventGreeting: Codable {















    public var _id: String?
    public var name: String?
    public var type: String?
    public var ownerType: String?
    public var owner: GroupGreetingEventGreetingOwner?
    public var greetingAudioFile: GroupGreetingEventGreetingAudioFile?
    public var audioTTS: String?

    public init(_id: String?, name: String?, type: String?, ownerType: String?, owner: GroupGreetingEventGreetingOwner?, greetingAudioFile: GroupGreetingEventGreetingAudioFile?, audioTTS: String?) {
        self._id = _id
        self.name = name
        self.type = type
        self.ownerType = ownerType
        self.owner = owner
        self.greetingAudioFile = greetingAudioFile
        self.audioTTS = audioTTS
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case type
        case ownerType
        case owner
        case greetingAudioFile
        case audioTTS
    }


}




public class GroupMembersUpdate: Codable {





    /** A list of the ids of the members to add. */
    public var memberIds: [String]?
    /** The current group version. */
    public var version: Int?

    public init(memberIds: [String]?, version: Int?) {
        self.memberIds = memberIds
        self.version = version
    }


}




public class GroupProfile: Codable {





    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The state of the user resource */
    public var state: State?
    /** Datetime of the last modification. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The version of the group resource */
    public var version: Int64?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, state: State?, dateModified: Date?, version: Int64?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.state = state
        self.dateModified = dateModified
        self.version = version
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case state
        case dateModified
        case version
        case selfUri
    }


}




public class GroupUpdate: Codable {







    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }









    public enum Visibility: String, Codable { 
        case _public = "public"
        case ownerids = "ownerIds"
        case members = "members"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The group name. */
    public var name: String?
    public var _description: String?
    /** State of the group. */
    public var state: State?
    /** Current version for this resource. */
    public var version: Int?
    public var images: [UserImage]?
    public var addresses: [GroupContact]?
    /** Are membership rules visible to the person requesting to view the group */
    public var rulesVisible: Bool?
    /** Who can view this group */
    public var visibility: Visibility?
    /** Allow roles to be assigned to this group */
    public var rolesEnabled: Bool?
    /** Owners of the group */
    public var ownerIds: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, state: State?, version: Int?, images: [UserImage]?, addresses: [GroupContact]?, rulesVisible: Bool?, visibility: Visibility?, rolesEnabled: Bool?, ownerIds: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.state = state
        self.version = version
        self.images = images
        self.addresses = addresses
        self.rulesVisible = rulesVisible
        self.visibility = visibility
        self.rolesEnabled = rolesEnabled
        self.ownerIds = ownerIds
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case state
        case version
        case images
        case addresses
        case rulesVisible
        case visibility
        case rolesEnabled
        case ownerIds
        case selfUri
    }


}




public class GuestCategoryReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class GuestMemberInfo: Codable {















    /** The display name to use for the guest member in the conversation. */
    public var displayName: String?
    /** The first name to use for the guest member in the conversation. */
    public var firstName: String?
    /** The last name to use for the guest member in the conversation. */
    public var lastName: String?
    /** The email address to use for the guest member in the conversation. */
    public var email: String?
    /** The phone number to use for the guest member in the conversation. */
    public var phoneNumber: String?
    /** The URL to the avatar image to use for the guest member in the conversation, if any. */
    public var avatarImageUrl: String?
    /** Any custom fields of information, in key-value format, to attach to the guest member in the conversation. */
    public var customFields: [String:String]?

    public init(displayName: String?, firstName: String?, lastName: String?, email: String?, phoneNumber: String?, avatarImageUrl: String?, customFields: [String:String]?) {
        self.displayName = displayName
        self.firstName = firstName
        self.lastName = lastName
        self.email = email
        self.phoneNumber = phoneNumber
        self.avatarImageUrl = avatarImageUrl
        self.customFields = customFields
    }


}




public class HeadcountForecast: Codable {





    /** Headcount information with shrinkage */
    public var _required: [HeadcountInterval]?
    /** Headcount information without shrinkage */
    public var requiredWithoutShrinkage: [HeadcountInterval]?

    public init(_required: [HeadcountInterval]?, requiredWithoutShrinkage: [HeadcountInterval]?) {
        self._required = _required
        self.requiredWithoutShrinkage = requiredWithoutShrinkage
    }

    public enum CodingKeys: String, CodingKey { 
        case _required = "required"
        case requiredWithoutShrinkage
    }


}



/** Link to a help or support resource */

public class HelpLink: Codable {







    /** URI of the help resource */
    public var uri: String?
    /** Link text of the resource */
    public var title: String?
    /** Description of the document or resource */
    public var _description: String?

    public init(uri: String?, title: String?, _description: String?) {
        self.uri = uri
        self.title = title
        self._description = _description
    }

    public enum CodingKeys: String, CodingKey { 
        case uri
        case title
        case _description = "description"
    }


}




public class HistoricalAdherenceExceptionInfo: Codable {







    public enum ScheduledActivityCategory: String, Codable { 
        case onQueueWork = "OnQueueWork"
        case _break = "Break"
        case meal = "Meal"
        case meeting = "Meeting"
        case offQueueWork = "OffQueueWork"
        case timeOff = "TimeOff"
        case training = "Training"
        case unavailable = "Unavailable"
        case unscheduled = "Unscheduled"
    }





    public enum ActualActivityCategory: String, Codable { 
        case onQueueWork = "OnQueueWork"
        case _break = "Break"
        case meal = "Meal"
        case meeting = "Meeting"
        case offQueueWork = "OffQueueWork"
        case timeOff = "TimeOff"
        case training = "Training"
        case unavailable = "Unavailable"
        case unscheduled = "Unscheduled"
    }

    public enum SystemPresence: String, Codable { 
        case available = "Available"
        case away = "Away"
        case busy = "Busy"
        case offline = "Offline"
        case idle = "Idle"
        case onQueue = "OnQueue"
        case meal = "Meal"
        case training = "Training"
        case meeting = "Meeting"
        case _break = "Break"
    }

    public enum RoutingStatus: String, Codable { 
        case offQueue = "OFF_QUEUE"
        case idle = "IDLE"
        case interacting = "INTERACTING"
        case notResponding = "NOT_RESPONDING"
        case communicating = "COMMUNICATING"
    }

    public enum Impact: String, Codable { 
        case positive = "Positive"
        case negative = "Negative"
        case neutral = "Neutral"
        case unknown = "Unknown"
    }



    /** Exception start offset in seconds relative to query start time */
    public var startOffsetSeconds: Int?
    /** Exception end offset in seconds relative to query start time */
    public var endOffsetSeconds: Int?
    /** The ID of the scheduled activity code for this user */
    public var scheduledActivityCodeId: String?
    /** Activity for which the user is scheduled */
    public var scheduledActivityCategory: ScheduledActivityCategory?
    /** The lookup IDs used to retrieve the scheduled secondary statuses from map of lookup ID to corresponding secondary presence ID */
    public var scheduledSecondaryPresenceLookupIds: [String]?
    /** The ID of the actual activity code for this user */
    public var actualActivityCodeId: String?
    /** Activity for which the user is actually engaged */
    public var actualActivityCategory: ActualActivityCategory?
    /** Actual underlying system presence value */
    public var systemPresence: SystemPresence?
    /** Actual underlying routing status, used to determine whether a user is actually in adherence when OnQueue */
    public var routingStatus: RoutingStatus?
    /** The impact of the current adherence state for this user */
    public var impact: Impact?
    /** The lookup ID used to retrieve the actual secondary status from map of lookup ID to corresponding secondary presence ID */
    public var secondaryPresenceLookupId: String?

    public init(startOffsetSeconds: Int?, endOffsetSeconds: Int?, scheduledActivityCodeId: String?, scheduledActivityCategory: ScheduledActivityCategory?, scheduledSecondaryPresenceLookupIds: [String]?, actualActivityCodeId: String?, actualActivityCategory: ActualActivityCategory?, systemPresence: SystemPresence?, routingStatus: RoutingStatus?, impact: Impact?, secondaryPresenceLookupId: String?) {
        self.startOffsetSeconds = startOffsetSeconds
        self.endOffsetSeconds = endOffsetSeconds
        self.scheduledActivityCodeId = scheduledActivityCodeId
        self.scheduledActivityCategory = scheduledActivityCategory
        self.scheduledSecondaryPresenceLookupIds = scheduledSecondaryPresenceLookupIds
        self.actualActivityCodeId = actualActivityCodeId
        self.actualActivityCategory = actualActivityCategory
        self.systemPresence = systemPresence
        self.routingStatus = routingStatus
        self.impact = impact
        self.secondaryPresenceLookupId = secondaryPresenceLookupId
    }


}




public class HistoricalImportStatus: Codable {







    public enum Status: String, Codable { 
        case initiated = "Initiated"
        case inProgress = "InProgress"
        case pending = "Pending"
        case success = "Success"
        case failed = "Failed"
        case cancelled = "Cancelled"
        case purged = "Purged"
        case purgePending = "PurgePending"
    }









    public enum ModelType: String, Codable { 
        case csv = "Csv"
        case json = "Json"
    }

    /** Request id of the historical import in the organization */
    public var requestId: String?
    /** The last day of the data you are importing. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateImportEnded: Date?
    /** The first day of the data you are importing. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateImportStarted: Date?
    /** Status of the historical import in the organization. */
    public var status: Status?
    /** Error occured if the status of the import is failed */
    public var error: String?
    /** Date in which the historical import is initiated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date in which the historical import is modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Whether this historical import is active or not */
    public var active: Bool?
    /** Whether this historical import is of type csv or json */
    public var type: ModelType?

    public init(requestId: String?, dateImportEnded: Date?, dateImportStarted: Date?, status: Status?, error: String?, dateCreated: Date?, dateModified: Date?, active: Bool?, type: ModelType?) {
        self.requestId = requestId
        self.dateImportEnded = dateImportEnded
        self.dateImportStarted = dateImportStarted
        self.status = status
        self.error = error
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.active = active
        self.type = type
    }


}




public class HistoricalImportStatusListing: Codable {



    public var entities: [HistoricalImportStatus]?

    public init(entities: [HistoricalImportStatus]?) {
        self.entities = entities
    }


}




public class HistoricalShrinkageAggregateResponse: Codable {

















    /** Aggregated shrinkage value in seconds for scheduled activities */
    public var scheduledShrinkageSeconds: Int?
    /** Aggregated shrinkage value in percent from 0.0 to 100.0 for scheduled activities */
    public var scheduledShrinkagePercent: Double?
    /** Aggregated actual value in seconds for scheduled activities */
    public var actualShrinkageSeconds: Int?
    /** Aggregated actual value in percent from 0.0 to 100.0 for scheduled activities */
    public var actualShrinkagePercent: Double?
    /** Aggregated shrinkage value in seconds for paid activities */
    public var paidShrinkageSeconds: Int?
    /** Aggregated shrinkage value in seconds for unpaid activities */
    public var unpaidShrinkageSeconds: Int?
    /** Aggregated shrinkage value in seconds for planned activities */
    public var plannedShrinkageSeconds: Int?
    /** Aggregated shrinkage value in seconds for unplanned activities */
    public var unplannedShrinkageSeconds: Int?

    public init(scheduledShrinkageSeconds: Int?, scheduledShrinkagePercent: Double?, actualShrinkageSeconds: Int?, actualShrinkagePercent: Double?, paidShrinkageSeconds: Int?, unpaidShrinkageSeconds: Int?, plannedShrinkageSeconds: Int?, unplannedShrinkageSeconds: Int?) {
        self.scheduledShrinkageSeconds = scheduledShrinkageSeconds
        self.scheduledShrinkagePercent = scheduledShrinkagePercent
        self.actualShrinkageSeconds = actualShrinkageSeconds
        self.actualShrinkagePercent = actualShrinkagePercent
        self.paidShrinkageSeconds = paidShrinkageSeconds
        self.unpaidShrinkageSeconds = unpaidShrinkageSeconds
        self.plannedShrinkageSeconds = plannedShrinkageSeconds
        self.unplannedShrinkageSeconds = unplannedShrinkageSeconds
    }


}



/** Defines the phone numbers, operating hours, and the Architect flows to execute for an IVR. */

public class IVR: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** The phone number(s) to contact the IVR by.  Each phone number must be unique and not in use by another resource.  For example, a user and an iVR cannot have the same phone number. */
    public var dnis: [String]?
    /** The Architect flow to execute during the hours an organization is open. */
    public var openHoursFlow: DomainEntityRef?
    /** The Architect flow to execute during the hours an organization is closed. */
    public var closedHoursFlow: DomainEntityRef?
    /** The Architect flow to execute during an organization's holiday hours. */
    public var holidayHoursFlow: DomainEntityRef?
    /** The schedule group defining the open and closed hours for an organization.  If this is provided, an open flow and a closed flow must be specified as well. */
    public var scheduleGroup: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, dnis: [String]?, openHoursFlow: DomainEntityRef?, closedHoursFlow: DomainEntityRef?, holidayHoursFlow: DomainEntityRef?, scheduleGroup: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.dnis = dnis
        self.openHoursFlow = openHoursFlow
        self.closedHoursFlow = closedHoursFlow
        self.holidayHoursFlow = holidayHoursFlow
        self.scheduleGroup = scheduleGroup
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case dnis
        case openHoursFlow
        case closedHoursFlow
        case holidayHoursFlow
        case scheduleGroup
        case selfUri
    }


}




public class HistoryHeadersTranslation: Codable {



















    /** A translation for the word \"from\", for the expected language */
    public var from: String?
    /** A translation for the word \"to\", for the expected language */
    public var to: String?
    /** A translation for the word \"cc\", for the expected language */
    public var cc: String?
    /** A translation for the word \"subject\", for the expected language */
    public var subject: String?
    /** A translation for the subject prefix \"Reply\", for the expected language */
    public var replyPrefix: String?
    /** A translation for the subject prefix \"Forward\", for the expected language */
    public var forwardPrefix: String?
    /** A translation for the word \"sent\", for the expected language */
    public var sent: String?
    /** The code of the expected language */
    public var language: String?
    /** Timezone used by the agent, used to format the sent email date and time. If not defined, will default to UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var timeZone: String?

    public init(from: String?, to: String?, cc: String?, subject: String?, replyPrefix: String?, forwardPrefix: String?, sent: String?, language: String?, timeZone: String?) {
        self.from = from
        self.to = to
        self.cc = cc
        self.subject = subject
        self.replyPrefix = replyPrefix
        self.forwardPrefix = forwardPrefix
        self.sent = sent
        self.language = language
        self.timeZone = timeZone
    }


}




public class HoldUpdatedEvent: Codable {











    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication */
    public var communicationId: String?
    /** Indicates whether this communication is held. */
    public var held: Bool?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, held: Bool?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.held = held
    }


}




public class HrisTimeOffType: Codable {









    /** The ID of the time off type configured in integration. */
    public var _id: String?
    /** The name of the time off type configured in integration. */
    public var name: String?
    /** The ID of the integration. */
    public var hrisIntegrationId: String?
    /** Secondary ID of the time off type, if configured in integration. */
    public var secondaryId: String?

    public init(_id: String?, name: String?, hrisIntegrationId: String?, secondaryId: String?) {
        self._id = _id
        self.name = name
        self.hrisIntegrationId = hrisIntegrationId
        self.secondaryId = secondaryId
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case hrisIntegrationId
        case secondaryId
    }


}




public class HrisTimeOffTypesJobResponse: Codable {



    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case error = "Error"
    }

    public var entities: [HrisTimeOffTypeResponse]?
    /** The status of the time off types job */
    public var status: Status?

    public init(entities: [HrisTimeOffTypeResponse]?, status: Status?) {
        self.entities = entities
        self.status = status
    }


}




public class IVRDivisionViewEntityListing: Codable {





















    public var entities: [IVRDivisionView]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [IVRDivisionView]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ImportReport: Codable {









    public var errors: [ImportError]?
    public var validated: ResultCounters?
    public var imported: ResultCounters?
    public var totalDocuments: Int?

    public init(errors: [ImportError]?, validated: ResultCounters?, imported: ResultCounters?, totalDocuments: Int?) {
        self.errors = errors
        self.validated = validated
        self.imported = imported
        self.totalDocuments = totalDocuments
    }


}




public class ImportTemplateImportStatusImportStatus: Codable {

    public enum ImportState: String, Codable { 
        case inProgress = "IN_PROGRESS"
        case failed = "FAILED"
    }















    /** current status of the import */
    public var importState: ImportState?
    /** total number of records to be imported */
    public var totalRecords: Int?
    /** number of records finished importing */
    public var completedRecords: Int?
    /** percentage of records finished importing */
    public var percentageComplete: Int?
    /** if the import has failed, the reason for the failure */
    public var failureReason: String?
    /** The ids for target contact lists */
    public var targetContactListIds: [String]?
    /** The prefix used for target contact list names */
    public var listNamePrefix: String?
    public var additionalProperties: [String:JSON]?

    public init(importState: ImportState?, totalRecords: Int?, completedRecords: Int?, percentageComplete: Int?, failureReason: String?, targetContactListIds: [String]?, listNamePrefix: String?, additionalProperties: [String:JSON]?) {
        self.importState = importState
        self.totalRecords = totalRecords
        self.completedRecords = completedRecords
        self.percentageComplete = percentageComplete
        self.failureReason = failureReason
        self.targetContactListIds = targetContactListIds
        self.listNamePrefix = listNamePrefix
        self.additionalProperties = additionalProperties
    }


}




public class InboundDomainEntityListing: Codable {





















    public var entities: [InboundDomain]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [InboundDomain]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class InboundOnlySetting: Codable {

    public enum Inbound: String, Codable { 
        case enabled = "Enabled"
        case disabled = "Disabled"
    }

    public var inbound: Inbound?

    public init(inbound: Inbound?) {
        self.inbound = inbound
    }


}




public class InboundRoute: Codable {





























    public enum HistoryInclusion: String, Codable { 
        case include = "Include"
        case exclude = "Exclude"
        case _optional = "Optional"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The search pattern that the mailbox name should match. */
    public var pattern: String?
    /** The queue to route the emails to. */
    public var queue: DomainEntityRef?
    /** The priority to use for routing. */
    public var priority: Int?
    /** The skills to use for routing. */
    public var skills: [DomainEntityRef]?
    /** The language to use for routing. */
    public var language: DomainEntityRef?
    /** The sender name to use for outgoing replies. */
    public var fromName: String?
    /** The sender email to use for outgoing replies. */
    public var fromEmail: String?
    /** The flow to use for processing the email. */
    public var flow: DomainEntityRef?
    /** The route to use for email replies. */
    public var replyEmailAddress: QueueEmailAddress?
    /** The recipients that should be automatically blind copied on outbound emails associated with this InboundRoute. */
    public var autoBcc: [EmailAddress]?
    /** The flow to use for processing inbound emails that have been marked as spam. */
    public var spamFlow: DomainEntityRef?
    /** The configuration for the canned response signature that will be appended to outbound emails sent via this route */
    public var signature: Signature?
    /** The configuration to indicate how the history of a conversation has to be included in a draft */
    public var historyInclusion: HistoryInclusion?
    /** Control if multiple actions are allowed on this route. When true the disconnect has to be done manually. When false a conversation will be disconnected by the system after every action */
    public var allowMultipleActions: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, pattern: String?, queue: DomainEntityRef?, priority: Int?, skills: [DomainEntityRef]?, language: DomainEntityRef?, fromName: String?, fromEmail: String?, flow: DomainEntityRef?, replyEmailAddress: QueueEmailAddress?, autoBcc: [EmailAddress]?, spamFlow: DomainEntityRef?, signature: Signature?, historyInclusion: HistoryInclusion?, allowMultipleActions: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.pattern = pattern
        self.queue = queue
        self.priority = priority
        self.skills = skills
        self.language = language
        self.fromName = fromName
        self.fromEmail = fromEmail
        self.flow = flow
        self.replyEmailAddress = replyEmailAddress
        self.autoBcc = autoBcc
        self.spamFlow = spamFlow
        self.signature = signature
        self.historyInclusion = historyInclusion
        self.allowMultipleActions = allowMultipleActions
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case pattern
        case queue
        case priority
        case skills
        case language
        case fromName
        case fromEmail
        case flow
        case replyEmailAddress
        case autoBcc
        case spamFlow
        case signature
        case historyInclusion
        case allowMultipleActions
        case selfUri
    }


}



/** Information about a CX infrastructure as code job */

public class InfrastructureascodeJob: Codable {











    public enum Status: String, Codable { 
        case created = "Created"
        case queued = "Queued"
        case running = "Running"
        case complete = "Complete"
        case failed = "Failed"
        case incomplete = "Incomplete"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** dryRun */
    public var dryRun: Bool?
    /** acceleratorId */
    public var acceleratorId: String?
    /** dateSubmitted. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateSubmitted: Date?
    /** submittedBy */
    public var submittedBy: UserReference?
    /** status */
    public var status: Status?
    /** errorInfo */
    public var errorInfo: ErrorInfo?
    /** results */
    public var results: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, dryRun: Bool?, acceleratorId: String?, dateSubmitted: Date?, submittedBy: UserReference?, status: Status?, errorInfo: ErrorInfo?, results: String?, selfUri: String?) {
        self._id = _id
        self.dryRun = dryRun
        self.acceleratorId = acceleratorId
        self.dateSubmitted = dateSubmitted
        self.submittedBy = submittedBy
        self.status = status
        self.errorInfo = errorInfo
        self.results = results
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case dryRun
        case acceleratorId
        case dateSubmitted
        case submittedBy
        case status
        case errorInfo
        case results
        case selfUri
    }


}




public class InitiateScreenRecording: Codable {







    public var recordACW: Bool?
    public var archiveRetention: ArchiveRetention?
    public var deleteRetention: DeleteRetention?

    public init(recordACW: Bool?, archiveRetention: ArchiveRetention?, deleteRetention: DeleteRetention?) {
        self.recordACW = recordACW
        self.archiveRetention = archiveRetention
        self.deleteRetention = deleteRetention
    }


}




public class InitiatingAction: Codable {





    /** Id of the audit initiating the transaction */
    public var transactionId: String?
    /** Action of the audit initiating the transaction */
    public var actionContext: String?

    public init(transactionId: String?, actionContext: String?) {
        self.transactionId = transactionId
        self.actionContext = actionContext
    }


}




public class InsightsAgents: Codable {





    public enum Granularity: String, Codable { 
        case daily = "Daily"
        case weekly = "Weekly"
        case monthly = "Monthly"
    }







    /** The performance profile */
    public var performanceProfile: AddressableEntityRef?
    /** The division */
    public var division: DivisionReference?
    /** Granularity */
    public var granularity: Granularity?
    /** Start workday used as the date range. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStartWorkday: Date?
    /** End workday used as the date range. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEndWorkday: Date?
    /** The list of insights agents */
    public var entities: [InsightsAgentItem]?

    public init(performanceProfile: AddressableEntityRef?, division: DivisionReference?, granularity: Granularity?, dateStartWorkday: Date?, dateEndWorkday: Date?, entities: [InsightsAgentItem]?) {
        self.performanceProfile = performanceProfile
        self.division = division
        self.granularity = granularity
        self.dateStartWorkday = dateStartWorkday
        self.dateEndWorkday = dateEndWorkday
        self.entities = entities
    }


}




public class InsightsDetails: Codable {





    public enum Granularity: String, Codable { 
        case daily = "Daily"
        case weekly = "Weekly"
        case monthly = "Monthly"
    }











    /** The performance profile */
    public var performanceProfile: AddressableEntityRef?
    /** The division */
    public var division: DivisionReference?
    /** Granularity */
    public var granularity: Granularity?
    /** The comparative period work day date range */
    public var comparativePeriod: WorkdayPeriod?
    /** The primary period work day date range */
    public var primaryPeriod: WorkdayPeriod?
    /** The query user */
    public var user: UserReference?
    /** The list of insights data for each metric of the user */
    public var metricData: [InsightsDetailsMetricItem]?
    /** Overall insights data of the user */
    public var overallData: InsightsDetailsOverallItem?

    public init(performanceProfile: AddressableEntityRef?, division: DivisionReference?, granularity: Granularity?, comparativePeriod: WorkdayPeriod?, primaryPeriod: WorkdayPeriod?, user: UserReference?, metricData: [InsightsDetailsMetricItem]?, overallData: InsightsDetailsOverallItem?) {
        self.performanceProfile = performanceProfile
        self.division = division
        self.granularity = granularity
        self.comparativePeriod = comparativePeriod
        self.primaryPeriod = primaryPeriod
        self.user = user
        self.metricData = metricData
        self.overallData = overallData
    }


}




public class InsightsDetailsMetricPeriodPoints: Codable {















    /** Points scored */
    public var points: Int?
    /** Max possible points */
    public var maxPoints: Int?
    /** Number of data points */
    public var dataPointCount: Int?
    /** Percentage of the goal */
    public var percentOfGoal: Double?
    /** The agent's rank in leader board for points on this metric */
    public var rankTotalPoints: Int?
    /** The agent's rank in leader board for percentage on this metric */
    public var rankPercentagePoints: Int?
    /** Average value */
    public var value: Double?

    public init(points: Int?, maxPoints: Int?, dataPointCount: Int?, percentOfGoal: Double?, rankTotalPoints: Int?, rankPercentagePoints: Int?, value: Double?) {
        self.points = points
        self.maxPoints = maxPoints
        self.dataPointCount = dataPointCount
        self.percentOfGoal = percentOfGoal
        self.rankTotalPoints = rankTotalPoints
        self.rankPercentagePoints = rankPercentagePoints
        self.value = value
    }


}




public class InsightsSummary: Codable {













    public enum Granularity: String, Codable { 
        case daily = "Daily"
        case weekly = "Weekly"
        case monthly = "Monthly"
    }







    public var entities: [InsightsSummaryUserItem]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    /** The performance profile */
    public var performanceProfile: AddressableEntityRef?
    /** The division */
    public var division: DivisionReference?
    /** Granularity */
    public var granularity: Granularity?
    /** The comparative period work day date range */
    public var comparativePeriod: WorkdayPeriod?
    /** The primary period work day date range */
    public var primaryPeriod: WorkdayPeriod?
    public var pageCount: Int?

    public init(entities: [InsightsSummaryUserItem]?, pageSize: Int?, pageNumber: Int?, total: Int64?, performanceProfile: AddressableEntityRef?, division: DivisionReference?, granularity: Granularity?, comparativePeriod: WorkdayPeriod?, primaryPeriod: WorkdayPeriod?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.performanceProfile = performanceProfile
        self.division = division
        self.granularity = granularity
        self.comparativePeriod = comparativePeriod
        self.primaryPeriod = primaryPeriod
        self.pageCount = pageCount
    }


}




public class InsightsSummaryMetricPeriodPoints: Codable {











    /** Points scored */
    public var points: Int?
    /** Max possible points */
    public var maxPoints: Int?
    /** Number of data points */
    public var dataPointCount: Int?
    /** Percentage of the goal */
    public var percentOfGoal: Double?
    /** Average value */
    public var value: Double?

    public init(points: Int?, maxPoints: Int?, dataPointCount: Int?, percentOfGoal: Double?, value: Double?) {
        self.points = points
        self.maxPoints = maxPoints
        self.dataPointCount = dataPointCount
        self.percentOfGoal = percentOfGoal
        self.value = value
    }


}




public class InsightsTrendMetricItem: Codable {





    /** The gamification metric for the trend */
    public var metric: AddressableEntityRef?
    /** Trends for the metric */
    public var trends: InsightsTrends?

    public init(metric: AddressableEntityRef?, trends: InsightsTrends?) {
        self.metric = metric
        self.trends = trends
    }


}




public class InstagramIntegrationUpdateRequest: Codable {















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the Instagram Integration */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    /** Defines the message settings to be applied for this integration */
    public var messagingSetting: MessagingSettingRequestReference?
    /** The long-lived Page Access Token of Instagram page.  See https://developers.facebook.com/docs/facebook-login/access-tokens.  Either pageAccessToken or userAccessToken should be provided. */
    public var pageAccessToken: String?
    /** The short-lived User Access Token of the Instagram user logged into the Facebook app.  See https://developers.facebook.com/docs/facebook-login/access-tokens.  Either pageAccessToken or userAccessToken should be provided. */
    public var userAccessToken: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingRequestReference?, pageAccessToken: String?, userAccessToken: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.pageAccessToken = pageAccessToken
        self.userAccessToken = userAccessToken
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case pageAccessToken
        case userAccessToken
        case selfUri
    }


}



/** Details for an Integration */

public class Integration: Codable {









    public enum IntendedState: String, Codable { 
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        case deleted = "DELETED"
        case restored = "RESTORED"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the integration, used to distinguish this integration from others of the same type. */
    public var name: String?
    /** Type of the integration */
    public var integrationType: IntegrationType?
    /** Notes about the integration. */
    public var notes: String?
    /** Configured state of the integration. */
    public var intendedState: IntendedState?
    /** Configuration information for the integration. */
    public var config: IntegrationConfigurationInfo?
    /** Last reported status of the integration. */
    public var reportedState: IntegrationStatusInfo?
    /** Read-only attributes for the integration. */
    public var attributes: [String:String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, integrationType: IntegrationType?, notes: String?, intendedState: IntendedState?, config: IntegrationConfigurationInfo?, reportedState: IntegrationStatusInfo?, attributes: [String:String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.integrationType = integrationType
        self.notes = notes
        self.intendedState = intendedState
        self.config = config
        self.reportedState = reportedState
        self.attributes = attributes
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case integrationType
        case notes
        case intendedState
        case config
        case reportedState
        case attributes
        case selfUri
    }


}




public class IntegrationActionFields: Codable {





    /** Reference to the Integration Action to be used when integrationAction type is qualified */
    public var integrationAction: IntegrationAction?
    /** Collection of Request Mappings to use */
    public var requestMappings: [RequestMapping]?

    public init(integrationAction: IntegrationAction?, requestMappings: [RequestMapping]?) {
        self.integrationAction = integrationAction
        self.requestMappings = requestMappings
    }


}



/** Status information for an Integration. */

public class IntegrationStatusInfo: Codable {

    public enum Code: String, Codable { 
        case active = "ACTIVE"
        case activating = "ACTIVATING"
        case inactive = "INACTIVE"
        case deactivating = "DEACTIVATING"
        case error = "ERROR"
    }







    /** Machine-readable status as reported by the integration. */
    public var code: Code?
    /** Localized, human-readable, effective status of the integration. */
    public var effective: String?
    /** Localizable status details for the integration. */
    public var detail: MessageInfo?
    /** Date and time (in UTC) when the integration status (i.e. the code field) was last updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var lastUpdated: Date?

    public init(code: Code?, effective: String?, detail: MessageInfo?, lastUpdated: Date?) {
        self.code = code
        self.effective = effective
        self.detail = detail
        self.lastUpdated = lastUpdated
    }


}




public class IntegrationTypeEntityListing: Codable {





















    public var entities: [IntegrationType]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [IntegrationType]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class Intent: Codable {



    public var name: String?

    public init(name: String?) {
        self.name = name
    }


}




public class IntradayPlanningGroupRequest: Codable {



    public enum Categories: String, Codable { 
        case forecastData = "ForecastData"
        case scheduleData = "ScheduleData"
        case performancePredictionData = "PerformancePredictionData"
    }





    /** Requested date in yyyy-MM-dd format. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var businessUnitDate: Date?
    /** The metric categories */
    public var categories: [Categories]?
    /** The IDs of the planning groups for which to fetch data.  Omitting or passing an empty list will return all available planning groups */
    public var planningGroupIds: [String]?
    /** The period/interval in minutes for which to aggregate the data. Required, defaults to 15 */
    public var intervalLengthMinutes: Int?

    public init(businessUnitDate: Date?, categories: [Categories]?, planningGroupIds: [String]?, intervalLengthMinutes: Int?) {
        self.businessUnitDate = businessUnitDate
        self.categories = categories
        self.planningGroupIds = planningGroupIds
        self.intervalLengthMinutes = intervalLengthMinutes
    }


}




public class JourneyAppEventsNotificationBrowser: Codable {





















    public var family: String?
    public var version: String?
    public var lang: String?
    public var fingerprint: String?
    public var viewHeight: Int?
    public var viewWidth: Int?
    public var featuresFlash: Bool?
    public var featuresJava: Bool?
    public var featuresPdf: Bool?
    public var featuresWebrtc: Bool?

    public init(family: String?, version: String?, lang: String?, fingerprint: String?, viewHeight: Int?, viewWidth: Int?, featuresFlash: Bool?, featuresJava: Bool?, featuresPdf: Bool?, featuresWebrtc: Bool?) {
        self.family = family
        self.version = version
        self.lang = lang
        self.fingerprint = fingerprint
        self.viewHeight = viewHeight
        self.viewWidth = viewWidth
        self.featuresFlash = featuresFlash
        self.featuresJava = featuresJava
        self.featuresPdf = featuresPdf
        self.featuresWebrtc = featuresWebrtc
    }


}




public class JourneyAppEventsNotificationMktCampaign: Codable {















    public var content: String?
    public var medium: String?
    public var name: String?
    public var source: String?
    public var term: String?
    public var clickId: String?
    public var network: String?

    public init(content: String?, medium: String?, name: String?, source: String?, term: String?, clickId: String?, network: String?) {
        self.content = content
        self.medium = medium
        self.name = name
        self.source = source
        self.term = term
        self.clickId = clickId
        self.network = network
    }


}




public class JourneyAppEventsNotificationNetworkConnectivity: Codable {









    public var carrier: String?
    public var bluetoothEnabled: Bool?
    public var cellularEnabled: Bool?
    public var wifiEnabled: Bool?

    public init(carrier: String?, bluetoothEnabled: Bool?, cellularEnabled: Bool?, wifiEnabled: Bool?) {
        self.carrier = carrier
        self.bluetoothEnabled = bluetoothEnabled
        self.cellularEnabled = cellularEnabled
        self.wifiEnabled = wifiEnabled
    }


}




public class JourneyAppEventsNotificationSdkLibrary: Codable {





    public var name: String?
    public var version: String?

    public init(name: String?, version: String?) {
        self.name = name
        self.version = version
    }


}




public class JourneyAppEventsNotificationSession: Codable {







    public var _id: String?
    public var selfUri: String?
    public var type: String?

    public init(_id: String?, selfUri: String?, type: String?) {
        self._id = _id
        self.selfUri = selfUri
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case type
    }


}



/** Settings concerning journey events */

public class JourneyEventsSettings: Codable {









    public enum PageviewConfig: String, Codable { 
        case auto = "Auto"
        case once = "Once"
        case off = "Off"
    }











    /** Whether or not journey event collection is enabled. */
    public var enabled: Bool?
    /** List of parameters to be excluded from the query string. */
    public var excludedQueryParameters: [String]?
    /** Whether or not to keep the URL fragment. */
    public var shouldKeepUrlFragment: Bool?
    /** List of query parameters used for search (e.g. 'q'). */
    public var searchQueryParameters: [String]?
    /** Controls how the pageview events are tracked. */
    public var pageviewConfig: PageviewConfig?
    /** Tracks when and where a visitor clicks on a webpage. */
    public var clickEvents: [SelectorEventTrigger]?
    /** Controls how the form submitted and form abandoned events are tracked after a visitor interacts with a form element. */
    public var formsTrackEvents: [FormsTrackTrigger]?
    /** Tracks when and where a visitor becomes inactive on a webpage. */
    public var idleEvents: [IdleEventTrigger]?
    /** Tracks when elements become visible or hidden on screen. */
    public var inViewportEvents: [SelectorEventTrigger]?
    /** Tracks when a visitor scrolls to a specific percentage of a webpage. */
    public var scrollDepthEvents: [ScrollPercentageEventTrigger]?

    public init(enabled: Bool?, excludedQueryParameters: [String]?, shouldKeepUrlFragment: Bool?, searchQueryParameters: [String]?, pageviewConfig: PageviewConfig?, clickEvents: [SelectorEventTrigger]?, formsTrackEvents: [FormsTrackTrigger]?, idleEvents: [IdleEventTrigger]?, inViewportEvents: [SelectorEventTrigger]?, scrollDepthEvents: [ScrollPercentageEventTrigger]?) {
        self.enabled = enabled
        self.excludedQueryParameters = excludedQueryParameters
        self.shouldKeepUrlFragment = shouldKeepUrlFragment
        self.searchQueryParameters = searchQueryParameters
        self.pageviewConfig = pageviewConfig
        self.clickEvents = clickEvents
        self.formsTrackEvents = formsTrackEvents
        self.idleEvents = idleEvents
        self.inViewportEvents = inViewportEvents
        self.scrollDepthEvents = scrollDepthEvents
    }


}




public class JourneyOutcomeEventsNotificationActionMap: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneyOutcomeEventsNotificationDevice: Codable {

















    public enum Category: String, Codable { 
        case desktop = "desktop"
        case mobile = "mobile"
        case tablet = "tablet"
        case other = "other"
    }



    public var type: String?
    public var isMobile: Bool?
    public var screenHeight: Int?
    public var screenWidth: Int?
    public var screenDensity: Int?
    public var fingerprint: String?
    public var osFamily: String?
    public var osVersion: String?
    public var category: Category?
    public var manufacturer: String?

    public init(type: String?, isMobile: Bool?, screenHeight: Int?, screenWidth: Int?, screenDensity: Int?, fingerprint: String?, osFamily: String?, osVersion: String?, category: Category?, manufacturer: String?) {
        self.type = type
        self.isMobile = isMobile
        self.screenHeight = screenHeight
        self.screenWidth = screenWidth
        self.screenDensity = screenDensity
        self.fingerprint = fingerprint
        self.osFamily = osFamily
        self.osVersion = osVersion
        self.category = category
        self.manufacturer = manufacturer
    }


}




public class JourneyOutcomeEventsNotificationOutcome: Codable {







    public var _id: String?
    public var selfUri: String?
    public var displayName: String?

    public init(_id: String?, selfUri: String?, displayName: String?) {
        self._id = _id
        self.selfUri = selfUri
        self.displayName = displayName
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case displayName
    }


}




public class JourneySegment: Codable {













    public enum Scope: String, Codable { 
        case session = "Session"
        case customer = "Customer"
    }

















    /** The ID of the segment. */
    public var _id: String?
    /** Whether or not the segment is active. */
    public var isActive: Bool?
    /** The display name of the segment. */
    public var displayName: String?
    /** The version of the segment. */
    public var version: Int?
    /** A description of the segment. */
    public var _description: String?
    /** The hexadecimal color value of the segment. */
    public var color: String?
    /** The target entity that a segment applies to. */
    public var scope: Scope?
    /** Whether or not the segment should be displayed to agent/supervisor users. */
    public var shouldDisplayToAgent: Bool?
    /** The context of the segment. */
    public var context: Context?
    /** The pattern of rules defining the segment. */
    public var journey: Journey?
    /** Details of an entity corresponding to this segment in an external system. */
    public var externalSegment: ExternalSegment?
    /** Time, in days, from when the segment is assigned until it is automatically unassigned. */
    public var assignmentExpirationDays: Int?
    /** The URI for this object */
    public var selfUri: String?
    /** Timestamp indicating when the segment was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    /** Timestamp indicating when the the segment was last updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?

    public init(_id: String?, isActive: Bool?, displayName: String?, version: Int?, _description: String?, color: String?, scope: Scope?, shouldDisplayToAgent: Bool?, context: Context?, journey: Journey?, externalSegment: ExternalSegment?, assignmentExpirationDays: Int?, selfUri: String?, createdDate: Date?, modifiedDate: Date?) {
        self._id = _id
        self.isActive = isActive
        self.displayName = displayName
        self.version = version
        self._description = _description
        self.color = color
        self.scope = scope
        self.shouldDisplayToAgent = shouldDisplayToAgent
        self.context = context
        self.journey = journey
        self.externalSegment = externalSegment
        self.assignmentExpirationDays = assignmentExpirationDays
        self.selfUri = selfUri
        self.createdDate = createdDate
        self.modifiedDate = modifiedDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case isActive
        case displayName
        case version
        case _description = "description"
        case color
        case scope
        case shouldDisplayToAgent
        case context
        case journey
        case externalSegment
        case assignmentExpirationDays
        case selfUri
        case createdDate
        case modifiedDate
    }


}




public class JourneySegmentRequest: Codable {











    public enum Scope: String, Codable { 
        case session = "Session"
        case customer = "Customer"
    }











    /** Whether or not the segment is active. */
    public var isActive: Bool?
    /** The display name of the segment. */
    public var displayName: String?
    /** The version of the segment. */
    public var version: Int?
    /** A description of the segment. */
    public var _description: String?
    /** The hexadecimal color value of the segment. */
    public var color: String?
    /** The target entity that a segment applies to. */
    public var scope: Scope?
    /** Whether or not the segment should be displayed to agent/supervisor users. */
    public var shouldDisplayToAgent: Bool?
    /** The context of the segment. */
    public var context: RequestContext?
    /** The pattern of rules defining the segment. */
    public var journey: RequestJourney?
    /** Details of an entity corresponding to this segment in an external system. */
    public var externalSegment: RequestExternalSegment?
    /** Time, in days, from when the segment is assigned until it is automatically unassigned. */
    public var assignmentExpirationDays: Int?

    public init(isActive: Bool?, displayName: String?, version: Int?, _description: String?, color: String?, scope: Scope?, shouldDisplayToAgent: Bool?, context: RequestContext?, journey: RequestJourney?, externalSegment: RequestExternalSegment?, assignmentExpirationDays: Int?) {
        self.isActive = isActive
        self.displayName = displayName
        self.version = version
        self._description = _description
        self.color = color
        self.scope = scope
        self.shouldDisplayToAgent = shouldDisplayToAgent
        self.context = context
        self.journey = journey
        self.externalSegment = externalSegment
        self.assignmentExpirationDays = assignmentExpirationDays
    }

    public enum CodingKeys: String, CodingKey { 
        case isActive
        case displayName
        case version
        case _description = "description"
        case color
        case scope
        case shouldDisplayToAgent
        case context
        case journey
        case externalSegment
        case assignmentExpirationDays
    }


}




public class JourneySessionEventsNotificationApp: Codable {









    public var name: String?
    public var namespace: String?
    public var version: String?
    public var buildNumber: String?

    public init(name: String?, namespace: String?, version: String?, buildNumber: String?) {
        self.name = name
        self.namespace = namespace
        self.version = version
        self.buildNumber = buildNumber
    }


}




public class JourneySessionEventsNotificationReferrer: Codable {

















    public enum Medium: String, Codable { 
        case _internal = "internal"
        case search = "search"
        case social = "social"
        case email = "email"
        case unknown = "unknown"
        case paid = "paid"
    }

    public var url: String?
    public var domain: String?
    public var hostname: String?
    public var keywords: String?
    public var pathname: String?
    public var queryString: String?
    public var fragment: String?
    public var name: String?
    public var medium: Medium?

    public init(url: String?, domain: String?, hostname: String?, keywords: String?, pathname: String?, queryString: String?, fragment: String?, name: String?, medium: Medium?) {
        self.url = url
        self.domain = domain
        self.hostname = hostname
        self.keywords = keywords
        self.pathname = pathname
        self.queryString = queryString
        self.fragment = fragment
        self.name = name
        self.medium = medium
    }


}




public class JourneySessionEventsNotificationSessionEvent: Codable {

























































    public enum OriginatingDirection: String, Codable { 
        case unknown = "Unknown"
        case inbound = "Inbound"
        case outbound = "Outbound"
    }











    public enum LastUserDisconnectType: String, Codable { 
        case unknown = "Unknown"
        case endpoint = "Endpoint"
        case client = "Client"
        case system = "System"
        case transfer = "Transfer"
        case error = "Error"
        case peer = "Peer"
        case other = "Other"
        case spam = "Spam"
        case timeout = "Timeout"
        case transportFailure = "TransportFailure"
        case conferenceTransfer = "ConferenceTransfer"
        case consultTransfer = "ConsultTransfer"
        case forwardTransfer = "ForwardTransfer"
        case noAnswerTransfer = "NoAnswerTransfer"
        case notAvailableTransfer = "NotAvailableTransfer"
        case uncallable = "Uncallable"
        case doNotDisturbEndpoint = "DoNotDisturbEndpoint"
        case doNotDisturbTransfer = "DoNotDisturbTransfer"
    }

    public enum LastAcdOutcome: String, Codable { 
        case unknown = "Unknown"
        case abandon = "Abandon"
        case answered = "Answered"
        case flowOut = "FlowOut"
    }









    public var _id: String?
    public var selfUri: String?
    public var createdDate: Date?
    public var endedDate: Date?
    public var externalContact: JourneySessionEventsNotificationExternalContact?
    public var customerId: String?
    public var customerIdType: String?
    public var type: String?
    public var outcomeAchievements: [JourneySessionEventsNotificationOutcomeAchievement]?
    public var segmentAssignments: [JourneySessionEventsNotificationSegmentAssignment]?
    public var awayDate: Date?
    public var browser: JourneySessionEventsNotificationBrowser?
    public var device: JourneySessionEventsNotificationDevice?
    public var geolocation: JourneySessionEventsNotificationGeoLocation?
    public var idleDate: Date?
    public var ipAddress: String?
    public var ipOrganization: String?
    public var lastPage: JourneySessionEventsNotificationPage?
    public var mktCampaign: JourneySessionEventsNotificationMktCampaign?
    public var referrer: JourneySessionEventsNotificationReferrer?
    public var searchTerms: [String]?
    public var userAgentString: String?
    public var durationInSeconds: Int?
    public var eventCount: Int?
    public var pageviewCount: Int?
    public var screenviewCount: Int?
    public var lastEvent: JourneySessionEventsNotificationSessionLastEvent?
    public var conversation: JourneySessionEventsNotificationConversation?
    public var originatingDirection: OriginatingDirection?
    public var conversationSubject: String?
    public var lastUserDisposition: JourneySessionEventsNotificationConversationUserDisposition?
    public var lastConnectedUser: JourneySessionEventsNotificationUser?
    public var lastConnectedQueue: JourneySessionEventsNotificationConnectedQueue?
    public var conversationChannels: [JourneySessionEventsNotificationConversationChannel]?
    public var lastUserDisconnectType: LastUserDisconnectType?
    public var lastAcdOutcome: LastAcdOutcome?
    public var authenticated: Bool?
    public var app: JourneySessionEventsNotificationApp?
    public var sdkLibrary: JourneySessionEventsNotificationSdkLibrary?
    public var networkConnectivity: JourneySessionEventsNotificationNetworkConnectivity?

    public init(_id: String?, selfUri: String?, createdDate: Date?, endedDate: Date?, externalContact: JourneySessionEventsNotificationExternalContact?, customerId: String?, customerIdType: String?, type: String?, outcomeAchievements: [JourneySessionEventsNotificationOutcomeAchievement]?, segmentAssignments: [JourneySessionEventsNotificationSegmentAssignment]?, awayDate: Date?, browser: JourneySessionEventsNotificationBrowser?, device: JourneySessionEventsNotificationDevice?, geolocation: JourneySessionEventsNotificationGeoLocation?, idleDate: Date?, ipAddress: String?, ipOrganization: String?, lastPage: JourneySessionEventsNotificationPage?, mktCampaign: JourneySessionEventsNotificationMktCampaign?, referrer: JourneySessionEventsNotificationReferrer?, searchTerms: [String]?, userAgentString: String?, durationInSeconds: Int?, eventCount: Int?, pageviewCount: Int?, screenviewCount: Int?, lastEvent: JourneySessionEventsNotificationSessionLastEvent?, conversation: JourneySessionEventsNotificationConversation?, originatingDirection: OriginatingDirection?, conversationSubject: String?, lastUserDisposition: JourneySessionEventsNotificationConversationUserDisposition?, lastConnectedUser: JourneySessionEventsNotificationUser?, lastConnectedQueue: JourneySessionEventsNotificationConnectedQueue?, conversationChannels: [JourneySessionEventsNotificationConversationChannel]?, lastUserDisconnectType: LastUserDisconnectType?, lastAcdOutcome: LastAcdOutcome?, authenticated: Bool?, app: JourneySessionEventsNotificationApp?, sdkLibrary: JourneySessionEventsNotificationSdkLibrary?, networkConnectivity: JourneySessionEventsNotificationNetworkConnectivity?) {
        self._id = _id
        self.selfUri = selfUri
        self.createdDate = createdDate
        self.endedDate = endedDate
        self.externalContact = externalContact
        self.customerId = customerId
        self.customerIdType = customerIdType
        self.type = type
        self.outcomeAchievements = outcomeAchievements
        self.segmentAssignments = segmentAssignments
        self.awayDate = awayDate
        self.browser = browser
        self.device = device
        self.geolocation = geolocation
        self.idleDate = idleDate
        self.ipAddress = ipAddress
        self.ipOrganization = ipOrganization
        self.lastPage = lastPage
        self.mktCampaign = mktCampaign
        self.referrer = referrer
        self.searchTerms = searchTerms
        self.userAgentString = userAgentString
        self.durationInSeconds = durationInSeconds
        self.eventCount = eventCount
        self.pageviewCount = pageviewCount
        self.screenviewCount = screenviewCount
        self.lastEvent = lastEvent
        self.conversation = conversation
        self.originatingDirection = originatingDirection
        self.conversationSubject = conversationSubject
        self.lastUserDisposition = lastUserDisposition
        self.lastConnectedUser = lastConnectedUser
        self.lastConnectedQueue = lastConnectedQueue
        self.conversationChannels = conversationChannels
        self.lastUserDisconnectType = lastUserDisconnectType
        self.lastAcdOutcome = lastAcdOutcome
        self.authenticated = authenticated
        self.app = app
        self.sdkLibrary = sdkLibrary
        self.networkConnectivity = networkConnectivity
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case createdDate
        case endedDate
        case externalContact
        case customerId
        case customerIdType
        case type
        case outcomeAchievements
        case segmentAssignments
        case awayDate
        case browser
        case device
        case geolocation
        case idleDate
        case ipAddress
        case ipOrganization
        case lastPage
        case mktCampaign
        case referrer
        case searchTerms
        case userAgentString
        case durationInSeconds
        case eventCount
        case pageviewCount
        case screenviewCount
        case lastEvent
        case conversation
        case originatingDirection
        case conversationSubject
        case lastUserDisposition
        case lastConnectedUser
        case lastConnectedQueue
        case conversationChannels
        case lastUserDisconnectType
        case lastAcdOutcome
        case authenticated
        case app
        case sdkLibrary
        case networkConnectivity
    }


}




public class JourneyWebActionEventsNotificationActionMap: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneyWebActionEventsNotificationDevice: Codable {

















    public enum Category: String, Codable { 
        case desktop = "desktop"
        case mobile = "mobile"
        case tablet = "tablet"
        case other = "other"
    }



    public var type: String?
    public var isMobile: Bool?
    public var screenHeight: Int?
    public var screenWidth: Int?
    public var screenDensity: Int?
    public var fingerprint: String?
    public var osFamily: String?
    public var osVersion: String?
    public var category: Category?
    public var manufacturer: String?

    public init(type: String?, isMobile: Bool?, screenHeight: Int?, screenWidth: Int?, screenDensity: Int?, fingerprint: String?, osFamily: String?, osVersion: String?, category: Category?, manufacturer: String?) {
        self.type = type
        self.isMobile = isMobile
        self.screenHeight = screenHeight
        self.screenWidth = screenWidth
        self.screenDensity = screenDensity
        self.fingerprint = fingerprint
        self.osFamily = osFamily
        self.osVersion = osVersion
        self.category = category
        self.manufacturer = manufacturer
    }


}




public class JourneyWebActionEventsNotificationEmergencyGroup: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneyWebEventsNotificationAssociatedValue: Codable {

    public enum DataType: String, Codable { 
        case number = "Number"
        case integer = "Integer"
    }



    public var dataType: DataType?
    public var value: Double?

    public init(dataType: DataType?, value: Double?) {
        self.dataType = dataType
        self.value = value
    }


}




public class JourneyWebEventsNotificationGeoLocation: Codable {





















    public var country: String?
    public var countryName: String?
    public var latitude: Double?
    public var longitude: Double?
    public var locality: String?
    public var postalCode: String?
    public var region: String?
    public var regionName: String?
    public var timezone: String?
    public var source: String?

    public init(country: String?, countryName: String?, latitude: Double?, longitude: Double?, locality: String?, postalCode: String?, region: String?, regionName: String?, timezone: String?, source: String?) {
        self.country = country
        self.countryName = countryName
        self.latitude = latitude
        self.longitude = longitude
        self.locality = locality
        self.postalCode = postalCode
        self.region = region
        self.regionName = regionName
        self.timezone = timezone
        self.source = source
    }


}




public class JourneyWebEventsNotificationSegment: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class KeyValue: Codable {





    /** Key for free-form data. */
    public var key: String?
    /** Value for free-form data. */
    public var value: String?

    public init(key: String?, value: String?) {
        self.key = key
        self.value = value
    }


}




public class KlaxonHeartBeatAlertsTopicNotificationUser: Codable {





    public var _id: String?
    public var displayName: String?

    public init(_id: String?, displayName: String?) {
        self._id = _id
        self.displayName = displayName
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case displayName
    }


}




public class KlaxonInteractionStatsRulesTopicInteractionStatRule: Codable {





    public enum Dimension: String, Codable { 
        case queueid = "queueId"
        case userid = "userId"
    }





    public enum Metric: String, Codable { 
        case tabandon = "tAbandon"
        case tanswered = "tAnswered"
        case ttalk = "tTalk"
        case noffered = "nOffered"
        case thandle = "tHandle"
        case ntransferred = "nTransferred"
        case oservicelevel = "oServiceLevel"
        case twait = "tWait"
        case theld = "tHeld"
        case tacw = "tAcw"
    }

    public enum MediaType: String, Codable { 
        case voice = "voice"
        case chat = "chat"
        case email = "email"
        case callback = "callback"
        case message = "message"
    }

    public enum NumericRange: String, Codable { 
        case gt = "gt"
        case gte = "gte"
        case lt = "lt"
        case lte = "lte"
        case eq = "eq"
        case ne = "ne"
    }

    public enum Statistic: String, Codable { 
        case count = "count"
        case min = "min"
        case ratio = "ratio"
        case max = "max"
    }









    public enum AlertTypes: String, Codable { 
        case sms = "SMS"
        case device = "DEVICE"
        case email = "EMAIL"
    }

    public var _id: String?
    public var name: String?
    public var dimension: Dimension?
    public var dimensionValue: String?
    public var dimensionValueName: String?
    public var metric: Metric?
    public var mediaType: MediaType?
    public var numericRange: NumericRange?
    public var statistic: Statistic?
    public var value: Double?
    public var inAlarm: Bool?
    public var enabled: Bool?
    public var notificationUsers: [KlaxonInteractionStatsRulesTopicNotificationUser]?
    public var alertTypes: [AlertTypes]?

    public init(_id: String?, name: String?, dimension: Dimension?, dimensionValue: String?, dimensionValueName: String?, metric: Metric?, mediaType: MediaType?, numericRange: NumericRange?, statistic: Statistic?, value: Double?, inAlarm: Bool?, enabled: Bool?, notificationUsers: [KlaxonInteractionStatsRulesTopicNotificationUser]?, alertTypes: [AlertTypes]?) {
        self._id = _id
        self.name = name
        self.dimension = dimension
        self.dimensionValue = dimensionValue
        self.dimensionValueName = dimensionValueName
        self.metric = metric
        self.mediaType = mediaType
        self.numericRange = numericRange
        self.statistic = statistic
        self.value = value
        self.inAlarm = inAlarm
        self.enabled = enabled
        self.notificationUsers = notificationUsers
        self.alertTypes = alertTypes
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dimension
        case dimensionValue
        case dimensionValueName
        case metric
        case mediaType
        case numericRange
        case statistic
        case value
        case inAlarm
        case enabled
        case notificationUsers
        case alertTypes
    }


}




public class KnowledgeConversationContextResponse: Codable {







    public enum MediaType: String, Codable { 
        case unknown = "Unknown"
        case callback = "Callback"
        case chat = "Chat"
        case cobrowse = "Cobrowse"
        case email = "Email"
        case message = "Message"
        case screenshare = "Screenshare"
        case video = "Video"
        case voice = "Voice"
    }

    /** The conversation. */
    public var conversation: AddressableEntityRef?
    /** The queue used to assign the interaction to the user. */
    public var queue: AddressableEntityRef?
    /** The end-user participant of the conversation. */
    public var externalContact: AddressableEntityRef?
    /** The media type of the conversation. */
    public var mediaType: MediaType?

    public init(conversation: AddressableEntityRef?, queue: AddressableEntityRef?, externalContact: AddressableEntityRef?, mediaType: MediaType?) {
        self.conversation = conversation
        self.queue = queue
        self.externalContact = externalContact
        self.mediaType = mediaType
    }


}




public class KnowledgeDocumentGuestSearchResult: Codable {





    /** The confidence associated with a document with respect to a search query. */
    public var confidence: Double?
    /** Document that matched the query. */
    public var document: KnowledgeGuestDocument?

    public init(confidence: Double?, document: KnowledgeGuestDocument?) {
        self.confidence = confidence
        self.document = document
    }


}




public class KnowledgeDocumentResponse: Codable {









    public enum State: String, Codable { 
        case draft = "Draft"
        case published = "Published"
        case archived = "Archived"
    }





























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Document title, having a limit of 500 words. */
    public var title: String?
    /** Indicates if the knowledge document should be included in search results. */
    public var visible: Bool?
    /** List of alternate phrases related to the title which improves search results. */
    public var alternatives: [KnowledgeDocumentAlternative]?
    /** State of the document. */
    public var state: State?
    /** Document creation date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Document last modification date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Document import date-time, or null if was not imported. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateImported: Date?
    /** The last published version number of the document. */
    public var lastPublishedVersionNumber: Int?
    /** The date on which the document was last published. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var datePublished: Date?
    /** The user who created the document. */
    public var createdBy: UserReference?
    /** The user who modified the document. */
    public var modifiedBy: UserReference?
    /** The version of the document. */
    public var documentVersion: AddressableEntityRef?
    /** The reference to category associated with the document. */
    public var category: CategoryResponse?
    /** The references to labels associated with the document. */
    public var labels: [LabelResponse]?
    /** Knowledge base to which the document belongs to. */
    public var knowledgeBase: KnowledgeBaseReference?
    /** Variations of the document. */
    public var variations: [DocumentVariation]?
    /** The reference to external id associated with the document. */
    public var externalId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, title: String?, visible: Bool?, alternatives: [KnowledgeDocumentAlternative]?, state: State?, dateCreated: Date?, dateModified: Date?, dateImported: Date?, lastPublishedVersionNumber: Int?, datePublished: Date?, createdBy: UserReference?, modifiedBy: UserReference?, documentVersion: AddressableEntityRef?, category: CategoryResponse?, labels: [LabelResponse]?, knowledgeBase: KnowledgeBaseReference?, variations: [DocumentVariation]?, externalId: String?, selfUri: String?) {
        self._id = _id
        self.title = title
        self.visible = visible
        self.alternatives = alternatives
        self.state = state
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.dateImported = dateImported
        self.lastPublishedVersionNumber = lastPublishedVersionNumber
        self.datePublished = datePublished
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.documentVersion = documentVersion
        self.category = category
        self.labels = labels
        self.knowledgeBase = knowledgeBase
        self.variations = variations
        self.externalId = externalId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case title
        case visible
        case alternatives
        case state
        case dateCreated
        case dateModified
        case dateImported
        case lastPublishedVersionNumber
        case datePublished
        case createdBy
        case modifiedBy
        case documentVersion
        case category
        case labels
        case knowledgeBase
        case variations
        case externalId
        case selfUri
    }


}




public class KnowledgeDocumentResponseListing: Codable {









    public var entities: [KnowledgeDocumentResponse]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [KnowledgeDocumentResponse]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class KnowledgeDocumentSearchResult: Codable {





    /** The confidence associated with a document with respect to a search query. */
    public var confidence: Double?
    /** Document that matched the query. */
    public var document: KnowledgeDocumentResponse?

    public init(confidence: Double?, document: KnowledgeDocumentResponse?) {
        self.confidence = confidence
        self.document = document
    }


}




public class KnowledgeDocumentVersion: Codable {















    /** Globally unique identifier for the document version. */
    public var _id: String?
    /** Published date of document version. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var datePublished: Date?
    /** The document which is versioned. */
    public var document: KnowledgeDocumentResponse?
    /** The globally unique identifier for the document version. If the value is provided, the document is restored to the given version. If not, it publishes the draft changes as a new version of the document. */
    public var restoreFromVersionId: String?
    /** Version Number of the document. */
    public var versionNumber: Int?
    /** Expiry date of document version, applicable only to the 'Archived' version of the document. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateExpires: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, datePublished: Date?, document: KnowledgeDocumentResponse?, restoreFromVersionId: String?, versionNumber: Int?, dateExpires: Date?, selfUri: String?) {
        self._id = _id
        self.datePublished = datePublished
        self.document = document
        self.restoreFromVersionId = restoreFromVersionId
        self.versionNumber = versionNumber
        self.dateExpires = dateExpires
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case datePublished
        case document
        case restoreFromVersionId
        case versionNumber
        case dateExpires
        case selfUri
    }


}




public class KnowledgeDocumentVersionListing: Codable {









    public var entities: [KnowledgeDocumentVersion]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [KnowledgeDocumentVersion]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class KnowledgeGuestDocumentResponseListing: Codable {









    public var entities: [KnowledgeGuestDocument]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [KnowledgeGuestDocument]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class KnowledgeGuestDocumentVariationContext: Codable {





    /** The knowledge context associated with the variation. */
    public var context: AddressableEntityRef?
    /** The list of knowledge context values associated with the variation. */
    public var values: [AddressableEntityRef]?

    public init(context: AddressableEntityRef?, values: [AddressableEntityRef]?) {
        self.context = context
        self.values = values
    }


}




public class KnowledgeImportJobRequest: Codable {



    public enum FileType: String, Codable { 
        case json = "Json"
        case csv = "Csv"
        case xlsx = "Xlsx"
    }





    /** Upload key */
    public var uploadKey: String?
    /** File type of the document */
    public var fileType: FileType?
    /** Additional optional settings */
    public var settings: KnowledgeImportJobSettings?
    /** If enabled pre-validation step will be skipped. */
    public var skipConfirmationStep: Bool?

    public init(uploadKey: String?, fileType: FileType?, settings: KnowledgeImportJobSettings?, skipConfirmationStep: Bool?) {
        self.uploadKey = uploadKey
        self.fileType = fileType
        self.settings = settings
        self.skipConfirmationStep = skipConfirmationStep
    }


}




public class KnowledgeSearchRequest: Codable {







    public enum DocumentType: String, Codable { 
        case faq = "Faq"
        case article = "Article"
    }





    /** Input query to search content in the knowledge base */
    public var query: String?
    /** Page size of the returned results */
    public var pageSize: Int?
    /** Page number of the returned results */
    public var pageNumber: Int?
    /** Document type to be used while searching */
    public var documentType: DocumentType?
    /** query search for specific languageCode */
    public var languageCode: String?
    /** If true the search query will be executed on draft documents, else it will be on active documents */
    public var searchOnDraftDocuments: Bool?

    public init(query: String?, pageSize: Int?, pageNumber: Int?, documentType: DocumentType?, languageCode: String?, searchOnDraftDocuments: Bool?) {
        self.query = query
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.documentType = documentType
        self.languageCode = languageCode
        self.searchOnDraftDocuments = searchOnDraftDocuments
    }


}




public class KnowledgeTraining: Codable {







    public enum Status: String, Codable { 
        case queued = "Queued"
        case inProgress = "InProgress"
        case succeeded = "Succeeded"
        case failed = "Failed"
    }







    public enum KnowledgeDocumentsState: String, Codable { 
        case draft = "Draft"
        case active = "Active"
        case discarded = "Discarded"
        case archived = "Archived"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Trigger date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateTriggered: Date?
    /** Training completed date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCompleted: Date?
    /** Training status. */
    public var status: Status?
    /** Language of the documents that are trained. */
    public var languageCode: String?
    /** Knowledge Base that the training belongs to. */
    public var knowledgeBase: KnowledgeBase?
    /** Any error message during the Training or Promote action. */
    public var errorMessage: String?
    /** State of the Trained Documents, which can be one of these Draft, Active, Discarded, Archived. */
    public var knowledgeDocumentsState: KnowledgeDocumentsState?
    /** Trained Documents Promoted date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var datePromoted: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, dateTriggered: Date?, dateCompleted: Date?, status: Status?, languageCode: String?, knowledgeBase: KnowledgeBase?, errorMessage: String?, knowledgeDocumentsState: KnowledgeDocumentsState?, datePromoted: Date?, selfUri: String?) {
        self._id = _id
        self.dateTriggered = dateTriggered
        self.dateCompleted = dateCompleted
        self.status = status
        self.languageCode = languageCode
        self.knowledgeBase = knowledgeBase
        self.errorMessage = errorMessage
        self.knowledgeDocumentsState = knowledgeDocumentsState
        self.datePromoted = datePromoted
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case dateTriggered
        case dateCompleted
        case status
        case languageCode
        case knowledgeBase
        case errorMessage
        case knowledgeDocumentsState
        case datePromoted
        case selfUri
    }


}




public class KpiResult: Codable {









    public enum MediaType: String, Codable { 
        case voice = "voice"
        case email = "email"
        case message = "message"
    }



    /** Absolute metric (in which the KPI is based) total for the interactions handled by predictive routing (GPR was on) */
    public var kpiTotalOn: Int64?
    /** Absolute metric (in which the KPI is based) total for the interactions not routed by predictive routing (GPR was off) */
    public var kpiTotalOff: Int64?
    /** Total interactions handled by predictive routing (GPR was on) */
    public var interactionCountOn: Int64?
    /** Total interactions not routed by predictive routing (GPR was off) */
    public var interactionCountOff: Int64?
    /** Media type used for the KPI */
    public var mediaType: MediaType?
    /** The percentage benefit for this media type for the duration of the comparison period */
    public var percentageBenefit: Double?

    public init(kpiTotalOn: Int64?, kpiTotalOff: Int64?, interactionCountOn: Int64?, interactionCountOff: Int64?, mediaType: MediaType?, percentageBenefit: Double?) {
        self.kpiTotalOn = kpiTotalOn
        self.kpiTotalOff = kpiTotalOff
        self.interactionCountOn = interactionCountOn
        self.interactionCountOff = interactionCountOff
        self.mediaType = mediaType
        self.percentageBenefit = percentageBenefit
    }


}




public class LabelCreateRequest: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the label. */
    public var name: String?
    /** The color for the label. */
    public var color: String?
    /** The external id associated with the label. */
    public var externalId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, color: String?, externalId: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.color = color
        self.externalId = externalId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case color
        case externalId
        case selfUri
    }


}




public class LabelUpdateRequest: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the label. */
    public var name: String?
    /** The color for the label. */
    public var color: String?
    /** The external id associated with the label. */
    public var externalId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, color: String?, externalId: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.color = color
        self.externalId = externalId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case color
        case externalId
        case selfUri
    }


}




public class LanguageEntityListing: Codable {





















    public var entities: [Language]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Language]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class LanguageOverride: Codable {







    /** The language code of the language being overridden */
    public var language: String?
    /** The ID of the TTS engine to use for this language override */
    public var engine: String?
    /** The ID of the voice to use for this language override. The voice must be supported by the chosen engine. */
    public var voice: String?

    public init(language: String?, engine: String?, voice: String?) {
        self.language = language
        self.engine = engine
        self.voice = voice
    }


}




public class LastResultByColumnConditionSettings: Codable {









    /** The name of the contact column to evaluate for Email. */
    public var emailColumnName: String?
    /** A list of wrapup code identifiers to match for Email. */
    public var emailWrapupCodes: [String]?
    /** The name of the contact column to evaluate for SMS. */
    public var smsColumnName: String?
    /** A list of wrapup code identifiers to match for SMS. */
    public var smsWrapupCodes: [String]?

    public init(emailColumnName: String?, emailWrapupCodes: [String]?, smsColumnName: String?, smsWrapupCodes: [String]?) {
        self.emailColumnName = emailColumnName
        self.emailWrapupCodes = emailWrapupCodes
        self.smsColumnName = smsColumnName
        self.smsWrapupCodes = smsWrapupCodes
    }


}




public class LearningAssignmentAggregateQueryRequestFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "And"
        case or = "Or"
    }



    /** The logic used to combine the clauses */
    public var type: ModelType?
    /** The list of clauses used to filter the data. Note that clauses must filter by attendeeId and a maximum of 100 user IDs are allowed */
    public var clauses: [LearningAssignmentAggregateQueryRequestClause]?

    public init(type: ModelType?, clauses: [LearningAssignmentAggregateQueryRequestClause]?) {
        self.type = type
        self.clauses = clauses
    }


}




public class LearningAssignmentAggregateQueryResponseMetric: Codable {

    public enum Metric: String, Codable { 
        case nactivities = "nActivities"
        case nplannedactivities = "nPlannedActivities"
        case ninprogressactivities = "nInProgressActivities"
        case ncompleteactivities = "nCompleteActivities"
        case noverdueactivities = "nOverdueActivities"
        case ninvalidscheduleactivities = "nInvalidScheduleActivities"
        case npassedactivities = "nPassedActivities"
        case nfailedactivities = "nFailedActivities"
        case oactivityscore = "oActivityScore"
        case nnotcompletedactivities = "nNotCompletedActivities"
    }



    /** The metric this applies to */
    public var metric: Metric?
    /** The aggregated values for this metric */
    public var stats: LearningAssignmentAggregateQueryResponseStats?

    public init(metric: Metric?, stats: LearningAssignmentAggregateQueryResponseStats?) {
        self.metric = metric
        self.stats = stats
    }


}




public class LearningAssignmentAggregateQueryResponseStats: Codable {









    /** The count for this metric */
    public var count: Int?
    /** The minimum value in this metric */
    public var min: Double?
    /** The maximum value in this metric */
    public var max: Double?
    /** The total of the values for this metric */
    public var sum: Double?

    public init(count: Int?, min: Double?, max: Double?, sum: Double?) {
        self.count = count
        self.min = min
        self.max = max
        self.sum = sum
    }


}




public class LearningAssignmentCreate: Codable {









    /** The Learning module Id associated with this assignment */
    public var moduleId: String?
    /** The User for whom the assignment is assigned */
    public var userId: String?
    /** The recommended completion date of assignment. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var recommendedCompletionDate: Date?
    /** The length in minutes of assignment */
    public var lengthInMinutes: Int?

    public init(moduleId: String?, userId: String?, recommendedCompletionDate: Date?, lengthInMinutes: Int?) {
        self.moduleId = moduleId
        self.userId = userId
        self.recommendedCompletionDate = recommendedCompletionDate
        self.lengthInMinutes = lengthInMinutes
    }


}




public class LearningAssignmentReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class LearningAssignmentStepSignedCookie: Codable {





    /** The base URL for the signed cookie */
    public var url: String?
    /** The cookie values required to access content from the base URL */
    public var cookieValues: [String:String]?

    public init(url: String?, cookieValues: [String:String]?) {
        self.url = url
        self.cookieValues = cookieValues
    }


}




public class LearningAssignmentTopicLearningAssignmentNotification: Codable {









    public enum State: String, Codable { 
        case assigned = "Assigned"
        case inProgress = "InProgress"
        case completed = "Completed"
        case deleted = "Deleted"
        case notCompleted = "NotCompleted"
        case invalidSchedule = "InvalidSchedule"
    }















    public var _id: String?
    public var user: LearningAssignmentTopicUserReference?
    public var module: LearningAssignmentTopicLearningModuleReference?
    public var version: Int?
    public var state: State?
    public var dateRecommendedForCompletion: Date?
    public var createdBy: LearningAssignmentTopicUserReference?
    public var dateCreated: Date?
    public var modifiedBy: LearningAssignmentTopicUserReference?
    public var dateModified: Date?
    public var isOverdue: Bool?
    public var lengthInMinutes: Int?

    public init(_id: String?, user: LearningAssignmentTopicUserReference?, module: LearningAssignmentTopicLearningModuleReference?, version: Int?, state: State?, dateRecommendedForCompletion: Date?, createdBy: LearningAssignmentTopicUserReference?, dateCreated: Date?, modifiedBy: LearningAssignmentTopicUserReference?, dateModified: Date?, isOverdue: Bool?, lengthInMinutes: Int?) {
        self._id = _id
        self.user = user
        self.module = module
        self.version = version
        self.state = state
        self.dateRecommendedForCompletion = dateRecommendedForCompletion
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
        self.isOverdue = isOverdue
        self.lengthInMinutes = lengthInMinutes
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case user
        case module
        case version
        case state
        case dateRecommendedForCompletion
        case createdBy
        case dateCreated
        case modifiedBy
        case dateModified
        case isOverdue
        case lengthInMinutes
    }


}




public class LearningAssignmentUpdate: Codable {

    public enum State: String, Codable { 
        case assigned = "Assigned"
        case inProgress = "InProgress"
        case completed = "Completed"
        case deleted = "Deleted"
        case notCompleted = "NotCompleted"
        case invalidSchedule = "InvalidSchedule"
    }



    /** The Learning Assignment state */
    public var state: State?
    /** An updated Assessment */
    public var assessment: LearningAssessment?

    public init(state: State?, assessment: LearningAssessment?) {
        self.state = state
        self.assessment = assessment
    }


}




public class LearningModuleCoverArtRequest: Codable {



    /** The key identifier for the cover art */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class LearningModuleInformStep: Codable {

    public enum ModelType: String, Codable { 
        case url = "Url"
        case content = "Content"
        case genesysBuiltInCourse = "GenesysBuiltInCourse"
        case richText = "RichText"
        case scorm = "Scorm"
    }















    /** The learning module inform step type */
    public var type: ModelType?
    /** The name of the inform step or content */
    public var name: String?
    /** The value for inform step */
    public var value: String?
    /** The sharing uri for Content type inform step */
    public var sharingUri: String?
    /** The document type for Content type Inform step */
    public var contentType: String?
    /** The order of inform step in a learning module */
    public var order: Int?
    /** The display name for the inform step */
    public var displayName: String?
    /** The description for the inform step */
    public var _description: String?

    public init(type: ModelType?, name: String?, value: String?, sharingUri: String?, contentType: String?, order: Int?, displayName: String?, _description: String?) {
        self.type = type
        self.name = name
        self.value = value
        self.sharingUri = sharingUri
        self.contentType = contentType
        self.order = order
        self.displayName = displayName
        self._description = _description
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case name
        case value
        case sharingUri
        case contentType
        case order
        case displayName
        case _description = "description"
    }


}



/** Learning module inform steps request */

public class LearningModuleInformStepRequest: Codable {

    public enum ModelType: String, Codable { 
        case url = "Url"
        case content = "Content"
        case genesysBuiltInCourse = "GenesysBuiltInCourse"
        case richText = "RichText"
        case scorm = "Scorm"
    }















    /** The learning module inform step type */
    public var type: ModelType?
    /** The name of the inform step or content */
    public var name: String?
    /** The value for inform step */
    public var value: String?
    /** The sharing uri for Content type inform step */
    public var sharingUri: String?
    /** The document type for Content type Inform step */
    public var contentType: String?
    /** The order of inform step in a learning module */
    public var order: Int?
    /** The display name for the inform step */
    public var displayName: String?
    /** The description for the inform step */
    public var _description: String?

    public init(type: ModelType?, name: String?, value: String?, sharingUri: String?, contentType: String?, order: Int?, displayName: String?, _description: String?) {
        self.type = type
        self.name = name
        self.value = value
        self.sharingUri = sharingUri
        self.contentType = contentType
        self.order = order
        self.displayName = displayName
        self._description = _description
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case name
        case value
        case sharingUri
        case contentType
        case order
        case displayName
        case _description = "description"
    }


}




public class LearningScheduleSlotsQueryRequest: Codable {









    /** Range of time to get slots for scheduling learning activities. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** The duration of coaching appointment to schedule in 15 minutes granularity */
    public var lengthInMinutes: Int?
    /** The user IDs for which to fetch schedules. Must be only 1. */
    public var userIds: [String]?
    /** Assignment ID to exclude from consideration when determining blocked slots */
    public var interruptibleAssignmentId: String?

    public init(interval: String?, lengthInMinutes: Int?, userIds: [String]?, interruptibleAssignmentId: String?) {
        self.interval = interval
        self.lengthInMinutes = lengthInMinutes
        self.userIds = userIds
        self.interruptibleAssignmentId = interruptibleAssignmentId
    }


}




public class LexV2Bot: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Lex V2 bot Id */
    public var botId: String?
    /** A region of the Lex V2 bot */
    public var region: String?
    /** A description of the Lex V2 bot */
    public var _description: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, botId: String?, region: String?, _description: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.botId = botId
        self.region = region
        self._description = _description
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case botId
        case region
        case _description = "description"
        case selfUri
    }


}




public class LexV2BotAlias: Codable {













    public enum Status: String, Codable { 
        case creating = "Creating"
        case available = "Available"
        case deleting = "Deleting"
        case failed = "Failed"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The Lex V2 bot region */
    public var region: String?
    /** The Lex V2 bot alias Id */
    public var aliasId: String?
    /** The Lex V2 bot this is an alias for */
    public var bot: LexV2Bot?
    /** The version of the Lex V2 bot this alias points at */
    public var botVersion: String?
    /** The status of the Lex V2 bot alias */
    public var status: Status?
    /** The target language of the Lex V2 bot */
    public var language: String?
    /** An array of Intents associated with this bot alias */
    public var intents: [LexV2Intent]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, region: String?, aliasId: String?, bot: LexV2Bot?, botVersion: String?, status: Status?, language: String?, intents: [LexV2Intent]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.region = region
        self.aliasId = aliasId
        self.bot = bot
        self.botVersion = botVersion
        self.status = status
        self.language = language
        self.intents = intents
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case region
        case aliasId
        case bot
        case botVersion
        case status
        case language
        case intents
        case selfUri
    }


}




public class LexV2Slot: Codable {











    /** The slot name */
    public var slotName: String?
    /** The slot description */
    public var _description: String?
    /** The slot id */
    public var slotId: String?
    /** The slot type */
    public var type: String?
    /** The slot type id */
    public var slotTypeId: String?

    public init(slotName: String?, _description: String?, slotId: String?, type: String?, slotTypeId: String?) {
        self.slotName = slotName
        self._description = _description
        self.slotId = slotId
        self.type = type
        self.slotTypeId = slotTypeId
    }

    public enum CodingKeys: String, CodingKey { 
        case slotName
        case _description = "description"
        case slotId
        case type
        case slotTypeId
    }


}




public class LicenseAssignmentRequest: Codable {







    /** The id of the license to assign/unassign. */
    public var licenseId: String?
    /** The ids of users to assign this license to. */
    public var userIdsAdd: [String]?
    /** The ids of users to unassign this license from. */
    public var userIdsRemove: [String]?

    public init(licenseId: String?, userIdsAdd: [String]?, userIdsRemove: [String]?) {
        self.licenseId = licenseId
        self.userIdsAdd = userIdsAdd
        self.userIdsRemove = userIdsRemove
    }


}




public class Limit: Codable {



    public enum Namespace: String, Codable { 
        case agentAssistant = "agent.assistant"
        case analyticsAlerting = "analytics.alerting"
        case analytics = "analytics"
        case analyticsRealtime = "analytics.realtime"
        case analyticsReportingSettings = "analytics.reporting.settings"
        case architect = "architect"
        case audiohook = "audiohook"
        case audit = "audit"
        case authApi = "auth.api"
        case authorization = "authorization"
        case automationTesting = "automation.testing"
        case bots = "bots"
        case botsVoice = "bots.voice"
        case callback = "callback"
        case cobrowse = "cobrowse"
        case contentManagement = "content.management"
        case conversation = "conversation"
        case dataactions = "dataactions"
        case datatables = "datatables"
        case directory = "directory"
        case email = "email"
        case employeeEngagement = "employee.engagement"
        case eventOrchestration = "event.orchestration"
        case externalContacts = "external.contacts"
        case gcv = "gcv"
        case gdpr = "gdpr"
        case groups = "groups"
        case historicalAdherence = "historical.adherence"
        case infrastructureascode = "infrastructureascode"
        case integrations = "integrations"
        case intentMiner = "intent.miner"
        case journey = "journey"
        case knowledge = "knowledge"
        case languageUnderstanding = "language.understanding"
        case learning = "learning"
        case limitRegistry = "limit.registry"
        case marketplace = "marketplace"
        case mediaCommunications = "media.communications"
        case messaging = "messaging"
        case notifications = "notifications"
        case onboarding = "onboarding"
        case outbound = "outbound"
        case platformApi = "platform.api"
        case predictiveRouting = "predictive.routing"
        case presence = "presence"
        case quality = "quality"
        case recording = "recording"
        case responseManagement = "response.management"
        case routing = "routing"
        case scim = "scim"
        case search = "search"
        case secondaryAutomationTesting = "secondary.automation.testing"
        case skills = "skills"
        case speechAndTextAnalytics = "speech.and.text.analytics"
        case speechIntegration = "speech.integration"
        case supportability = "supportability"
        case taskManagement = "task.management"
        case telephonyConfiguration = "telephony.configuration"
        case usage = "usage"
        case users = "users"
        case webDeployments = "web.deployments"
        case webMessaging = "web.messaging"
        case webchat = "webchat"
        case webhooks = "webhooks"
        case workforceManagement = "workforce.management"
    }



    public var key: String?
    public var namespace: Namespace?
    public var value: Int64?

    public init(key: String?, namespace: Namespace?, value: Int64?) {
        self.key = key
        self.namespace = namespace
        self.value = value
    }


}




public class LineBase: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    public var lineMetaBase: DomainEntityRef?
    public var properties: [String:JSON]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, lineMetaBase: DomainEntityRef?, properties: [String:JSON]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.lineMetaBase = lineMetaBase
        self.properties = properties
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case lineMetaBase
        case properties
        case selfUri
    }


}




public class LineStatus: Codable {











    /** The id of this line */
    public var _id: String?
    /** Indicates whether the edge can reach the line. */
    public var reachable: Bool?
    /** The line's address of record. */
    public var addressOfRecord: String?
    /** The addresses used to contact the line. */
    public var contactAddresses: [String]?
    /** The time the line entered its current reachable state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var reachableStateTime: Date?

    public init(_id: String?, reachable: Bool?, addressOfRecord: String?, contactAddresses: [String]?, reachableStateTime: Date?) {
        self._id = _id
        self.reachable = reachable
        self.addressOfRecord = addressOfRecord
        self.contactAddresses = contactAddresses
        self.reachableStateTime = reachableStateTime
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case reachable
        case addressOfRecord
        case contactAddresses
        case reachableStateTime
    }


}




public class ListWrapperInterval: Codable {



    public var values: [String]?

    public init(values: [String]?) {
        self.values = values
    }


}




public class ListWrapperSecondaryPresence: Codable {



    public var values: [SecondaryPresence]?

    public init(values: [SecondaryPresence]?) {
        self.values = values
    }


}




public class ListedProgram: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var _description: String?
    public var published: Bool?
    public var topicsCount: Int?
    public var tags: [String]?
    public var modifiedBy: AddressableEntityRef?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, published: Bool?, topicsCount: Int?, tags: [String]?, modifiedBy: AddressableEntityRef?, dateModified: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.published = published
        self.topicsCount = topicsCount
        self.tags = tags
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case published
        case topicsCount
        case tags
        case modifiedBy
        case dateModified
        case selfUri
    }


}




public class LocalDateRange: Codable {





    /** The inclusive start of a date range in yyyy-MM-dd format. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var startDate: Date?
    /** The inclusive end of a date range in yyyy-MM-dd format. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var endDate: Date?

    public init(startDate: Date?, endDate: Date?) {
        self.startDate = startDate
        self.endDate = endDate
    }


}




public class LocalEncryptionConfiguration: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The url for decryption. This must specify the path to where Purecloud can requests decryption */
    public var url: String?
    /** The api id for Hawk Authentication. */
    public var apiId: String?
    /** The api shared symmetric key used for hawk authentication */
    public var apiKey: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, url: String?, apiId: String?, apiKey: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.url = url
        self.apiId = apiId
        self.apiKey = apiKey
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case url
        case apiId
        case apiKey
        case selfUri
    }


}




public class LocationAddressVerificationDetails: Codable {

    public enum Status: String, Codable { 
        case pending = "Pending"
        case inProgress = "InProgress"
        case retry = "Retry"
        case complete = "Complete"
        case failed = "Failed"
    }







    /** Status of address verification process */
    public var status: Status?
    /** Finished time of address verification process. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateFinished: Date?
    /** Time started of address verification process. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStarted: Date?
    /** Third party service used for address verification */
    public var service: String?

    public init(status: Status?, dateFinished: Date?, dateStarted: Date?, service: String?) {
        self.status = status
        self.dateFinished = dateFinished
        self.dateStarted = dateStarted
        self.service = service
    }


}




public class ManagementUnitSettingsRequest: Codable {













    /** Adherence settings for this management unit */
    public var adherence: AdherenceSettings?
    /** Short term forecasting settings for this management unit.  Moving to Business Unit */
    public var shortTermForecasting: ShortTermForecastingSettings?
    /** Time off request settings for this management unit */
    public var timeOff: TimeOffRequestSettings?
    /** Scheduling settings for this management unit */
    public var scheduling: SchedulingSettingsRequest?
    /** Shift trade settings for this management unit */
    public var shiftTrading: ShiftTradeSettings?
    /** Version info metadata for the associated management unit */
    public var metadata: WfmVersionedEntityMetadata?

    public init(adherence: AdherenceSettings?, shortTermForecasting: ShortTermForecastingSettings?, timeOff: TimeOffRequestSettings?, scheduling: SchedulingSettingsRequest?, shiftTrading: ShiftTradeSettings?, metadata: WfmVersionedEntityMetadata?) {
        self.adherence = adherence
        self.shortTermForecasting = shortTermForecasting
        self.timeOff = timeOff
        self.scheduling = scheduling
        self.shiftTrading = shiftTrading
        self.metadata = metadata
    }


}




public class MatchShiftTradeResponse: Codable {







    /** The associated shift trade */
    public var trade: ShiftTradeResponse?
    /** Constraint violations which disallow this shift trade */
    public var violations: [ShiftTradeMatchViolation]?
    /** Constraint violations for this shift trade which require shift trade administrator review */
    public var adminReviewViolations: [ShiftTradeMatchViolation]?

    public init(trade: ShiftTradeResponse?, violations: [ShiftTradeMatchViolation]?, adminReviewViolations: [ShiftTradeMatchViolation]?) {
        self.trade = trade
        self.violations = violations
        self.adminReviewViolations = adminReviewViolations
    }


}




public class MediaParticipantRequest: Codable {



    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case parked = "parked"
        case _none = "none"
    }











    /** Wrap-up to assign to this participant. */
    public var wrapup: WrapupInput?
    /** The state to update to set for this participant's communications.  Possible values are: 'connected' and 'disconnected'. */
    public var state: State?
    /** True to enable recording of this participant, otherwise false to disable recording. */
    public var recording: Bool?
    /** True to mute this conversation participant. */
    public var muted: Bool?
    /** True to confine this conversation participant.  Should only be used for ad-hoc conferences */
    public var confined: Bool?
    /** True to hold this conversation participant. */
    public var held: Bool?
    /** True to skip wrap-up for this participant. */
    public var wrapupSkipped: Bool?

    public init(wrapup: WrapupInput?, state: State?, recording: Bool?, muted: Bool?, confined: Bool?, held: Bool?, wrapupSkipped: Bool?) {
        self.wrapup = wrapup
        self.state = state
        self.recording = recording
        self.muted = muted
        self.confined = confined
        self.held = held
        self.wrapupSkipped = wrapupSkipped
    }


}




public class MergeOperation: Codable {







    /** The source contact for the merge operation */
    public var sourceContact: AddressableEntityRef?
    /** The target contact for the merge operation */
    public var targetContact: AddressableEntityRef?
    /** The contact created as a result of the merge operation */
    public var resultingContact: AddressableEntityRef?

    public init(sourceContact: AddressableEntityRef?, targetContact: AddressableEntityRef?, resultingContact: AddressableEntityRef?) {
        self.sourceContact = sourceContact
        self.targetContact = targetContact
        self.resultingContact = resultingContact
    }


}




public class MergeRequest: Codable {





    /** The ID of the source contact for the merge operation */
    public var sourceContactId: String?
    /** The ID of the target contact for the merge operation */
    public var targetContactId: String?

    public init(sourceContactId: String?, targetContactId: String?) {
        self.sourceContactId = sourceContactId
        self.targetContactId = targetContactId
    }


}




public class MessageConversationEntityListing: Codable {





















    public var entities: [MessageConversation]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [MessageConversation]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class MessagingCampaign: Codable {













    public enum CampaignStatus: String, Codable { 
        case on = "on"
        case stopping = "stopping"
        case off = "off"
        case complete = "complete"
        case invalid = "invalid"
        case forcedOff = "forced_off"
    }



























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** The division this entity belongs to. */
    public var division: DomainEntityRef?
    /** The current status of the messaging campaign. A messaging campaign may be turned 'on' or 'off'. */
    public var campaignStatus: CampaignStatus?
    /** The callable time set for this messaging campaign. */
    public var callableTimeSet: DomainEntityRef?
    /** The contact list that this messaging campaign will send messages for. */
    public var contactList: DomainEntityRef?
    /** The dnc lists to check before sending a message for this messaging campaign. */
    public var dncLists: [DomainEntityRef]?
    /** Whether this messaging campaign is always running */
    public var alwaysRunning: Bool?
    /** The order in which to sort contacts for dialing, based on up to four columns. */
    public var contactSorts: [ContactSort]?
    /** How many messages this messaging campaign will send per minute. */
    public var messagesPerMinute: Int?
    /** Rule Sets to be applied while this campaign is sending messages */
    public var ruleSets: [DomainEntityRef]?
    /** The contact list filter to check before sending a message for this messaging campaign. */
    public var contactListFilters: [DomainEntityRef]?
    /** A list of current error conditions associated with this messaging campaign. */
    public var errors: [RestErrorDetail]?
    /** Indicates (when true) that the campaign supports dynamic queueing of the contact list at the time of a request for contacts. */
    public var dynamicContactQueueingSettings: DynamicContactQueueingSettings?
    /** Configuration for this messaging campaign to send Email messages. */
    public var emailConfig: EmailConfig?
    /** Configuration for this messaging campaign to send SMS messages. */
    public var smsConfig: SmsConfig?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, division: DomainEntityRef?, campaignStatus: CampaignStatus?, callableTimeSet: DomainEntityRef?, contactList: DomainEntityRef?, dncLists: [DomainEntityRef]?, alwaysRunning: Bool?, contactSorts: [ContactSort]?, messagesPerMinute: Int?, ruleSets: [DomainEntityRef]?, contactListFilters: [DomainEntityRef]?, errors: [RestErrorDetail]?, dynamicContactQueueingSettings: DynamicContactQueueingSettings?, emailConfig: EmailConfig?, smsConfig: SmsConfig?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.division = division
        self.campaignStatus = campaignStatus
        self.callableTimeSet = callableTimeSet
        self.contactList = contactList
        self.dncLists = dncLists
        self.alwaysRunning = alwaysRunning
        self.contactSorts = contactSorts
        self.messagesPerMinute = messagesPerMinute
        self.ruleSets = ruleSets
        self.contactListFilters = contactListFilters
        self.errors = errors
        self.dynamicContactQueueingSettings = dynamicContactQueueingSettings
        self.emailConfig = emailConfig
        self.smsConfig = smsConfig
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case division
        case campaignStatus
        case callableTimeSet
        case contactList
        case dncLists
        case alwaysRunning
        case contactSorts
        case messagesPerMinute
        case ruleSets
        case contactListFilters
        case errors
        case dynamicContactQueueingSettings
        case emailConfig
        case smsConfig
        case selfUri
    }


}




public class MessagingCampaignDivisionViewEntityListing: Codable {





















    public var entities: [MessagingCampaignDivisionView]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [MessagingCampaignDivisionView]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class MessagingCampaignScheduleEntityListing: Codable {





















    public var entities: [MessagingCampaignSchedule]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [MessagingCampaignSchedule]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class MessagingCommunicationAnsweredEvent: Codable {









    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication */
    public var communicationId: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
    }


}




public class MessagingCommunicationEndedEvent: Codable {









    public enum DisconnectType: String, Codable { 
        case unknown = "Unknown"
        case _self = "Self"
        case peer = "Peer"
        case system = "System"
        case error = "Error"
        case transfer = "Transfer"
        case transferACD = "TransferACD"
        case transferUser = "TransferUser"
    }

    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication. */
    public var communicationId: String?
    /** Indicates how this communication was ended. */
    public var disconnectType: DisconnectType?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, disconnectType: DisconnectType?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.disconnectType = disconnectType
    }


}




public class MessagingEndTransferEvent: Codable {









    public enum FinalState: String, Codable { 
        case completed = "Completed"
        case canceled = "Canceled"
        case failed = "Failed"
    }



    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** The id (V4 UUID) used to identify the transfer already started by the external platform. */
    public var commandId: String?
    /** Indicates whether the transfer completed successfully, was cancelled, or failed for some reason. */
    public var finalState: FinalState?
    /** The id (V4 UUID) of the communication that was being transferred. */
    public var objectCommunicationId: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, commandId: String?, finalState: FinalState?, objectCommunicationId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.commandId = commandId
        self.finalState = finalState
        self.objectCommunicationId = objectCommunicationId
    }


}




public class MessagingFlowEstablishedEvent: Codable {













    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication. */
    public var communicationId: String?
    /** Metadata about this communication. */
    public var initialConfiguration: MessagingInitialConfiguration?
    /** Metadata about the source of this communication's interaction. */
    public var sourceConfiguration: SourceConfiguration?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, initialConfiguration: MessagingInitialConfiguration?, sourceConfiguration: SourceConfiguration?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.initialConfiguration = initialConfiguration
        self.sourceConfiguration = sourceConfiguration
    }


}




public class MessagingRoutingTransferEvent: Codable {







    public enum TransferType: String, Codable { 
        case attended = "Attended"
        case unattended = "Unattended"
    }















    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** Indicates the desired type of transfer. */
    public var transferType: TransferType?
    /** The id (V4 UUID) used by the external platform to refer to the transfer in subsequent *Transfer events. */
    public var commandId: String?
    /** Indicates the desired type of transfer. */
    public var initiatingCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred away from. In many cases this will be the same as the `initiatingCommunicationId`. */
    public var targetCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred. */
    public var objectCommunicationId: String?
    /** The id (V4 UUID) of the desired destination queue that the object communication should be transferred to. */
    public var destinationQueueId: String?
    /** The unique identifier (V4 UUID) for the language that should be used to determine the destination for the conversation. */
    public var languageId: String?
    /** The unique identifiers (V4 UUID) for the skills that should be used to determine the destination for the conversation. */
    public var skillIds: [String]?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, transferType: TransferType?, commandId: String?, initiatingCommunicationId: String?, targetCommunicationId: String?, objectCommunicationId: String?, destinationQueueId: String?, languageId: String?, skillIds: [String]?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.transferType = transferType
        self.commandId = commandId
        self.initiatingCommunicationId = initiatingCommunicationId
        self.targetCommunicationId = targetCommunicationId
        self.objectCommunicationId = objectCommunicationId
        self.destinationQueueId = destinationQueueId
        self.languageId = languageId
        self.skillIds = skillIds
    }


}



/** Messaging setting for messaging platform integrations */

public class MessagingSettingPatchRequest: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The messaging Setting profile name */
    public var name: String?
    /** Settings relating to message contents */
    public var content: ContentSetting?
    /** Settings relating to events which may occur */
    public var event: EventSetting?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, content: ContentSetting?, event: EventSetting?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.content = content
        self.event = event
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case content
        case event
        case selfUri
    }


}



/** Messaging Setting for messaging platform integrations */

public class MessagingSettingReference: Codable {





















    /** The messaging Setting unique identifier associated with this integration */
    public var _id: String?
    /** The messaging Setting profile name */
    public var name: String?
    /** The messaging Setting profile URI */
    public var selfUri: String?
    /** Date this messaging Setting was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date this messaging Setting was modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Version number */
    public var version: String?
    /** User reference that created this Setting */
    public var createdBy: DomainEntityRef?
    /** User reference that modified this Setting */
    public var updatedBy: DomainEntityRef?
    /** Settings relating to message contents */
    public var content: ContentSetting?
    /** Settings relating to events which may occur */
    public var event: EventSetting?

    public init(_id: String?, name: String?, selfUri: String?, dateCreated: Date?, dateModified: Date?, version: String?, createdBy: DomainEntityRef?, updatedBy: DomainEntityRef?, content: ContentSetting?, event: EventSetting?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.createdBy = createdBy
        self.updatedBy = updatedBy
        self.content = content
        self.event = event
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
        case dateCreated
        case dateModified
        case version
        case createdBy
        case updatedBy
        case content
        case event
    }


}



/** Messaging Setting for messaging platform integrations */

public class MessagingSettingRequestReference: Codable {



    /** The messaging Setting unique identifier associated with this integration */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class MessagingSticker: Codable {











    public enum MessengerType: String, Codable { 
        case sms = "sms"
        case facebook = "facebook"
        case twitter = "twitter"
        case line = "line"
        case whatsapp = "whatsapp"
        case webmessaging = "webmessaging"
        case instagram = "instagram"
        case _open = "open"
    }

    public enum StickerType: String, Codable { 
        case standard = "standard"
        case free = "free"
        case paid = "paid"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The sticker Id of the sticker, assigned by the sticker provider. */
    public var providerStickerId: Int?
    /** The package Id of the sticker, assigned by the sticker provider. */
    public var providerPackageId: Int?
    /** The package name of the sticker, assigned by the sticker provider. */
    public var packageName: String?
    /** The type of the messenger provider. */
    public var messengerType: MessengerType?
    /** The type of the sticker. */
    public var stickerType: StickerType?
    /** The version of the sticker, assigned by the provider. */
    public var providerVersion: Int64?
    public var uriLocation: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, providerStickerId: Int?, providerPackageId: Int?, packageName: String?, messengerType: MessengerType?, stickerType: StickerType?, providerVersion: Int64?, uriLocation: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.providerStickerId = providerStickerId
        self.providerPackageId = providerPackageId
        self.packageName = packageName
        self.messengerType = messengerType
        self.stickerType = stickerType
        self.providerVersion = providerVersion
        self.uriLocation = uriLocation
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case providerStickerId
        case providerPackageId
        case packageName
        case messengerType
        case stickerType
        case providerVersion
        case uriLocation
        case selfUri
    }


}



/** The apps embedded in the messenger */

public class MessengerApps: Codable {





    /** The conversation settings that handles chats within the messenger */
    public var conversations: ConversationAppSettings?
    /** The knowledge base config for messenger */
    public var knowledge: Knowledge?

    public init(conversations: ConversationAppSettings?, knowledge: Knowledge?) {
        self.conversations = conversations
        self.knowledge = knowledge
    }


}



/** Settings concerning messenger */

public class MessengerSettings: Codable {













    /** Whether or not messenger is enabled */
    public var enabled: Bool?
    /** The style settings for messenger */
    public var styles: MessengerStyles?
    /** The launcher button settings for messenger */
    public var launcherButton: LauncherButtonSettings?
    /** The file upload settings for messenger */
    public var fileUpload: FileUploadSettings?
    /** The apps embedded in the messenger */
    public var apps: MessengerApps?
    /** The homescreen settings for messenger */
    public var homeScreen: MessengerHomeScreen?

    public init(enabled: Bool?, styles: MessengerStyles?, launcherButton: LauncherButtonSettings?, fileUpload: FileUploadSettings?, apps: MessengerApps?, homeScreen: MessengerHomeScreen?) {
        self.enabled = enabled
        self.styles = styles
        self.launcherButton = launcherButton
        self.fileUpload = fileUpload
        self.apps = apps
        self.homeScreen = homeScreen
    }


}




public class MessengerStyles: Codable {



    /** The primary color of messenger in hexadecimal */
    public var primaryColor: String?

    public init(primaryColor: String?) {
        self.primaryColor = primaryColor
    }


}



/** Additional documentation about an artifact */

public class MetadataDocumentation: Codable {





    /** description of the documentation */
    public var _description: String?
    /** location where the documentation can be accessed */
    public var location: String?

    public init(_description: String?, location: String?) {
        self._description = _description
        self.location = location
    }

    public enum CodingKeys: String, CodingKey { 
        case _description = "description"
        case location
    }


}




public class MeteredAssignmentByAgent: Codable {













    public var evaluationContextId: String?
    public var evaluators: [User]?
    public var maxNumberEvaluations: Int?
    public var evaluationForm: EvaluationForm?
    public var timeInterval: TimeInterval?
    public var timeZone: String?

    public init(evaluationContextId: String?, evaluators: [User]?, maxNumberEvaluations: Int?, evaluationForm: EvaluationForm?, timeInterval: TimeInterval?, timeZone: String?) {
        self.evaluationContextId = evaluationContextId
        self.evaluators = evaluators
        self.maxNumberEvaluations = maxNumberEvaluations
        self.evaluationForm = evaluationForm
        self.timeInterval = timeInterval
        self.timeZone = timeZone
    }


}




public class ModelingStatusResponse: Codable {



    public enum Status: String, Codable { 
        case pending = "Pending"
        case success = "Success"
        case failed = "Failed"
        case ongoing = "Ongoing"
        case partialFailure = "PartialFailure"
    }





    /** The ID generated for the modeling job.  Use to GET result when job is completed. */
    public var _id: String?
    /** The status of the modeling job. */
    public var status: Status?
    /** If the request could not be properly processed, error details will be given here. */
    public var errorDetails: [ModelingProcessingError]?
    /** The uri of the modeling result. It has a value if the status is either 'Success', 'PartialFailure', or 'Failed'. */
    public var modelingResultUri: String?

    public init(_id: String?, status: Status?, errorDetails: [ModelingProcessingError]?, modelingResultUri: String?) {
        self._id = _id
        self.status = status
        self.errorDetails = errorDetails
        self.modelingResultUri = modelingResultUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case status
        case errorDetails
        case modelingResultUri
    }


}




public class ModifiableRuleProperties: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Name of the rule */
    public var name: String?
    /** The description of the rule. */
    public var _description: String?
    /** Indicates if the rule is enabled. */
    public var enabled: Bool?
    /** The alert notification types to trigger when alarm state changes as well as the users they will be sent to. */
    public var notifications: [AlertNotification]?
    /** Indicates if the alert will send a notification when it is closed. */
    public var sendExitingAlarmNotifications: Bool?
    /** The amount of time in milliseconds to wait between notification. */
    public var waitBetweenNotificationMs: Int64?
    /** The set of metric conditions that would trigger an alert. */
    public var conditions: CommonRuleConditions?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, enabled: Bool?, notifications: [AlertNotification]?, sendExitingAlarmNotifications: Bool?, waitBetweenNotificationMs: Int64?, conditions: CommonRuleConditions?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.enabled = enabled
        self.notifications = notifications
        self.sendExitingAlarmNotifications = sendExitingAlarmNotifications
        self.waitBetweenNotificationMs = waitBetweenNotificationMs
        self.conditions = conditions
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case enabled
        case notifications
        case sendExitingAlarmNotifications
        case waitBetweenNotificationMs
        case conditions
        case selfUri
    }


}




public class MoveManagementUnitResponse: Codable {



    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }

    /** The new business unit */
    public var businessUnit: BusinessUnitReference?
    /** The status of the move.  Will always be 'Processing' unless the Management Unit is already in the requested Business Unit in which case it will be 'Complete' */
    public var status: Status?

    public init(businessUnit: BusinessUnitReference?, status: Status?) {
        self.businessUnit = businessUnit
        self.status = status
    }


}




public class NTPSettings: Codable {



    /** List of NTP servers, in priority order */
    public var servers: [String]?

    public init(servers: [String]?) {
        self.servers = servers
    }


}




public class NluDetectionContext: Codable {





    /** Restrict detection to this intent. */
    public var intent: ContextIntent?
    /** Use this entity to restrict detection. */
    public var entity: ContextEntity?

    public init(intent: ContextIntent?, entity: ContextEntity?) {
        self.intent = intent
        self.entity = entity
    }


}




public class NluDomainVersionQualityReport: Codable {







    /** The domain and version details of the quality report */
    public var version: NluDomainVersion?
    /** The confusion matrix for the Domain Version */
    public var confusionMatrix: [NluConfusionMatrixRow]?
    /** The quality report summary for the Domain Version */
    public var summary: NluQualityReportSummary?

    public init(version: NluDomainVersion?, confusionMatrix: [NluConfusionMatrixRow]?, summary: NluQualityReportSummary?) {
        self.version = version
        self.confusionMatrix = confusionMatrix
        self.summary = summary
    }


}




public class NluFeedbackListing: Codable {





















    public var entities: [NluFeedbackResponse]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [NluFeedbackResponse]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class NluFeedbackRequest: Codable {









    /** The feedback text. */
    public var text: String?
    /** Detected intent of the utterance */
    public var intents: [IntentFeedback]?
    /** The domain version ID of the feedback. */
    public var versionId: String?
    /** The language of the version to which feedback is linked, e.g. en-us, de-de */
    public var language: String?

    public init(text: String?, intents: [IntentFeedback]?, versionId: String?, language: String?) {
        self.text = text
        self.intents = intents
        self.versionId = versionId
        self.language = language
    }


}




public class NluQualityReportSummaryMetric: Codable {





    /** The name of the metric. e.g. recall, f1_score */
    public var name: String?
    /** The value of the metric */
    public var value: Float?

    public init(name: String?, value: Float?) {
        self.name = name
        self.value = value
    }


}




public class Note: Codable {





    public enum EntityType: String, Codable { 
        case contact = "contact"
        case organization = "organization"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The id of the contact or organization to which this note refers. This only needs to be set for input when using the Bulk APIs. */
    public var entityId: String?
    /** This is only need to be set when using Bulk API. Using any other value than contact or organization will result in null being used. */
    public var entityType: EntityType?
    public var noteText: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifyDate: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createDate: Date?
    /** When creating or updating a note, only User.id is required. User object is fully populated when expanding a note. */
    public var createdBy: User?
    /** Links to the sources of data (e.g. one source might be a CRM) that contributed data to this record.  Read-only, and only populated when requested via expand param. */
    public var externalDataSources: [ExternalDataSource]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, entityId: String?, entityType: EntityType?, noteText: String?, modifyDate: Date?, createDate: Date?, createdBy: User?, externalDataSources: [ExternalDataSource]?, selfUri: String?) {
        self._id = _id
        self.entityId = entityId
        self.entityType = entityType
        self.noteText = noteText
        self.modifyDate = modifyDate
        self.createDate = createDate
        self.createdBy = createdBy
        self.externalDataSources = externalDataSources
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case entityId
        case entityType
        case noteText
        case modifyDate
        case createDate
        case createdBy
        case externalDataSources
        case selfUri
    }


}




public class NoteListing: Codable {























    public var entities: [Note]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var partialResults: Bool?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Note]?, pageSize: Int?, pageNumber: Int?, total: Int64?, partialResults: Bool?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.partialResults = partialResults
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** Template body object. */

public class NotificationTemplateBody: Codable {





    /** Body text. For WhatsApp, ignored. */
    public var text: String?
    /** Template parameters for placeholders in template. */
    public var parameters: [NotificationTemplateParameter]?

    public init(text: String?, parameters: [NotificationTemplateParameter]?) {
        self.text = text
        self.parameters = parameters
    }


}



/** Template footer object. */

public class NotificationTemplateFooter: Codable {



    /** Footer text. For WhatsApp, ignored. */
    public var text: String?

    public init(text: String?) {
        self.text = text
    }


}



/** Model for a Nuance bot variable */

public class NuanceBotVariable: Codable {













    /** The variable ID */
    public var _id: String?
    /** The variable display name */
    public var name: String?
    /** The variable description */
    public var _description: String?
    /** True if the variable is a reserved variable */
    public var reserved: Bool?
    /** The type information for this variable */
    public var simpleVariableInfo: String?
    /** The type information for this variable */
    public var complexGenericVariableInfo: ComplexVariableInfo?

    public init(_id: String?, name: String?, _description: String?, reserved: Bool?, simpleVariableInfo: String?, complexGenericVariableInfo: ComplexVariableInfo?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.reserved = reserved
        self.simpleVariableInfo = simpleVariableInfo
        self.complexGenericVariableInfo = complexGenericVariableInfo
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case reserved
        case simpleVariableInfo
        case complexGenericVariableInfo
    }


}



/** Model for a Nuance bot geography */

public class NuanceGeography: Codable {





    /** The geography ID */
    public var _id: String?
    /** The geography name */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}



/** Model for a Nuance bot organization */

public class NuanceOrganization: Codable {





    /** The organization ID */
    public var _id: String?
    /** The organization name */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class NumericRange: Codable {









    /** Greater than */
    public var gt: Double?
    /** Greater than or equal to */
    public var gte: Double?
    /** Less than */
    public var lt: Double?
    /** Less than or equal to */
    public var lte: Double?

    public init(gt: Double?, gte: Double?, lt: Double?, lte: Double?) {
        self.gt = gt
        self.gte = gte
        self.lt = lt
        self.lte = lte
    }


}




public class ObjectiveTemplate: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var zones: [ObjectiveZone]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, zones: [ObjectiveZone]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.zones = zones
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case zones
        case selfUri
    }


}



/** Attachment object. */

public class OpenContentAttachment: Codable {



    public enum MediaType: String, Codable { 
        case image = "Image"
        case video = "Video"
        case audio = "Audio"
        case file = "File"
        case link = "Link"
    }











    /** Provider specific ID for attachment. For example, middleware media UUID. */
    public var _id: String?
    /** The type of attachment this instance represents. */
    public var mediaType: MediaType?
    /** URL of the attachment. */
    public var url: String?
    /** Attachment mime type (https://www.iana.org/assignments/media-types/media-types.xhtml). */
    public var mime: String?
    /** Text associated with attachment such as an image caption. */
    public var text: String?
    /** Secure hash of the attachment content. */
    public var sha256: String?
    /** Suggested file name for attachment. */
    public var filename: String?

    public init(_id: String?, mediaType: MediaType?, url: String?, mime: String?, text: String?, sha256: String?, filename: String?) {
        self._id = _id
        self.mediaType = mediaType
        self.url = url
        self.mime = mime
        self.text = text
        self.sha256 = sha256
        self.filename = filename
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case mediaType
        case url
        case mime
        case text
        case sha256
        case filename
    }


}



/** Message event element. */

public class OpenEvent: Codable {

    public enum EventType: String, Codable { 
        case typing = "Typing"
    }

    /** Type of this event element */
    public var eventType: EventType?

    public init(eventType: EventType?) {
        self.eventType = eventType
    }


}



/** Message content element. */

public class OpenInboundMessageContent: Codable {



    /** Attachment content. */
    public var attachment: OpenContentAttachment?

    public init(attachment: OpenContentAttachment?) {
        self.attachment = attachment
    }


}



/** Open Messaging rich media message structure */

public class OpenNormalizedMessage: Codable {





    public enum ModelType: String, Codable { 
        case text = "Text"
        case receipt = "Receipt"
    }





    public enum Status: String, Codable { 
        case sent = "Sent"
        case delivered = "Delivered"
        case read = "Read"
        case failed = "Failed"
        case published = "Published"
        case removed = "Removed"
    }





    public enum Direction: String, Codable { 
        case inbound = "Inbound"
        case outbound = "Outbound"
    }



    /** Unique ID of the message. This ID is generated by Messaging Platform. Message receipts will have the same ID as the message they reference, as such should only be set when sending a message receipt. */
    public var _id: String?
    /** Channel-specific information that describes the message and the message channel/provider. */
    public var channel: OpenMessagingChannel?
    /** Message type. */
    public var type: ModelType?
    /** Message text. */
    public var text: String?
    /** List of content elements. */
    public var content: [OpenMessageContent]?
    /** Message receipt status, only used with type Receipt. */
    public var status: Status?
    /** List of reasons for a message receipt that indicates the message has failed. Only used with Failed status. */
    public var reasons: [ConversationReason]?
    /** Indicates if this is the last message receipt for this message, or if another message receipt can be expected. */
    public var isFinalReceipt: Bool?
    /** The direction of the message. */
    public var direction: Direction?
    /** Additional metadata about this message. */
    public var metadata: [String:String]?

    public init(_id: String?, channel: OpenMessagingChannel?, type: ModelType?, text: String?, content: [OpenMessageContent]?, status: Status?, reasons: [ConversationReason]?, isFinalReceipt: Bool?, direction: Direction?, metadata: [String:String]?) {
        self._id = _id
        self.channel = channel
        self.type = type
        self.text = text
        self.content = content
        self.status = status
        self.reasons = reasons
        self.isFinalReceipt = isFinalReceipt
        self.direction = direction
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case channel
        case type
        case text
        case content
        case status
        case reasons
        case isFinalReceipt
        case direction
        case metadata
    }


}




public class OperationalEventNotificationTopicEventEntity: Codable {







    public var _id: String?
    public var name: String?
    public var _description: String?

    public init(_id: String?, name: String?, _description: String?) {
        self._id = _id
        self.name = name
        self._description = _description
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
    }


}




public class OrgUser: Codable {

















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }

























































    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    public var chat: Chat?
    public var department: String?
    public var email: String?
    /** Auto populated from addresses. */
    public var primaryContactInfo: [Contact]?
    /** Email addresses and phone numbers for this user */
    public var addresses: [Contact]?
    /** The current state for this user. */
    public var state: State?
    public var title: String?
    public var username: String?
    public var manager: User?
    public var images: [UserImage]?
    /** Required when updating a user, this value should be the current version of the user.  The current version can be obtained with a GET on the user before doing a PATCH. */
    public var version: Int?
    public var certifications: [String]?
    public var biography: Biography?
    public var employerInfo: EmployerInfo?
    /** Preferred full name of the agent */
    public var preferredName: String?
    /** ACD routing status */
    public var routingStatus: RoutingStatus?
    /** Active presence */
    public var presence: UserPresence?
    /** Integration presence */
    public var integrationPresence: UserPresence?
    /** Summary of conversion statistics for conversation types. */
    public var conversationSummary: UserConversationSummary?
    /** Determine if out of office is enabled */
    public var outOfOffice: OutOfOffice?
    /** Current geolocation position */
    public var geolocation: Geolocation?
    /** Effective, default, and last station information */
    public var station: UserStations?
    /** Roles and permissions assigned to the user */
    public var authorization: UserAuthorization?
    /** Profile skills possessed by the user */
    public var profileSkills: [String]?
    /** The user placement at each site location. */
    public var locations: [Location]?
    /** The groups the user is a member of */
    public var groups: [Group]?
    /** The team the user is a member of */
    public var team: Team?
    /** Routing (ACD) skills possessed by the user */
    public var skills: [UserRoutingSkill]?
    /** Routing (ACD) languages possessed by the user */
    public var languages: [UserRoutingLanguage]?
    /** acd auto answer */
    public var acdAutoAnswer: Bool?
    /** preferred language by the user */
    public var languagePreference: String?
    public var lastTokenIssued: OAuthLastTokenIssued?
    /** The last time the user logged in using username and password. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateLastLogin: Date?
    public var organization: Organization?

    public init(_id: String?, name: String?, division: Division?, chat: Chat?, department: String?, email: String?, primaryContactInfo: [Contact]?, addresses: [Contact]?, state: State?, title: String?, username: String?, manager: User?, images: [UserImage]?, version: Int?, certifications: [String]?, biography: Biography?, employerInfo: EmployerInfo?, preferredName: String?, routingStatus: RoutingStatus?, presence: UserPresence?, integrationPresence: UserPresence?, conversationSummary: UserConversationSummary?, outOfOffice: OutOfOffice?, geolocation: Geolocation?, station: UserStations?, authorization: UserAuthorization?, profileSkills: [String]?, locations: [Location]?, groups: [Group]?, team: Team?, skills: [UserRoutingSkill]?, languages: [UserRoutingLanguage]?, acdAutoAnswer: Bool?, languagePreference: String?, lastTokenIssued: OAuthLastTokenIssued?, dateLastLogin: Date?, organization: Organization?) {
        self._id = _id
        self.name = name
        self.division = division
        self.chat = chat
        self.department = department
        self.email = email
        self.primaryContactInfo = primaryContactInfo
        self.addresses = addresses
        self.state = state
        self.title = title
        self.username = username
        self.manager = manager
        self.images = images
        self.version = version
        self.certifications = certifications
        self.biography = biography
        self.employerInfo = employerInfo
        self.preferredName = preferredName
        self.routingStatus = routingStatus
        self.presence = presence
        self.integrationPresence = integrationPresence
        self.conversationSummary = conversationSummary
        self.outOfOffice = outOfOffice
        self.geolocation = geolocation
        self.station = station
        self.authorization = authorization
        self.profileSkills = profileSkills
        self.locations = locations
        self.groups = groups
        self.team = team
        self.skills = skills
        self.languages = languages
        self.acdAutoAnswer = acdAutoAnswer
        self.languagePreference = languagePreference
        self.lastTokenIssued = lastTokenIssued
        self.dateLastLogin = dateLastLogin
        self.organization = organization
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case chat
        case department
        case email
        case primaryContactInfo
        case addresses
        case state
        case title
        case username
        case manager
        case images
        case version
        case certifications
        case biography
        case employerInfo
        case preferredName
        case routingStatus
        case presence
        case integrationPresence
        case conversationSummary
        case outOfOffice
        case geolocation
        case station
        case authorization
        case profileSkills
        case locations
        case groups
        case team
        case skills
        case languages
        case acdAutoAnswer
        case languagePreference
        case lastTokenIssued
        case dateLastLogin
        case organization
    }


}




public class Page: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var versionId: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    public var rootContainer: [String:JSON]?
    public var properties: [String:JSON]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, versionId: String?, createdDate: Date?, modifiedDate: Date?, rootContainer: [String:JSON]?, properties: [String:JSON]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.versionId = versionId
        self.createdDate = createdDate
        self.modifiedDate = modifiedDate
        self.rootContainer = rootContainer
        self.properties = properties
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case versionId
        case createdDate
        case modifiedDate
        case rootContainer
        case properties
        case selfUri
    }


}




public class OrphanRecording: Codable {









    public enum ProviderType: String, Codable { 
        case edge = "EDGE"
        case chat = "CHAT"
        case email = "EMAIL"
        case screenRecording = "SCREEN_RECORDING"
        case pureengage = "PUREENGAGE"
        case pureconnect = "PURECONNECT"
    }



    public enum MediaType: String, Codable { 
        case call = "CALL"
        case chat = "CHAT"
        case email = "EMAIL"
        case screen = "SCREEN"
    }

    public enum FileState: String, Codable { 
        case archived = "ARCHIVED"
        case available = "AVAILABLE"
        case deleted = "DELETED"
        case restored = "RESTORED"
        case restoring = "RESTORING"
        case uploading = "UPLOADING"
    }





    public enum OrphanStatus: String, Codable { 
        case noConversation = "NO_CONVERSATION"
        case unknownConversation = "UNKNOWN_CONVERSATION"
        case conversationNotComplete = "CONVERSATION_NOT_COMPLETE"
        case conversationNotEvaluated = "CONVERSATION_NOT_EVALUATED"
        case evaluated = "EVALUATED"
    }



    public enum Region: String, Codable { 
        case afSouth1 = "af-south-1"
        case apEast1 = "ap-east-1"
        case apNortheast1 = "ap-northeast-1"
        case apNortheast2 = "ap-northeast-2"
        case apNortheast3 = "ap-northeast-3"
        case apSouth1 = "ap-south-1"
        case apSoutheast1 = "ap-southeast-1"
        case apSoutheast2 = "ap-southeast-2"
        case apSoutheast3 = "ap-southeast-3"
        case caCentral1 = "ca-central-1"
        case euCentral1 = "eu-central-1"
        case euCentral2 = "eu-central-2"
        case euWest1 = "eu-west-1"
        case euWest2 = "eu-west-2"
        case euWest3 = "eu-west-3"
        case meCentral1 = "me-central-1"
        case saEast1 = "sa-east-1"
        case usEast1 = "us-east-1"
        case usWest2 = "us-west-2"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdTime: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var recoveredTime: Date?
    public var providerType: ProviderType?
    public var mediaSizeBytes: Int64?
    public var mediaType: MediaType?
    public var fileState: FileState?
    public var providerEndpoint: Endpoint?
    public var recording: Recording?
    /** The status of the orphaned recording's conversation. */
    public var orphanStatus: OrphanStatus?
    /** An identifier used during recovery operations by the supplying hybrid platform to track back and determine which interaction this recording is associated with */
    public var sourceOrphaningId: String?
    public var region: Region?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, createdTime: Date?, recoveredTime: Date?, providerType: ProviderType?, mediaSizeBytes: Int64?, mediaType: MediaType?, fileState: FileState?, providerEndpoint: Endpoint?, recording: Recording?, orphanStatus: OrphanStatus?, sourceOrphaningId: String?, region: Region?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.createdTime = createdTime
        self.recoveredTime = recoveredTime
        self.providerType = providerType
        self.mediaSizeBytes = mediaSizeBytes
        self.mediaType = mediaType
        self.fileState = fileState
        self.providerEndpoint = providerEndpoint
        self.recording = recording
        self.orphanStatus = orphanStatus
        self.sourceOrphaningId = sourceOrphaningId
        self.region = region
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case createdTime
        case recoveredTime
        case providerType
        case mediaSizeBytes
        case mediaType
        case fileState
        case providerEndpoint
        case recording
        case orphanStatus
        case sourceOrphaningId
        case region
        case selfUri
    }


}




public class OrphanRecordingListing: Codable {





















    public var entities: [OrphanRecording]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [OrphanRecording]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class OutOfOffice: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var user: User?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endDate: Date?
    public var active: Bool?
    public var indefinite: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, user: User?, startDate: Date?, endDate: Date?, active: Bool?, indefinite: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.user = user
        self.startDate = startDate
        self.endDate = endDate
        self.active = active
        self.indefinite = indefinite
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case user
        case startDate
        case endDate
        case active
        case indefinite
        case selfUri
    }


}




public class OutOfOfficeEventOutOfOffice: Codable {











    public var user: OutOfOfficeEventUser?
    public var active: Bool?
    public var indefinite: Bool?
    public var startDate: Date?
    public var endDate: Date?

    public init(user: OutOfOfficeEventUser?, active: Bool?, indefinite: Bool?, startDate: Date?, endDate: Date?) {
        self.user = user
        self.active = active
        self.indefinite = indefinite
        self.startDate = startDate
        self.endDate = endDate
    }


}




public class OutboundMessagingCampaignPostContactEmailEventTopicEmailAttributes: Codable {











    public var emailSubject: String?
    public var configuredEmailAddress: String?
    public var contactEmailAddress: String?
    public var replyToAddress: String?
    public var contactEmailColumnName: String?

    public init(emailSubject: String?, configuredEmailAddress: String?, contactEmailAddress: String?, replyToAddress: String?, contactEmailColumnName: String?) {
        self.emailSubject = emailSubject
        self.configuredEmailAddress = configuredEmailAddress
        self.contactEmailAddress = contactEmailAddress
        self.replyToAddress = replyToAddress
        self.contactEmailColumnName = contactEmailColumnName
    }


}



/** An outbound-messaging messaging campaign email Config */

public class OutboundMessagingMessagingCampaignConfigChangeEmailConfig: Codable {









    /** The Contact List column specifying the email to send to the contact. */
    public var emailColumns: [String]?
    /** A reference for a Response */
    public var contentTemplate: OutboundMessagingMessagingCampaignConfigChangeResponseRef?
    public var fromAddress: OutboundMessagingMessagingCampaignConfigChangeFromEmailAddress?
    public var replyToAddress: OutboundMessagingMessagingCampaignConfigChangeReplyToEmailAddress?

    public init(emailColumns: [String]?, contentTemplate: OutboundMessagingMessagingCampaignConfigChangeResponseRef?, fromAddress: OutboundMessagingMessagingCampaignConfigChangeFromEmailAddress?, replyToAddress: OutboundMessagingMessagingCampaignConfigChangeReplyToEmailAddress?) {
        self.emailColumns = emailColumns
        self.contentTemplate = contentTemplate
        self.fromAddress = fromAddress
        self.replyToAddress = replyToAddress
    }


}




public class OutboundMessagingMessagingCampaignConfigChangeMessagingCampaign: Codable {

    public enum CampaignStatus: String, Codable { 
        case on = "on"
        case off = "off"
        case complete = "complete"
        case stopping = "stopping"
        case invalid = "invalid"
    }



































    public var campaignStatus: CampaignStatus?
    public var callableTimeSet: OutboundMessagingMessagingCampaignConfigChangeUriReference?
    /** A UriReference for a resource */
    public var contactList: OutboundMessagingMessagingCampaignConfigChangeUriReference?
    /** The dnc lists to check before sending a message for this messaging campaign. */
    public var dncLists: [OutboundMessagingMessagingCampaignConfigChangeUriReference]?
    /** The contact list filters to check before sending a message for this messaging campaign. */
    public var contactListFilters: [OutboundMessagingMessagingCampaignConfigChangeUriReference]?
    /** Whether this messaging campaign is always running. */
    public var alwaysRunning: Bool?
    /** The order in which to sort contacts for dialing, based on up to four columns. */
    public var contactSorts: [OutboundMessagingMessagingCampaignConfigChangeContactSort]?
    /** How many messages this messaging campaign will send per minute. */
    public var messagesPerMinute: Int?
    public var ruleSets: [OutboundMessagingMessagingCampaignConfigChangeUriReference]?
    public var smsConfig: OutboundMessagingMessagingCampaignConfigChangeSmsConfig?
    public var emailConfig: OutboundMessagingMessagingCampaignConfigChangeEmailConfig?
    /** A list of current error conditions associated with this messaging campaign */
    public var errors: [OutboundMessagingMessagingCampaignConfigChangeErrorDetail]?
    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The UI-visible name of the object */
    public var name: String?
    /** Creation time of the entity */
    public var dateCreated: Date?
    /** Last modified time of the entity */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** A UriReference for a resource */
    public var division: OutboundMessagingMessagingCampaignConfigChangeUriReference?

    public init(campaignStatus: CampaignStatus?, callableTimeSet: OutboundMessagingMessagingCampaignConfigChangeUriReference?, contactList: OutboundMessagingMessagingCampaignConfigChangeUriReference?, dncLists: [OutboundMessagingMessagingCampaignConfigChangeUriReference]?, contactListFilters: [OutboundMessagingMessagingCampaignConfigChangeUriReference]?, alwaysRunning: Bool?, contactSorts: [OutboundMessagingMessagingCampaignConfigChangeContactSort]?, messagesPerMinute: Int?, ruleSets: [OutboundMessagingMessagingCampaignConfigChangeUriReference]?, smsConfig: OutboundMessagingMessagingCampaignConfigChangeSmsConfig?, emailConfig: OutboundMessagingMessagingCampaignConfigChangeEmailConfig?, errors: [OutboundMessagingMessagingCampaignConfigChangeErrorDetail]?, _id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, division: OutboundMessagingMessagingCampaignConfigChangeUriReference?) {
        self.campaignStatus = campaignStatus
        self.callableTimeSet = callableTimeSet
        self.contactList = contactList
        self.dncLists = dncLists
        self.contactListFilters = contactListFilters
        self.alwaysRunning = alwaysRunning
        self.contactSorts = contactSorts
        self.messagesPerMinute = messagesPerMinute
        self.ruleSets = ruleSets
        self.smsConfig = smsConfig
        self.emailConfig = emailConfig
        self.errors = errors
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.division = division
    }

    public enum CodingKeys: String, CodingKey { 
        case campaignStatus
        case callableTimeSet
        case contactList
        case dncLists
        case contactListFilters
        case alwaysRunning
        case contactSorts
        case messagesPerMinute
        case ruleSets
        case smsConfig
        case emailConfig
        case errors
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case division
    }


}




public class OutboundRouteBaseEntityListing: Codable {





















    public var entities: [OutboundRouteBase]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [OutboundRouteBase]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class OutcomeAchievement: Codable {





    /** The outcome that was achieved. */
    public var outcome: AchievedOutcome?
    /** Timestamp indicating when the outcome was achieved. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var achievedDate: Date?

    public init(outcome: AchievedOutcome?, achievedDate: Date?) {
        self.outcome = outcome
        self.achievedDate = achievedDate
    }


}




public class OutlierInfo: Codable {





    /** Boolean to identify if an outlier or not. */
    public var outlier: Bool?
    /** Outlier score for this utterance. The score is always 0 or greater and higher the score, the more outlier. */
    public var score: Float?

    public init(outlier: Bool?, score: Float?) {
        self.outlier = outlier
        self.score = score
    }


}




public class Participant: Codable {













































    public enum WrapupPrompt: String, Codable { 
        case mandatory = "mandatory"
        case _optional = "optional"
        case agentrequested = "agentRequested"
        case timeout = "timeout"
        case forcedtimeout = "forcedTimeout"
    }







































    public enum ScreenRecordingState: String, Codable { 
        case requested = "requested"
        case active = "active"
        case paused = "paused"
        case stopped = "stopped"
        case error = "error"
        case timeout = "timeout"
    }

    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }







    /** A globally unique identifier for this conversation. */
    public var _id: String?
    /** The timestamp when this participant joined the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startTime: Date?
    /** The timestamp when this participant disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?
    /** The timestamp when this participant was connected to the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** A human readable name identifying the participant. */
    public var name: String?
    /** If this participant represents a user, then this will be an URI that can be used to fetch the user. */
    public var userUri: String?
    /** If this participant represents a user, then this will be the globally unique identifier for the user. */
    public var userId: String?
    /** If this participant represents an external contact, then this will be the globally unique identifier for the external contact. */
    public var externalContactId: String?
    /** If this participant represents an external org, then this will be the globally unique identifier for the external org. */
    public var externalOrganizationId: String?
    /** If present, the queue id that the communication channel came in on. */
    public var queueId: String?
    /** If present, group of users the participant represents. */
    public var groupId: String?
    /** The team id that this participant is a member of when added to the conversation. */
    public var teamId: String?
    /** If present, the queue name that the communication channel came in on. */
    public var queueName: String?
    /** A well known string that specifies the purpose of this participant. */
    public var purpose: String?
    /** A well known string that specifies the type of this participant. */
    public var participantType: String?
    /** If this participant is part of a consult transfer, then this will be the participant id of the participant being transferred. */
    public var consultParticipantId: String?
    /** The address for the this participant. For a phone call this will be the ANI. */
    public var address: String?
    /** The address for the this participant. For a phone call this will be the ANI. */
    public var ani: String?
    /** The ani-based name for this participant. */
    public var aniName: String?
    /** The address for the this participant. For a phone call this will be the ANI. */
    public var dnis: String?
    /** An ISO 639 language code specifying the locale for this participant */
    public var locale: String?
    /** True iff this participant is required to enter wrapup for this conversation. */
    public var wrapupRequired: Bool?
    /** This field controls how the UI prompts the agent for a wrapup. */
    public var wrapupPrompt: WrapupPrompt?
    /** Specifies how long a timed ACW session will last. */
    public var wrapupTimeoutMs: Int?
    /** The UI sets this field when the agent chooses to skip entering a wrapup for this participant. */
    public var wrapupSkipped: Bool?
    /** Call wrap up or disposition data. */
    public var wrapup: Wrapup?
    /** List of roles this participant's media has had on the conversation, ie monitor, coach, etc. */
    public var mediaRoles: [String]?
    /** Information on how a communication should be routed to an agent. */
    public var conversationRoutingData: ConversationRoutingData?
    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutMs: Int?
    /** If this participant is a monitor, then this will be the id of the participant that is being monitored. */
    public var monitoredParticipantId: String?
    /** If this participant is a coach, then this will be the id of the participant that is being coached. */
    public var coachedParticipantId: String?
    /** Additional participant attributes */
    public var attributes: [String:String]?
    public var calls: [Call]?
    public var callbacks: [Callback]?
    public var chats: [ConversationChat]?
    public var cobrowsesessions: [Cobrowsesession]?
    public var emails: [Email]?
    public var messages: [Message]?
    public var screenshares: [Screenshare]?
    public var socialExpressions: [SocialExpression]?
    public var videos: [Video]?
    public var evaluations: [Evaluation]?
    /** The current screen recording state for this participant. */
    public var screenRecordingState: ScreenRecordingState?
    /** The reason specifying why participant flagged the conversation. */
    public var flaggedReason: FlaggedReason?
    /** The timestamp when this participant started after-call work. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAcwTime: Date?
    /** The timestamp when this participant ended after-call work. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endAcwTime: Date?
    /** If this participant barged in a participant's call, then this will be the id of the targeted participant. */
    public var bargedParticipantId: String?

    public init(_id: String?, startTime: Date?, endTime: Date?, connectedTime: Date?, name: String?, userUri: String?, userId: String?, externalContactId: String?, externalOrganizationId: String?, queueId: String?, groupId: String?, teamId: String?, queueName: String?, purpose: String?, participantType: String?, consultParticipantId: String?, address: String?, ani: String?, aniName: String?, dnis: String?, locale: String?, wrapupRequired: Bool?, wrapupPrompt: WrapupPrompt?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, wrapup: Wrapup?, mediaRoles: [String]?, conversationRoutingData: ConversationRoutingData?, alertingTimeoutMs: Int?, monitoredParticipantId: String?, coachedParticipantId: String?, attributes: [String:String]?, calls: [Call]?, callbacks: [Callback]?, chats: [ConversationChat]?, cobrowsesessions: [Cobrowsesession]?, emails: [Email]?, messages: [Message]?, screenshares: [Screenshare]?, socialExpressions: [SocialExpression]?, videos: [Video]?, evaluations: [Evaluation]?, screenRecordingState: ScreenRecordingState?, flaggedReason: FlaggedReason?, startAcwTime: Date?, endAcwTime: Date?, bargedParticipantId: String?) {
        self._id = _id
        self.startTime = startTime
        self.endTime = endTime
        self.connectedTime = connectedTime
        self.name = name
        self.userUri = userUri
        self.userId = userId
        self.externalContactId = externalContactId
        self.externalOrganizationId = externalOrganizationId
        self.queueId = queueId
        self.groupId = groupId
        self.teamId = teamId
        self.queueName = queueName
        self.purpose = purpose
        self.participantType = participantType
        self.consultParticipantId = consultParticipantId
        self.address = address
        self.ani = ani
        self.aniName = aniName
        self.dnis = dnis
        self.locale = locale
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.wrapup = wrapup
        self.mediaRoles = mediaRoles
        self.conversationRoutingData = conversationRoutingData
        self.alertingTimeoutMs = alertingTimeoutMs
        self.monitoredParticipantId = monitoredParticipantId
        self.coachedParticipantId = coachedParticipantId
        self.attributes = attributes
        self.calls = calls
        self.callbacks = callbacks
        self.chats = chats
        self.cobrowsesessions = cobrowsesessions
        self.emails = emails
        self.messages = messages
        self.screenshares = screenshares
        self.socialExpressions = socialExpressions
        self.videos = videos
        self.evaluations = evaluations
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.bargedParticipantId = bargedParticipantId
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case startTime
        case endTime
        case connectedTime
        case name
        case userUri
        case userId
        case externalContactId
        case externalOrganizationId
        case queueId
        case groupId
        case teamId
        case queueName
        case purpose
        case participantType
        case consultParticipantId
        case address
        case ani
        case aniName
        case dnis
        case locale
        case wrapupRequired
        case wrapupPrompt
        case wrapupTimeoutMs
        case wrapupSkipped
        case wrapup
        case mediaRoles
        case conversationRoutingData
        case alertingTimeoutMs
        case monitoredParticipantId
        case coachedParticipantId
        case attributes
        case calls
        case callbacks
        case chats
        case cobrowsesessions
        case emails
        case messages
        case screenshares
        case socialExpressions
        case videos
        case evaluations
        case screenRecordingState
        case flaggedReason
        case startAcwTime
        case endAcwTime
        case bargedParticipantId
    }


}




public class PatchActionMapScheduleGroups: Codable {





    /** The actions map's associated schedule group. */
    public var actionMapScheduleGroup: ActionMapScheduleGroup?
    /** The action map's associated emergency schedule group. */
    public var emergencyActionMapScheduleGroup: ActionMapScheduleGroup?

    public init(actionMapScheduleGroup: ActionMapScheduleGroup?, emergencyActionMapScheduleGroup: ActionMapScheduleGroup?) {
        self.actionMapScheduleGroup = actionMapScheduleGroup
        self.emergencyActionMapScheduleGroup = emergencyActionMapScheduleGroup
    }


}




public class PatchActionProperties: Codable {











    /** Prompt message shown to user, used for webchat type action. */
    public var webchatPrompt: String?
    /** Title shown to the user, used for webchat type action. */
    public var webchatTitleText: String?
    /** Accept button text shown to user, used for webchat type action. */
    public var webchatAcceptText: String?
    /** Decline button text shown to user, used for webchat type action. */
    public var webchatDeclineText: String?
    /** Survey provided to the user, used for webchat type action. */
    public var webchatSurvey: PatchActionSurvey?

    public init(webchatPrompt: String?, webchatTitleText: String?, webchatAcceptText: String?, webchatDeclineText: String?, webchatSurvey: PatchActionSurvey?) {
        self.webchatPrompt = webchatPrompt
        self.webchatTitleText = webchatTitleText
        self.webchatAcceptText = webchatAcceptText
        self.webchatDeclineText = webchatDeclineText
        self.webchatSurvey = webchatSurvey
    }


}




public class PatchActionSurvey: Codable {



    /** Questions shown to the user. */
    public var questions: [PatchSurveyQuestion]?

    public init(questions: [PatchSurveyQuestion]?) {
        self.questions = questions
    }


}




public class PatchBuScheduleRunRequest: Codable {



    /** The rescheduling options to update */
    public var reschedulingOptions: PatchBuReschedulingOptionsRequest?

    public init(reschedulingOptions: PatchBuReschedulingOptionsRequest?) {
        self.reschedulingOptions = reschedulingOptions
    }


}




public class PatchContextPattern: Codable {



    /** A list of one or more criteria to satisfy. */
    public var criteria: [PatchEntityTypeCriteria]?

    public init(criteria: [PatchEntityTypeCriteria]?) {
        self.criteria = criteria
    }


}




public class PatchPredictorRequest: Codable {







    /** Number of seconds allocated to predictive routing before attempting a different routing method. This is a value between 12 and 900 seconds. */
    public var routingTimeoutSeconds: Int?
    /** The predictor schedule that determines when the predictor is used for routing interactions. */
    public var schedule: PredictorSchedule?
    /** The predictor balancing configuration to enable workload balancing */
    public var workloadBalancingConfig: PredictorWorkloadBalancing?

    public init(routingTimeoutSeconds: Int?, schedule: PredictorSchedule?, workloadBalancingConfig: PredictorWorkloadBalancing?) {
        self.routingTimeoutSeconds = routingTimeoutSeconds
        self.schedule = schedule
        self.workloadBalancingConfig = workloadBalancingConfig
    }


}




public class PatchSurveyQuestion: Codable {

    public enum ModelType: String, Codable { 
        case text = "text"
        case hidden = "hidden"
        case select = "select"
        case checkbox = "checkbox"
        case textarea = "textarea"
    }



    public enum CustomerProperty: String, Codable { 
        case givenname = "givenName"
        case familyname = "familyName"
        case email = "email"
        case phone = "phone"
        case gender = "gender"
        case companyname = "companyName"
    }





    /** Type of survey question. */
    public var type: ModelType?
    /** Label of question. */
    public var label: String?
    /** The customer property that the answer maps to. */
    public var customerProperty: CustomerProperty?
    /** Choices available to user. */
    public var choices: [String]?
    /** Whether answering this question is mandatory. */
    public var isMandatory: Bool?

    public init(type: ModelType?, label: String?, customerProperty: CustomerProperty?, choices: [String]?, isMandatory: Bool?) {
        self.type = type
        self.label = label
        self.customerProperty = customerProperty
        self.choices = choices
        self.isMandatory = isMandatory
    }


}




public class PatchUser: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Preferred full name of agent */
    public var preferredName: String?
    /** The value that denotes if acdAutoAnswer is set on the user */
    public var acdAutoAnswer: Bool?

    public init(_id: String?, preferredName: String?, acdAutoAnswer: Bool?) {
        self._id = _id
        self.preferredName = preferredName
        self.acdAutoAnswer = acdAutoAnswer
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case preferredName
        case acdAutoAnswer
    }


}




public class PerformancePredictionOutputs: Codable {







    /** Date as an ISO-8601 string, corresponding to the beginning of the performance prediction results */
    public var calculationStartDate: Date?
    /** Interval length of the response metrics */
    public var calculationIntervalLengthMinutes: Int?
    /** List of planning group level performance prediction results */
    public var planningGroupResults: [PlanningGroupOutputs]?

    public init(calculationStartDate: Date?, calculationIntervalLengthMinutes: Int?, planningGroupResults: [PlanningGroupOutputs]?) {
        self.calculationStartDate = calculationStartDate
        self.calculationIntervalLengthMinutes = calculationIntervalLengthMinutes
        self.planningGroupResults = planningGroupResults
    }


}




public class PerformancePredictionRecalculationResponse: Codable {







    public enum State: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case error = "Error"
    }

    /** The operationId for which to listen */
    public var operationId: String?
    /** The url to GET the results of the performance prediction. This field is populated only if query state is 'Complete' */
    public var downloadUrl: String?
    /** Result will always come via downloadUrls; however the schema is included for documentation */
    public var downloadResult: PerformancePredictionOutputs?
    /** The state of the performance prediction */
    public var state: State?

    public init(operationId: String?, downloadUrl: String?, downloadResult: PerformancePredictionOutputs?, state: State?) {
        self.operationId = operationId
        self.downloadUrl = downloadUrl
        self.downloadResult = downloadResult
        self.state = state
    }


}




public class PerformancePredictionResponse: Codable {











    public enum State: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case error = "Error"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The weekDate of the short term forecast in yyyy-MM-dd format. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekDate: Date?
    /** The ID of the schedule this performance prediction is associated with */
    public var scheduleId: String?
    /** The url to GET the results of the performance prediction. This field is populated only if query state is 'Complete' */
    public var downloadUrl: String?
    /** Result will always come via downloadUrls; however the schema is included for documentation */
    public var downloadResult: PerformancePredictionOutputs?
    /** The state of the performance prediction */
    public var state: State?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, weekDate: Date?, scheduleId: String?, downloadUrl: String?, downloadResult: PerformancePredictionOutputs?, state: State?, selfUri: String?) {
        self._id = _id
        self.weekDate = weekDate
        self.scheduleId = scheduleId
        self.downloadUrl = downloadUrl
        self.downloadResult = downloadResult
        self.state = state
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case scheduleId
        case downloadUrl
        case downloadResult
        case state
        case selfUri
    }


}




public class Phone: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }

































    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** The site associated to the phone. */
    public var site: DomainEntityRef?
    /** Phone Base Settings */
    public var phoneBaseSettings: PhoneBaseSettings?
    public var lineBaseSettings: DomainEntityRef?
    public var phoneMetaBase: DomainEntityRef?
    /** Lines */
    public var lines: [Line]?
    /** The status of the phone and lines from the primary Edge. */
    public var status: PhoneStatus?
    /** The status of the phone and lines from the secondary Edge. */
    public var secondaryStatus: PhoneStatus?
    /** User Agent Information for this phone. This includes model, firmware version, and manufacturer. */
    public var userAgentInfo: UserAgentInfo?
    public var properties: [String:JSON]?
    public var capabilities: PhoneCapabilities?
    /** This is the user associated with a WebRTC type phone.  It is required for all WebRTC phones. */
    public var webRtcUser: DomainEntityRef?
    public var primaryEdge: Edge?
    public var secondaryEdge: Edge?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, site: DomainEntityRef?, phoneBaseSettings: PhoneBaseSettings?, lineBaseSettings: DomainEntityRef?, phoneMetaBase: DomainEntityRef?, lines: [Line]?, status: PhoneStatus?, secondaryStatus: PhoneStatus?, userAgentInfo: UserAgentInfo?, properties: [String:JSON]?, capabilities: PhoneCapabilities?, webRtcUser: DomainEntityRef?, primaryEdge: Edge?, secondaryEdge: Edge?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.site = site
        self.phoneBaseSettings = phoneBaseSettings
        self.lineBaseSettings = lineBaseSettings
        self.phoneMetaBase = phoneMetaBase
        self.lines = lines
        self.status = status
        self.secondaryStatus = secondaryStatus
        self.userAgentInfo = userAgentInfo
        self.properties = properties
        self.capabilities = capabilities
        self.webRtcUser = webRtcUser
        self.primaryEdge = primaryEdge
        self.secondaryEdge = secondaryEdge
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case site
        case phoneBaseSettings
        case lineBaseSettings
        case phoneMetaBase
        case lines
        case status
        case secondaryStatus
        case userAgentInfo
        case properties
        case capabilities
        case webRtcUser
        case primaryEdge
        case secondaryEdge
        case selfUri
    }


}




public class Phrase: Codable {



    public enum Strictness: String, Codable { 
        case _1 = "1"
        case _55 = "55"
        case _65 = "65"
        case _72 = "72"
        case _85 = "85"
        case _90 = "90"
    }

    public enum Sentiment: String, Codable { 
        case unspecified = "Unspecified"
        case positive = "Positive"
        case neutral = "Neutral"
        case negative = "Negative"
    }

    /** The phrase text */
    public var text: String?
    /** The phrase strictness, default value is null */
    public var strictness: Strictness?
    /** The phrase sentiment, default value is Unspecified. Note: Sentiment value for phrases is currently not in use and has no impact to the system. */
    public var sentiment: Sentiment?

    public init(text: String?, strictness: Strictness?, sentiment: Sentiment?) {
        self.text = text
        self.strictness = strictness
        self.sentiment = sentiment
    }


}




public class PolicyEntityListing: Codable {





















    public var entities: [Policy]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Policy]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class PolicyErrors: Codable {



    public var policyErrorMessages: [PolicyErrorMessage]?

    public init(policyErrorMessages: [PolicyErrorMessage]?) {
        self.policyErrorMessages = policyErrorMessages
    }


}



/** Definition of an Action to be created or updated. */

public class PostActionInput: Codable {













    /** Category of action, Can be up to 256 characters long */
    public var category: String?
    /** Name of action, Can be up to 256 characters long */
    public var name: String?
    /** The ID of the integration this action is associated to */
    public var integrationId: String?
    /** Configuration to support request and response processing */
    public var config: ActionConfig?
    /** Action contract */
    public var contract: ActionContractInput?
    /** Indication of whether or not the action is designed to accept sensitive data */
    public var secure: Bool?

    public init(category: String?, name: String?, integrationId: String?, config: ActionConfig?, contract: ActionContractInput?, secure: Bool?) {
        self.category = category
        self.name = name
        self.integrationId = integrationId
        self.config = config
        self.contract = contract
        self.secure = secure
    }


}




public class PresenceEventUserPresence: Codable {











    public var source: String?
    public var presenceDefinition: PresenceEventOrganizationPresence?
    public var primary: Bool?
    public var message: String?
    public var modifiedDate: Date?

    public init(source: String?, presenceDefinition: PresenceEventOrganizationPresence?, primary: Bool?, message: String?, modifiedDate: Date?) {
        self.source = source
        self.presenceDefinition = presenceDefinition
        self.primary = primary
        self.message = message
        self.modifiedDate = modifiedDate
    }


}




public class ProgramJob: Codable {



    public enum State: String, Codable { 
        case running = "Running"
        case completed = "Completed"
        case failed = "Failed"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var state: State?
    public var programs: [BaseProgramEntity]?
    public var createdBy: AddressableEntityRef?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, state: State?, programs: [BaseProgramEntity]?, createdBy: AddressableEntityRef?, dateCreated: Date?, dateModified: Date?, selfUri: String?) {
        self._id = _id
        self.state = state
        self.programs = programs
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case programs
        case createdBy
        case dateCreated
        case dateModified
        case selfUri
    }


}




public class ProgramJobRequest: Codable {



    /** The ids of the programs used for this job */
    public var programIds: [String]?

    public init(programIds: [String]?) {
        self.programIds = programIds
    }


}




public class ProgramsMappingsEntityListing: Codable {











    public var entities: [ProgramMappings]?
    public var pageSize: Int?
    public var nextUri: String?
    public var pageCount: Int?
    public var selfUri: String?

    public init(entities: [ProgramMappings]?, pageSize: Int?, nextUri: String?, pageCount: Int?, selfUri: String?) {
        self.entities = entities
        self.pageSize = pageSize
        self.nextUri = nextUri
        self.pageCount = pageCount
        self.selfUri = selfUri
    }


}




public class PromptAssetEntityListing: Codable {





















    public var entities: [PromptAsset]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [PromptAsset]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class PropertyChange: Codable {







    /** The property that was changed */
    public var property: String?
    /** Previous values for the property. */
    public var oldValues: [String]?
    /** New values for the property. */
    public var newValues: [String]?

    public init(property: String?, oldValues: [String]?, newValues: [String]?) {
        self.property = property
        self.oldValues = oldValues
        self.newValues = newValues
    }


}




public class PublishForm: Codable {





    /** Is this form published */
    public var published: Bool?
    /** Unique Id for this version of this form */
    public var _id: String?

    public init(published: Bool?, _id: String?) {
        self.published = published
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case published
        case _id = "id"
    }


}




public class QualityAuditQueryExecutionResultsResponse: Codable {









    /** Id of the audit query execution request. */
    public var _id: String?
    /** Number of results in a page. */
    public var pageSize: Int?
    /** Optional cursor to indicate where to resume the results. */
    public var cursor: String?
    /** List of audit messages. */
    public var entities: [QualityAuditLogMessage]?

    public init(_id: String?, pageSize: Int?, cursor: String?, entities: [QualityAuditLogMessage]?) {
        self._id = _id
        self.pageSize = pageSize
        self.cursor = cursor
        self.entities = entities
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case pageSize
        case cursor
        case entities
    }


}




public class QualityAuditQueryExecutionStatusResponse: Codable {



    public enum State: String, Codable { 
        case queued = "Queued"
        case running = "Running"
        case succeeded = "Succeeded"
        case failed = "Failed"
        case cancelled = "Cancelled"
    }









    /** Id of the audit query execution request. */
    public var _id: String?
    /** Status of the audit query execution request. */
    public var state: State?
    /** Start date and time of the audit query execution. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?
    /** Interval for the audit query. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Filters for the audit query. */
    public var filters: [QualityAuditQueryFilter]?
    /** Sort parameter for the audit query. */
    public var sort: [AuditQuerySort]?

    public init(_id: String?, state: State?, dateStart: Date?, interval: String?, filters: [QualityAuditQueryFilter]?, sort: [AuditQuerySort]?) {
        self._id = _id
        self.state = state
        self.dateStart = dateStart
        self.interval = interval
        self.filters = filters
        self.sort = sort
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case dateStart
        case interval
        case filters
        case sort
    }


}




public class QualityAuditQueryFilter: Codable {

    public enum Property: String, Codable { 
        case userId = "UserId"
        case trusteeOrganizationId = "TrusteeOrganizationId"
        case trusteeOnlyAudits = "TrusteeOnlyAudits"
        case clientId = "ClientId"
        case action = "Action"
        case entityType = "EntityType"
        case entityId = "EntityId"
        case conversationId = "ConversationId"
        case serviceName = "ServiceName"
    }



    /** Name of the property to filter. */
    public var property: Property?
    /** Value of the property to filter. */
    public var value: String?

    public init(property: Property?, value: String?) {
        self.property = property
        self.value = value
    }


}




public class QueryAdherenceExplanationsResponse: Codable {







    /** The asynchronous job handling the query */
    public var job: AdherenceExplanationJobReference?
    /** The result of the query. May come via notification */
    public var result: AdherenceExplanationListing?
    /** The URL from which to download the result. May come via notification */
    public var downloadUrl: String?

    public init(job: AdherenceExplanationJobReference?, result: AdherenceExplanationListing?, downloadUrl: String?) {
        self.job = job
        self.result = result
        self.downloadUrl = downloadUrl
    }


}




public class QueryTimeOffIntegrationStatusRequest: Codable {



    /** A list of time off request lookups */
    public var timeOffRequestLookups: [TimeOffRequestLookup]?

    public init(timeOffRequestLookups: [TimeOffRequestLookup]?) {
        self.timeOffRequestLookups = timeOffRequestLookups
    }


}




public class QueryTimeOffLimitValuesRequest: Codable {







    /** The time off limit object id to retrieve values for. Required if activityCodeId is not specified */
    public var timeOffLimitId: String?
    /** The activity code id to filter the affected limit objects by. Required if timeOffLimitId is not specified */
    public var activityCodeId: String?
    /** The list of the date ranges to return time off limit, allocated and waitlisted minutes. The valid number of date ranges is between 1 and 30. Maximum total number of days in all ranges in 366. */
    public var dateRanges: [LocalDateRange]?

    public init(timeOffLimitId: String?, activityCodeId: String?, dateRanges: [LocalDateRange]?) {
        self.timeOffLimitId = timeOffLimitId
        self.activityCodeId = activityCodeId
        self.dateRanges = dateRanges
    }


}




public class QueryWaitlistPositionsRequest: Codable {



    /** The list of the time off request ids for which to fetch the daily waitlist positions */
    public var timeOffRequests: [UserTimeOffRequestReference]?

    public init(timeOffRequests: [UserTimeOffRequestReference]?) {
        self.timeOffRequests = timeOffRequests
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class QueueConversationCallEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: QueueConversationCallEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: QueueConversationCallEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}




public class QueueConversationCallEventTopicJourneyContext: Codable {







    public var customer: QueueConversationCallEventTopicJourneyCustomer?
    public var customerSession: QueueConversationCallEventTopicJourneyCustomerSession?
    public var triggeringAction: QueueConversationCallEventTopicJourneyAction?

    public init(customer: QueueConversationCallEventTopicJourneyCustomer?, customerSession: QueueConversationCallEventTopicJourneyCustomerSession?, triggeringAction: QueueConversationCallEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class QueueConversationCallEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationCallbackEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationCallbackEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}




public class QueueConversationCallbackEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: QueueConversationCallbackEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int?

    public init(agent: QueueConversationCallbackEventTopicUriReference?, score: Int?) {
        self.agent = agent
        self.score = score
    }


}




public class QueueConversationChatEventTopicChatMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case timeout = "timeout"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }







































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }















    public var _id: String?
    public var name: String?
    public var address: String?
    public var startTime: Date?
    public var connectedTime: Date?
    public var endTime: Date?
    public var startHoldTime: Date?
    public var purpose: String?
    public var state: State?
    public var initialState: InitialState?
    public var direction: Direction?
    public var disconnectType: DisconnectType?
    public var held: Bool?
    public var wrapupRequired: Bool?
    public var wrapupPrompt: String?
    public var user: QueueConversationChatEventTopicUriReference?
    public var queue: QueueConversationChatEventTopicUriReference?
    public var team: QueueConversationChatEventTopicUriReference?
    public var attributes: [String:String]?
    public var errorInfo: QueueConversationChatEventTopicErrorBody?
    public var script: QueueConversationChatEventTopicUriReference?
    public var wrapupTimeoutMs: Int?
    public var wrapupSkipped: Bool?
    public var alertingTimeoutMs: Int?
    public var provider: String?
    public var externalContact: QueueConversationChatEventTopicUriReference?
    public var externalOrganization: QueueConversationChatEventTopicUriReference?
    public var wrapup: QueueConversationChatEventTopicWrapup?
    public var conversationRoutingData: QueueConversationChatEventTopicConversationRoutingData?
    public var peer: String?
    public var screenRecordingState: String?
    public var flaggedReason: FlaggedReason?
    public var journeyContext: QueueConversationChatEventTopicJourneyContext?
    public var startAcwTime: Date?
    public var endAcwTime: Date?
    public var mediaRoles: [String]?
    public var queueMediaSettings: QueueConversationChatEventTopicQueueMediaSettings?
    public var roomId: String?
    public var avatarImageUrl: String?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, initialState: InitialState?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, user: QueueConversationChatEventTopicUriReference?, queue: QueueConversationChatEventTopicUriReference?, team: QueueConversationChatEventTopicUriReference?, attributes: [String:String]?, errorInfo: QueueConversationChatEventTopicErrorBody?, script: QueueConversationChatEventTopicUriReference?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, alertingTimeoutMs: Int?, provider: String?, externalContact: QueueConversationChatEventTopicUriReference?, externalOrganization: QueueConversationChatEventTopicUriReference?, wrapup: QueueConversationChatEventTopicWrapup?, conversationRoutingData: QueueConversationChatEventTopicConversationRoutingData?, peer: String?, screenRecordingState: String?, flaggedReason: FlaggedReason?, journeyContext: QueueConversationChatEventTopicJourneyContext?, startAcwTime: Date?, endAcwTime: Date?, mediaRoles: [String]?, queueMediaSettings: QueueConversationChatEventTopicQueueMediaSettings?, roomId: String?, avatarImageUrl: String?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.conversationRoutingData = conversationRoutingData
        self.peer = peer
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.mediaRoles = mediaRoles
        self.queueMediaSettings = queueMediaSettings
        self.roomId = roomId
        self.avatarImageUrl = avatarImageUrl
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case initialState
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalOrganization
        case wrapup
        case conversationRoutingData
        case peer
        case screenRecordingState
        case flaggedReason
        case journeyContext
        case startAcwTime
        case endAcwTime
        case mediaRoles
        case queueMediaSettings
        case roomId
        case avatarImageUrl
    }


}




public class QueueConversationChatEventTopicDetail: Codable {









    public var errorCode: String?
    public var fieldName: String?
    public var entityId: String?
    public var entityName: String?

    public init(errorCode: String?, fieldName: String?, entityId: String?, entityName: String?) {
        self.errorCode = errorCode
        self.fieldName = fieldName
        self.entityId = entityId
        self.entityName = entityName
    }


}




public class QueueConversationChatEventTopicErrorBody: Codable {





















    public var message: String?
    public var code: String?
    public var status: Int?
    public var entityId: String?
    public var entityName: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var contextId: String?
    public var details: [QueueConversationChatEventTopicDetail]?
    public var errors: [QueueConversationChatEventTopicErrorBody]?

    public init(message: String?, code: String?, status: Int?, entityId: String?, entityName: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, details: [QueueConversationChatEventTopicDetail]?, errors: [QueueConversationChatEventTopicErrorBody]?) {
        self.message = message
        self.code = code
        self.status = status
        self.entityId = entityId
        self.entityName = entityName
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.details = details
        self.errors = errors
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class QueueConversationChatEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int?

    public init(_id: String?, version: Int?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}




public class QueueConversationChatEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationCobrowseEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationCobrowseEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}




public class QueueConversationCobrowseEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: QueueConversationCobrowseEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int?

    public init(agent: QueueConversationCobrowseEventTopicUriReference?, score: Int?) {
        self.agent = agent
        self.score = score
    }


}




public class QueueConversationEmailEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}




public class QueueConversationEventTopicChat: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferForward = "transfer.forward"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }

















    public var state: State?
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The source provider of the chat. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The room id for the chat. */
    public var roomId: String?
    /** The avatar for the chat (if available). */
    public var avatarImageUrl: String?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the chat was placed on hold in the cloud clock if the chat is currently on hold. */
    public var startHoldTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    public var journeyContext: QueueConversationEventTopicJourneyContext?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _id: String?, provider: String?, scriptId: String?, peerId: String?, roomId: String?, avatarImageUrl: String?, held: Bool?, disconnectType: DisconnectType?, startHoldTime: Date?, connectedTime: Date?, disconnectedTime: Date?, journeyContext: QueueConversationEventTopicJourneyContext?, wrapup: QueueConversationEventTopicWrapup?, afterCallWork: QueueConversationEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: QueueConversationEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.roomId = roomId
        self.avatarImageUrl = avatarImageUrl
        self.held = held
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.journeyContext = journeyContext
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case provider
        case scriptId
        case peerId
        case roomId
        case avatarImageUrl
        case held
        case disconnectType
        case startHoldTime
        case connectedTime
        case disconnectedTime
        case journeyContext
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}



/** Fields identifying the destination of a given conversation command. */

public class QueueConversationEventTopicDestination: Codable {





    /** The id of the user if the command destination is a user. */
    public var userId: String?
    /** The destination address if the command destination is an endpoint. */
    public var address: String?

    public init(userId: String?, address: String?) {
        self.userId = userId
        self.address = address
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class QueueConversationEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: QueueConversationEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: QueueConversationEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}



/** A subset of the Journey System's data relevant to a part of a conversation (for external linkage and internal usage/context). */

public class QueueConversationEventTopicJourneyContext: Codable {







    public var customer: QueueConversationEventTopicJourneyCustomer?
    public var customerSession: QueueConversationEventTopicJourneyCustomerSession?
    public var triggeringAction: QueueConversationEventTopicJourneyAction?

    public init(customer: QueueConversationEventTopicJourneyCustomer?, customerSession: QueueConversationEventTopicJourneyCustomerSession?, triggeringAction: QueueConversationEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class QueueConversationEventTopicMessage: Codable {



    public enum State: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case disconnected = "disconnected"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case disconnected = "disconnected"
    }

    public enum Direction: String, Codable { 
        case outbound = "outbound"
        case inbound = "inbound"
    }











    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }















    public enum ModelType: String, Codable { 
        case unknown = "unknown"
        case sms = "sms"
        case twitter = "twitter"
        case facebook = "facebook"
        case line = "line"
        case viber = "viber"
        case wechat = "wechat"
        case whatsapp = "whatsapp"
        case telegram = "telegram"
        case kakao = "kakao"
        case webmessaging = "webmessaging"
        case _open = "open"
        case instagram = "instagram"
    }



















    /** A globally unique identifier for this communication. */
    public var _id: String?
    public var state: State?
    public var initialState: InitialState?
    /** Whether a message is inbound or outbound. */
    public var direction: Direction?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** Detailed information about an error response. */
    public var errorInfo: QueueConversationEventTopicErrorDetails?
    /** The source provider of the email. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the email was placed on hold in the cloud clock if the email is currently on hold. */
    public var startHoldTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** Address and name data for a call endpoint. */
    public var toAddress: QueueConversationEventTopicAddress?
    /** Address and name data for a call endpoint. */
    public var fromAddress: QueueConversationEventTopicAddress?
    /** The messages sent on this communication channel. */
    public var messages: [QueueConversationEventTopicMessageDetails]?
    /** the messages transcript file uri. */
    public var messagesTranscriptUri: String?
    /** Indicates the type of message platform from which the message originated. */
    public var type: ModelType?
    /** Indicates the country where the recipient is associated in ISO 3166-1 alpha-2 format. */
    public var recipientCountry: String?
    /** The type of the recipient. Eg: Provisioned phoneNumber is the recipient for sms message type. */
    public var recipientType: String?
    /** A subset of the Journey System's data relevant to a part of a conversation (for external linkage and internal usage/context). */
    public var journeyContext: QueueConversationEventTopicJourneyContext?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** UUID of virtual agent assistant that provide suggestions to the agent participant during the conversation. */
    public var agentAssistantId: String?
    public var byoSmsIntegrationId: String?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationEventTopicQueueMediaSettings?

    public init(_id: String?, state: State?, initialState: InitialState?, direction: Direction?, held: Bool?, errorInfo: QueueConversationEventTopicErrorDetails?, provider: String?, scriptId: String?, peerId: String?, disconnectType: DisconnectType?, startHoldTime: Date?, connectedTime: Date?, disconnectedTime: Date?, toAddress: QueueConversationEventTopicAddress?, fromAddress: QueueConversationEventTopicAddress?, messages: [QueueConversationEventTopicMessageDetails]?, messagesTranscriptUri: String?, type: ModelType?, recipientCountry: String?, recipientType: String?, journeyContext: QueueConversationEventTopicJourneyContext?, wrapup: QueueConversationEventTopicWrapup?, afterCallWork: QueueConversationEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, agentAssistantId: String?, byoSmsIntegrationId: String?, queueMediaSettings: QueueConversationEventTopicQueueMediaSettings?) {
        self._id = _id
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.held = held
        self.errorInfo = errorInfo
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.toAddress = toAddress
        self.fromAddress = fromAddress
        self.messages = messages
        self.messagesTranscriptUri = messagesTranscriptUri
        self.type = type
        self.recipientCountry = recipientCountry
        self.recipientType = recipientType
        self.journeyContext = journeyContext
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.agentAssistantId = agentAssistantId
        self.byoSmsIntegrationId = byoSmsIntegrationId
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case initialState
        case direction
        case held
        case errorInfo
        case provider
        case scriptId
        case peerId
        case disconnectType
        case startHoldTime
        case connectedTime
        case disconnectedTime
        case toAddress
        case fromAddress
        case messages
        case messagesTranscriptUri
        case type
        case recipientCountry
        case recipientType
        case journeyContext
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case agentAssistantId
        case byoSmsIntegrationId
        case queueMediaSettings
    }


}




public class QueueConversationEventTopicMessageDetails: Codable {





    public enum MessageStatus: String, Codable { 
        case queued = "queued"
        case sent = "sent"
        case failed = "failed"
        case received = "received"
        case deliverySuccess = "delivery-success"
        case deliveryFailed = "delivery-failed"
        case read = "read"
        case removed = "removed"
    }











    /** UUID identifying the message media. */
    public var messageId: String?
    /** The time when the message was sent or received. */
    public var messageTime: Date?
    /** Indicates the delivery status of the message. */
    public var messageStatus: MessageStatus?
    /** The message segment count, greater than 1 if the message content was split into multiple parts for this message type, e.g. SMS character limits. */
    public var messageSegmentCount: Int?
    /** The media (images, files, etc) associated with this message, if any */
    public var media: [QueueConversationEventTopicMessageMedia]?
    /** Detailed information about an error response. */
    public var errorInfo: QueueConversationEventTopicErrorDetails?
    /** A list of stickers included in the message */
    public var stickers: [QueueConversationEventTopicMessageSticker]?
    public var messageMetadata: QueueConversationEventTopicMessageMetadata?

    public init(messageId: String?, messageTime: Date?, messageStatus: MessageStatus?, messageSegmentCount: Int?, media: [QueueConversationEventTopicMessageMedia]?, errorInfo: QueueConversationEventTopicErrorDetails?, stickers: [QueueConversationEventTopicMessageSticker]?, messageMetadata: QueueConversationEventTopicMessageMetadata?) {
        self.messageId = messageId
        self.messageTime = messageTime
        self.messageStatus = messageStatus
        self.messageSegmentCount = messageSegmentCount
        self.media = media
        self.errorInfo = errorInfo
        self.stickers = stickers
        self.messageMetadata = messageMetadata
    }


}




public class QueueConversationEventTopicMessageMedia: Codable {











    /** The location of the media, useful for retrieving it */
    public var url: String?
    /** The optional internet media type of the the media object.  If null then the media type should be dictated by the url */
    public var mediaType: String?
    /** The optional content length of the the media object, in bytes. */
    public var contentLengthBytes: Int?
    /** The optional name of the the media object. */
    public var name: String?
    /** The optional id of the the media object. */
    public var _id: String?

    public init(url: String?, mediaType: String?, contentLengthBytes: Int?, name: String?, _id: String?) {
        self.url = url
        self.mediaType = mediaType
        self.contentLengthBytes = contentLengthBytes
        self.name = name
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case url
        case mediaType
        case contentLengthBytes
        case name
        case _id = "id"
    }


}




public class QueueConversationEventTopicMessageMetadataEvent: Codable {





    /** Type of this event element. */
    public var eventType: String?
    /** Event subtype, if any */
    public var subType: String?

    public init(eventType: String?, subType: String?) {
        self.eventType = eventType
        self.subType = subType
    }


}




public class QueueConversationEventTopicMessageSticker: Codable {





    /** The location of the sticker, useful for retrieving it */
    public var url: String?
    /** The unique id of the the sticker object. */
    public var _id: String?

    public init(url: String?, _id: String?) {
        self.url = url
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case url
        case _id = "id"
    }


}




public class QueueConversationEventTopicScreenshare: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }













    public var state: State?
    public var initialState: InitialState?
    /** Address and name data for a call endpoint. */
    public var _self: QueueConversationEventTopicAddress?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The room id context (xmpp jid) for the conference session. */
    public var context: String?
    /** Indicates whether this participant is sharing their screen to the session. */
    public var sharing: Bool?
    /** The source provider of the screen share. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The number of peer participants from the perspective of the participant in the conference. */
    public var peerCount: JSON?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _self: QueueConversationEventTopicAddress?, _id: String?, context: String?, sharing: Bool?, provider: String?, scriptId: String?, peerId: String?, peerCount: JSON?, disconnectType: DisconnectType?, connectedTime: Date?, disconnectedTime: Date?, wrapup: QueueConversationEventTopicWrapup?, afterCallWork: QueueConversationEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: QueueConversationEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._self = _self
        self._id = _id
        self.context = context
        self.sharing = sharing
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.peerCount = peerCount
        self.disconnectType = disconnectType
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _self = "self"
        case _id = "id"
        case context
        case sharing
        case provider
        case scriptId
        case peerId
        case peerCount
        case disconnectType
        case connectedTime
        case disconnectedTime
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}



/** Information about the workflow. */

public class QueueConversationEventTopicWorkflow: Codable {



    /** The id of the workflow */
    public var workflowId: String?

    public init(workflowId: String?) {
        self.workflowId = workflowId
    }


}



/** Call wrap up or disposition data. */

public class QueueConversationEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}




public class QueueConversationMessageEventTopicDetail: Codable {









    public var errorCode: String?
    public var fieldName: String?
    public var entityId: String?
    public var entityName: String?

    public init(errorCode: String?, fieldName: String?, entityId: String?, entityName: String?) {
        self.errorCode = errorCode
        self.fieldName = fieldName
        self.entityId = entityId
        self.entityName = entityName
    }


}




public class QueueConversationMessageEventTopicErrorBody: Codable {





















    public var message: String?
    public var code: String?
    public var status: Int?
    public var entityId: String?
    public var entityName: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var contextId: String?
    public var details: [QueueConversationMessageEventTopicDetail]?
    public var errors: [QueueConversationMessageEventTopicErrorBody]?

    public init(message: String?, code: String?, status: Int?, entityId: String?, entityName: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, details: [QueueConversationMessageEventTopicDetail]?, errors: [QueueConversationMessageEventTopicErrorBody]?) {
        self.message = message
        self.code = code
        self.status = status
        self.entityId = entityId
        self.entityName = entityName
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.details = details
        self.errors = errors
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class QueueConversationMessageEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int?

    public init(_id: String?, version: Int?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}




public class QueueConversationMessageEventTopicMessageMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case timeout = "timeout"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }







































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }













    public enum ModelType: String, Codable { 
        case unknown = "unknown"
        case sms = "sms"
        case twitter = "twitter"
        case facebook = "facebook"
        case line = "line"
        case viber = "viber"
        case wechat = "wechat"
        case whatsapp = "whatsapp"
        case telegram = "telegram"
        case kakao = "kakao"
        case webmessaging = "webmessaging"
        case _open = "open"
        case instagram = "instagram"
    }









    public var _id: String?
    public var name: String?
    public var address: String?
    public var startTime: Date?
    public var connectedTime: Date?
    public var endTime: Date?
    public var startHoldTime: Date?
    public var purpose: String?
    public var state: State?
    public var initialState: InitialState?
    public var direction: Direction?
    public var disconnectType: DisconnectType?
    public var held: Bool?
    public var wrapupRequired: Bool?
    public var wrapupPrompt: String?
    public var user: QueueConversationMessageEventTopicUriReference?
    public var queue: QueueConversationMessageEventTopicUriReference?
    public var team: QueueConversationMessageEventTopicUriReference?
    public var attributes: [String:String]?
    public var errorInfo: QueueConversationMessageEventTopicErrorBody?
    public var script: QueueConversationMessageEventTopicUriReference?
    public var wrapupTimeoutMs: Int?
    public var wrapupSkipped: Bool?
    public var alertingTimeoutMs: Int?
    public var provider: String?
    public var externalContact: QueueConversationMessageEventTopicUriReference?
    public var externalOrganization: QueueConversationMessageEventTopicUriReference?
    public var wrapup: QueueConversationMessageEventTopicWrapup?
    public var conversationRoutingData: QueueConversationMessageEventTopicConversationRoutingData?
    public var peer: String?
    public var screenRecordingState: String?
    public var flaggedReason: FlaggedReason?
    public var journeyContext: QueueConversationMessageEventTopicJourneyContext?
    public var startAcwTime: Date?
    public var endAcwTime: Date?
    public var mediaRoles: [String]?
    public var queueMediaSettings: QueueConversationMessageEventTopicQueueMediaSettings?
    public var messages: [QueueConversationMessageEventTopicMessageDetails]?
    public var type: ModelType?
    public var recipientCountry: String?
    public var recipientType: String?
    public var byoSmsIntegrationId: String?
    public var monitoredParticipantId: String?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, initialState: InitialState?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, user: QueueConversationMessageEventTopicUriReference?, queue: QueueConversationMessageEventTopicUriReference?, team: QueueConversationMessageEventTopicUriReference?, attributes: [String:String]?, errorInfo: QueueConversationMessageEventTopicErrorBody?, script: QueueConversationMessageEventTopicUriReference?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, alertingTimeoutMs: Int?, provider: String?, externalContact: QueueConversationMessageEventTopicUriReference?, externalOrganization: QueueConversationMessageEventTopicUriReference?, wrapup: QueueConversationMessageEventTopicWrapup?, conversationRoutingData: QueueConversationMessageEventTopicConversationRoutingData?, peer: String?, screenRecordingState: String?, flaggedReason: FlaggedReason?, journeyContext: QueueConversationMessageEventTopicJourneyContext?, startAcwTime: Date?, endAcwTime: Date?, mediaRoles: [String]?, queueMediaSettings: QueueConversationMessageEventTopicQueueMediaSettings?, messages: [QueueConversationMessageEventTopicMessageDetails]?, type: ModelType?, recipientCountry: String?, recipientType: String?, byoSmsIntegrationId: String?, monitoredParticipantId: String?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.conversationRoutingData = conversationRoutingData
        self.peer = peer
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.mediaRoles = mediaRoles
        self.queueMediaSettings = queueMediaSettings
        self.messages = messages
        self.type = type
        self.recipientCountry = recipientCountry
        self.recipientType = recipientType
        self.byoSmsIntegrationId = byoSmsIntegrationId
        self.monitoredParticipantId = monitoredParticipantId
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case initialState
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalOrganization
        case wrapup
        case conversationRoutingData
        case peer
        case screenRecordingState
        case flaggedReason
        case journeyContext
        case startAcwTime
        case endAcwTime
        case mediaRoles
        case queueMediaSettings
        case messages
        case type
        case recipientCountry
        case recipientType
        case byoSmsIntegrationId
        case monitoredParticipantId
    }


}




public class QueueConversationMessageEventTopicMessageMetadata: Codable {







    /** Message type. */
    public var type: String?
    /** List of message events, if any */
    public var events: [QueueConversationMessageEventTopicMessageMetadataEvent]?
    /** List of message content, if any */
    public var content: [QueueConversationMessageEventTopicMessageMetadataContent]?

    public init(type: String?, events: [QueueConversationMessageEventTopicMessageMetadataEvent]?, content: [QueueConversationMessageEventTopicMessageMetadataContent]?) {
        self.type = type
        self.events = events
        self.content = content
    }


}




public class QueueConversationMessageEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class QueueConversationScreenShareEventTopicConversationRoutingData: Codable {











    /** A UriReference for a resource */
    public var queue: QueueConversationScreenShareEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: QueueConversationScreenShareEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int?
    /** The skills to use for routing decisions */
    public var skills: [QueueConversationScreenShareEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [QueueConversationScreenShareEventTopicScoredAgent]?

    public init(queue: QueueConversationScreenShareEventTopicUriReference?, language: QueueConversationScreenShareEventTopicUriReference?, priority: Int?, skills: [QueueConversationScreenShareEventTopicUriReference]?, scoredAgents: [QueueConversationScreenShareEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}




public class QueueConversationScreenShareEventTopicScreenShareConversation: Codable {









    public var _id: String?
    public var name: String?
    public var participants: [QueueConversationScreenShareEventTopicScreenShareMediaParticipant]?
    public var otherMediaUris: [String]?

    public init(_id: String?, name: String?, participants: [QueueConversationScreenShareEventTopicScreenShareMediaParticipant]?, otherMediaUris: [String]?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
    }


}




public class QueueConversationSocialExpressionEventTopicChat: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferForward = "transfer.forward"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }

















    public var state: State?
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The source provider of the chat. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The room id for the chat. */
    public var roomId: String?
    /** The avatar for the chat (if available). */
    public var avatarImageUrl: String?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the chat was placed on hold in the cloud clock if the chat is currently on hold. */
    public var startHoldTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    public var journeyContext: QueueConversationSocialExpressionEventTopicJourneyContext?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationSocialExpressionEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationSocialExpressionEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationSocialExpressionEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _id: String?, provider: String?, scriptId: String?, peerId: String?, roomId: String?, avatarImageUrl: String?, held: Bool?, disconnectType: DisconnectType?, startHoldTime: Date?, connectedTime: Date?, disconnectedTime: Date?, journeyContext: QueueConversationSocialExpressionEventTopicJourneyContext?, wrapup: QueueConversationSocialExpressionEventTopicWrapup?, afterCallWork: QueueConversationSocialExpressionEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: QueueConversationSocialExpressionEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.roomId = roomId
        self.avatarImageUrl = avatarImageUrl
        self.held = held
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.journeyContext = journeyContext
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case provider
        case scriptId
        case peerId
        case roomId
        case avatarImageUrl
        case held
        case disconnectType
        case startHoldTime
        case connectedTime
        case disconnectedTime
        case journeyContext
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}



/** Fields identifying the destination of a given conversation command. */

public class QueueConversationSocialExpressionEventTopicDestination: Codable {





    /** The id of the user if the command destination is a user. */
    public var userId: String?
    /** The destination address if the command destination is an endpoint. */
    public var address: String?

    public init(userId: String?, address: String?) {
        self.userId = userId
        self.address = address
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class QueueConversationSocialExpressionEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: QueueConversationSocialExpressionEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: QueueConversationSocialExpressionEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}



/** A subset of the Journey System's data relevant to a part of a conversation (for external linkage and internal usage/context). */

public class QueueConversationSocialExpressionEventTopicJourneyContext: Codable {







    public var customer: QueueConversationSocialExpressionEventTopicJourneyCustomer?
    public var customerSession: QueueConversationSocialExpressionEventTopicJourneyCustomerSession?
    public var triggeringAction: QueueConversationSocialExpressionEventTopicJourneyAction?

    public init(customer: QueueConversationSocialExpressionEventTopicJourneyCustomer?, customerSession: QueueConversationSocialExpressionEventTopicJourneyCustomerSession?, triggeringAction: QueueConversationSocialExpressionEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class QueueConversationSocialExpressionEventTopicMessage: Codable {



    public enum State: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case disconnected = "disconnected"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case disconnected = "disconnected"
    }

    public enum Direction: String, Codable { 
        case outbound = "outbound"
        case inbound = "inbound"
    }











    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }















    public enum ModelType: String, Codable { 
        case unknown = "unknown"
        case sms = "sms"
        case twitter = "twitter"
        case facebook = "facebook"
        case line = "line"
        case viber = "viber"
        case wechat = "wechat"
        case whatsapp = "whatsapp"
        case telegram = "telegram"
        case kakao = "kakao"
        case webmessaging = "webmessaging"
        case _open = "open"
        case instagram = "instagram"
    }



















    /** A globally unique identifier for this communication. */
    public var _id: String?
    public var state: State?
    public var initialState: InitialState?
    /** Whether a message is inbound or outbound. */
    public var direction: Direction?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** Detailed information about an error response. */
    public var errorInfo: QueueConversationSocialExpressionEventTopicErrorDetails?
    /** The source provider of the email. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the email was placed on hold in the cloud clock if the email is currently on hold. */
    public var startHoldTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** Address and name data for a call endpoint. */
    public var toAddress: QueueConversationSocialExpressionEventTopicAddress?
    /** Address and name data for a call endpoint. */
    public var fromAddress: QueueConversationSocialExpressionEventTopicAddress?
    /** The messages sent on this communication channel. */
    public var messages: [QueueConversationSocialExpressionEventTopicMessageDetails]?
    /** the messages transcript file uri. */
    public var messagesTranscriptUri: String?
    /** Indicates the type of message platform from which the message originated. */
    public var type: ModelType?
    /** Indicates the country where the recipient is associated in ISO 3166-1 alpha-2 format. */
    public var recipientCountry: String?
    /** The type of the recipient. Eg: Provisioned phoneNumber is the recipient for sms message type. */
    public var recipientType: String?
    /** A subset of the Journey System's data relevant to a part of a conversation (for external linkage and internal usage/context). */
    public var journeyContext: QueueConversationSocialExpressionEventTopicJourneyContext?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationSocialExpressionEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationSocialExpressionEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** UUID of virtual agent assistant that provide suggestions to the agent participant during the conversation. */
    public var agentAssistantId: String?
    public var byoSmsIntegrationId: String?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationSocialExpressionEventTopicQueueMediaSettings?

    public init(_id: String?, state: State?, initialState: InitialState?, direction: Direction?, held: Bool?, errorInfo: QueueConversationSocialExpressionEventTopicErrorDetails?, provider: String?, scriptId: String?, peerId: String?, disconnectType: DisconnectType?, startHoldTime: Date?, connectedTime: Date?, disconnectedTime: Date?, toAddress: QueueConversationSocialExpressionEventTopicAddress?, fromAddress: QueueConversationSocialExpressionEventTopicAddress?, messages: [QueueConversationSocialExpressionEventTopicMessageDetails]?, messagesTranscriptUri: String?, type: ModelType?, recipientCountry: String?, recipientType: String?, journeyContext: QueueConversationSocialExpressionEventTopicJourneyContext?, wrapup: QueueConversationSocialExpressionEventTopicWrapup?, afterCallWork: QueueConversationSocialExpressionEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, agentAssistantId: String?, byoSmsIntegrationId: String?, queueMediaSettings: QueueConversationSocialExpressionEventTopicQueueMediaSettings?) {
        self._id = _id
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.held = held
        self.errorInfo = errorInfo
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.toAddress = toAddress
        self.fromAddress = fromAddress
        self.messages = messages
        self.messagesTranscriptUri = messagesTranscriptUri
        self.type = type
        self.recipientCountry = recipientCountry
        self.recipientType = recipientType
        self.journeyContext = journeyContext
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.agentAssistantId = agentAssistantId
        self.byoSmsIntegrationId = byoSmsIntegrationId
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case initialState
        case direction
        case held
        case errorInfo
        case provider
        case scriptId
        case peerId
        case disconnectType
        case startHoldTime
        case connectedTime
        case disconnectedTime
        case toAddress
        case fromAddress
        case messages
        case messagesTranscriptUri
        case type
        case recipientCountry
        case recipientType
        case journeyContext
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case agentAssistantId
        case byoSmsIntegrationId
        case queueMediaSettings
    }


}




public class QueueConversationSocialExpressionEventTopicMessageDetails: Codable {





    public enum MessageStatus: String, Codable { 
        case queued = "queued"
        case sent = "sent"
        case failed = "failed"
        case received = "received"
        case deliverySuccess = "delivery-success"
        case deliveryFailed = "delivery-failed"
        case read = "read"
        case removed = "removed"
    }











    /** UUID identifying the message media. */
    public var messageId: String?
    /** The time when the message was sent or received. */
    public var messageTime: Date?
    /** Indicates the delivery status of the message. */
    public var messageStatus: MessageStatus?
    /** The message segment count, greater than 1 if the message content was split into multiple parts for this message type, e.g. SMS character limits. */
    public var messageSegmentCount: Int?
    /** The media (images, files, etc) associated with this message, if any */
    public var media: [QueueConversationSocialExpressionEventTopicMessageMedia]?
    /** Detailed information about an error response. */
    public var errorInfo: QueueConversationSocialExpressionEventTopicErrorDetails?
    /** A list of stickers included in the message */
    public var stickers: [QueueConversationSocialExpressionEventTopicMessageSticker]?
    public var messageMetadata: QueueConversationSocialExpressionEventTopicMessageMetadata?

    public init(messageId: String?, messageTime: Date?, messageStatus: MessageStatus?, messageSegmentCount: Int?, media: [QueueConversationSocialExpressionEventTopicMessageMedia]?, errorInfo: QueueConversationSocialExpressionEventTopicErrorDetails?, stickers: [QueueConversationSocialExpressionEventTopicMessageSticker]?, messageMetadata: QueueConversationSocialExpressionEventTopicMessageMetadata?) {
        self.messageId = messageId
        self.messageTime = messageTime
        self.messageStatus = messageStatus
        self.messageSegmentCount = messageSegmentCount
        self.media = media
        self.errorInfo = errorInfo
        self.stickers = stickers
        self.messageMetadata = messageMetadata
    }


}




public class QueueConversationSocialExpressionEventTopicMessageMedia: Codable {











    /** The location of the media, useful for retrieving it */
    public var url: String?
    /** The optional internet media type of the the media object.  If null then the media type should be dictated by the url */
    public var mediaType: String?
    /** The optional content length of the the media object, in bytes. */
    public var contentLengthBytes: Int?
    /** The optional name of the the media object. */
    public var name: String?
    /** The optional id of the the media object. */
    public var _id: String?

    public init(url: String?, mediaType: String?, contentLengthBytes: Int?, name: String?, _id: String?) {
        self.url = url
        self.mediaType = mediaType
        self.contentLengthBytes = contentLengthBytes
        self.name = name
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case url
        case mediaType
        case contentLengthBytes
        case name
        case _id = "id"
    }


}




public class QueueConversationSocialExpressionEventTopicMessageMetadataEvent: Codable {





    /** Type of this event element. */
    public var eventType: String?
    /** Event subtype, if any */
    public var subType: String?

    public init(eventType: String?, subType: String?) {
        self.eventType = eventType
        self.subType = subType
    }


}




public class QueueConversationSocialExpressionEventTopicMessageSticker: Codable {





    /** The location of the sticker, useful for retrieving it */
    public var url: String?
    /** The unique id of the the sticker object. */
    public var _id: String?

    public init(url: String?, _id: String?) {
        self.url = url
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case url
        case _id = "id"
    }


}




public class QueueConversationSocialExpressionEventTopicScreenshare: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }













    public var state: State?
    public var initialState: InitialState?
    /** Address and name data for a call endpoint. */
    public var _self: QueueConversationSocialExpressionEventTopicAddress?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The room id context (xmpp jid) for the conference session. */
    public var context: String?
    /** Indicates whether this participant is sharing their screen to the session. */
    public var sharing: Bool?
    /** The source provider of the screen share. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The number of peer participants from the perspective of the participant in the conference. */
    public var peerCount: JSON?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationSocialExpressionEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationSocialExpressionEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationSocialExpressionEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _self: QueueConversationSocialExpressionEventTopicAddress?, _id: String?, context: String?, sharing: Bool?, provider: String?, scriptId: String?, peerId: String?, peerCount: JSON?, disconnectType: DisconnectType?, connectedTime: Date?, disconnectedTime: Date?, wrapup: QueueConversationSocialExpressionEventTopicWrapup?, afterCallWork: QueueConversationSocialExpressionEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: QueueConversationSocialExpressionEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._self = _self
        self._id = _id
        self.context = context
        self.sharing = sharing
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.peerCount = peerCount
        self.disconnectType = disconnectType
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _self = "self"
        case _id = "id"
        case context
        case sharing
        case provider
        case scriptId
        case peerId
        case peerCount
        case disconnectType
        case connectedTime
        case disconnectedTime
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}



/** Information about the workflow. */

public class QueueConversationSocialExpressionEventTopicWorkflow: Codable {



    /** The id of the workflow */
    public var workflowId: String?

    public init(workflowId: String?) {
        self.workflowId = workflowId
    }


}



/** Call wrap up or disposition data. */

public class QueueConversationSocialExpressionEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}




public class QueueConversationVideoEventTopicCallback: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case scheduled = "scheduled"
        case uploading = "uploading"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case scheduled = "scheduled"
        case uploading = "uploading"
        case _none = "none"
    }



    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }



    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferForward = "transfer.forward"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }











































    public var state: State?
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The direction of the call */
    public var direction: Direction?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the callback was placed on hold in the cloud clock if the callback is currently on hold. */
    public var startHoldTime: Date?
    public var dialerPreview: QueueConversationVideoEventTopicDialerPreview?
    public var voicemail: QueueConversationVideoEventTopicVoicemail?
    /** The phone number(s) to use to place the callback. */
    public var callbackNumbers: [String]?
    /** The name of the user requesting a callback. */
    public var callbackUserName: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** True if the call for the callback uses external dialing. */
    public var externalCampaign: Bool?
    /** True if the ability to skip a callback should be enabled. */
    public var skipEnabled: Bool?
    /** The source provider of the callback. */
    public var provider: String?
    /** The number of seconds before the system automatically places a call for a callback.  0 means the automatic placement is disabled. */
    public var timeoutSeconds: Int?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** The timestamp when this communication is scheduled in the provider clock. If this value is missing it indicates the callback will be placed immediately. */
    public var callbackScheduledTime: Date?
    /** The id of the config for automatically placing the callback (and handling the disposition). If null, the callback will not be placed automatically but routed to an agent as per normal. */
    public var automatedCallbackConfigId: String?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationVideoEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationVideoEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** The phone number displayed to recipients of the phone call. The value should conform to the E164 format. */
    public var callerId: String?
    /** The name displayed to recipients of the phone call. */
    public var callerIdName: String?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationVideoEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _id: String?, direction: Direction?, held: Bool?, disconnectType: DisconnectType?, startHoldTime: Date?, dialerPreview: QueueConversationVideoEventTopicDialerPreview?, voicemail: QueueConversationVideoEventTopicVoicemail?, callbackNumbers: [String]?, callbackUserName: String?, scriptId: String?, peerId: String?, externalCampaign: Bool?, skipEnabled: Bool?, provider: String?, timeoutSeconds: Int?, connectedTime: Date?, disconnectedTime: Date?, callbackScheduledTime: Date?, automatedCallbackConfigId: String?, wrapup: QueueConversationVideoEventTopicWrapup?, afterCallWork: QueueConversationVideoEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, callerId: String?, callerIdName: String?, queueMediaSettings: QueueConversationVideoEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.direction = direction
        self.held = held
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.dialerPreview = dialerPreview
        self.voicemail = voicemail
        self.callbackNumbers = callbackNumbers
        self.callbackUserName = callbackUserName
        self.scriptId = scriptId
        self.peerId = peerId
        self.externalCampaign = externalCampaign
        self.skipEnabled = skipEnabled
        self.provider = provider
        self.timeoutSeconds = timeoutSeconds
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.callbackScheduledTime = callbackScheduledTime
        self.automatedCallbackConfigId = automatedCallbackConfigId
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.callerId = callerId
        self.callerIdName = callerIdName
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case direction
        case held
        case disconnectType
        case startHoldTime
        case dialerPreview
        case voicemail
        case callbackNumbers
        case callbackUserName
        case scriptId
        case peerId
        case externalCampaign
        case skipEnabled
        case provider
        case timeoutSeconds
        case connectedTime
        case disconnectedTime
        case callbackScheduledTime
        case automatedCallbackConfigId
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case callerId
        case callerIdName
        case queueMediaSettings
    }


}




public class QueueConversationVideoEventTopicCobrowse: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }



































    public var state: State?
    public var initialState: InitialState?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** Address and name data for a call endpoint. */
    public var _self: QueueConversationVideoEventTopicAddress?
    /** The room id for the chat. */
    public var roomId: String?
    /** The co-browse session ID. */
    public var cobrowseSessionId: String?
    /** This value identifies the role of the co-browse client within the co-browse session (a client is a sharer or a viewer). */
    public var cobrowseRole: String?
    /** ID of co-browse participants for which this client has been granted control (list is empty if this client cannot control any shared pages). */
    public var controlling: [String]?
    /** The URL that can be used to open co-browse session in web browser. */
    public var viewerUrl: String?
    /** The source provider of the co-browse communication. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The time when the provider event which triggered this conversation update happened in the corrected provider clock (milliseconds since 1970-01-01 00:00:00 UTC). */
    public var providerEventTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationVideoEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationVideoEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationVideoEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, disconnectType: DisconnectType?, _id: String?, _self: QueueConversationVideoEventTopicAddress?, roomId: String?, cobrowseSessionId: String?, cobrowseRole: String?, controlling: [String]?, viewerUrl: String?, provider: String?, scriptId: String?, peerId: String?, providerEventTime: Date?, connectedTime: Date?, disconnectedTime: Date?, wrapup: QueueConversationVideoEventTopicWrapup?, afterCallWork: QueueConversationVideoEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: QueueConversationVideoEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self.disconnectType = disconnectType
        self._id = _id
        self._self = _self
        self.roomId = roomId
        self.cobrowseSessionId = cobrowseSessionId
        self.cobrowseRole = cobrowseRole
        self.controlling = controlling
        self.viewerUrl = viewerUrl
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.providerEventTime = providerEventTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case disconnectType
        case _id = "id"
        case _self = "self"
        case roomId
        case cobrowseSessionId
        case cobrowseRole
        case controlling
        case viewerUrl
        case provider
        case scriptId
        case peerId
        case providerEventTime
        case connectedTime
        case disconnectedTime
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}



/** The preview data to be used when this callback is a Preview. */

public class QueueConversationVideoEventTopicDialerPreview: Codable {











    public var _id: String?
    /** The contact associated with this preview data pop */
    public var contactId: String?
    /** The contactList associated with this preview data pop. */
    public var contactListId: String?
    /** The campaignId associated with this preview data pop. */
    public var campaignId: String?
    /** The phone number columns associated with this campaign */
    public var phoneNumberColumns: [QueueConversationVideoEventTopicPhoneNumberColumn]?

    public init(_id: String?, contactId: String?, contactListId: String?, campaignId: String?, phoneNumberColumns: [QueueConversationVideoEventTopicPhoneNumberColumn]?) {
        self._id = _id
        self.contactId = contactId
        self.contactListId = contactListId
        self.campaignId = campaignId
        self.phoneNumberColumns = phoneNumberColumns
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case contactId
        case contactListId
        case campaignId
        case phoneNumberColumns
    }


}



/** Extra information on fax transmission. */

public class QueueConversationVideoEventTopicFaxStatus: Codable {

















    /** The fax direction, either \"send\" or \"receive\". */
    public var direction: String?
    /** Total number of expected pages, if known. */
    public var expectedPages: Int?
    /** Active page of the transmission. */
    public var activePage: Int?
    /** Number of lines that have completed transmission. */
    public var linesTransmitted: Int?
    /** Number of bytes that have competed transmission. */
    public var bytesTransmitted: Int?
    /** Current signaling rate of transmission, baud rate. */
    public var baudRate: Int?
    /** Number of page errors. */
    public var pageErrors: Int?
    /** Number of line errors. */
    public var lineErrors: Int?

    public init(direction: String?, expectedPages: Int?, activePage: Int?, linesTransmitted: Int?, bytesTransmitted: Int?, baudRate: Int?, pageErrors: Int?, lineErrors: Int?) {
        self.direction = direction
        self.expectedPages = expectedPages
        self.activePage = activePage
        self.linesTransmitted = linesTransmitted
        self.bytesTransmitted = bytesTransmitted
        self.baudRate = baudRate
        self.pageErrors = pageErrors
        self.lineErrors = lineErrors
    }


}




public class QueueConversationVideoEventTopicMessageMetadataContent: Codable {





    /** Type of this content element. */
    public var contentType: String?
    /** Content subtype, if any */
    public var subType: String?

    public init(contentType: String?, subType: String?) {
        self.contentType = contentType
        self.subType = subType
    }


}




public class QueueConversationVideoEventTopicParticipant: Codable {





















































    public enum ScreenRecordingState: String, Codable { 
        case requested = "requested"
        case active = "active"
        case paused = "paused"
        case stopped = "stopped"
        case error = "error"
        case timeout = "timeout"
    }

























    /** A globally unique identifier for this conversation. */
    public var _id: String?
    /** The timestamp when this participant was connected to the conversation in the provider clock. */
    public var connectedTime: Date?
    /** The timestamp when this participant disconnected from the conversation in the provider clock. */
    public var endTime: Date?
    /** If this participant represents a user, then this will be the globally unique identifier for the user. */
    public var userId: String?
    /** If this participant represents an external contact, then this will be the globally unique identifier for the external contact. */
    public var externalContactId: String?
    /** If this participant represents an external org, then this will be the globally unique identifier for the external org. */
    public var externalOrganizationId: String?
    /** A human readable name identifying the participant. */
    public var name: String?
    /** If present, the queue id that the communication channel came in on. */
    public var queueId: String?
    /** If present, the group id that the participant represents. */
    public var groupId: String?
    /** The team id that this participant is a member of when added to the conversation. */
    public var teamId: String?
    /** A well known string that specifies the purpose or type of this participant. */
    public var purpose: String?
    /** If this participant is part of a consult transfer, then this will be the participant id of the participant being transferred. */
    public var consultParticipantId: String?
    /** The address for the this participant. For a phone call this will be the ANI. */
    public var address: String?
    /** True iff this participant is required to enter wrapup for this conversation. */
    public var wrapupRequired: Bool?
    /** True when a participant is expected to enter a wrapup code once the call connects. */
    public var wrapupExpected: Bool?
    /** This field controls how the UI prompts the agent for a wrapup. */
    public var wrapupPrompt: String?
    /** Specifies how long a timed ACW session will last. */
    public var wrapupTimeoutMs: Int?
    public var wrapup: QueueConversationVideoEventTopicWrapup?
    /** The timestamp when this participant started after-call work. */
    public var startAcwTime: Date?
    /** The timestamp when this participant ended after-call work. */
    public var endAcwTime: Date?
    public var conversationRoutingData: QueueConversationVideoEventTopicConversationRoutingData?
    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutMs: Int?
    /** If this participant is a monitor, then this will be the id of the participant that is being monitored. */
    public var monitoredParticipantId: String?
    /** If this participant is a coach, then this will be the id of the participant that is being coached. */
    public var coachedParticipantId: String?
    /** If this participant created a barge in conference, then this will be the id of the participant that is barged in. */
    public var bargedParticipantId: String?
    /** List of roles this participant's media has had on the conversation, ie monitor, coach, etc. */
    public var mediaRoles: [String]?
    /** The current screen recording state for this participant. */
    public var screenRecordingState: ScreenRecordingState?
    /** If this participant has flagged the conversation, the reason code given. */
    public var flaggedReason: String?
    /** Additional participant attributes */
    public var attributes: [String:String]?
    public var calls: [QueueConversationVideoEventTopicCall]?
    public var callbacks: [QueueConversationVideoEventTopicCallback]?
    public var chats: [QueueConversationVideoEventTopicChat]?
    public var cobrowsesessions: [QueueConversationVideoEventTopicCobrowse]?
    public var emails: [QueueConversationVideoEventTopicEmail]?
    public var messages: [QueueConversationVideoEventTopicMessage]?
    public var screenshares: [QueueConversationVideoEventTopicScreenshare]?
    public var socialExpressions: [QueueConversationVideoEventTopicSocialExpression]?
    public var videos: [QueueConversationVideoEventTopicVideo]?
    public var workflow: QueueConversationVideoEventTopicWorkflow?

    public init(_id: String?, connectedTime: Date?, endTime: Date?, userId: String?, externalContactId: String?, externalOrganizationId: String?, name: String?, queueId: String?, groupId: String?, teamId: String?, purpose: String?, consultParticipantId: String?, address: String?, wrapupRequired: Bool?, wrapupExpected: Bool?, wrapupPrompt: String?, wrapupTimeoutMs: Int?, wrapup: QueueConversationVideoEventTopicWrapup?, startAcwTime: Date?, endAcwTime: Date?, conversationRoutingData: QueueConversationVideoEventTopicConversationRoutingData?, alertingTimeoutMs: Int?, monitoredParticipantId: String?, coachedParticipantId: String?, bargedParticipantId: String?, mediaRoles: [String]?, screenRecordingState: ScreenRecordingState?, flaggedReason: String?, attributes: [String:String]?, calls: [QueueConversationVideoEventTopicCall]?, callbacks: [QueueConversationVideoEventTopicCallback]?, chats: [QueueConversationVideoEventTopicChat]?, cobrowsesessions: [QueueConversationVideoEventTopicCobrowse]?, emails: [QueueConversationVideoEventTopicEmail]?, messages: [QueueConversationVideoEventTopicMessage]?, screenshares: [QueueConversationVideoEventTopicScreenshare]?, socialExpressions: [QueueConversationVideoEventTopicSocialExpression]?, videos: [QueueConversationVideoEventTopicVideo]?, workflow: QueueConversationVideoEventTopicWorkflow?) {
        self._id = _id
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.userId = userId
        self.externalContactId = externalContactId
        self.externalOrganizationId = externalOrganizationId
        self.name = name
        self.queueId = queueId
        self.groupId = groupId
        self.teamId = teamId
        self.purpose = purpose
        self.consultParticipantId = consultParticipantId
        self.address = address
        self.wrapupRequired = wrapupRequired
        self.wrapupExpected = wrapupExpected
        self.wrapupPrompt = wrapupPrompt
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapup = wrapup
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.conversationRoutingData = conversationRoutingData
        self.alertingTimeoutMs = alertingTimeoutMs
        self.monitoredParticipantId = monitoredParticipantId
        self.coachedParticipantId = coachedParticipantId
        self.bargedParticipantId = bargedParticipantId
        self.mediaRoles = mediaRoles
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.attributes = attributes
        self.calls = calls
        self.callbacks = callbacks
        self.chats = chats
        self.cobrowsesessions = cobrowsesessions
        self.emails = emails
        self.messages = messages
        self.screenshares = screenshares
        self.socialExpressions = socialExpressions
        self.videos = videos
        self.workflow = workflow
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case connectedTime
        case endTime
        case userId
        case externalContactId
        case externalOrganizationId
        case name
        case queueId
        case groupId
        case teamId
        case purpose
        case consultParticipantId
        case address
        case wrapupRequired
        case wrapupExpected
        case wrapupPrompt
        case wrapupTimeoutMs
        case wrapup
        case startAcwTime
        case endAcwTime
        case conversationRoutingData
        case alertingTimeoutMs
        case monitoredParticipantId
        case coachedParticipantId
        case bargedParticipantId
        case mediaRoles
        case screenRecordingState
        case flaggedReason
        case attributes
        case calls
        case callbacks
        case chats
        case cobrowsesessions
        case emails
        case messages
        case screenshares
        case socialExpressions
        case videos
        case workflow
    }


}



/** Represents the queue setting for this media. */

public class QueueConversationVideoEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}




public class QueueConversationVideoEventTopicRecentTransfer: Codable {



    public enum State: String, Codable { 
        case pending = "pending"
        case active = "active"
        case complete = "complete"
        case canceled = "canceled"
        case failed = "failed"
        case timeout = "timeout"
        case unknown = "unknown"
    }









    public enum TransferType: String, Codable { 
        case attended = "attended"
        case unattended = "unattended"
    }

    /** The id of the command. */
    public var _id: String?
    public var state: State?
    /** The date/time that this command was issued. */
    public var dateIssued: Date?
    public var initiator: QueueConversationVideoEventTopicInitiator?
    public var modifiedBy: QueueConversationVideoEventTopicModifiedBy?
    public var destination: QueueConversationVideoEventTopicDestination?
    /** The type of transfer to perform. */
    public var transferType: TransferType?

    public init(_id: String?, state: State?, dateIssued: Date?, initiator: QueueConversationVideoEventTopicInitiator?, modifiedBy: QueueConversationVideoEventTopicModifiedBy?, destination: QueueConversationVideoEventTopicDestination?, transferType: TransferType?) {
        self._id = _id
        self.state = state
        self.dateIssued = dateIssued
        self.initiator = initiator
        self.modifiedBy = modifiedBy
        self.destination = destination
        self.transferType = transferType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case dateIssued
        case initiator
        case modifiedBy
        case destination
        case transferType
    }


}



/** The voicemail data to be used when this callback is an ACD voicemail. */

public class QueueConversationVideoEventTopicVoicemail: Codable {



    public enum UploadStatus: String, Codable { 
        case pending = "pending"
        case complete = "complete"
        case failed = "failed"
        case timeout = "timeout"
        case _none = "none"
    }

    /** The voicemail id */
    public var _id: String?
    /** current state of the voicemail upload */
    public var uploadStatus: UploadStatus?

    public init(_id: String?, uploadStatus: UploadStatus?) {
        self._id = _id
        self.uploadStatus = uploadStatus
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case uploadStatus
    }


}




public class QueueMediaSettings: Codable {











    /** The queue media settings for call interactions. */
    public var call: MediaSettings?
    /** The queue media settings for callback interactions. */
    public var callback: CallbackMediaSettings?
    /** The queue media settings for chat interactions. */
    public var chat: MediaSettings?
    /** The queue media settings for email interactions. */
    public var email: MediaSettings?
    /** The queue media settings for message interactions. */
    public var message: MediaSettings?

    public init(call: MediaSettings?, callback: CallbackMediaSettings?, chat: MediaSettings?, email: MediaSettings?, message: MediaSettings?) {
        self.call = call
        self.callback = callback
        self.chat = chat
        self.email = email
        self.message = message
    }


}




public class QueueUtilizationDiagnostic: Codable {



















    /** Identifier of the queue */
    public var queue: DomainEntityRef?
    /** The number of users joined to the queue */
    public var usersInQueue: Int?
    /** The number of users active on the queue */
    public var activeUsersInQueue: Int?
    /** The number of users with a status of on-queue */
    public var usersOnQueue: Int?
    /** The number of users in the queue currently not engaged */
    public var usersNotUtilized: Int?
    /** The number of users in the queue with a station */
    public var usersOnQueueWithStation: Int?
    /** The number of users currently engaged in a campaign call */
    public var usersOnACampaignCall: Int?
    /** The number of users whose station is homed to an edge different from the campaign */
    public var usersOnDifferentEdgeGroup: Int?
    /** The number of users currently engaged in a communication that is not part of the campaign */
    public var usersOnANonCampaignCall: Int?

    public init(queue: DomainEntityRef?, usersInQueue: Int?, activeUsersInQueue: Int?, usersOnQueue: Int?, usersNotUtilized: Int?, usersOnQueueWithStation: Int?, usersOnACampaignCall: Int?, usersOnDifferentEdgeGroup: Int?, usersOnANonCampaignCall: Int?) {
        self.queue = queue
        self.usersInQueue = usersInQueue
        self.activeUsersInQueue = activeUsersInQueue
        self.usersOnQueue = usersOnQueue
        self.usersNotUtilized = usersNotUtilized
        self.usersOnQueueWithStation = usersOnQueueWithStation
        self.usersOnACampaignCall = usersOnACampaignCall
        self.usersOnDifferentEdgeGroup = usersOnDifferentEdgeGroup
        self.usersOnANonCampaignCall = usersOnANonCampaignCall
    }


}




public class RateLimitAggregateQueryResponse: Codable {



    public var results: [RateLimitAggregateDataContainer]?

    public init(results: [RateLimitAggregateDataContainer]?) {
        self.results = results
    }


}




public class RateLimitAggregationView: Codable {

    public enum Target: String, Codable { 
        case oratelimitrecorded = "oRateLimitRecorded"
    }



    public enum Function: String, Codable { 
        case rangebound = "rangeBound"
    }



    /** Target metric name */
    public var target: Target?
    /** A unique name for this view. Must be distinct from other views and built-in metric names. */
    public var name: String?
    /** Type of view you wish to create */
    public var function: Function?
    /** Range of numbers for slicing up data */
    public var range: AggregationRange?

    public init(target: Target?, name: String?, function: Function?, range: AggregationRange?) {
        self.target = target
        self.name = name
        self.function = function
        self.range = range
    }


}




public class Reaction: Codable {





    public enum ReactionType: String, Codable { 
        case hangup = "hangup"
        case transfer = "transfer"
        case transferFlow = "transfer_flow"
        case playFile = "play_file"
    }

    /** Parameter for this reaction. For transfer_flow, this would be the outbound flow id. */
    public var data: String?
    /** Name of the parameter for this reaction. For transfer_flow, this would be the outbound flow name. */
    public var name: String?
    /** The reaction to take for a given call analysis result. */
    public var reactionType: ReactionType?

    public init(data: String?, name: String?, reactionType: ReactionType?) {
        self.data = data
        self.name = name
        self.reactionType = reactionType
    }


}




public class Recipient: Codable {















    public enum MessengerType: String, Codable { 
        case sms = "sms"
        case facebook = "facebook"
        case twitter = "twitter"
        case line = "line"
        case whatsapp = "whatsapp"
        case webmessaging = "webmessaging"
        case instagram = "instagram"
        case _open = "open"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** An automate flow object which defines the set of actions to be taken, when a message is received by this recipient. */
    public var flow: Flow?
    /** Date this recipient was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date this recipient was modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** User that created this recipient */
    public var createdBy: User?
    /** User that modified this recipient */
    public var modifiedBy: User?
    /** The messenger type for this recipient */
    public var messengerType: MessengerType?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, flow: Flow?, dateCreated: Date?, dateModified: Date?, createdBy: User?, modifiedBy: User?, messengerType: MessengerType?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.flow = flow
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.messengerType = messengerType
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case flow
        case dateCreated
        case dateModified
        case createdBy
        case modifiedBy
        case messengerType
        case selfUri
    }


}




public class RecipientListing: Codable {





















    public var entities: [Recipient]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Recipient]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class RecipientRequest: Codable {



    /** An automate flow object which defines the set of actions to be taken, when a message is received by this recipient. */
    public var flow: RecipientFlow?

    public init(flow: RecipientFlow?) {
        self.flow = flow
    }


}




public class RecordingArchiveRestoreTopicMediaResult: Codable {









    public var channelId: String?
    public var waveUri: String?
    public var mediaUri: String?
    public var waveformData: [Double]?

    public init(channelId: String?, waveUri: String?, mediaUri: String?, waveformData: [Double]?) {
        self.channelId = channelId
        self.waveUri = waveUri
        self.mediaUri = mediaUri
        self.waveformData = waveformData
    }


}



/** Story object. */

public class RecordingContentStory: Codable {

    public enum ModelType: String, Codable { 
        case mention = "Mention"
        case reply = "Reply"
    }





    /** Type of ephemeral story attachment. */
    public var type: ModelType?
    /** URL to the ephemeral story. */
    public var url: String?
    /** ID of the ephemeral story being replied to. */
    public var replyToId: String?

    public init(type: ModelType?, url: String?, replyToId: String?) {
        self.type = type
        self.url = url
        self.replyToId = replyToId
    }


}




public class RecordingMetadata: Codable {

















    public enum FileState: String, Codable { 
        case archived = "ARCHIVED"
        case available = "AVAILABLE"
        case deleted = "DELETED"
        case restored = "RESTORED"
        case restoring = "RESTORING"
        case uploading = "UPLOADING"
        case error = "ERROR"
    }





    public enum ArchiveMedium: String, Codable { 
        case cloudarchive = "CLOUDARCHIVE"
    }















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var conversationId: String?
    public var path: String?
    /** The start time of the recording for screen recordings. Null for other types. */
    public var startTime: String?
    public var endTime: String?
    /** The type of media that the recording is. At the moment that could be audio, chat, email, or message. */
    public var media: String?
    /** Annotations that belong to the recording. Populated when recording filestate is AVAILABLE. */
    public var annotations: [Annotation]?
    /** Represents the current file state for a recording. Examples: Uploading, Archived, etc */
    public var fileState: FileState?
    /** The amount of time a restored recording will remain restored before being archived again. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var restoreExpirationTime: Date?
    /** The date the recording will be archived. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var archiveDate: Date?
    /** The type of archive medium used. Example: CloudArchive */
    public var archiveMedium: ArchiveMedium?
    /** The date the recording will be deleted. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var deleteDate: Date?
    /** The date the recording will be exported. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var exportDate: Date?
    /** The date the recording was exported. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var exportedDate: Date?
    /** How many archive restorations the organization is allowed to have. */
    public var maxAllowedRestorationsForOrg: Int?
    /** The remaining archive restorations the organization has. */
    public var remainingRestorationsAllowedForOrg: Int?
    /** The session id represents an external resource id, such as email, call, chat, etc */
    public var sessionId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, conversationId: String?, path: String?, startTime: String?, endTime: String?, media: String?, annotations: [Annotation]?, fileState: FileState?, restoreExpirationTime: Date?, archiveDate: Date?, archiveMedium: ArchiveMedium?, deleteDate: Date?, exportDate: Date?, exportedDate: Date?, maxAllowedRestorationsForOrg: Int?, remainingRestorationsAllowedForOrg: Int?, sessionId: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.conversationId = conversationId
        self.path = path
        self.startTime = startTime
        self.endTime = endTime
        self.media = media
        self.annotations = annotations
        self.fileState = fileState
        self.restoreExpirationTime = restoreExpirationTime
        self.archiveDate = archiveDate
        self.archiveMedium = archiveMedium
        self.deleteDate = deleteDate
        self.exportDate = exportDate
        self.exportedDate = exportedDate
        self.maxAllowedRestorationsForOrg = maxAllowedRestorationsForOrg
        self.remainingRestorationsAllowedForOrg = remainingRestorationsAllowedForOrg
        self.sessionId = sessionId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case conversationId
        case path
        case startTime
        case endTime
        case media
        case annotations
        case fileState
        case restoreExpirationTime
        case archiveDate
        case archiveMedium
        case deleteDate
        case exportDate
        case exportedDate
        case maxAllowedRestorationsForOrg
        case remainingRestorationsAllowedForOrg
        case sessionId
        case selfUri
    }


}




public class RecordingTranscodeCompleteTopicMediaResult: Codable {









    public var channelId: String?
    public var waveUri: String?
    public var mediaUri: String?
    public var waveformData: [Double]?

    public init(channelId: String?, waveUri: String?, mediaUri: String?, waveformData: [Double]?) {
        self.channelId = channelId
        self.waveUri = waveUri
        self.mediaUri = mediaUri
        self.waveformData = waveformData
    }


}




public class RegisterArchitectJobResponse: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Presigned URL to upload the file in S3 */
    public var presignedUrl: String?
    /** Required headers when uploading a file through PUT request to the URL */
    public var headers: [String:String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, presignedUrl: String?, headers: [String:String]?, selfUri: String?) {
        self._id = _id
        self.presignedUrl = presignedUrl
        self.headers = headers
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case presignedUrl
        case headers
        case selfUri
    }


}




public class Relationship: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The user associated with the external organization. When creating or updating a relationship, only User.id is required. User object is fully populated when expanding a note. */
    public var user: User?
    /** The external organization this relationship is attached to */
    public var externalOrganization: ExternalOrganization?
    /** The relationship or role of the user to this external organization.Examples: Account Manager, Sales Engineer, Implementation Consultant */
    public var relationship: String?
    /** Links to the sources of data (e.g. one source might be a CRM) that contributed data to this record.  Read-only, and only populated when requested via expand param. */
    public var externalDataSources: [ExternalDataSource]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, user: User?, externalOrganization: ExternalOrganization?, relationship: String?, externalDataSources: [ExternalDataSource]?, selfUri: String?) {
        self._id = _id
        self.user = user
        self.externalOrganization = externalOrganization
        self.relationship = relationship
        self.externalDataSources = externalDataSources
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case user
        case externalOrganization
        case relationship
        case externalDataSources
        case selfUri
    }


}




public class RelationshipListing: Codable {























    public var entities: [Relationship]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var partialResults: Bool?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Relationship]?, pageSize: Int?, pageNumber: Int?, total: Int64?, partialResults: Bool?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.partialResults = partialResults
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ReportScheduleEntityListing: Codable {





















    public var entities: [ReportSchedule]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ReportSchedule]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ReportingExportJobResponse: Codable {







    public enum Status: String, Codable { 
        case submitted = "SUBMITTED"
        case running = "RUNNING"
        case cancelling = "CANCELLING"
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case completedWithPartialResults = "COMPLETED_WITH_PARTIAL_RESULTS"
        case failed = "FAILED"
    }



    public enum ExportFormat: String, Codable { 
        case csv = "CSV"
        case pdf = "PDF"
    }





    public enum ViewType: String, Codable { 
        case queuePerformanceSummaryView = "QUEUE_PERFORMANCE_SUMMARY_VIEW"
        case queuePerformanceDetailView = "QUEUE_PERFORMANCE_DETAIL_VIEW"
        case interactionSearchView = "INTERACTION_SEARCH_VIEW"
        case agentPerformanceSummaryView = "AGENT_PERFORMANCE_SUMMARY_VIEW"
        case agentPerformanceDetailView = "AGENT_PERFORMANCE_DETAIL_VIEW"
        case agentStatusSummaryView = "AGENT_STATUS_SUMMARY_VIEW"
        case agentStatusDetailView = "AGENT_STATUS_DETAIL_VIEW"
        case agentEvaluationSummaryView = "AGENT_EVALUATION_SUMMARY_VIEW"
        case agentEvaluationDetailView = "AGENT_EVALUATION_DETAIL_VIEW"
        case agentQueueDetailView = "AGENT_QUEUE_DETAIL_VIEW"
        case agentInteractionDetailView = "AGENT_INTERACTION_DETAIL_VIEW"
        case abandonInsightsView = "ABANDON_INSIGHTS_VIEW"
        case skillsPerformanceView = "SKILLS_PERFORMANCE_VIEW"
        case surveyFormPerformanceSummaryView = "SURVEY_FORM_PERFORMANCE_SUMMARY_VIEW"
        case surveyFormPerformanceDetailView = "SURVEY_FORM_PERFORMANCE_DETAIL_VIEW"
        case dnisPerformanceSummaryView = "DNIS_PERFORMANCE_SUMMARY_VIEW"
        case dnisPerformanceDetailView = "DNIS_PERFORMANCE_DETAIL_VIEW"
        case wrapUpPerformanceSummaryView = "WRAP_UP_PERFORMANCE_SUMMARY_VIEW"
        case agentWrapUpPerformanceDetailView = "AGENT_WRAP_UP_PERFORMANCE_DETAIL_VIEW"
        case queueActivitySummaryView = "QUEUE_ACTIVITY_SUMMARY_VIEW"
        case queueActivityDetailView = "QUEUE_ACTIVITY_DETAIL_VIEW"
        case agentQueueActivitySummaryView = "AGENT_QUEUE_ACTIVITY_SUMMARY_VIEW"
        case queueAgentDetailView = "QUEUE_AGENT_DETAIL_VIEW"
        case queueInteractionDetailView = "QUEUE_INTERACTION_DETAIL_VIEW"
        case agentScheduleDetailView = "AGENT_SCHEDULE_DETAIL_VIEW"
        case ivrPerformanceSummaryView = "IVR_PERFORMANCE_SUMMARY_VIEW"
        case ivrPerformanceDetailView = "IVR_PERFORMANCE_DETAIL_VIEW"
        case answerInsightsView = "ANSWER_INSIGHTS_VIEW"
        case handleInsightsView = "HANDLE_INSIGHTS_VIEW"
        case talkInsightsView = "TALK_INSIGHTS_VIEW"
        case holdInsightsView = "HOLD_INSIGHTS_VIEW"
        case acwInsightsView = "ACW_INSIGHTS_VIEW"
        case waitInsightsView = "WAIT_INSIGHTS_VIEW"
        case agentWrapUpPerformanceIntervalDetailView = "AGENT_WRAP_UP_PERFORMANCE_INTERVAL_DETAIL_VIEW"
        case flowOutcomeSummaryView = "FLOW_OUTCOME_SUMMARY_VIEW"
        case flowOutcomePerformanceDetailView = "FLOW_OUTCOME_PERFORMANCE_DETAIL_VIEW"
        case flowOutcomePerformanceIntervalDetailView = "FLOW_OUTCOME_PERFORMANCE_INTERVAL_DETAIL_VIEW"
        case flowDestinationSummaryView = "FLOW_DESTINATION_SUMMARY_VIEW"
        case flowDestinationDetailView = "FLOW_DESTINATION_DETAIL_VIEW"
        case apiUsageView = "API_USAGE_VIEW"
        case scheduledCallbacksView = "SCHEDULED_CALLBACKS_VIEW"
        case contentSearchView = "CONTENT_SEARCH_VIEW"
        case landingPage = "LANDING_PAGE"
        case dashboardSummary = "DASHBOARD_SUMMARY"
        case dashboardDetail = "DASHBOARD_DETAIL"
        case dashboardUsers = "DASHBOARD_USERS"
        case dashboardUsersDetail = "DASHBOARD_USERS_DETAIL"
        case journeyActionMapSummaryView = "JOURNEY_ACTION_MAP_SUMMARY_VIEW"
        case journeyOutcomeSummaryView = "JOURNEY_OUTCOME_SUMMARY_VIEW"
        case journeySegmentSummaryView = "JOURNEY_SEGMENT_SUMMARY_VIEW"
        case agentDevelopmentDetailView = "AGENT_DEVELOPMENT_DETAIL_VIEW"
        case agentDevelopmentDetailMeView = "AGENT_DEVELOPMENT_DETAIL_ME_VIEW"
        case agentDevelopmentSummaryView = "AGENT_DEVELOPMENT_SUMMARY_VIEW"
        case agentPerformanceMeView = "AGENT_PERFORMANCE_ME_VIEW"
        case agentStatusMeView = "AGENT_STATUS_ME_VIEW"
        case agentEvaluationMeView = "AGENT_EVALUATION_ME_VIEW"
        case agentScorecardView = "AGENT_SCORECARD_VIEW"
        case agentScorecardMeView = "AGENT_SCORECARD_ME_VIEW"
        case agentGamificationLeadershipView = "AGENT_GAMIFICATION_LEADERSHIP_VIEW"
        case agentScheduleMeView = "AGENT_SCHEDULE_ME_VIEW"
        case botPerformanceSummaryView = "BOT_PERFORMANCE_SUMMARY_VIEW"
        case botPerformanceDetailView = "BOT_PERFORMANCE_DETAIL_VIEW"
        case scheduledExportsView = "SCHEDULED_EXPORTS_VIEW"
        case topicTrendSummaryView = "TOPIC_TREND_SUMMARY_VIEW"
        case topicTrendDetailView = "TOPIC_TREND_DETAIL_VIEW"
        case actionMapBlockedConstraintsDetailView = "ACTION_MAP_BLOCKED_CONSTRAINTS_DETAIL_VIEW"
        case actionMapBlockedConstraintsIntervalDetailView = "ACTION_MAP_BLOCKED_CONSTRAINTS_INTERVAL_DETAIL_VIEW"
        case flowMilestonePerformanceDetailView = "FLOW_MILESTONE_PERFORMANCE_DETAIL_VIEW"
        case flowMilestonePerformanceIntervalDetailView = "FLOW_MILESTONE_PERFORMANCE_INTERVAL_DETAIL_VIEW"
        case agentTopicSummaryView = "AGENT_TOPIC_SUMMARY_VIEW"
        case agentTopicDetailView = "AGENT_TOPIC_DETAIL_VIEW"
        case queueTopicSummaryView = "QUEUE_TOPIC_SUMMARY_VIEW"
        case queueTopicDetailView = "QUEUE_TOPIC_DETAIL_VIEW"
        case flowTopicSummaryView = "FLOW_TOPIC_SUMMARY_VIEW"
        case flowTopicDetailView = "FLOW_TOPIC_DETAIL_VIEW"
        case agentInteractionsMeView = "AGENT_INTERACTIONS_ME_VIEW"
        case alertRulesView = "ALERT_RULES_VIEW"
        case configureAlertRuleView = "CONFIGURE_ALERT_RULE_VIEW"
        case predictiveRoutingView = "PREDICTIVE_ROUTING_VIEW"
        case predictiveRoutingQueueOverview = "PREDICTIVE_ROUTING_QUEUE_OVERVIEW"
        case predictiveRoutingModelView = "PREDICTIVE_ROUTING_MODEL_VIEW"
        case predictiveRoutingImpactView = "PREDICTIVE_ROUTING_IMPACT_VIEW"
        case dataActionsPerformanceSummaryView = "DATA_ACTIONS_PERFORMANCE_SUMMARY_VIEW"
        case dataActionsPerformanceDetailView = "DATA_ACTIONS_PERFORMANCE_DETAIL_VIEW"
        case agentTimelineSummaryView = "AGENT_TIMELINE_SUMMARY_VIEW"
        case agentTimelineDetailView = "AGENT_TIMELINE_DETAIL_VIEW"
        case agentLoginLogoutSummaryView = "AGENT_LOGIN_LOGOUT_SUMMARY_VIEW"
        case agentLoginLogoutDetailView = "AGENT_LOGIN_LOGOUT_DETAIL_VIEW"
        case campaignPerformanceSummaryView = "CAMPAIGN_PERFORMANCE_SUMMARY_VIEW"
        case campaignPerformanceDetailView = "CAMPAIGN_PERFORMANCE_DETAIL_VIEW"
        case knowledgePerformanceView = "KNOWLEDGE_PERFORMANCE_VIEW"
        case agentScorecardInsightsSummaryView = "AGENT_SCORECARD_INSIGHTS_SUMMARY_VIEW"
        case agentScorecardInsightsDetailView = "AGENT_SCORECARD_INSIGHTS_DETAIL_VIEW"
        case queueWrapupDetailView = "QUEUE_WRAPUP_DETAIL_VIEW"
        case interactionDetailView = "INTERACTION_DETAIL_VIEW"
        case campaignInteractionDetailView = "CAMPAIGN_INTERACTION_DETAIL_VIEW"
        case campaignAttemptDetailView = "CAMPAIGN_ATTEMPT_DETAIL_VIEW"
        case workitemPerformanceSummaryView = "WORKITEM_PERFORMANCE_SUMMARY_VIEW"
        case agentAssistPerformanceView = "AGENT_ASSIST_PERFORMANCE_VIEW"
        case contactCenterPerformanceView = "CONTACT_CENTER_PERFORMANCE_VIEW"
        case queueRoutingPerformanceView = "QUEUE_ROUTING_PERFORMANCE_VIEW"
        case agentWorkitemPerformanceSummaryView = "AGENT_WORKITEM_PERFORMANCE_SUMMARY_VIEW"
        case agentWorkitemPerformanceDetailView = "AGENT_WORKITEM_PERFORMANCE_DETAIL_VIEW"
        case queueWorkitemPerformanceSummaryView = "QUEUE_WORKITEM_PERFORMANCE_SUMMARY_VIEW"
        case queueWorkitemPerformanceDetailView = "QUEUE_WORKITEM_PERFORMANCE_DETAIL_VIEW"
    }

    public enum ExportErrorMessagesType: String, Codable { 
        case failedConvertingExportJob = "FAILED_CONVERTING_EXPORT_JOB"
        case failedNoDataExportJobFound = "FAILED_NO_DATA_EXPORT_JOB_FOUND"
        case failedGettingDataFromService = "FAILED_GETTING_DATA_FROM_SERVICE"
        case failedGeneratingTempFile = "FAILED_GENERATING_TEMP_FILE"
        case failedSavingFileToS3 = "FAILED_SAVING_FILE_TO_S3"
        case failedNotifyingSkywalkerOfDownload = "FAILED_NOTIFYING_SKYWALKER_OF_DOWNLOAD"
        case failedBuildingDownloadUrlFromSkywalkerResponse = "FAILED_BUILDING_DOWNLOAD_URL_FROM_SKYWALKER_RESPONSE"
        case failedConvertingExportJobToQueuePerformanceJob = "FAILED_CONVERTING_EXPORT_JOB_TO_QUEUE_PERFORMANCE_JOB"
        case exportTypeNotImplemented = "EXPORT_TYPE_NOT_IMPLEMENTED"
        case reachedMaximumAttemptOfRetry = "REACHED_MAXIMUM_ATTEMPT_OF_RETRY"
        case failedLongRunningExport = "FAILED_LONG_RUNNING_EXPORT"
        case tooManyRequestsFromAnOrganization = "TOO_MANY_REQUESTS_FROM_AN_ORGANIZATION"
        case failedAsExportFileSizeIsGreaterThan10mb = "FAILED_AS_EXPORT_FILE_SIZE_IS_GREATER_THAN_10MB"
        case notAuthorizedToViewExport = "NOT_AUTHORIZED_TO_VIEW_EXPORT"
        case staticLinkExportFailed = "STATIC_LINK_EXPORT_FAILED"
        case tooManySearchCriteria = "TOO_MANY_SEARCH_CRITERIA"
        case searchCriteriaValuesExceedLimit = "SEARCH_CRITERIA_VALUES_EXCEED_LIMIT"
        case exportEmailFileSizeExceededLimit = "EXPORT_EMAIL_FILE_SIZE_EXCEEDED_LIMIT"
        case circuitBreakerOpenForViewType = "CIRCUIT_BREAKER_OPEN_FOR_VIEW_TYPE"
    }

























    public enum CsvDelimiter: String, Codable { 
        case semicolon = "SEMICOLON"
        case comma = "COMMA"
    }













    public enum DurationFormat: String, Codable { 
        case seconds = "Seconds"
        case milliseconds = "Milliseconds"
        case hhmmss = "Hhmmss"
        case hms = "Hms"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The unique run id of the export schedule execute */
    public var runId: String?
    /** The current status of the export request */
    public var status: Status?
    /** The requested timezone of the exported data. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var timeZone: String?
    /** The requested format of the exported data */
    public var exportFormat: ExportFormat?
    /** The time period used to limit the the exported data. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** The url to download the request if it's status is completed */
    public var downloadUrl: String?
    /** The type of view export job to be created */
    public var viewType: ViewType?
    /** The error message in case the export request failed */
    public var exportErrorMessagesType: ExportErrorMessagesType?
    /** The Period of the request in which to break down the intervals. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H */
    public var period: String?
    /** Filters to apply to create the view */
    public var filter: ViewFilter?
    /** Indicates if the request has been marked as read */
    public var read: Bool?
    /** The created date/time of the request. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDateTime: Date?
    /** The last modified date/time of the request. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDateTime: Date?
    /** The locale use for localization of the exported data, i.e. en-us, es-mx   */
    public var locale: String?
    /** The percentage of the job that has completed processing */
    public var percentageComplete: Double?
    /** Indicates if durations are formatted in hh:mm:ss format instead of ms */
    public var hasFormatDurations: Bool?
    /** Indicates if filters will be split in aggregate detail exports */
    public var hasSplitFilters: Bool?
    /** Excludes empty rows from the exports */
    public var excludeEmptyRows: Bool?
    /** Indicates if media type will be split in aggregate detail exports */
    public var hasSplitByMedia: Bool?
    /** Indicates if summary row needs to be present in exports */
    public var hasSummaryRow: Bool?
    /** The user supplied csv delimiter string value either of type 'comma' or 'semicolon' permitted for the export request */
    public var csvDelimiter: CsvDelimiter?
    /** The list of ordered selected columns from the export view by the user */
    public var selectedColumns: [SelectedColumns]?
    /** Indicates if custom participant attributes will be exported */
    public var hasCustomParticipantAttributes: Bool?
    /** The list of email recipients for the exports */
    public var recipientEmails: [String]?
    /** The status of individual email addresses as a map */
    public var emailStatuses: [String:String]?
    /** The optional error message in case the export fail to email */
    public var emailErrorDescription: String?
    /** Indicates whether to include selected duration format to the column headers */
    public var includeDurationFormatInHeader: Bool?
    /** Indicates the duration format for the exports */
    public var durationFormat: DurationFormat?
    /** Indicates whether the export run is allowed to rerun */
    public var exportAllowedToRerun: Bool?
    public var enabled: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, runId: String?, status: Status?, timeZone: String?, exportFormat: ExportFormat?, interval: String?, downloadUrl: String?, viewType: ViewType?, exportErrorMessagesType: ExportErrorMessagesType?, period: String?, filter: ViewFilter?, read: Bool?, createdDateTime: Date?, modifiedDateTime: Date?, locale: String?, percentageComplete: Double?, hasFormatDurations: Bool?, hasSplitFilters: Bool?, excludeEmptyRows: Bool?, hasSplitByMedia: Bool?, hasSummaryRow: Bool?, csvDelimiter: CsvDelimiter?, selectedColumns: [SelectedColumns]?, hasCustomParticipantAttributes: Bool?, recipientEmails: [String]?, emailStatuses: [String:String]?, emailErrorDescription: String?, includeDurationFormatInHeader: Bool?, durationFormat: DurationFormat?, exportAllowedToRerun: Bool?, enabled: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.runId = runId
        self.status = status
        self.timeZone = timeZone
        self.exportFormat = exportFormat
        self.interval = interval
        self.downloadUrl = downloadUrl
        self.viewType = viewType
        self.exportErrorMessagesType = exportErrorMessagesType
        self.period = period
        self.filter = filter
        self.read = read
        self.createdDateTime = createdDateTime
        self.modifiedDateTime = modifiedDateTime
        self.locale = locale
        self.percentageComplete = percentageComplete
        self.hasFormatDurations = hasFormatDurations
        self.hasSplitFilters = hasSplitFilters
        self.excludeEmptyRows = excludeEmptyRows
        self.hasSplitByMedia = hasSplitByMedia
        self.hasSummaryRow = hasSummaryRow
        self.csvDelimiter = csvDelimiter
        self.selectedColumns = selectedColumns
        self.hasCustomParticipantAttributes = hasCustomParticipantAttributes
        self.recipientEmails = recipientEmails
        self.emailStatuses = emailStatuses
        self.emailErrorDescription = emailErrorDescription
        self.includeDurationFormatInHeader = includeDurationFormatInHeader
        self.durationFormat = durationFormat
        self.exportAllowedToRerun = exportAllowedToRerun
        self.enabled = enabled
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case runId
        case status
        case timeZone
        case exportFormat
        case interval
        case downloadUrl
        case viewType
        case exportErrorMessagesType
        case period
        case filter
        case read
        case createdDateTime
        case modifiedDateTime
        case locale
        case percentageComplete
        case hasFormatDurations
        case hasSplitFilters
        case excludeEmptyRows
        case hasSplitByMedia
        case hasSummaryRow
        case csvDelimiter
        case selectedColumns
        case hasCustomParticipantAttributes
        case recipientEmails
        case emailStatuses
        case emailErrorDescription
        case includeDurationFormatInHeader
        case durationFormat
        case exportAllowedToRerun
        case enabled
        case selfUri
    }


}




public class ReportingInterval: Codable {

    public enum IntervalType: String, Codable { 
        case day = "Day"
        case week = "Week"
        case month = "Month"
    }



    /** The granularity of the reporting interval period */
    public var intervalType: IntervalType?
    /** The value of the reporting interval period for a given interval type */
    public var intervalValue: Int?

    public init(intervalType: IntervalType?, intervalValue: Int?) {
        self.intervalType = intervalType
        self.intervalValue = intervalValue
    }


}




public class ReportingTurnsResponse: Codable {









    public var entities: [ReportingTurn]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [ReportingTurn]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class RequestContext: Codable {



    /** A list of one or more patterns to match. */
    public var patterns: [RequestContextPattern]?

    public init(patterns: [RequestContextPattern]?) {
        self.patterns = patterns
    }


}




public class RequestMapping: Codable {



    public enum AttributeType: String, Codable { 
        case string = "String"
        case number = "Number"
        case integer = "Integer"
        case boolean = "Boolean"
    }

    public enum MappingType: String, Codable { 
        case lookup = "Lookup"
        case hardCoded = "HardCoded"
    }



    /** Name of the Integration Action Attribute to supply the value for */
    public var name: String?
    /** Type of the value supplied */
    public var attributeType: AttributeType?
    /** Method of finding value to use with Attribute */
    public var mappingType: MappingType?
    /** Value to supply for the specified Attribute */
    public var value: String?

    public init(name: String?, attributeType: AttributeType?, mappingType: MappingType?, value: String?) {
        self.name = name
        self.attributeType = attributeType
        self.mappingType = mappingType
        self.value = value
    }


}




public class ResponseAssetSearchResults: Codable {











    /** The total number of results found */
    public var total: Int64?
    /** The total number of pages */
    public var pageCount: Int?
    /** The current page size */
    public var pageSize: Int?
    /** The current page number */
    public var pageNumber: Int?
    /** Search results */
    public var results: [ResponseAsset]?

    public init(total: Int64?, pageCount: Int?, pageSize: Int?, pageNumber: Int?, results: [ResponseAsset]?) {
        self.total = total
        self.pageCount = pageCount
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.results = results
    }


}



/** Query result list */

public class ResponseEntityList: Codable {





















    public var entities: [ModelResponse]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ModelResponse]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** Used to filter response queries */

public class ResponseFilter: Codable {



    public enum Operator: String, Codable { 
        case _in = "IN"
        case equals = "EQUALS"
        case notequals = "NOTEQUALS"
    }



    /** Field to filter on. Allowed values are 'name', 'libraryId', 'text.contentType', 'messagingTemplate' and 'responseType' */
    public var name: String?
    /** Filter operation: IN, EQUALS, NOTEQUALS. */
    public var _operator: Operator?
    /** Values to filter on. If name is 'responseType' then allowed values are 'CampaignSmsTemplate', 'CampaignEmailTemplate', 'Footer' and 'Signature' */
    public var values: [String]?

    public init(name: String?, _operator: Operator?, values: [String]?) {
        self.name = name
        self._operator = _operator
        self.values = values
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _operator = "operator"
        case values
    }


}



/** Used to query for responses */

public class ResponseQueryRequest: Codable {







    /** Query phrase to search response text and name. If not set will match all. */
    public var queryPhrase: String?
    /** The maximum number of hits to return. Default: 25, Maximum: 500. */
    public var pageSize: Int?
    /** Filter the query results. */
    public var filters: [ResponseFilter]?

    public init(queryPhrase: String?, pageSize: Int?, filters: [ResponseFilter]?) {
        self.queryPhrase = queryPhrase
        self.pageSize = pageSize
        self.filters = filters
    }


}



/** Contains information about the substitutions associated with a response. */

public class ResponseSubstitution: Codable {







    /** Response substitution identifier. */
    public var _id: String?
    /** Response substitution description. */
    public var _description: String?
    /** Response substitution default value. */
    public var defaultValue: String?

    public init(_id: String?, _description: String?, defaultValue: String?) {
        self._id = _id
        self._description = _description
        self.defaultValue = defaultValue
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case _description = "description"
        case defaultValue
    }


}




public class RestErrorDetail: Codable {





    /** name of the error */
    public var error: String?
    /** additional information regarding the error */
    public var details: String?

    public init(error: String?, details: String?) {
        self.error = error
        self.details = details
    }


}




public class ReverseWhitepagesLookupResult: Codable {





    public var contacts: [ExternalContact]?
    public var externalOrganizations: [ExternalOrganization]?

    public init(contacts: [ExternalContact]?, externalOrganizations: [ExternalOrganization]?) {
        self.contacts = contacts
        self.externalOrganizations = externalOrganizations
    }


}




public class RoutePathResponse: Codable {



    public enum MediaType: String, Codable { 
        case voice = "Voice"
        case chat = "Chat"
        case email = "Email"
        case callback = "Callback"
        case message = "Message"
    }





    /** The ID of the queue associated with the route path */
    public var queue: QueueReference?
    /** The media type of the given queue associated with the route path */
    public var mediaType: MediaType?
    /** The ID of the language associated with the route path */
    public var language: LanguageReference?
    /** The set of skills associated with the route path */
    public var skills: [RoutingSkillReference]?

    public init(queue: QueueReference?, mediaType: MediaType?, language: LanguageReference?, skills: [RoutingSkillReference]?) {
        self.queue = queue
        self.mediaType = mediaType
        self.language = language
        self.skills = skills
    }


}




public class RoutingEstablishedEvent: Codable {

























    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication */
    public var communicationId: String?
    /** Identifies the phone number used to reach this queue if it is different from the information that would be accessed by queueId. */
    public var phoneNumber: String?
    /** The id (V4 UUID) of the queue that is routing this conversation. */
    public var queueId: String?
    /** The automatic number identification if it is available for this conversation. */
    public var ani: String?
    /** The dialed number identification if it is available for this conversation. */
    public var dnis: String?
    /** The unique identifiers (V4 UUID) for the skills that should be used to determine the destination for the conversation. */
    public var skillIds: [String]?
    /** The unique identifier (V4 UUID) for the language that should be used to determine the destination for the conversation. */
    public var languageId: String?
    /** Metadata about this communication. */
    public var initialConfiguration: InitialConfiguration?
    /** Metadata about the source of this communication's interaction. */
    public var sourceConfiguration: SourceConfiguration?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, phoneNumber: String?, queueId: String?, ani: String?, dnis: String?, skillIds: [String]?, languageId: String?, initialConfiguration: InitialConfiguration?, sourceConfiguration: SourceConfiguration?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.phoneNumber = phoneNumber
        self.queueId = queueId
        self.ani = ani
        self.dnis = dnis
        self.skillIds = skillIds
        self.languageId = languageId
        self.initialConfiguration = initialConfiguration
        self.sourceConfiguration = sourceConfiguration
    }


}




public class RoutingSkillReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class RoutingStatusDetailQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [RoutingStatusDetailQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [RoutingStatusDetailQueryPredicate]?

    public init(type: ModelType?, clauses: [RoutingStatusDetailQueryClause]?, predicates: [RoutingStatusDetailQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class SIPSearchPublicRequest: Codable {





















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** unique identification of the placed call */
    public var callId: String?
    /** SIP user to who the call was placed */
    public var toUser: String?
    /** SIP user who placed the call */
    public var fromUser: String?
    /** Unique identification of the conversation */
    public var conversationId: String?
    /** Unique identification of the participant */
    public var participantId: String?
    /** Start date of the search. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?
    /** End date of the search. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateEnd: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, callId: String?, toUser: String?, fromUser: String?, conversationId: String?, participantId: String?, dateStart: Date?, dateEnd: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.callId = callId
        self.toUser = toUser
        self.fromUser = fromUser
        self.conversationId = conversationId
        self.participantId = participantId
        self.dateStart = dateStart
        self.dateEnd = dateEnd
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case callId
        case toUser
        case fromUser
        case conversationId
        case participantId
        case dateStart
        case dateEnd
        case selfUri
    }


}




public class Salesforce: Codable {























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var disabled: Bool?
    public var issuerURI: String?
    public var ssoTargetURI: String?
    public var sloURI: String?
    public var sloBinding: String?
    public var relyingPartyIdentifier: String?
    public var certificate: String?
    public var certificates: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, disabled: Bool?, issuerURI: String?, ssoTargetURI: String?, sloURI: String?, sloBinding: String?, relyingPartyIdentifier: String?, certificate: String?, certificates: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.disabled = disabled
        self.issuerURI = issuerURI
        self.ssoTargetURI = ssoTargetURI
        self.sloURI = sloURI
        self.sloBinding = sloBinding
        self.relyingPartyIdentifier = relyingPartyIdentifier
        self.certificate = certificate
        self.certificates = certificates
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case disabled
        case issuerURI
        case ssoTargetURI
        case sloURI
        case sloBinding
        case relyingPartyIdentifier
        case certificate
        case certificates
        case selfUri
    }


}



/** A schedule group. */

public class ScheduleGroupDivisionView: Codable {









    /** The schedule group identifier */
    public var _id: String?
    /** The schedule group name */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case selfUri
    }


}




public class ScheduleUploadProcessingResponse: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }





    /** The status of the operation */
    public var status: Status?
    /** The ID for the operation */
    public var operationId: String?
    /** The result of the operation.  Null unless status == Complete */
    public var result: BuScheduleMetadata?

    public init(status: Status?, operationId: String?, result: BuScheduleMetadata?) {
        self.status = status
        self.operationId = operationId
        self.result = result
    }


}




public class SchedulerMessageArgument: Codable {

    public enum ModelType: String, Codable { 
        case agentId = "AgentId"
        case date = "Date"
    }



    /** The type of this message parameter */
    public var type: ModelType?
    /** The value of this message parameter */
    public var value: String?

    public init(type: ModelType?, value: String?) {
        self.type = type
        self.value = value
    }


}




public class SchedulerMessageSeverityCount: Codable {

    public enum Severity: String, Codable { 
        case ignore = "Ignore"
        case information = "Information"
        case warning = "Warning"
        case error = "Error"
    }



    /** The schedule message severity */
    public var severity: Severity?
    /** The number of schedule messages with the given severity */
    public var count: Int?

    public init(severity: Severity?, count: Int?) {
        self.severity = severity
        self.count = count
    }


}



/** A schedule. */

public class SchedulesDivisionView: Codable {









    /** The schedule identifier */
    public var _id: String?
    /** The schedule name */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case selfUri
    }


}




public class SchedulingSettingsResponse: Codable {









    public enum StartDayOfWeekend: String, Codable { 
        case sunday = "Sunday"
        case monday = "Monday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
        case thursday = "Thursday"
        case friday = "Friday"
        case saturday = "Saturday"
    }

    /** Max occupancy percent for deferred work */
    public var maxOccupancyPercentForDeferredWork: Int?
    /** Default shrinkage percent for scheduling */
    public var defaultShrinkagePercent: Double?
    /** Shrinkage overrides for scheduling */
    public var shrinkageOverrides: ShrinkageOverrides?
    /** Planning period settings for scheduling */
    public var planningPeriod: PlanningPeriodSettings?
    /** Start day of weekend for scheduling */
    public var startDayOfWeekend: StartDayOfWeekend?

    public init(maxOccupancyPercentForDeferredWork: Int?, defaultShrinkagePercent: Double?, shrinkageOverrides: ShrinkageOverrides?, planningPeriod: PlanningPeriodSettings?, startDayOfWeekend: StartDayOfWeekend?) {
        self.maxOccupancyPercentForDeferredWork = maxOccupancyPercentForDeferredWork
        self.defaultShrinkagePercent = defaultShrinkagePercent
        self.shrinkageOverrides = shrinkageOverrides
        self.planningPeriod = planningPeriod
        self.startDayOfWeekend = startDayOfWeekend
    }


}




public class SchedulingStatusResponse: Codable {



    public enum Status: String, Codable { 
        case pending = "Pending"
        case success = "Success"
        case failed = "Failed"
        case ongoing = "Ongoing"
        case partialFailure = "PartialFailure"
    }







    /** The ID generated for the scheduling job.  Use to GET result when job is completed. */
    public var _id: String?
    /** The status of the scheduling job. */
    public var status: Status?
    /** If the request could not be properly processed, error details will be given here. */
    public var errorDetails: [SchedulingProcessingError]?
    /** The uri of the scheduling result. It has a value if the status is 'Success'. */
    public var schedulingResultUri: String?
    /** The percentage of the job that is complete. */
    public var percentComplete: Int?

    public init(_id: String?, status: Status?, errorDetails: [SchedulingProcessingError]?, schedulingResultUri: String?, percentComplete: Int?) {
        self._id = _id
        self.status = status
        self.errorDetails = errorDetails
        self.schedulingResultUri = schedulingResultUri
        self.percentComplete = percentComplete
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case status
        case errorDetails
        case schedulingResultUri
        case percentComplete
    }


}



/** Defines a response for a list of SCIM resource types. */

public class ScimConfigResourceTypesListResponse: Codable {











    /** The list of supported schemas. */
    public var schemas: [String]?
    /** The total number of results. */
    public var totalResults: Int64?
    /** The 1-based index of the first result returned by this request. Add this to \"itemsPerPage\" when requesting the next page of results. */
    public var startIndex: Int64?
    /** The number of resources returned per page. */
    public var itemsPerPage: Int64?
    /** The list of requested resources. */
    public var resources: [ScimConfigResourceType]?

    public init(schemas: [String]?, totalResults: Int64?, startIndex: Int64?, itemsPerPage: Int64?, resources: [ScimConfigResourceType]?) {
        self.schemas = schemas
        self.totalResults = totalResults
        self.startIndex = startIndex
        self.itemsPerPage = itemsPerPage
        self.resources = resources
    }

    public enum CodingKeys: String, CodingKey { 
        case schemas
        case totalResults
        case startIndex
        case itemsPerPage
        case resources = "Resources"
    }


}



/** The routing skill assigned to a user. */

public class ScimUserRoutingSkill: Codable {





    /** The case-sensitive name of a routing skill configured in Genesys Cloud. */
    public var name: String?
    /** A rating from 0.0 to 5.0 that indicates how adept an agent is at a particular skill. When \"Best available skills\" is enabled for a queue in Genesys Cloud, ACD interactions in that queue are routed to agents with higher proficiency ratings. */
    public var proficiency: Double?

    public init(name: String?, proficiency: Double?) {
        self.name = name
        self.proficiency = proficiency
    }


}




public class ScreenRecordingUserAuthenticatedInfo: Codable {



    /** Id of Genesys Cloud Background Assistant */
    public var backgroundAssistantId: String?

    public init(backgroundAssistantId: String?) {
        self.backgroundAssistantId = backgroundAssistantId
    }


}




public class ScriptEntityListing: Codable {





















    public var entities: [Script]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Script]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class SearchAggregation: Codable {





    public enum ModelType: String, Codable { 
        case count = "COUNT"
        case sum = "SUM"
        case average = "AVERAGE"
        case term = "TERM"
        case contains = "CONTAINS"
        case startsWith = "STARTS_WITH"
        case endsWith = "ENDS_WITH"
    }





    public enum Order: String, Codable { 
        case valueDesc = "VALUE_DESC"
        case valueAsc = "VALUE_ASC"
        case countDesc = "COUNT_DESC"
        case countAsc = "COUNT_ASC"
    }

    /** The field used for aggregation */
    public var field: String?
    /** The name of the aggregation. The response aggregation uses this name. */
    public var name: String?
    /** The type of aggregation to perform */
    public var type: ModelType?
    /** A value to use for aggregation */
    public var value: String?
    /** The number aggregations results to return out of the entire result set */
    public var size: Int?
    /** The order in which aggregation results are sorted */
    public var order: [Order]?

    public init(field: String?, name: String?, type: ModelType?, value: String?, size: Int?, order: [Order]?) {
        self.field = field
        self.name = name
        self.type = type
        self.value = value
        self.size = size
        self.order = order
    }


}




public class SearchShiftTradeResponse: Codable {







    /** A trade which matches search criteria */
    public var trade: ShiftTradeResponse?
    /** IDs of shifts which match the search criteria */
    public var matchingReceivingShiftIds: [String]?
    /** A preview of what the shift trade would look like if matched */
    public var preview: ShiftTradePreviewResponse?

    public init(trade: ShiftTradeResponse?, matchingReceivingShiftIds: [String]?, preview: ShiftTradePreviewResponse?) {
        self.trade = trade
        self.matchingReceivingShiftIds = matchingReceivingShiftIds
        self.preview = preview
    }


}




public class SearchShiftTradesResponse: Codable {





    /** The shift trades that match the search criteria */
    public var trades: [SearchShiftTradeResponse]?
    /** URL from which to fetch results for requests with a large result set. If populated, the downloaded data will conform to the same schema as would normally be returned, excepting downloaded data will never itself contain a downloadUrl */
    public var downloadUrl: String?

    public init(trades: [SearchShiftTradeResponse]?, downloadUrl: String?) {
        self.trades = trades
        self.downloadUrl = downloadUrl
    }


}




public class SegmentDetailQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [SegmentDetailQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [SegmentDetailQueryPredicate]?

    public init(type: ModelType?, clauses: [SegmentDetailQueryClause]?, predicates: [SegmentDetailQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class SelectedColumns: Codable {





    /** Indicates the order/position of the selected column */
    public var columnOrder: Int?
    /** Indicates enum name of the column from the export view */
    public var columnName: String?

    public init(columnOrder: Int?, columnName: String?) {
        self.columnOrder = columnOrder
        self.columnName = columnName
    }


}



/** Details about a selector event trigger */

public class SelectorEventTrigger: Codable {





    /** Element that triggers event. */
    public var selector: String?
    /** Name of event triggered when element matching selector is interacted with. */
    public var eventName: String?

    public init(selector: String?, eventName: String?) {
        self.selector = selector
        self.eventName = eventName
    }


}




public class SentimentFeedbackEntityListing: Codable {



    public var entities: [SentimentFeedback]?

    public init(entities: [SentimentFeedback]?) {
        self.entities = entities
    }


}




public class ServiceGoalTemplate: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Service level targets for this service goal template */
    public var serviceLevel: BuServiceLevel?
    /** Average speed of answer targets for this service goal template */
    public var averageSpeedOfAnswer: BuAverageSpeedOfAnswer?
    /** Abandon rate targets for this service goal template */
    public var abandonRate: BuAbandonRate?
    /** Version metadata for the service goal template */
    public var metadata: WfmVersionedEntityMetadata?
    /** Settings controlling max percent increase and decrease of service goals for this service goal template */
    public var impactOverride: ServiceGoalTemplateImpactOverride?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, serviceLevel: BuServiceLevel?, averageSpeedOfAnswer: BuAverageSpeedOfAnswer?, abandonRate: BuAbandonRate?, metadata: WfmVersionedEntityMetadata?, impactOverride: ServiceGoalTemplateImpactOverride?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.serviceLevel = serviceLevel
        self.averageSpeedOfAnswer = averageSpeedOfAnswer
        self.abandonRate = abandonRate
        self.metadata = metadata
        self.impactOverride = impactOverride
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case serviceLevel
        case averageSpeedOfAnswer
        case abandonRate
        case metadata
        case impactOverride
        case selfUri
    }


}




public class SetWrapperRoutePathRequest: Codable {



    public var values: [RoutePathRequest]?

    public init(values: [RoutePathRequest]?) {
        self.values = values
    }


}




public class SetWrapperSyncTimeOffProperty: Codable {


    public enum Values: String, Codable { 
        case payableMinutes = "PayableMinutes"
    }
    public var values: [Values]?

    public init(values: [Values]?) {
        self.values = values
    }


}




public class ShareEntityListing: Codable {





















    public var entities: [Share]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Share]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class SharedEntity: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class SharedResponse: Codable {











    public var _id: String?
    public var downloadUri: String?
    public var viewUri: String?
    public var document: Document?
    public var share: Share?

    public init(_id: String?, downloadUri: String?, viewUri: String?, document: Document?, share: Share?) {
        self._id = _id
        self.downloadUri = downloadUri
        self.viewUri = viewUri
        self.document = document
        self.share = share
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case downloadUri
        case viewUri
        case document
        case share
    }


}




public class ShiftTradeActivityPreviewResponse: Codable {











    /** The start date and time of this activity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** The length in minutes of this activity */
    public var lengthMinutes: Int?
    /** The ID of the activity code for this activity */
    public var activityCodeId: String?
    /** Whether this activity counts as paid time */
    public var countsAsPaidTime: Bool?
    /** Payable minutes for this activity */
    public var payableMinutes: Int?

    public init(startDate: Date?, lengthMinutes: Int?, activityCodeId: String?, countsAsPaidTime: Bool?, payableMinutes: Int?) {
        self.startDate = startDate
        self.lengthMinutes = lengthMinutes
        self.activityCodeId = activityCodeId
        self.countsAsPaidTime = countsAsPaidTime
        self.payableMinutes = payableMinutes
    }


}




public class ShiftTradeNotification: Codable {







    public enum NewState: String, Codable { 
        case unmatched = "Unmatched"
        case matched = "Matched"
        case approved = "Approved"
        case denied = "Denied"
        case expired = "Expired"
        case canceled = "Canceled"
    }









    /** The start date of the schedule with which this trade is associated */
    public var weekDate: String?
    /** The ID of the shift trade */
    public var tradeId: String?
    /** Whether this is a one sided shift trade */
    public var oneSided: Bool?
    /** The new state of the shift trade, null if there was no change */
    public var newState: NewState?
    /** The user who initiated the shift trade */
    public var initiatingUser: UserReference?
    /** The start date and time of the initiating shift. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var initiatingShiftDate: Date?
    /** The user on the receiving side of this shift trade (null if not matched) */
    public var receivingUser: UserReference?
    /** The start date and time of the receiving shift (null if not matched or if one-sided. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var receivingShiftDate: Date?

    public init(weekDate: String?, tradeId: String?, oneSided: Bool?, newState: NewState?, initiatingUser: UserReference?, initiatingShiftDate: Date?, receivingUser: UserReference?, receivingShiftDate: Date?) {
        self.weekDate = weekDate
        self.tradeId = tradeId
        self.oneSided = oneSided
        self.newState = newState
        self.initiatingUser = initiatingUser
        self.initiatingShiftDate = initiatingShiftDate
        self.receivingUser = receivingUser
        self.receivingShiftDate = receivingShiftDate
    }


}




public class ShiftTradePreviewResponse: Codable {



    /** List of activities that will make up the new shift if this shift trade is approved */
    public var activities: [ShiftTradeActivityPreviewResponse]?

    public init(activities: [ShiftTradeActivityPreviewResponse]?) {
        self.activities = activities
    }


}




public class ShortTermForecastingSettings: Codable {



    /** The number of weeks to consider by default when generating a volume forecast */
    public var defaultHistoryWeeks: Int?

    public init(defaultHistoryWeeks: Int?) {
        self.defaultHistoryWeeks = defaultHistoryWeeks
    }


}




public class ShrinkageOverride: Codable {





    /** Index of shrinkage override interval. Starting index is 0 and indexes are based on 15 minute intervals for a 7 day week */
    public var intervalIndex: Int?
    /** Shrinkage override percent. Setting a null value will reset the interval to the default */
    public var shrinkagePercent: Double?

    public init(intervalIndex: Int?, shrinkagePercent: Double?) {
        self.intervalIndex = intervalIndex
        self.shrinkagePercent = shrinkagePercent
    }


}




public class ShrinkageOverrides: Codable {





    /** Set true to clear the shrinkage interval overrides */
    public var clear: Bool?
    /** List of interval shrinkage overrides */
    public var values: [ShrinkageOverride]?

    public init(clear: Bool?, values: [ShrinkageOverride]?) {
        self.clear = clear
        self.values = values
    }


}




public class Signature: Codable {







    public enum InclusionType: String, Codable { 
        case draft = "Draft"
        case send = "Send"
        case sendOnce = "SendOnce"
    }

    /** A toggle to enable the signature on email send. */
    public var enabled: Bool?
    /** The identifier referring to an email signature canned response. */
    public var cannedResponseId: String?
    /** A toggle that defines if a signature is always included or only set on the first email in an email chain. */
    public var alwaysIncluded: Bool?
    /** The configuration to indicate when the signature of a conversation has to be included */
    public var inclusionType: InclusionType?

    public init(enabled: Bool?, cannedResponseId: String?, alwaysIncluded: Bool?, inclusionType: InclusionType?) {
        self.enabled = enabled
        self.cannedResponseId = cannedResponseId
        self.alwaysIncluded = alwaysIncluded
        self.inclusionType = inclusionType
    }


}




public class SignedUrlResponse: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Url of the downloaded pcap file */
    public var url: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, url: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.url = url
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case url
        case selfUri
    }


}




public class SipDownloadResponse: Codable {





    /** unique id of the downloaded file */
    public var downloadId: String?
    /** Document id of pcap file */
    public var documentId: String?

    public init(downloadId: String?, documentId: String?) {
        self.downloadId = downloadId
        self.documentId = documentId
    }


}




public class SkillGroup: Codable {















    public enum Status: String, Codable { 
        case inProgress = "InProgress"
        case complete = "Complete"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The group name. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    /** Group description */
    public var _description: String?
    /** Estimated number of members in this group. It can take some time for the count to be updated after expressions are changed. */
    public var memberCount: Int64?
    /** Last modified date/time of the skill group. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Created date/time of the skill group. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Group's filling status */
    public var status: Status?
    /** Conditions for this group */
    public var skillConditions: [SkillGroupCondition]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, _description: String?, memberCount: Int64?, dateModified: Date?, dateCreated: Date?, status: Status?, skillConditions: [SkillGroupCondition]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.memberCount = memberCount
        self.dateModified = dateModified
        self.dateCreated = dateCreated
        self.status = status
        self.skillConditions = skillConditions
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case memberCount
        case dateModified
        case dateCreated
        case status
        case skillConditions
        case selfUri
    }


}




public class SkillGroupCondition: Codable {





    public enum Operation: String, Codable { 
        case and = "And"
        case not = "Not"
        case or = "Or"
    }

    /** Routing skill conditions that will be used for building the query */
    public var routingSkillConditions: [SkillGroupRoutingCondition]?
    /** Routing skill conditions that will be used for building the query */
    public var languageSkillConditions: [SkillGroupLanguageCondition]?
    /** Operator that will be applied to the conditions */
    public var operation: Operation?

    public init(routingSkillConditions: [SkillGroupRoutingCondition]?, languageSkillConditions: [SkillGroupLanguageCondition]?, operation: Operation?) {
        self.routingSkillConditions = routingSkillConditions
        self.languageSkillConditions = languageSkillConditions
        self.operation = operation
    }


}




public class SmsAddressProvision: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Name associated with this address */
    public var name: String?
    /** The number and street address where this address is located. */
    public var street: String?
    /** The city in which this address is in */
    public var city: String?
    /** The state or region this address is in */
    public var region: String?
    /** The postal code this address is in */
    public var postalCode: String?
    /** The ISO country code of this address */
    public var countryCode: String?
    /** This is used when the address is created. If the value is not set or true, then the system will, if necessary, auto-correct the address you provide. Set this value to false if the system should not auto-correct the address. */
    public var autoCorrectAddress: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, street: String?, city: String?, region: String?, postalCode: String?, countryCode: String?, autoCorrectAddress: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.street = street
        self.city = city
        self.region = region
        self.postalCode = postalCode
        self.countryCode = countryCode
        self.autoCorrectAddress = autoCorrectAddress
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case street
        case city
        case region
        case postalCode
        case countryCode
        case autoCorrectAddress
        case selfUri
    }


}




public class SocialHandle: Codable {

    public enum ModelType: String, Codable { 
        case twitter = "TWITTER"
    }



    public var type: ModelType?
    public var value: String?

    public init(type: ModelType?, value: String?) {
        self.type = type
        self.value = value
    }


}




public class SpeechTextAnalyticsSettingsRequest: Codable {









    /** Setting to choose name for the default program for topic detection */
    public var defaultProgramId: String?
    /** Setting to choose expected dialects */
    public var expectedDialects: [String]?
    /** Setting to enable/disable text analytics */
    public var textAnalyticsEnabled: Bool?
    /** Setting to enable/disable Agent Empathy setting */
    public var agentEmpathyEnabled: Bool?

    public init(defaultProgramId: String?, expectedDialects: [String]?, textAnalyticsEnabled: Bool?, agentEmpathyEnabled: Bool?) {
        self.defaultProgramId = defaultProgramId
        self.expectedDialects = expectedDialects
        self.textAnalyticsEnabled = textAnalyticsEnabled
        self.agentEmpathyEnabled = agentEmpathyEnabled
    }


}




public class SplittingInformation: Codable {

    public enum Criteria: String, Codable { 
        case percentage = "Percentage"
        case quantity = "Quantity"
        case column = "Column"
        case custom = "Custom"
    }







    /** The splitting criteria type */
    public var criteria: Criteria?
    /** The criteria value for the specified criteria type */
    public var criteriaValue: String?
    /** Whether to create remainder contact list */
    public var createRemainderContactList: Bool?
    /** Whether to use waterfall rule */
    public var useWaterfallRule: Bool?

    public init(criteria: Criteria?, criteriaValue: String?, createRemainderContactList: Bool?, useWaterfallRule: Bool?) {
        self.criteria = criteria
        self.criteriaValue = criteriaValue
        self.createRemainderContactList = createRemainderContactList
        self.useWaterfallRule = useWaterfallRule
    }


}




public class StatEventCampaignTopicIntervalMetrics: Codable {





    public var interval: String?
    public var metrics: [StatEventCampaignTopicMetricStats]?

    public init(interval: String?, metrics: [StatEventCampaignTopicMetricStats]?) {
        self.interval = interval
        self.metrics = metrics
    }


}




public class StatEventCampaignTopicMetricStats: Codable {







    public var metric: String?
    public var qualifier: String?
    public var stats: [String:Double]?

    public init(metric: String?, qualifier: String?, stats: [String:Double]?) {
        self.metric = metric
        self.qualifier = qualifier
        self.stats = stats
    }


}




public class StatEventFlowOutcomeTopicIntervalMetrics: Codable {





    public var interval: String?
    public var metrics: [StatEventFlowOutcomeTopicMetricStats]?

    public init(interval: String?, metrics: [StatEventFlowOutcomeTopicMetricStats]?) {
        self.interval = interval
        self.metrics = metrics
    }


}




public class StatEventFlowOutcomeTopicMetricStats: Codable {







    public var metric: String?
    public var qualifier: String?
    public var stats: [String:Double]?

    public init(metric: String?, qualifier: String?, stats: [String:Double]?) {
        self.metric = metric
        self.qualifier = qualifier
        self.stats = stats
    }


}




public class StatEventQueueTopicStatsNotification: Codable {





    public var group: [String:String]?
    public var data: [StatEventQueueTopicIntervalMetrics]?

    public init(group: [String:String]?, data: [StatEventQueueTopicIntervalMetrics]?) {
        self.group = group
        self.data = data
    }


}




public class StatEventUserTopicIntervalMetrics: Codable {





    public var interval: String?
    public var metrics: [StatEventUserTopicMetricStats]?

    public init(interval: String?, metrics: [StatEventUserTopicMetricStats]?) {
        self.interval = interval
        self.metrics = metrics
    }


}




public class StatEventUserTopicMetricStats: Codable {







    public var metric: String?
    public var qualifier: String?
    public var stats: [String:Double]?

    public init(metric: String?, qualifier: String?, stats: [String:Double]?) {
        self.metric = metric
        self.qualifier = qualifier
        self.stats = stats
    }


}




public class StatusChange: Codable {



    public enum Status: String, Codable { 
        case approved = "Approved"
        case rejected = "Rejected"
        case rollback = "Rollback"
        case pending = "Pending"
        case _open = "Open"
        case secondaryApprovalNamespacesAdded = "SecondaryApprovalNamespacesAdded"
        case reviewerApproved = "ReviewerApproved"
        case reviewerRejected = "ReviewerRejected"
        case reviewerRollback = "ReviewerRollback"
        case implementingChange = "ImplementingChange"
        case changeImplemented = "ChangeImplemented"
        case implementingRollback = "ImplementingRollback"
        case rollbackImplemented = "RollbackImplemented"
    }

    public enum PreviousStatus: String, Codable { 
        case approved = "Approved"
        case rejected = "Rejected"
        case rollback = "Rollback"
        case pending = "Pending"
        case _open = "Open"
        case secondaryApprovalNamespacesAdded = "SecondaryApprovalNamespacesAdded"
        case reviewerApproved = "ReviewerApproved"
        case reviewerRejected = "ReviewerRejected"
        case reviewerRollback = "ReviewerRollback"
        case implementingChange = "ImplementingChange"
        case changeImplemented = "ChangeImplemented"
        case implementingRollback = "ImplementingRollback"
        case rollbackImplemented = "RollbackImplemented"
    }

    public enum Namespace: String, Codable { 
        case agentAssistant = "agent.assistant"
        case analyticsAlerting = "analytics.alerting"
        case analytics = "analytics"
        case analyticsRealtime = "analytics.realtime"
        case analyticsReportingSettings = "analytics.reporting.settings"
        case architect = "architect"
        case audiohook = "audiohook"
        case audit = "audit"
        case authApi = "auth.api"
        case authorization = "authorization"
        case automationTesting = "automation.testing"
        case bots = "bots"
        case botsVoice = "bots.voice"
        case callback = "callback"
        case cobrowse = "cobrowse"
        case contentManagement = "content.management"
        case conversation = "conversation"
        case dataactions = "dataactions"
        case datatables = "datatables"
        case directory = "directory"
        case email = "email"
        case employeeEngagement = "employee.engagement"
        case eventOrchestration = "event.orchestration"
        case externalContacts = "external.contacts"
        case gcv = "gcv"
        case gdpr = "gdpr"
        case groups = "groups"
        case historicalAdherence = "historical.adherence"
        case infrastructureascode = "infrastructureascode"
        case integrations = "integrations"
        case intentMiner = "intent.miner"
        case journey = "journey"
        case knowledge = "knowledge"
        case languageUnderstanding = "language.understanding"
        case learning = "learning"
        case limitRegistry = "limit.registry"
        case marketplace = "marketplace"
        case mediaCommunications = "media.communications"
        case messaging = "messaging"
        case notifications = "notifications"
        case onboarding = "onboarding"
        case outbound = "outbound"
        case platformApi = "platform.api"
        case predictiveRouting = "predictive.routing"
        case presence = "presence"
        case quality = "quality"
        case recording = "recording"
        case responseManagement = "response.management"
        case routing = "routing"
        case scim = "scim"
        case search = "search"
        case secondaryAutomationTesting = "secondary.automation.testing"
        case skills = "skills"
        case speechAndTextAnalytics = "speech.and.text.analytics"
        case speechIntegration = "speech.integration"
        case supportability = "supportability"
        case taskManagement = "task.management"
        case telephonyConfiguration = "telephony.configuration"
        case usage = "usage"
        case users = "users"
        case webDeployments = "web.deployments"
        case webMessaging = "web.messaging"
        case webchat = "webchat"
        case webhooks = "webhooks"
        case workforceManagement = "workforce.management"
    }



    public enum RejectReason: String, Codable { 
        case alternativeExists = "AlternativeExists"
        case increaseNotRequired = "IncreaseNotRequired"
        case platformMisuse = "PlatformMisuse"
        case platformStability = "PlatformStability"
        case otherReason = "OtherReason"
    }

    /** The date of this status change. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStatusChanged: Date?
    /** The status the change request transitioned to */
    public var status: Status?
    /** The status the change request transitioned from */
    public var previousStatus: PreviousStatus?
    /** The namespace for the status change */
    public var namespace: Namespace?
    /** A short message describing the status change */
    public var message: String?
    /** The reason for rejecting the limit override request */
    public var rejectReason: RejectReason?

    public init(dateStatusChanged: Date?, status: Status?, previousStatus: PreviousStatus?, namespace: Namespace?, message: String?, rejectReason: RejectReason?) {
        self.dateStatusChanged = dateStatusChanged
        self.status = status
        self.previousStatus = previousStatus
        self.namespace = namespace
        self.message = message
        self.rejectReason = rejectReason
    }


}




public class StopSettings: Codable {





    /** List of keywords for compliance */
    public var keyword: [String]?
    /** The response configuration for the keywords */
    public var response: ComplianceResponse?

    public init(keyword: [String]?, response: ComplianceResponse?) {
        self.keyword = keyword
        self.response = response
    }


}




public class StreetAddress: Codable {

















    /** 2 Letter Country code, like US or GB */
    public var country: String?
    /** State or Province */
    public var a1: String?
    /** City or township */
    public var a3: String?
    /** Number and street */
    public var RD: String?
    /** House Number */
    public var HNO: String?
    /** extra location info like suite 300 */
    public var LOC: String?
    /** Name of the customer */
    public var NAM: String?
    /** Postal code */
    public var PC: String?

    public init(country: String?, a1: String?, a3: String?, RD: String?, HNO: String?, LOC: String?, NAM: String?, PC: String?) {
        self.country = country
        self.a1 = a1
        self.a3 = a3
        self.RD = RD
        self.HNO = HNO
        self.LOC = LOC
        self.NAM = NAM
        self.PC = PC
    }

    public enum CodingKeys: String, CodingKey { 
        case country
        case a1 = "A1"
        case a3 = "A3"
        case RD
        case HNO
        case LOC
        case NAM
        case PC
    }


}




public class SubscriberResponse: Codable {





    /** Suggested valid addresses */
    public var messageReturned: [String]?
    /** http status */
    public var status: String?

    public init(messageReturned: [String]?, status: String?) {
        self.messageReturned = messageReturned
        self.status = status
    }


}




public class SubscriptionOverviewUsage: Codable {

























    /** Product charge name */
    public var name: String?
    /** Product part number */
    public var partNumber: String?
    /** UI grouping key */
    public var grouping: String?
    /** UI unit of measure */
    public var unitOfMeasureType: String?
    /** Usage count for specified period */
    public var usageQuantity: String?
    /** Price for usage / overage charge */
    public var overagePrice: String?
    /** Items prepaid for specified period */
    public var prepayQuantity: String?
    /** Price for prepay charge */
    public var prepayPrice: String?
    /** Notes about the usage/charge item */
    public var usageNotes: String?
    /** Indicates whether the item is cancellable */
    public var isCancellable: Bool?
    /** Quantity multiplier for this charge */
    public var bundleQuantity: String?
    /** A charge from a third party entity */
    public var isThirdParty: Bool?

    public init(name: String?, partNumber: String?, grouping: String?, unitOfMeasureType: String?, usageQuantity: String?, overagePrice: String?, prepayQuantity: String?, prepayPrice: String?, usageNotes: String?, isCancellable: Bool?, bundleQuantity: String?, isThirdParty: Bool?) {
        self.name = name
        self.partNumber = partNumber
        self.grouping = grouping
        self.unitOfMeasureType = unitOfMeasureType
        self.usageQuantity = usageQuantity
        self.overagePrice = overagePrice
        self.prepayQuantity = prepayQuantity
        self.prepayPrice = prepayPrice
        self.usageNotes = usageNotes
        self.isCancellable = isCancellable
        self.bundleQuantity = bundleQuantity
        self.isThirdParty = isThirdParty
    }


}




public class SuggestSearchRequest: Codable {







    /** Provides more details about a specified resource */
    public var expand: [String]?
    /** Resource domain type to search */
    public var types: [String]?
    /** Suggest query */
    public var query: [SuggestSearchCriteria]?

    public init(expand: [String]?, types: [String]?, query: [SuggestSearchCriteria]?) {
        self.expand = expand
        self.types = types
        self.query = query
    }


}




public class SupportCenterFeedbackSettings: Codable {



    /** Whether or not requesting customer feedback on article content and article search results is enabled */
    public var enabled: Bool?

    public init(enabled: Bool?) {
        self.enabled = enabled
    }


}




public class SupportCenterGlobalStyle: Codable {













    /** Global background color, in hexadecimal format, eg #ffffff */
    public var backgroundColor: String?
    /** Global primary color, in hexadecimal format, eg #ffffff */
    public var primaryColor: String?
    /** Global dark primary color, in hexadecimal format, eg #ffffff */
    public var primaryColorDark: String?
    /** Global light primary color, in hexadecimal format, eg #ffffff */
    public var primaryColorLight: String?
    /** Global text color, in hexadecimal format, eg #ffffff */
    public var textColor: String?
    /** Global font family */
    public var fontFamily: String?

    public init(backgroundColor: String?, primaryColor: String?, primaryColorDark: String?, primaryColorLight: String?, textColor: String?, fontFamily: String?) {
        self.backgroundColor = backgroundColor
        self.primaryColor = primaryColor
        self.primaryColorDark = primaryColorDark
        self.primaryColorLight = primaryColorLight
        self.textColor = textColor
        self.fontFamily = fontFamily
    }


}




public class SupportCenterHeroStyle: Codable {







    /** Background color for hero section, in hexadecimal format, eg #ffffff */
    public var backgroundColor: String?
    /** Text color for hero section, in hexadecimal format, eg #ffffff */
    public var textColor: String?
    /** Background image for hero section */
    public var image: SupportCenterImage?

    public init(backgroundColor: String?, textColor: String?, image: SupportCenterImage?) {
        self.backgroundColor = backgroundColor
        self.textColor = textColor
        self.image = image
    }


}




public class SurveyAggregateDataContainer: Codable {





    /** A mapping from dimension to value */
    public var group: [String:String]?
    public var data: [StatisticalResponse]?

    public init(group: [String:String]?, data: [StatisticalResponse]?) {
        self.group = group
        self.data = data
    }


}




public class SurveyAggregateQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [SurveyAggregateQueryPredicate]?

    public init(type: ModelType?, predicates: [SurveyAggregateQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class SurveyAggregationQuery: Codable {







    public enum GroupBy: String, Codable { 
        case conversationid = "conversationId"
        case divisionid = "divisionId"
        case externalcontactid = "externalContactId"
        case mediatype = "mediaType"
        case queueid = "queueId"
        case requestedlanguageid = "requestedLanguageId"
        case requestedroutingskillid = "requestedRoutingSkillId"
        case surveyanswerid = "surveyAnswerId"
        case surveyerrorreason = "surveyErrorReason"
        case surveyformcontextid = "surveyFormContextId"
        case surveyformid = "surveyFormId"
        case surveyformname = "surveyFormName"
        case surveyid = "surveyId"
        case surveypreviousstatus = "surveyPreviousStatus"
        case surveypromoterscore = "surveyPromoterScore"
        case surveyquestiongroupid = "surveyQuestionGroupId"
        case surveyquestionid = "surveyQuestionId"
        case surveystatus = "surveyStatus"
        case teamid = "teamId"
        case userid = "userId"
        case wrapupcode = "wrapUpCode"
    }



    public enum Metrics: String, Codable { 
        case nsurveyerrors = "nSurveyErrors"
        case nsurveynpsdetractors = "nSurveyNpsDetractors"
        case nsurveynpspromoters = "nSurveyNpsPromoters"
        case nsurveynpsresponses = "nSurveyNpsResponses"
        case nsurveyquestiongroupresponses = "nSurveyQuestionGroupResponses"
        case nsurveyquestionresponses = "nSurveyQuestionResponses"
        case nsurveyresponses = "nSurveyResponses"
        case nsurveysabandoned = "nSurveysAbandoned"
        case nsurveysdeleted = "nSurveysDeleted"
        case nsurveysexpired = "nSurveysExpired"
        case nsurveyssent = "nSurveysSent"
        case nsurveysstarted = "nSurveysStarted"
        case osurveyquestiongroupscore = "oSurveyQuestionGroupScore"
        case osurveyquestionscore = "oSurveyQuestionScore"
        case osurveytotalscore = "oSurveyTotalScore"
    }





    public enum AlternateTimeDimension: String, Codable { 
        case eventtime = "eventTime"
        case surveycreateddate = "surveyCreatedDate"
    }

    /** Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H */
    public var granularity: String?
    /** Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var timeZone: String?
    /** Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group. */
    public var groupBy: [GroupBy]?
    /** Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters */
    public var filter: SurveyAggregateQueryFilter?
    /** Behaves like a SQL SELECT clause. Only named metrics will be retrieved. */
    public var metrics: [Metrics]?
    /** Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c') */
    public var flattenMultivaluedDimensions: Bool?
    /** Custom derived metric views */
    public var views: [SurveyAggregationView]?
    /** Dimension to use as the alternative timestamp for data in the aggregate.  Choosing \"eventTime\" uses the actual time of the data event. */
    public var alternateTimeDimension: AlternateTimeDimension?

    public init(interval: String?, granularity: String?, timeZone: String?, groupBy: [GroupBy]?, filter: SurveyAggregateQueryFilter?, metrics: [Metrics]?, flattenMultivaluedDimensions: Bool?, views: [SurveyAggregationView]?, alternateTimeDimension: AlternateTimeDimension?) {
        self.interval = interval
        self.granularity = granularity
        self.timeZone = timeZone
        self.groupBy = groupBy
        self.filter = filter
        self.metrics = metrics
        self.flattenMultivaluedDimensions = flattenMultivaluedDimensions
        self.views = views
        self.alternateTimeDimension = alternateTimeDimension
    }


}




public class SurveyDetailQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case eventtime = "eventTime"
        case queueid = "queueId"
        case surveycompleteddate = "surveyCompletedDate"
        case surveyformcontextid = "surveyFormContextId"
        case surveyformid = "surveyFormId"
        case surveyid = "surveyId"
        case surveypromoterscore = "surveyPromoterScore"
        case surveystatus = "surveyStatus"
        case userid = "userId"
    }

    public enum Metric: String, Codable { 
        case osurveytotalscore = "oSurveyTotalScore"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Left hand side for metric predicates */
    public var metric: Metric?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension or metric predicates */
    public var value: String?
    /** Right hand side for dimension or metric predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, metric: Metric?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self.metric = metric
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case metric
        case _operator = "operator"
        case value
        case range
    }


}




public class SurveyErrorDetails: Codable {





    /** Additional information about any errors that occurred in the survey invite flow. */
    public var flowDiagnosticInfo: FlowDiagnosticInfo?
    /** An error code indicating the reason for the survey failure. */
    public var surveyErrorReason: String?

    public init(flowDiagnosticInfo: FlowDiagnosticInfo?, surveyErrorReason: String?) {
        self.flowDiagnosticInfo = flowDiagnosticInfo
        self.surveyErrorReason = surveyErrorReason
    }


}




public class SystemPresence: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}




public class SystemPromptAssetEntityListing: Codable {





















    public var entities: [SystemPromptAsset]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [SystemPromptAsset]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class Team: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The team name */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    /** Team information. */
    public var _description: String?
    /** Last modified datetime. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified datetime. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Number of members in a team */
    public var memberCount: Int64?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, _description: String?, dateCreated: Date?, dateModified: Date?, memberCount: Int64?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.memberCount = memberCount
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case dateCreated
        case dateModified
        case memberCount
        case selfUri
    }


}




public class TeamMembers: Codable {



    /** A list of the ids of the members to add or remove */
    public var memberIds: [String]?

    public init(memberIds: [String]?) {
        self.memberIds = memberIds
    }


}




public class TeamsSearchResponse: Codable {



















    /** The total number of results found */
    public var total: Int64?
    /** The total number of pages */
    public var pageCount: Int?
    /** The current page size */
    public var pageSize: Int?
    /** The current page number */
    public var pageNumber: Int?
    /** Q64 value for the previous page of results */
    public var previousPage: String?
    /** Q64 value for the current page of results */
    public var currentPage: String?
    /** Q64 value for the next page of results */
    public var nextPage: String?
    /** Resource types the search was performed against */
    public var types: [String]?
    /** Search results */
    public var results: [Team]?

    public init(total: Int64?, pageCount: Int?, pageSize: Int?, pageNumber: Int?, previousPage: String?, currentPage: String?, nextPage: String?, types: [String]?, results: [Team]?) {
        self.total = total
        self.pageCount = pageCount
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.previousPage = previousPage
        self.currentPage = currentPage
        self.nextPage = nextPage
        self.types = types
        self.results = results
    }


}




public class TermAttribute: Codable {





    public enum ModelType: String, Codable { 
        case number = "NUMBER"
        case string = "STRING"
        case date = "DATE"
        case boolean = "BOOLEAN"
        case list = "LIST"
    }

    public var _id: String?
    public var name: String?
    public var type: ModelType?

    public init(_id: String?, name: String?, type: ModelType?) {
        self._id = _id
        self.name = name
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case type
    }


}



/** Information about the Trigger test mode target validation step */

public class TestTargetOperation: Codable {









    /** The name of the processing step */
    public var name: String?
    /** The number of the processing step */
    public var step: Int?
    /** Whether or not the operation matches expectations */
    public var matches: Bool?
    /** Details about why the operation did or did not succeed */
    public var details: [String]?

    public init(name: String?, step: Int?, matches: Bool?, details: [String]?) {
        self.name = name
        self.step = step
        self.matches = matches
        self.details = details
    }


}



/** Channel information relevant to a bot flow. */

public class TextBotChannel: Codable {

    public enum Name: String, Codable { 
        case chat = "Chat"
        case call = "Call"
        case messaging = "Messaging"
    }


    public enum InputModes: String, Codable { 
        case text = "Text"
    }

    public enum OutputModes: String, Codable { 
        case text = "Text"
    }


    /** The name of the channel. */
    public var name: Name?
    /** The input modes for the channel. */
    public var inputModes: [InputModes]?
    /** The output modes for the channel. */
    public var outputModes: [OutputModes]?
    /** Information about the end user agent calling the bot flow. */
    public var userAgent: TextBotUserAgent?

    public init(name: Name?, inputModes: [InputModes]?, outputModes: [OutputModes]?, userAgent: TextBotUserAgent?) {
        self.name = name
        self.inputModes = inputModes
        self.outputModes = outputModes
        self.userAgent = userAgent
    }


}




public class TextBotFlowMilestone: Codable {







    /** The Milestone's ID. */
    public var _id: String?
    /** The timestamp of when the milestone was reached. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateReached: Date?
    /** The sequence number of the milestone. */
    public var sequence: Int64?

    public init(_id: String?, dateReached: Date?, sequence: Int64?) {
        self._id = _id
        self.dateReached = dateReached
        self.sequence = sequence
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case dateReached
        case sequence
    }


}



/** Settings for an input event to the bot flow indicating user input is available. */

public class TextBotUserInputEvent: Codable {

    public enum Mode: String, Codable { 
        case text = "Text"
    }



    /** The input mode. */
    public var mode: Mode?
    /** The input alternatives. */
    public var alternatives: [TextBotUserInputAlternative]?

    public init(mode: Mode?, alternatives: [TextBotUserInputAlternative]?) {
        self.mode = mode
        self.alternatives = alternatives
    }


}




public class TimeAllowed: Codable {







    public var timeSlots: [TimeSlot]?
    public var timeZoneId: String?
    public var empty: Bool?

    public init(timeSlots: [TimeSlot]?, timeZoneId: String?, empty: Bool?) {
        self.timeSlots = timeSlots
        self.timeZoneId = timeZoneId
        self.empty = empty
    }


}




public class TimeInterval: Codable {









    public var months: Int?
    public var weeks: Int?
    public var days: Int?
    public var hours: Int?

    public init(months: Int?, weeks: Int?, days: Int?, hours: Int?) {
        self.months = months
        self.weeks = weeks
        self.days = days
        self.hours = hours
    }


}




public class TimeOffLimitRange: Codable {



    public enum Granularity: String, Codable { 
        case daily = "Daily"
    }



    /** Start date of the range. The end date is determined by 'granularity' and the size of 'limitMinutesPerInterval'. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var startDate: Date?
    /** Granularity choice for the time off limit */
    public var granularity: Granularity?
    /** The list of time off limit values in minutes per granularity interval. If 'null' is specified, then interval specific value is cleared. Such interval will have 'defaultLimitMinutes' value */
    public var limitMinutesPerInterval: [Int]?

    public init(startDate: Date?, granularity: Granularity?, limitMinutesPerInterval: [Int]?) {
        self.startDate = startDate
        self.granularity = granularity
        self.limitMinutesPerInterval = limitMinutesPerInterval
    }


}




public class TimeOffRequestLookup: Codable {





    /** The ID of the time off request */
    public var timeOffRequestId: String?
    /** The ID of the user to whom the time off request belongs */
    public var userId: String?

    public init(timeOffRequestId: String?, userId: String?) {
        self.timeOffRequestId = timeOffRequestId
        self.userId = userId
    }


}




public class TimeOffRequestSettings: Codable {







    /** Whether to enforce a submission range for agent time off requests */
    public var submissionRangeEnforced: Bool?
    /** The earliest number of days from now for which an agent can submit a time off request.  Use negative numbers to indicate days in the past */
    public var submissionEarliestDaysFromNow: Int?
    /** The latest number of days from now for which an agent can submit a time off request */
    public var submissionLatestDaysFromNow: Int?

    public init(submissionRangeEnforced: Bool?, submissionEarliestDaysFromNow: Int?, submissionLatestDaysFromNow: Int?) {
        self.submissionRangeEnforced = submissionRangeEnforced
        self.submissionEarliestDaysFromNow = submissionEarliestDaysFromNow
        self.submissionLatestDaysFromNow = submissionLatestDaysFromNow
    }


}




public class TokenInfoClonedUser: Codable {





    /** User id of the original native user */
    public var _id: String?
    /** Organization of the original native user */
    public var organization: Entity?

    public init(_id: String?, organization: Entity?) {
        self._id = _id
        self.organization = organization
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case organization
    }


}




public class Topic: Codable {









    public enum Strictness: String, Codable { 
        case _1 = "1"
        case _55 = "55"
        case _65 = "65"
        case _72 = "72"
        case _85 = "85"
        case _90 = "90"
    }







    public enum Participants: String, Codable { 
        case external = "External"
        case _internal = "Internal"
        case all = "All"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var _description: String?
    public var published: Bool?
    public var strictness: Strictness?
    public var programs: [BaseProgramEntity]?
    public var tags: [String]?
    public var dialect: String?
    public var participants: Participants?
    public var phrases: [Phrase]?
    public var modifiedBy: AddressableEntityRef?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    public var publishedBy: AddressableEntityRef?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var datePublished: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, published: Bool?, strictness: Strictness?, programs: [BaseProgramEntity]?, tags: [String]?, dialect: String?, participants: Participants?, phrases: [Phrase]?, modifiedBy: AddressableEntityRef?, dateModified: Date?, publishedBy: AddressableEntityRef?, datePublished: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.published = published
        self.strictness = strictness
        self.programs = programs
        self.tags = tags
        self.dialect = dialect
        self.participants = participants
        self.phrases = phrases
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
        self.publishedBy = publishedBy
        self.datePublished = datePublished
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case published
        case strictness
        case programs
        case tags
        case dialect
        case participants
        case phrases
        case modifiedBy
        case dateModified
        case publishedBy
        case datePublished
        case selfUri
    }


}



/** Cursor listing of Topics. */

public class TopicCursorEntityListing: Codable {









    public var entities: [String]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [String]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class TopicOffset: Codable {





    /** Count of words before the topic  */
    public var wordCount: Int64?
    /** Count of characters before the topic  */
    public var characterCount: Int64?

    public init(wordCount: Int64?, characterCount: Int64?) {
        self.wordCount = wordCount
        self.characterCount = characterCount
    }


}




public class TopicRequest: Codable {





    public enum Strictness: String, Codable { 
        case _1 = "1"
        case _55 = "55"
        case _65 = "65"
        case _72 = "72"
        case _85 = "85"
        case _90 = "90"
    }







    public enum Participants: String, Codable { 
        case external = "External"
        case _internal = "Internal"
        case all = "All"
    }



    /** The topic name */
    public var name: String?
    /** The topic description */
    public var _description: String?
    /** The topic strictness, default value is 72 */
    public var strictness: Strictness?
    /** The ids of programs associated to the topic */
    public var programIds: [String]?
    /** The topic tags */
    public var tags: [String]?
    /** The topic dialect */
    public var dialect: String?
    /** The topic participants, default value is All */
    public var participants: Participants?
    /** The topic phrases */
    public var phrases: [Phrase]?

    public init(name: String?, _description: String?, strictness: Strictness?, programIds: [String]?, tags: [String]?, dialect: String?, participants: Participants?, phrases: [Phrase]?) {
        self.name = name
        self._description = _description
        self.strictness = strictness
        self.programIds = programIds
        self.tags = tags
        self.dialect = dialect
        self.participants = participants
        self.phrases = phrases
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _description = "description"
        case strictness
        case programIds
        case tags
        case dialect
        case participants
        case phrases
    }


}




public class TranscriptAggregateQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case addressfrom = "addressFrom"
        case addressto = "addressTo"
        case ani = "ani"
        case channel = "channel"
        case conversationduration = "conversationDuration"
        case conversationid = "conversationId"
        case direction = "direction"
        case divisionid = "divisionId"
        case dnis = "dnis"
        case flowid = "flowId"
        case flowversion = "flowVersion"
        case handletime = "handleTime"
        case mediatype = "mediaType"
        case messagetype = "messageType"
        case queueid = "queueId"
        case resultsby = "resultsBy"
        case teamid = "teamId"
        case topicid = "topicId"
        case userid = "userId"
        case wrapupcode = "wrapUpCode"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension predicates */
    public var value: String?
    /** Right hand side for dimension predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case _operator = "operator"
        case value
        case range
    }


}




public class TranscriptionSettings: Codable {

    public enum Transcription: String, Codable { 
        case disabled = "Disabled"
        case enabledGlobally = "EnabledGlobally"
        case enabledQueueFlow = "EnabledQueueFlow"
    }











    /** Setting to enable/disable transcription capability */
    public var transcription: Transcription?
    /** Configure confidence threshold. The possible values are from 1 to 100. */
    public var transcriptionConfidenceThreshold: Int?
    /** Boolean flag indicating whether low latency transcription via Notification API is enabled */
    public var lowLatencyTranscriptionEnabled: Bool?
    /** Setting to enable/disable content search */
    public var contentSearchEnabled: Bool?
    /** Setting to enable/disable PCI DSS Redaction */
    public var pciDssRedactionEnabled: Bool?
    /** Setting to enable/disable PII Redaction */
    public var piiRedactionEnabled: Bool?

    public init(transcription: Transcription?, transcriptionConfidenceThreshold: Int?, lowLatencyTranscriptionEnabled: Bool?, contentSearchEnabled: Bool?, pciDssRedactionEnabled: Bool?, piiRedactionEnabled: Bool?) {
        self.transcription = transcription
        self.transcriptionConfidenceThreshold = transcriptionConfidenceThreshold
        self.lowLatencyTranscriptionEnabled = lowLatencyTranscriptionEnabled
        self.contentSearchEnabled = contentSearchEnabled
        self.pciDssRedactionEnabled = pciDssRedactionEnabled
        self.piiRedactionEnabled = piiRedactionEnabled
    }


}




public class TranscriptionTopicTranscriptWord: Codable {











    public var confidence: Double?
    public var startTimeMs: Int?
    public var offsetMs: Int?
    public var durationMs: Int?
    public var word: String?

    public init(confidence: Double?, startTimeMs: Int?, offsetMs: Int?, durationMs: Int?, word: String?) {
        self.confidence = confidence
        self.startTimeMs = startTimeMs
        self.offsetMs = offsetMs
        self.durationMs = durationMs
        self.word = word
    }


}




public class Transcripts: Codable {







    /** List of transcript contents which needs to satisfy exact match criteria */
    public var exactMatch: [String]?
    /** List of transcript contents which needs to satisfy contains criteria */
    public var contains: [String]?
    /** List of transcript contents which needs to satisfy does not contain criteria */
    public var doesNotContain: [String]?

    public init(exactMatch: [String]?, contains: [String]?, doesNotContain: [String]?) {
        self.exactMatch = exactMatch
        self.contains = contains
        self.doesNotContain = doesNotContain
    }


}




public class TransferDestination: Codable {





    /** The id of the user if the command destination is a user. */
    public var userId: String?
    /** The destination address if the command destination is an endpoint. */
    public var address: String?

    public init(userId: String?, address: String?) {
        self.userId = userId
        self.address = address
    }


}




public class TriggerEntityListing: Codable {









    public var entities: [Trigger]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [Trigger]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class TrunkBase: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }









    public enum TrunkType: String, Codable { 
        case external = "EXTERNAL"
        case phone = "PHONE"
        case edge = "EDGE"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** The meta-base this trunk is based on. */
    public var trunkMetabase: DomainEntityRef?
    public var properties: [String:JSON]?
    /** The type of this trunk base. */
    public var trunkType: TrunkType?
    /** Is this trunk being managed remotely. This property is synchronized with the managed property of the Edge Group to which it is assigned. */
    public var managed: Bool?
    /** Used to determine the media regions for inbound and outbound calls through a trunk. Also determines the dial plan to use for calls that came in on a trunk and have to be sent out on it as well. */
    public var site: DomainEntityRef?
    /** Allows a customer to set the site to which inbound calls will be routed */
    public var inboundSite: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, trunkMetabase: DomainEntityRef?, properties: [String:JSON]?, trunkType: TrunkType?, managed: Bool?, site: DomainEntityRef?, inboundSite: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.trunkMetabase = trunkMetabase
        self.properties = properties
        self.trunkType = trunkType
        self.managed = managed
        self.site = site
        self.inboundSite = inboundSite
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case trunkMetabase
        case properties
        case trunkType
        case managed
        case site
        case inboundSite
        case selfUri
    }


}




public class TrunkConnectedStatus: Codable {





    public var connected: Bool?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedStateTime: Date?

    public init(connected: Bool?, connectedStateTime: Date?) {
        self.connected = connected
        self.connectedStateTime = connectedStateTime
    }


}




public class TrunkInstanceTopicTrunk: Codable {











    public var _id: String?
    public var connectedStatus: TrunkInstanceTopicTrunkConnectedStatus?
    public var optionsStatus: [TrunkInstanceTopicTrunkMetricsOptions]?
    public var registersStatus: [TrunkInstanceTopicTrunkMetricsRegisters]?
    public var ipStatus: TrunkInstanceTopicTrunkMetricsNetworkTypeIp?

    public init(_id: String?, connectedStatus: TrunkInstanceTopicTrunkConnectedStatus?, optionsStatus: [TrunkInstanceTopicTrunkMetricsOptions]?, registersStatus: [TrunkInstanceTopicTrunkMetricsRegisters]?, ipStatus: TrunkInstanceTopicTrunkMetricsNetworkTypeIp?) {
        self._id = _id
        self.connectedStatus = connectedStatus
        self.optionsStatus = optionsStatus
        self.registersStatus = registersStatus
        self.ipStatus = ipStatus
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case connectedStatus
        case optionsStatus
        case registersStatus
        case ipStatus
    }


}




public class TrunkInstanceTopicTrunkMetricsOptions: Codable {









    public var proxyAddress: String?
    public var optionState: Bool?
    public var optionStateTime: Date?
    public var errorInfo: TrunkInstanceTopicTrunkErrorInfo?

    public init(proxyAddress: String?, optionState: Bool?, optionStateTime: Date?, errorInfo: TrunkInstanceTopicTrunkErrorInfo?) {
        self.proxyAddress = proxyAddress
        self.optionState = optionState
        self.optionStateTime = optionStateTime
        self.errorInfo = errorInfo
    }


}




public class TrunkMetabaseEntityListing: Codable {























    public var entities: [Metabase]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    /** The total organization-wide number of entities. */
    public var totalNumberOfEntities: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Metabase]?, pageSize: Int?, pageNumber: Int?, total: Int64?, totalNumberOfEntities: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.totalNumberOfEntities = totalNumberOfEntities
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class TrunkMetricsRegisters: Codable {









    /** Server proxy address that this registers array element represents. */
    public var proxyAddress: String?
    /** True if last REGISTER message had positive response; false if error response or no response. */
    public var registerState: Bool?
    /** ISO 8601 format UTC absolute date & time of the last change of the register state. */
    public var registerStateTime: Date?
    public var errorInfo: TrunkErrorInfo?

    public init(proxyAddress: String?, registerState: Bool?, registerStateTime: Date?, errorInfo: TrunkErrorInfo?) {
        self.proxyAddress = proxyAddress
        self.registerState = registerState
        self.registerStateTime = registerStateTime
        self.errorInfo = errorInfo
    }


}




public class TrunkRecordingEnabledCount: Codable {





    /** The amount of trunks that have recording enabled */
    public var enabledCount: Int?
    /** The amount of trunks that do not have recording enabled */
    public var disabledCount: Int?

    public init(enabledCount: Int?, disabledCount: Int?) {
        self.enabledCount = enabledCount
        self.disabledCount = disabledCount
    }


}




public class TrustGroup: Codable {











    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }



    public enum ModelType: String, Codable { 
        case official = "official"
        case social = "social"
    }







    public enum Visibility: String, Codable { 
        case _public = "public"
        case owners = "owners"
        case members = "members"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The group name. */
    public var name: String?
    public var _description: String?
    /** Last modified date/time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Number of members. */
    public var memberCount: Int64?
    /** Active, inactive, or deleted state. */
    public var state: State?
    /** Current version for this resource. */
    public var version: Int?
    /** Type of group. */
    public var type: ModelType?
    public var images: [UserImage]?
    public var addresses: [GroupContact]?
    /** Are membership rules visible to the person requesting to view the group */
    public var rulesVisible: Bool?
    /** Who can view this group */
    public var visibility: Visibility?
    /** Allow roles to be assigned to this group */
    public var rolesEnabled: Bool?
    /** Owners of the group */
    public var owners: [User]?
    /** The date on which the trusted group was added. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The user that added trusted group. */
    public var createdBy: OrgUser?

    public init(_id: String?, name: String?, _description: String?, dateModified: Date?, memberCount: Int64?, state: State?, version: Int?, type: ModelType?, images: [UserImage]?, addresses: [GroupContact]?, rulesVisible: Bool?, visibility: Visibility?, rolesEnabled: Bool?, owners: [User]?, dateCreated: Date?, createdBy: OrgUser?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.dateModified = dateModified
        self.memberCount = memberCount
        self.state = state
        self.version = version
        self.type = type
        self.images = images
        self.addresses = addresses
        self.rulesVisible = rulesVisible
        self.visibility = visibility
        self.rolesEnabled = rolesEnabled
        self.owners = owners
        self.dateCreated = dateCreated
        self.createdBy = createdBy
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case dateModified
        case memberCount
        case state
        case version
        case type
        case images
        case addresses
        case rulesVisible
        case visibility
        case rolesEnabled
        case owners
        case dateCreated
        case createdBy
    }


}




public class TrustRequest: Codable {















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** User who created this request. */
    public var createdBy: OrgUser?
    /** Date request was created. There is a 48 hour expiration on all requests. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Trustee organization who generated this request. */
    public var trustee: Organization?
    /** The list of trustee users that are requesting access. */
    public var users: [OrgUser]?
    /** The list of trustee groups that are requesting access. */
    public var groups: [TrustGroup]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, createdBy: OrgUser?, dateCreated: Date?, trustee: Organization?, users: [OrgUser]?, groups: [TrustGroup]?, selfUri: String?) {
        self._id = _id
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.trustee = trustee
        self.users = users
        self.groups = groups
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case createdBy
        case dateCreated
        case trustee
        case users
        case groups
        case selfUri
    }


}




public class TrustUser: Codable {

















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }

























































    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    public var chat: Chat?
    public var department: String?
    public var email: String?
    /** Auto populated from addresses. */
    public var primaryContactInfo: [Contact]?
    /** Email addresses and phone numbers for this user */
    public var addresses: [Contact]?
    /** The current state for this user. */
    public var state: State?
    public var title: String?
    public var username: String?
    public var manager: User?
    public var images: [UserImage]?
    /** Required when updating a user, this value should be the current version of the user.  The current version can be obtained with a GET on the user before doing a PATCH. */
    public var version: Int?
    public var certifications: [String]?
    public var biography: Biography?
    public var employerInfo: EmployerInfo?
    /** Preferred full name of the agent */
    public var preferredName: String?
    /** ACD routing status */
    public var routingStatus: RoutingStatus?
    /** Active presence */
    public var presence: UserPresence?
    /** Integration presence */
    public var integrationPresence: UserPresence?
    /** Summary of conversion statistics for conversation types. */
    public var conversationSummary: UserConversationSummary?
    /** Determine if out of office is enabled */
    public var outOfOffice: OutOfOffice?
    /** Current geolocation position */
    public var geolocation: Geolocation?
    /** Effective, default, and last station information */
    public var station: UserStations?
    /** Roles and permissions assigned to the user */
    public var authorization: UserAuthorization?
    /** Profile skills possessed by the user */
    public var profileSkills: [String]?
    /** The user placement at each site location. */
    public var locations: [Location]?
    /** The groups the user is a member of */
    public var groups: [Group]?
    /** The team the user is a member of */
    public var team: Team?
    /** Routing (ACD) skills possessed by the user */
    public var skills: [UserRoutingSkill]?
    /** Routing (ACD) languages possessed by the user */
    public var languages: [UserRoutingLanguage]?
    /** acd auto answer */
    public var acdAutoAnswer: Bool?
    /** preferred language by the user */
    public var languagePreference: String?
    public var lastTokenIssued: OAuthLastTokenIssued?
    /** The last time the user logged in using username and password. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateLastLogin: Date?
    public var trustUserDetails: TrustUserDetails?

    public init(_id: String?, name: String?, division: Division?, chat: Chat?, department: String?, email: String?, primaryContactInfo: [Contact]?, addresses: [Contact]?, state: State?, title: String?, username: String?, manager: User?, images: [UserImage]?, version: Int?, certifications: [String]?, biography: Biography?, employerInfo: EmployerInfo?, preferredName: String?, routingStatus: RoutingStatus?, presence: UserPresence?, integrationPresence: UserPresence?, conversationSummary: UserConversationSummary?, outOfOffice: OutOfOffice?, geolocation: Geolocation?, station: UserStations?, authorization: UserAuthorization?, profileSkills: [String]?, locations: [Location]?, groups: [Group]?, team: Team?, skills: [UserRoutingSkill]?, languages: [UserRoutingLanguage]?, acdAutoAnswer: Bool?, languagePreference: String?, lastTokenIssued: OAuthLastTokenIssued?, dateLastLogin: Date?, trustUserDetails: TrustUserDetails?) {
        self._id = _id
        self.name = name
        self.division = division
        self.chat = chat
        self.department = department
        self.email = email
        self.primaryContactInfo = primaryContactInfo
        self.addresses = addresses
        self.state = state
        self.title = title
        self.username = username
        self.manager = manager
        self.images = images
        self.version = version
        self.certifications = certifications
        self.biography = biography
        self.employerInfo = employerInfo
        self.preferredName = preferredName
        self.routingStatus = routingStatus
        self.presence = presence
        self.integrationPresence = integrationPresence
        self.conversationSummary = conversationSummary
        self.outOfOffice = outOfOffice
        self.geolocation = geolocation
        self.station = station
        self.authorization = authorization
        self.profileSkills = profileSkills
        self.locations = locations
        self.groups = groups
        self.team = team
        self.skills = skills
        self.languages = languages
        self.acdAutoAnswer = acdAutoAnswer
        self.languagePreference = languagePreference
        self.lastTokenIssued = lastTokenIssued
        self.dateLastLogin = dateLastLogin
        self.trustUserDetails = trustUserDetails
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case chat
        case department
        case email
        case primaryContactInfo
        case addresses
        case state
        case title
        case username
        case manager
        case images
        case version
        case certifications
        case biography
        case employerInfo
        case preferredName
        case routingStatus
        case presence
        case integrationPresence
        case conversationSummary
        case outOfOffice
        case geolocation
        case station
        case authorization
        case profileSkills
        case locations
        case groups
        case team
        case skills
        case languages
        case acdAutoAnswer
        case languagePreference
        case lastTokenIssued
        case dateLastLogin
        case trustUserDetails
    }


}




public class TrustUserDetails: Codable {





    /** Date Trust User was added. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** User that added trusted user. */
    public var createdBy: OrgUser?

    public init(dateCreated: Date?, createdBy: OrgUser?) {
        self.dateCreated = dateCreated
        self.createdBy = createdBy
    }


}




public class TrusteeAuthorization: Codable {



    /** Permissions that the trustee user has in the trustor organization */
    public var permissions: [String]?

    public init(permissions: [String]?) {
        self.permissions = permissions
    }


}




public class Trustor: Codable {















    /** Organization Id for this trust. */
    public var _id: String?
    /** If disabled no trustee user will have access, even if they were previously added. */
    public var enabled: Bool?
    /** Date Trust was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** User that created trust. */
    public var createdBy: OrgUser?
    /** Organization associated with this trust. */
    public var organization: Organization?
    /** Authorization for the trustee user has in this trustor organization */
    public var authorization: TrusteeAuthorization?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, enabled: Bool?, dateCreated: Date?, createdBy: OrgUser?, organization: Organization?, authorization: TrusteeAuthorization?, selfUri: String?) {
        self._id = _id
        self.enabled = enabled
        self.dateCreated = dateCreated
        self.createdBy = createdBy
        self.organization = organization
        self.authorization = authorization
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case enabled
        case dateCreated
        case createdBy
        case organization
        case authorization
        case selfUri
    }


}




public class TwitterIntegration: Codable {



















    public enum Tier: String, Codable { 
        case premium = "premium"
        case enterprise = "enterprise"
    }















    public enum CreateStatus: String, Codable { 
        case initiated = "Initiated"
        case completed = "Completed"
        case error = "Error"
    }





    /** A unique Integration Id */
    public var _id: String?
    /** The name of the Twitter Integration */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    public var messagingSetting: MessagingSettingReference?
    /** The Access Token Key from Twitter messenger */
    public var accessTokenKey: String?
    /** The Consumer Key from Twitter messenger */
    public var consumerKey: String?
    /** The Username from Twitter */
    public var username: String?
    /** The UserId from Twitter */
    public var userId: String?
    /** The status of the Twitter Integration */
    public var status: String?
    /** The type of twitter account to be used for the integration */
    public var tier: Tier?
    /** The Twitter environment name, e.g.: env-beta (required for premium tier) */
    public var envName: String?
    /** The recipient associated to the Twitter Integration. This recipient is used to associate a flow to an integration */
    public var recipient: DomainEntityRef?
    /** Date this Integration was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date this Integration was modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** User reference that created this Integration */
    public var createdBy: DomainEntityRef?
    /** User reference that last modified this Integration */
    public var modifiedBy: DomainEntityRef?
    /** Version number required for updates. */
    public var version: Int?
    /** Status of asynchronous create operation */
    public var createStatus: CreateStatus?
    /** Error information returned, if createStatus is set to Error */
    public var createError: ErrorBody?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingReference?, accessTokenKey: String?, consumerKey: String?, username: String?, userId: String?, status: String?, tier: Tier?, envName: String?, recipient: DomainEntityRef?, dateCreated: Date?, dateModified: Date?, createdBy: DomainEntityRef?, modifiedBy: DomainEntityRef?, version: Int?, createStatus: CreateStatus?, createError: ErrorBody?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.accessTokenKey = accessTokenKey
        self.consumerKey = consumerKey
        self.username = username
        self.userId = userId
        self.status = status
        self.tier = tier
        self.envName = envName
        self.recipient = recipient
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.version = version
        self.createStatus = createStatus
        self.createError = createError
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case accessTokenKey
        case consumerKey
        case username
        case userId
        case status
        case tier
        case envName
        case recipient
        case dateCreated
        case dateModified
        case createdBy
        case modifiedBy
        case version
        case createStatus
        case createError
        case selfUri
    }


}




public class TwitterIntegrationRequest: Codable {

















    public enum Tier: String, Codable { 
        case premium = "premium"
        case enterprise = "enterprise"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the Twitter Integration */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    /** Defines the message settings to be applied for this integration */
    public var messagingSetting: MessagingSettingRequestReference?
    /** The Access Token Key from Twitter messenger */
    public var accessTokenKey: String?
    /** The Access Token Secret from Twitter messenger */
    public var accessTokenSecret: String?
    /** The Consumer Key from Twitter messenger */
    public var consumerKey: String?
    /** The Consumer Secret from Twitter messenger */
    public var consumerSecret: String?
    /** The type of twitter account to be used for the integration */
    public var tier: Tier?
    /** The Twitter environment name, e.g.: env-beta (required for premium tier) */
    public var envName: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingRequestReference?, accessTokenKey: String?, accessTokenSecret: String?, consumerKey: String?, consumerSecret: String?, tier: Tier?, envName: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.accessTokenKey = accessTokenKey
        self.accessTokenSecret = accessTokenSecret
        self.consumerKey = consumerKey
        self.consumerSecret = consumerSecret
        self.tier = tier
        self.envName = envName
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case accessTokenKey
        case accessTokenSecret
        case consumerKey
        case consumerSecret
        case tier
        case envName
        case selfUri
    }


}




public class UnansweredPhraseGroupUpdateResponse: Codable {





    /** List of phrases and documents linked in the patch request */
    public var phraseAssociations: [PhraseAssociations]?
    /** Knowledge base unanswered group response */
    public var group: UnansweredGroup?

    public init(phraseAssociations: [PhraseAssociations]?, group: UnansweredGroup?) {
        self.phraseAssociations = phraseAssociations
        self.group = group
    }


}




public class UnifiedGeneralTopic: Codable {



    public enum Status: String, Codable { 
        case deprecated = "Deprecated"
        case outdated = "Outdated"
        case modified = "Modified"
        case upToDate = "UpToDate"
        case toBeCreated = "ToBeCreated"
        case createdByUser = "CreatedByUser"
    }

    public var name: String?
    public var status: Status?

    public init(name: String?, status: Status?) {
        self.name = name
        self.status = status
    }


}




public class UnreadFields: Codable {



    /** The new unread state of the alert */
    public var state: Bool?

    public init(state: Bool?) {
        self.state = state
    }


}




public class UnreadStatus: Codable {



    /** Sets if the alert is read or unread. */
    public var unread: Bool?

    public init(unread: Bool?) {
        self.unread = unread
    }


}




public class UpdateBusinessUnitRequest: Codable {







    /** The name of the business unit */
    public var name: String?
    /** The ID of the division to which the business unit should be moved */
    public var divisionId: String?
    /** Configuration for the business unit */
    public var settings: UpdateBusinessUnitSettingsRequest?

    public init(name: String?, divisionId: String?, settings: UpdateBusinessUnitSettingsRequest?) {
        self.name = name
        self.divisionId = divisionId
        self.settings = settings
    }


}



/** Definition of an Action Draft to be created or updated. */

public class UpdateDraftInput: Codable {













    /** Category of action, Can be up to 256 characters long */
    public var category: String?
    /** Name of action, Can be up to 256 characters long */
    public var name: String?
    /** Configuration to support request and response processing */
    public var config: ActionConfig?
    /** Action contract */
    public var contract: ActionContractInput?
    /** Indication of whether or not the action is designed to accept sensitive data */
    public var secure: Bool?
    /** Version of current Draft */
    public var version: Int?

    public init(category: String?, name: String?, config: ActionConfig?, contract: ActionContractInput?, secure: Bool?, version: Int?) {
        self.category = category
        self.name = name
        self.config = config
        self.contract = contract
        self.secure = secure
        self.version = version
    }


}




public class UpdateNotificationsRequest: Codable {



    /** The notifications to update */
    public var entities: [WfmUserNotification]?

    public init(entities: [WfmUserNotification]?) {
        self.entities = entities
    }


}




public class UpdateUser: Codable {

































    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var chat: Chat?
    public var department: String?
    public var email: String?
    /** The address(s) used for primary contact. Updates to the corresponding address in the addresses list will be reflected here. */
    public var primaryContactInfo: [Contact]?
    /** Email address, phone number, and/or extension for this user. One entry is allowed per media type */
    public var addresses: [Contact]?
    public var title: String?
    public var username: String?
    /** Preferred full name of agent */
    public var preferredName: String?
    public var manager: String?
    public var images: [UserImage]?
    /** This value should be the current version of the user. The current version can be obtained with a GET on the user before doing a PATCH. */
    public var version: Int?
    /** Profile skills possessed by the user */
    public var profileSkills: [String]?
    /** The user placement at each site location. */
    public var locations: [Location]?
    /** The groups the user is a member of */
    public var groups: [Group]?
    /** The state of the user. This property can be used to restore a deleted user or transition between active and inactive. If specified, it is the only modifiable field. */
    public var state: State?
    /** The value that denotes if acdAutoAnswer is set on the user */
    public var acdAutoAnswer: Bool?
    public var certifications: [String]?
    public var biography: Biography?
    public var employerInfo: EmployerInfo?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, chat: Chat?, department: String?, email: String?, primaryContactInfo: [Contact]?, addresses: [Contact]?, title: String?, username: String?, preferredName: String?, manager: String?, images: [UserImage]?, version: Int?, profileSkills: [String]?, locations: [Location]?, groups: [Group]?, state: State?, acdAutoAnswer: Bool?, certifications: [String]?, biography: Biography?, employerInfo: EmployerInfo?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.chat = chat
        self.department = department
        self.email = email
        self.primaryContactInfo = primaryContactInfo
        self.addresses = addresses
        self.title = title
        self.username = username
        self.preferredName = preferredName
        self.manager = manager
        self.images = images
        self.version = version
        self.profileSkills = profileSkills
        self.locations = locations
        self.groups = groups
        self.state = state
        self.acdAutoAnswer = acdAutoAnswer
        self.certifications = certifications
        self.biography = biography
        self.employerInfo = employerInfo
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case chat
        case department
        case email
        case primaryContactInfo
        case addresses
        case title
        case username
        case preferredName
        case manager
        case images
        case version
        case profileSkills
        case locations
        case groups
        case state
        case acdAutoAnswer
        case certifications
        case biography
        case employerInfo
        case selfUri
    }


}




public class Usage: Codable {



    public var types: [UsageItem]?

    public init(types: [UsageItem]?) {
        self.types = types
    }


}




public class UserAgentInfo: Codable {







    /** The firmware version of the phone. */
    public var firmwareVersion: String?
    /** The manufacturer of the phone. */
    public var manufacturer: String?
    /** The model of the phone. */
    public var model: String?

    public init(firmwareVersion: String?, manufacturer: String?, model: String?) {
        self.firmwareVersion = firmwareVersion
        self.manufacturer = manufacturer
        self.model = model
    }


}




public class UserAggregateQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [UserAggregateQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [UserAggregateQueryPredicate]?

    public init(type: ModelType?, clauses: [UserAggregateQueryClause]?, predicates: [UserAggregateQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class UserAppEntityListing: Codable {





















    public var entities: [UserApp]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [UserApp]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class UserAvailableTimes: Codable {





    /** User reference */
    public var user: UserReference?
    /** Periods of availability to schedule coaching appointment for an user */
    public var availableTimes: [AvailableTime]?

    public init(user: UserReference?, availableTimes: [AvailableTime]?) {
        self.user = user
        self.availableTimes = availableTimes
    }


}




public class UserGreetingEventGreeting: Codable {















    public var _id: String?
    public var name: String?
    public var type: String?
    public var ownerType: String?
    public var owner: UserGreetingEventGreetingOwner?
    public var greetingAudioFile: UserGreetingEventGreetingAudioFile?
    public var audioTTS: String?

    public init(_id: String?, name: String?, type: String?, ownerType: String?, owner: UserGreetingEventGreetingOwner?, greetingAudioFile: UserGreetingEventGreetingAudioFile?, audioTTS: String?) {
        self._id = _id
        self.name = name
        self.type = type
        self.ownerType = ownerType
        self.owner = owner
        self.greetingAudioFile = greetingAudioFile
        self.audioTTS = audioTTS
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case type
        case ownerType
        case owner
        case greetingAudioFile
        case audioTTS
    }


}




public class UserInsightsTrendMetricItem: Codable {





    /** The gamification metric for the trend */
    public var metric: AddressableEntityRef?
    /** Trends for the metric */
    public var trends: UserInsightsTrends?

    public init(metric: AddressableEntityRef?, trends: UserInsightsTrends?) {
        self.metric = metric
        self.trends = trends
    }


}




public class UserLanguageEntityListing: Codable {





















    public var entities: [UserRoutingLanguage]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [UserRoutingLanguage]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class UserObservationQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case userid = "userId"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension predicates */
    public var value: String?
    /** Right hand side for dimension predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case _operator = "operator"
        case value
        case range
    }


}




public class UserPresence: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Deprecated - The sourceID field should be used as a replacement. */
    public var source: String?
    /** Represents the ID of a registered source */
    public var sourceId: String?
    /** A boolean used to tell whether or not to set this presence source as the primary on a PATCH */
    public var primary: Bool?
    public var presenceDefinition: PresenceDefinition?
    public var message: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, source: String?, sourceId: String?, primary: Bool?, presenceDefinition: PresenceDefinition?, message: String?, modifiedDate: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.source = source
        self.sourceId = sourceId
        self.primary = primary
        self.presenceDefinition = presenceDefinition
        self.message = message
        self.modifiedDate = modifiedDate
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case source
        case sourceId
        case primary
        case presenceDefinition
        case message
        case modifiedDate
        case selfUri
    }


}




public class UserProfile: Codable {





    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The state of the user resource */
    public var state: State?
    /** Datetime of the last modification. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The version of the group resource */
    public var version: Int64?
    /** User information expansions */
    public var expands: UserExpands?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, state: State?, dateModified: Date?, version: Int64?, expands: UserExpands?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.state = state
        self.dateModified = dateModified
        self.version = version
        self.expands = expands
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case state
        case dateModified
        case version
        case expands
        case selfUri
    }


}




public class UserReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}



/** Error information that the Public API will receive in a response body. This allows backend services to pass an error message to consumers of the Public API. */

public class UserRoutingStatusErrorInfo: Codable {













    /** A code unique to this error. Typically prefixed with the service that originated the error. For example CONFIG_USER_NOT_FOUND */
    public var errorCode: String?
    /** The HTTP status code for this message. If left blank the status code from the HTTP response is used. */
    public var status: Int?
    /** The correlation Id or context Id for this message. If left blank the Public API will look at the HTTP response header 'ININ-Correlation-Id' instead. */
    public var correlationId: String?
    /** A customer friendly message. This should be a complete sentence, use proper grammar and only include information useful to a customer. This is not a dev message and should not include things like Org Id */
    public var userMessage: String?
    /** This is the same as userMessage except it uses template fields for variable replacement. For instance: 'User {username} was not found' */
    public var userParamsMessage: String?
    /** Used in conjunction with userParamsMessage. These are the template parameters. For instance: UserParam.key = 'username', UserParam.value = 'chuck.pulfer' */
    public var userParams: [UserRoutingStatusUserParam]?

    public init(errorCode: String?, status: Int?, correlationId: String?, userMessage: String?, userParamsMessage: String?, userParams: [UserRoutingStatusUserParam]?) {
        self.errorCode = errorCode
        self.status = status
        self.correlationId = correlationId
        self.userMessage = userMessage
        self.userParamsMessage = userParamsMessage
        self.userParams = userParams
    }


}




public class UserRoutingStatusRoutingStatus: Codable {

    public enum Status: String, Codable { 
        case offQueue = "OFF_QUEUE"
        case idle = "IDLE"
        case interacting = "INTERACTING"
        case notResponding = "NOT_RESPONDING"
        case communicating = "COMMUNICATING"
    }



    /** Indicates the Routing State of the agent. */
    public var status: Status?
    /** The timestamp when the agent went into this state. */
    public var startTime: Date?

    public init(status: Status?, startTime: Date?) {
        self.status = status
        self.startTime = startTime
    }


}




public class UserRoutingStatusUserRoutingStatus: Codable {







    /** The unique identifier of the user. */
    public var _id: String?
    public var routingStatus: UserRoutingStatusRoutingStatus?
    public var errorInfo: UserRoutingStatusErrorInfo?

    public init(_id: String?, routingStatus: UserRoutingStatusRoutingStatus?, errorInfo: UserRoutingStatusErrorInfo?) {
        self._id = _id
        self.routingStatus = routingStatus
        self.errorInfo = errorInfo
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case routingStatus
        case errorInfo
    }


}




public class UserStartDetailEventTopicUserStartEvent: Codable {









    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
    }



    public enum Direction: String, Codable { 
        case unknown = "UNKNOWN"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }

















    public enum MessageType: String, Codable { 
        case unknown = "UNKNOWN"
        case sms = "SMS"
        case twitter = "TWITTER"
        case facebook = "FACEBOOK"
        case line = "LINE"
        case whatsapp = "WHATSAPP"
        case webmessaging = "WEBMESSAGING"
        case _open = "OPEN"
        case instagram = "INSTAGRAM"
    }











    public var eventTime: Int?
    public var conversationId: String?
    public var participantId: String?
    public var sessionId: String?
    public var mediaType: MediaType?
    public var provider: String?
    public var direction: Direction?
    public var ani: String?
    public var dnis: String?
    public var addressTo: String?
    public var addressFrom: String?
    public var callbackUserName: String?
    public var callbackNumbers: [String]?
    public var callbackScheduledTime: Int?
    public var subject: String?
    public var messageType: MessageType?
    public var userId: String?
    public var divisionId: String?
    public var queueId: String?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?

    public init(eventTime: Int?, conversationId: String?, participantId: String?, sessionId: String?, mediaType: MediaType?, provider: String?, direction: Direction?, ani: String?, dnis: String?, addressTo: String?, addressFrom: String?, callbackUserName: String?, callbackNumbers: [String]?, callbackScheduledTime: Int?, subject: String?, messageType: MessageType?, userId: String?, divisionId: String?, queueId: String?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.sessionId = sessionId
        self.mediaType = mediaType
        self.provider = provider
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.addressTo = addressTo
        self.addressFrom = addressFrom
        self.callbackUserName = callbackUserName
        self.callbackNumbers = callbackNumbers
        self.callbackScheduledTime = callbackScheduledTime
        self.subject = subject
        self.messageType = messageType
        self.userId = userId
        self.divisionId = divisionId
        self.queueId = queueId
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
    }


}




public class UserStationChangeTopicUser: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class UserTransferEvent: Codable {







    public enum TransferType: String, Codable { 
        case attended = "Attended"
        case unattended = "Unattended"
    }











    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** Indicates the desired type of transfer. */
    public var transferType: TransferType?
    /** The id (V4 UUID) used by the external platform to refer to the transfer in subsequent Transfer events. */
    public var commandId: String?
    /** The id (V4 UUID) of the communication representing the participant that is initiating the transfer. */
    public var initiatingCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred away from. In many cases this will be the same as the `initiatingCommunicationId`. */
    public var targetCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred. */
    public var objectCommunicationId: String?
    /** The id (V4 UUID) of the desired destination user that the object communication should be transferred to. */
    public var destinationUserId: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, transferType: TransferType?, commandId: String?, initiatingCommunicationId: String?, targetCommunicationId: String?, objectCommunicationId: String?, destinationUserId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.transferType = transferType
        self.commandId = commandId
        self.initiatingCommunicationId = initiatingCommunicationId
        self.targetCommunicationId = targetCommunicationId
        self.objectCommunicationId = objectCommunicationId
        self.destinationUserId = destinationUserId
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationContentLocation: Codable {











    public var url: String?
    public var address: String?
    public var text: String?
    public var latitude: Double?
    public var longitude: Double?

    public init(url: String?, address: String?, text: String?, latitude: Double?, longitude: Double?) {
        self.url = url
        self.address = address
        self.text = text
        self.latitude = latitude
        self.longitude = longitude
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationContentStory: Codable {

    public enum ModelType: String, Codable { 
        case mention = "Mention"
        case reply = "Reply"
    }





    public var type: ModelType?
    public var url: String?
    public var replyToId: String?

    public init(type: ModelType?, url: String?, replyToId: String?) {
        self.type = type
        self.url = url
        self.replyToId = replyToId
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationMessagingFromRecipient: Codable {





    public enum IdType: String, Codable { 
        case email = "Email"
        case phone = "Phone"
        case opaque = "Opaque"
    }











    public var nickname: String?
    public var _id: String?
    public var idType: IdType?
    public var image: String?
    public var firstName: String?
    public var lastName: String?
    public var email: String?
    public var additionalIds: [V2ConversationMessageTypingEventForUserTopicConversationRecipientAdditionalIdentifier]?

    public init(nickname: String?, _id: String?, idType: IdType?, image: String?, firstName: String?, lastName: String?, email: String?, additionalIds: [V2ConversationMessageTypingEventForUserTopicConversationRecipientAdditionalIdentifier]?) {
        self.nickname = nickname
        self._id = _id
        self.idType = idType
        self.image = image
        self.firstName = firstName
        self.lastName = lastName
        self.email = email
        self.additionalIds = additionalIds
    }

    public enum CodingKeys: String, CodingKey { 
        case nickname
        case _id = "id"
        case idType
        case image
        case firstName
        case lastName
        case email
        case additionalIds
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationNotificationTemplateBody: Codable {





    public var text: String?
    public var parameters: [V2ConversationMessageTypingEventForUserTopicConversationNotificationTemplateParameter]?

    public init(text: String?, parameters: [V2ConversationMessageTypingEventForUserTopicConversationNotificationTemplateParameter]?) {
        self.text = text
        self.parameters = parameters
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationNotificationTemplateFooter: Codable {



    public var text: String?

    public init(text: String?) {
        self.text = text
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationReason: Codable {

    public enum Code: String, Codable { 
        case messageExpired = "MessageExpired"
        case rateLimited = "RateLimited"
        case messageNotAllowed = "MessageNotAllowed"
        case generalError = "GeneralError"
        case unsupportedMessage = "UnsupportedMessage"
        case unknownMessage = "UnknownMessage"
        case invalidMessageStructure = "InvalidMessageStructure"
        case invalidDestination = "InvalidDestination"
        case serverError = "ServerError"
        case mediaTypeNotAllowed = "MediaTypeNotAllowed"
        case invalidMediaContentLength = "InvalidMediaContentLength"
        case recipientOptedOut = "RecipientOptedOut"
    }



    public var code: Code?
    public var message: String?

    public init(code: Code?, message: String?) {
        self.code = code
        self.message = message
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationContentActions: Codable {







    public var url: String?
    public var urlTarget: String?
    public var textback: String?

    public init(url: String?, urlTarget: String?, textback: String?) {
        self.url = url
        self.urlTarget = urlTarget
        self.textback = textback
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationContentGeneric: Codable {













    public var title: String?
    public var _description: String?
    public var image: String?
    public var video: String?
    public var actions: V2ConversationMessageTypingEventForWorkflowTopicConversationContentActions?
    public var components: [V2ConversationMessageTypingEventForWorkflowTopicConversationButtonComponent]?

    public init(title: String?, _description: String?, image: String?, video: String?, actions: V2ConversationMessageTypingEventForWorkflowTopicConversationContentActions?, components: [V2ConversationMessageTypingEventForWorkflowTopicConversationButtonComponent]?) {
        self.title = title
        self._description = _description
        self.image = image
        self.video = video
        self.actions = actions
        self.components = components
    }

    public enum CodingKeys: String, CodingKey { 
        case title
        case _description = "description"
        case image
        case video
        case actions
        case components
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationMessagingToRecipient: Codable {





    public enum IdType: String, Codable { 
        case email = "Email"
        case phone = "Phone"
        case opaque = "Opaque"
    }











    public var nickname: String?
    public var _id: String?
    public var idType: IdType?
    public var image: String?
    public var firstName: String?
    public var lastName: String?
    public var email: String?
    public var additionalIds: [V2ConversationMessageTypingEventForWorkflowTopicConversationRecipientAdditionalIdentifier]?

    public init(nickname: String?, _id: String?, idType: IdType?, image: String?, firstName: String?, lastName: String?, email: String?, additionalIds: [V2ConversationMessageTypingEventForWorkflowTopicConversationRecipientAdditionalIdentifier]?) {
        self.nickname = nickname
        self._id = _id
        self.idType = idType
        self.image = image
        self.firstName = firstName
        self.lastName = lastName
        self.email = email
        self.additionalIds = additionalIds
    }

    public enum CodingKeys: String, CodingKey { 
        case nickname
        case _id = "id"
        case idType
        case image
        case firstName
        case lastName
        case email
        case additionalIds
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationNotificationTemplateParameter: Codable {





    public var name: String?
    public var text: String?

    public init(name: String?, text: String?) {
        self.name = name
        self.text = text
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicMessageData: Codable {





    public var conversationId: String?
    public var normalizedMessage: V2ConversationMessageTypingEventForWorkflowTopicConversationNormalizedMessage?

    public init(conversationId: String?, normalizedMessage: V2ConversationMessageTypingEventForWorkflowTopicConversationNormalizedMessage?) {
        self.conversationId = conversationId
        self.normalizedMessage = normalizedMessage
    }


}




public class V2FlowExecutionDataFlowidTopicFlowErrorWarningInfo: Codable {







    /** The reason a executionItem encountered an error or warning. */
    public var reason: String?
    /** If applicable, the executionId for the executionItem that invoked the error or warning. */
    public var executionId: String?
    /** If applicable, the objectId for the executionItem that invoked the error or warning. */
    public var objectId: String?

    public init(reason: String?, executionId: String?, objectId: String?) {
        self.reason = reason
        self.executionId = executionId
        self.objectId = objectId
    }


}



/** This contains contextual information about an invoking entity. */

public class V2FlowExecutionDataFlowidTopicProcessAutomation: Codable {





    /** The identifier of the process automation trigger that invoked this flow. */
    public var triggerId: String?
    /** The name of the process automation trigger that invoked this flow. */
    public var triggerName: String?

    public init(triggerId: String?, triggerName: String?) {
        self.triggerId = triggerId
        self.triggerName = triggerName
    }


}




public class V2MobiusRulesTopicRule: Codable {







    public enum ModelType: String, Codable { 
        case conversationMetrics = "ConversationMetrics"
        case userPresence = "UserPresence"
        case workforceManagement = "WorkforceManagement"
        case unknown = "Unknown"
    }









    public enum Action: String, Codable { 
        case unknown = "UNKNOWN"
        case create = "CREATE"
        case update = "UPDATE"
        case delete = "DELETE"
    }





    public var _id: UUID?
    public var userId: UUID?
    public var name: String?
    public var type: ModelType?
    public var notifications: [V2MobiusRulesTopicAlertNotification]?
    public var conditions: V2MobiusRulesTopicCondition?
    public var enabled: Bool?
    public var inAlarm: Bool?
    public var action: Action?
    public var dateCreated: Date?
    public var sendExitingAlarmNotification: Bool?

    public init(_id: UUID?, userId: UUID?, name: String?, type: ModelType?, notifications: [V2MobiusRulesTopicAlertNotification]?, conditions: V2MobiusRulesTopicCondition?, enabled: Bool?, inAlarm: Bool?, action: Action?, dateCreated: Date?, sendExitingAlarmNotification: Bool?) {
        self._id = _id
        self.userId = userId
        self.name = name
        self.type = type
        self.notifications = notifications
        self.conditions = conditions
        self.enabled = enabled
        self.inAlarm = inAlarm
        self.action = action
        self.dateCreated = dateCreated
        self.sendExitingAlarmNotification = sendExitingAlarmNotification
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case userId
        case name
        case type
        case notifications
        case conditions
        case enabled
        case inAlarm
        case action
        case dateCreated
        case sendExitingAlarmNotification
    }


}




public class ValidateWorkPlanResponse: Codable {







    /** The work plan reference associated with this response */
    public var workPlan: WorkPlanReference?
    /** Whether the work plan is valid or not */
    public var valid: Bool?
    /** Validation messages for this work plan */
    public var messages: ValidateWorkPlanMessages?

    public init(workPlan: WorkPlanReference?, valid: Bool?, messages: ValidateWorkPlanMessages?) {
        self.workPlan = workPlan
        self.valid = valid
        self.messages = messages
    }


}




public class ValidationLimits: Codable {













    public var minLength: MinLength?
    public var maxLength: MaxLength?
    public var minItems: MinLength?
    public var maxItems: MaxLength?
    public var minimum: MinLength?
    public var maximum: MaxLength?

    public init(minLength: MinLength?, maxLength: MaxLength?, minItems: MinLength?, maxItems: MaxLength?, minimum: MinLength?, maximum: MaxLength?) {
        self.minLength = minLength
        self.maxLength = maxLength
        self.minItems = minItems
        self.maxItems = maxItems
        self.minimum = minimum
        self.maximum = maximum
    }


}




public class ValidationServiceRequest: Codable {





    /** The last day of the data you are importing. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateImportEnded: Date?
    /** S3 key for the uploaded file */
    public var uploadKey: String?

    public init(dateImportEnded: Date?, uploadKey: String?) {
        self.dateImportEnded = dateImportEnded
        self.uploadKey = uploadKey
    }


}




public class Voicemail: Codable {



    public enum UploadStatus: String, Codable { 
        case pending = "pending"
        case complete = "complete"
        case failed = "failed"
        case timeout = "timeout"
        case _none = "none"
    }

    /** The voicemail id */
    public var _id: String?
    /** current state of the voicemail upload */
    public var uploadStatus: UploadStatus?

    public init(_id: String?, uploadStatus: UploadStatus?) {
        self._id = _id
        self.uploadStatus = uploadStatus
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case uploadStatus
    }


}




public class VoicemailMessagesTopicVoicemailMessage: Codable {

































    public var _id: String?
    public var read: Bool?
    public var audioRecordingDurationSeconds: Int?
    public var audioRecordingSizeBytes: Int?
    public var createdDate: Date?
    public var modifiedDate: Date?
    public var createdDateString: String?
    public var callerAddress: String?
    public var callerName: String?
    public var action: String?
    public var note: String?
    public var deleted: Bool?
    public var modifiedByUserId: String?
    public var copiedTo: [VoicemailMessagesTopicVoicemailCopyRecord]?
    public var copiedFrom: VoicemailMessagesTopicVoicemailCopyRecord?
    public var modifiedDateString: String?

    public init(_id: String?, read: Bool?, audioRecordingDurationSeconds: Int?, audioRecordingSizeBytes: Int?, createdDate: Date?, modifiedDate: Date?, createdDateString: String?, callerAddress: String?, callerName: String?, action: String?, note: String?, deleted: Bool?, modifiedByUserId: String?, copiedTo: [VoicemailMessagesTopicVoicemailCopyRecord]?, copiedFrom: VoicemailMessagesTopicVoicemailCopyRecord?, modifiedDateString: String?) {
        self._id = _id
        self.read = read
        self.audioRecordingDurationSeconds = audioRecordingDurationSeconds
        self.audioRecordingSizeBytes = audioRecordingSizeBytes
        self.createdDate = createdDate
        self.modifiedDate = modifiedDate
        self.createdDateString = createdDateString
        self.callerAddress = callerAddress
        self.callerName = callerName
        self.action = action
        self.note = note
        self.deleted = deleted
        self.modifiedByUserId = modifiedByUserId
        self.copiedTo = copiedTo
        self.copiedFrom = copiedFrom
        self.modifiedDateString = modifiedDateString
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case read
        case audioRecordingDurationSeconds
        case audioRecordingSizeBytes
        case createdDate
        case modifiedDate
        case createdDateString
        case callerAddress
        case callerName
        case action
        case note
        case deleted
        case modifiedByUserId
        case copiedTo
        case copiedFrom
        case modifiedDateString
    }


}




public class VoicemailsSearchResponse: Codable {



















    /** The total number of results found */
    public var total: Int64?
    /** The total number of pages */
    public var pageCount: Int?
    /** The current page size */
    public var pageSize: Int?
    /** The current page number */
    public var pageNumber: Int?
    /** Q64 value for the previous page of results */
    public var previousPage: String?
    /** Q64 value for the current page of results */
    public var currentPage: String?
    /** Q64 value for the next page of results */
    public var nextPage: String?
    /** Resource types the search was performed against */
    public var types: [String]?
    /** Search results */
    public var results: [VoicemailMessage]?

    public init(total: Int64?, pageCount: Int?, pageSize: Int?, pageNumber: Int?, previousPage: String?, currentPage: String?, nextPage: String?, types: [String]?, results: [VoicemailMessage]?) {
        self.total = total
        self.pageCount = pageCount
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.previousPage = previousPage
        self.currentPage = currentPage
        self.nextPage = nextPage
        self.types = types
        self.results = results
    }


}




public class WebChatMemberInfo: Codable {















    public enum Role: String, Codable { 
        case agent = "AGENT"
        case customer = "CUSTOMER"
        case workflow = "WORKFLOW"
        case acd = "ACD"
    }









    public enum State: String, Codable { 
        case connected = "CONNECTED"
        case disconnected = "DISCONNECTED"
        case alerting = "ALERTING"
    }

    /** The communicationId of this member. */
    public var _id: String?
    /** The display name of the member. */
    public var displayName: String?
    /** The first name of the member. */
    public var firstName: String?
    /** The last name of the member. */
    public var lastName: String?
    /** The email address of the member. */
    public var email: String?
    /** The phone number of the member. */
    public var phoneNumber: String?
    /** The url to the avatar image of the member. */
    public var avatarImageUrl: String?
    /** The role of the member, one of [agent, customer, acd, workflow] */
    public var role: Role?
    /** The time the member joined the conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var joinDate: Date?
    /** The time the member left the conversation, or null if the member is still active in the conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var leaveDate: Date?
    /** If true, the guest member is an authenticated guest. */
    public var authenticatedGuest: Bool?
    /** Any custom fields of information pertaining to this member. */
    public var customFields: [String:String]?
    /** The connection state of this member. */
    public var state: State?

    public init(_id: String?, displayName: String?, firstName: String?, lastName: String?, email: String?, phoneNumber: String?, avatarImageUrl: String?, role: Role?, joinDate: Date?, leaveDate: Date?, authenticatedGuest: Bool?, customFields: [String:String]?, state: State?) {
        self._id = _id
        self.displayName = displayName
        self.firstName = firstName
        self.lastName = lastName
        self.email = email
        self.phoneNumber = phoneNumber
        self.avatarImageUrl = avatarImageUrl
        self.role = role
        self.joinDate = joinDate
        self.leaveDate = leaveDate
        self.authenticatedGuest = authenticatedGuest
        self.customFields = customFields
        self.state = state
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case displayName
        case firstName
        case lastName
        case email
        case phoneNumber
        case avatarImageUrl
        case role
        case joinDate
        case leaveDate
        case authenticatedGuest
        case customFields
        case state
    }


}



/** Details about the active configuration on a deployment */

public class WebDeploymentActiveConfigurationOnDeployment: Codable {





    /** The active configuration on a deployment */
    public var configurationVersion: WebDeploymentConfigurationVersion?
    /** The web deployment associated with the active configuration */
    public var deployment: WebDeployment?

    public init(configurationVersion: WebDeploymentConfigurationVersion?, deployment: WebDeployment?) {
        self.configurationVersion = configurationVersion
        self.deployment = deployment
    }


}




public class WebDeploymentHeadlessMode: Codable {



    /** Whether or not Headless Mode is enabled */
    public var enabled: Bool?

    public init(enabled: Bool?) {
        self.enabled = enabled
    }


}




public class WebDeploymentsConfigTopicWebMessagingConfigChangeEventBody: Codable {





    public enum Status: String, Codable { 
        case pending = "Pending"
        case active = "Active"
        case inactive = "Inactive"
        case error = "Error"
        case deleting = "Deleting"
    }

    public var _id: String?
    public var version: String?
    public var status: Status?

    public init(_id: String?, version: String?, status: Status?) {
        self._id = _id
        self.version = version
        self.status = status
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
        case status
    }


}



/** Message event element.  Examples include: system messages, typing indicators, cobrowse offerings. */

public class WebMessagingEvent: Codable {

    public enum EventType: String, Codable { 
        case coBrowse = "CoBrowse"
        case presence = "Presence"
    }





    /** Type of this event element */
    public var eventType: EventType?
    /** Cobrowse event. */
    public var coBrowse: WebMessagingEventCoBrowse?
    /** Presence event. */
    public var presence: WebMessagingEventPresence?

    public init(eventType: EventType?, coBrowse: WebMessagingEventCoBrowse?, presence: WebMessagingEventPresence?) {
        self.eventType = eventType
        self.coBrowse = coBrowse
        self.presence = presence
    }


}



/** A web messaging message */

public class WebMessagingMessage: Codable {





    public enum ModelType: String, Codable { 
        case text = "Text"
        case structured = "Structured"
        case receipt = "Receipt"
        case event = "Event"
    }







    public enum Direction: String, Codable { 
        case inbound = "Inbound"
        case outbound = "Outbound"
    }

    public enum OriginatingEntity: String, Codable { 
        case human = "Human"
        case bot = "Bot"
    }



    /** Unique ID of the message. This ID is generated by Messaging Platform. Message receipts will have the same ID as the message they reference. */
    public var _id: String?
    /** Channel-specific information that describes the message and the message channel/provider. */
    public var channel: WebMessagingChannel?
    /** Message type. */
    public var type: ModelType?
    /** Message text. */
    public var text: String?
    /** List of content elements. */
    public var content: [WebMessagingContent]?
    /** List of event elements. */
    public var events: [WebMessagingEvent]?
    /** The direction of the message.  Direction is always from the perspective of the Genesys Cloud platform.  An Inbound message is one sent from a guest to the Genesys Cloud Platform.  An Outbound message is one sent from the Genesys Cloud Platform to a guest. */
    public var direction: Direction?
    /** Specifies if this message was sent by a human agent or bot. The platform may use this to apply appropriate provider policies. */
    public var originatingEntity: OriginatingEntity?
    /** Additional metadata about this message. */
    public var metadata: [String:String]?

    public init(_id: String?, channel: WebMessagingChannel?, type: ModelType?, text: String?, content: [WebMessagingContent]?, events: [WebMessagingEvent]?, direction: Direction?, originatingEntity: OriginatingEntity?, metadata: [String:String]?) {
        self._id = _id
        self.channel = channel
        self.type = type
        self.text = text
        self.content = content
        self.events = events
        self.direction = direction
        self.originatingEntity = originatingEntity
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case channel
        case type
        case text
        case content
        case events
        case direction
        case originatingEntity
        case metadata
    }


}




public class WeekScheduleResponse: Codable {





    /** The result of the request. The value will be null if response is large */
    public var result: WeekSchedule?
    /** The url to fetch the result for large responses. The value is null if result contains the data */
    public var downloadUrl: String?

    public init(result: WeekSchedule?, downloadUrl: String?) {
        self.result = result
        self.downloadUrl = downloadUrl
    }


}




public class WeekShiftTradeListResponse: Codable {





    public var entities: [WeekShiftTradeResponse]?
    /** URL from which to fetch results for requests with a large result set. If populated, the downloaded data will conform to the same schema as would normally be returned, excepting downloaded data will never itself contain a downloadUrl */
    public var downloadUrl: String?

    public init(entities: [WeekShiftTradeResponse]?, downloadUrl: String?) {
        self.entities = entities
        self.downloadUrl = downloadUrl
    }


}




public class WfmAgentAdherenceExplanationChangedAgentTopicBusinessUnit: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmAgentAdherenceExplanationChangedBusinessUnitTopicBusinessUnit: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmBuIntradayDataUpdateTopicBuIntradayForecastData: Codable {





    public var offered: Double?
    public var averageHandleTimeSeconds: Double?

    public init(offered: Double?, averageHandleTimeSeconds: Double?) {
        self.offered = offered
        self.averageHandleTimeSeconds = averageHandleTimeSeconds
    }


}




public class WfmBuIntradayDataUpdateTopicBuIntradayScheduleData: Codable {



    public var onQueueTimeSeconds: Int?

    public init(onQueueTimeSeconds: Int?) {
        self.onQueueTimeSeconds = onQueueTimeSeconds
    }


}




public class WfmBuIntradayDataUpdateTopicBuScheduleReference: Codable {





    public var _id: String?
    public var weekDate: Date?

    public init(_id: String?, weekDate: Date?) {
        self._id = _id
        self.weekDate = weekDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
    }


}




public class WfmBuScheduleQueryResultTopicBuScheduleSearchResultNotification: Codable {







    public var operationId: String?
    public var businessUnitId: String?
    public var downloadUrl: String?

    public init(operationId: String?, businessUnitId: String?, downloadUrl: String?) {
        self.operationId = operationId
        self.businessUnitId = businessUnitId
        self.downloadUrl = downloadUrl
    }


}




public class WfmBuScheduleRunTopicBuScheduleReference: Codable {





    public var _id: String?
    public var weekDate: Date?

    public init(_id: String?, weekDate: Date?) {
        self._id = _id
        self.weekDate = weekDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
    }


}




public class WfmBuScheduleTopicBuScheduleGenerationResultSummary: Codable {









    public var failed: Bool?
    public var runId: String?
    public var messageCount: Int?
    public var messageSeverityCounts: [WfmBuScheduleTopicSchedulerMessageSeverityCount]?

    public init(failed: Bool?, runId: String?, messageCount: Int?, messageSeverityCounts: [WfmBuScheduleTopicSchedulerMessageSeverityCount]?) {
        self.failed = failed
        self.runId = runId
        self.messageCount = messageCount
        self.messageSeverityCounts = messageSeverityCounts
    }


}




public class WfmBuScheduleTopicBuScheduleNotification: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }



    public enum EventType: String, Codable { 
        case update = "Update"
        case _import = "Import"
        case copy = "Copy"
        case delete = "Delete"
    }



    public var status: Status?
    public var operationId: String?
    public var eventType: EventType?
    public var result: WfmBuScheduleTopicBuScheduleMetadata?

    public init(status: Status?, operationId: String?, eventType: EventType?, result: WfmBuScheduleTopicBuScheduleMetadata?) {
        self.status = status
        self.operationId = operationId
        self.eventType = eventType
        self.result = result
    }


}




public class WfmBuScheduleTopicSchedulerMessageSeverityCount: Codable {

    public enum Severity: String, Codable { 
        case ignore = "Ignore"
        case information = "Information"
        case warning = "Warning"
        case error = "Error"
    }



    public var severity: Severity?
    public var count: Int?

    public init(severity: Severity?, count: Int?) {
        self.severity = severity
        self.count = count
    }


}




public class WfmBuScheduleTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmBuShortTermForecastCopyCompleteTopicBuForecastModification: Codable {

    public enum ModelType: String, Codable { 
        case minimumPerInterval = "MinimumPerInterval"
        case maximumPerInterval = "MaximumPerInterval"
        case setValuePerInterval = "SetValuePerInterval"
        case changeValuePerInterval = "ChangeValuePerInterval"
        case changePercentPerInterval = "ChangePercentPerInterval"
        case setValueOverRange = "SetValueOverRange"
        case changeValueOverRange = "ChangeValueOverRange"
        case setValuesForIntervalSet = "SetValuesForIntervalSet"
        case setMultiGranularityValuesForIntervalSet = "SetMultiGranularityValuesForIntervalSet"
    }





    public enum Metric: String, Codable { 
        case offered = "Offered"
        case averageHandleTimeSeconds = "AverageHandleTimeSeconds"
    }

    public enum LegacyMetric: String, Codable { 
        case averageAfterCallWorkTimeSeconds = "AverageAfterCallWorkTimeSeconds"
        case averageHandleTimeSeconds = "AverageHandleTimeSeconds"
        case averageTalkTimeSeconds = "AverageTalkTimeSeconds"
        case offered = "Offered"
    }

















    public var type: ModelType?
    public var startIntervalIndex: Int?
    public var endIntervalIndex: Int?
    public var metric: Metric?
    public var legacyMetric: LegacyMetric?
    public var value: Double?
    public var values: [WfmBuShortTermForecastCopyCompleteTopicModificationIntervalOffsetValue]?
    public var secondaryValues: [WfmBuShortTermForecastCopyCompleteTopicModificationIntervalOffsetValue]?
    public var enabled: Bool?
    public var granularity: String?
    public var secondaryGranularity: String?
    public var displayGranularity: String?
    public var planningGroupIds: [String]?

    public init(type: ModelType?, startIntervalIndex: Int?, endIntervalIndex: Int?, metric: Metric?, legacyMetric: LegacyMetric?, value: Double?, values: [WfmBuShortTermForecastCopyCompleteTopicModificationIntervalOffsetValue]?, secondaryValues: [WfmBuShortTermForecastCopyCompleteTopicModificationIntervalOffsetValue]?, enabled: Bool?, granularity: String?, secondaryGranularity: String?, displayGranularity: String?, planningGroupIds: [String]?) {
        self.type = type
        self.startIntervalIndex = startIntervalIndex
        self.endIntervalIndex = endIntervalIndex
        self.metric = metric
        self.legacyMetric = legacyMetric
        self.value = value
        self.values = values
        self.secondaryValues = secondaryValues
        self.enabled = enabled
        self.granularity = granularity
        self.secondaryGranularity = secondaryGranularity
        self.displayGranularity = displayGranularity
        self.planningGroupIds = planningGroupIds
    }


}




public class WfmBuShortTermForecastCopyCompleteTopicModificationIntervalOffsetValue: Codable {





    public var intervalIndex: Int?
    public var value: Double?

    public init(intervalIndex: Int?, value: Double?) {
        self.intervalIndex = intervalIndex
        self.value = value
    }


}




public class WfmBuShortTermForecastCopyCompleteTopicWfmVersionedEntityMetadata: Codable {







    public var version: Int?
    public var modifiedBy: WfmBuShortTermForecastCopyCompleteTopicUserReference?
    public var dateModified: Date?

    public init(version: Int?, modifiedBy: WfmBuShortTermForecastCopyCompleteTopicUserReference?, dateModified: Date?) {
        self.version = version
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
    }


}




public class WfmBuShortTermForecastGenerateProgressTopicForecastSourceDayPointer: Codable {

    public enum DayOfWeek: String, Codable { 
        case sunday = "Sunday"
        case monday = "Monday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
        case thursday = "Thursday"
        case friday = "Friday"
        case saturday = "Saturday"
        case eighthDay = "EighthDay"
    }









    public var dayOfWeek: DayOfWeek?
    public var weight: Int?
    public var date: String?
    public var fileName: String?
    public var dataKey: String?

    public init(dayOfWeek: DayOfWeek?, weight: Int?, date: String?, fileName: String?, dataKey: String?) {
        self.dayOfWeek = dayOfWeek
        self.weight = weight
        self.date = date
        self.fileName = fileName
        self.dataKey = dataKey
    }


}




public class WfmBuShortTermForecastGenerateProgressTopicGenerateBuShortTermForecastProgressNotification: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }







    public var status: Status?
    public var result: WfmBuShortTermForecastGenerateProgressTopicBuShortTermForecast?
    public var operationId: String?
    public var progress: Int?

    public init(status: Status?, result: WfmBuShortTermForecastGenerateProgressTopicBuShortTermForecast?, operationId: String?, progress: Int?) {
        self.status = status
        self.result = result
        self.operationId = operationId
        self.progress = progress
    }


}




public class WfmBuShortTermForecastGenerateProgressTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}



/** User information for a WhatsApp account */

public class WhatsAppId: Codable {





    /** The phone number associated with this WhatsApp account */
    public var phoneNumber: PhoneNumber?
    /** The displayName of this person's account in WhatsApp */
    public var displayName: String?

    public init(phoneNumber: PhoneNumber?, displayName: String?) {
        self.phoneNumber = phoneNumber
        self.displayName = displayName
    }


}




public class WfmBuShortTermForecastUpdateCompleteTopicBuForecastModification: Codable {

    public enum ModelType: String, Codable { 
        case minimumPerInterval = "MinimumPerInterval"
        case maximumPerInterval = "MaximumPerInterval"
        case setValuePerInterval = "SetValuePerInterval"
        case changeValuePerInterval = "ChangeValuePerInterval"
        case changePercentPerInterval = "ChangePercentPerInterval"
        case setValueOverRange = "SetValueOverRange"
        case changeValueOverRange = "ChangeValueOverRange"
        case setValuesForIntervalSet = "SetValuesForIntervalSet"
        case setMultiGranularityValuesForIntervalSet = "SetMultiGranularityValuesForIntervalSet"
    }





    public enum Metric: String, Codable { 
        case offered = "Offered"
        case averageHandleTimeSeconds = "AverageHandleTimeSeconds"
    }

    public enum LegacyMetric: String, Codable { 
        case averageAfterCallWorkTimeSeconds = "AverageAfterCallWorkTimeSeconds"
        case averageHandleTimeSeconds = "AverageHandleTimeSeconds"
        case averageTalkTimeSeconds = "AverageTalkTimeSeconds"
        case offered = "Offered"
    }

















    public var type: ModelType?
    public var startIntervalIndex: Int?
    public var endIntervalIndex: Int?
    public var metric: Metric?
    public var legacyMetric: LegacyMetric?
    public var value: Double?
    public var values: [WfmBuShortTermForecastUpdateCompleteTopicModificationIntervalOffsetValue]?
    public var secondaryValues: [WfmBuShortTermForecastUpdateCompleteTopicModificationIntervalOffsetValue]?
    public var enabled: Bool?
    public var granularity: String?
    public var secondaryGranularity: String?
    public var displayGranularity: String?
    public var planningGroupIds: [String]?

    public init(type: ModelType?, startIntervalIndex: Int?, endIntervalIndex: Int?, metric: Metric?, legacyMetric: LegacyMetric?, value: Double?, values: [WfmBuShortTermForecastUpdateCompleteTopicModificationIntervalOffsetValue]?, secondaryValues: [WfmBuShortTermForecastUpdateCompleteTopicModificationIntervalOffsetValue]?, enabled: Bool?, granularity: String?, secondaryGranularity: String?, displayGranularity: String?, planningGroupIds: [String]?) {
        self.type = type
        self.startIntervalIndex = startIntervalIndex
        self.endIntervalIndex = endIntervalIndex
        self.metric = metric
        self.legacyMetric = legacyMetric
        self.value = value
        self.values = values
        self.secondaryValues = secondaryValues
        self.enabled = enabled
        self.granularity = granularity
        self.secondaryGranularity = secondaryGranularity
        self.displayGranularity = displayGranularity
        self.planningGroupIds = planningGroupIds
    }


}




public class WfmBuShortTermForecastUpdateCompleteTopicModificationIntervalOffsetValue: Codable {





    public var intervalIndex: Int?
    public var value: Double?

    public init(intervalIndex: Int?, value: Double?) {
        self.intervalIndex = intervalIndex
        self.value = value
    }


}




public class WfmBuShortTermForecastUpdateCompleteTopicWfmVersionedEntityMetadata: Codable {







    public var version: Int?
    public var modifiedBy: WfmBuShortTermForecastUpdateCompleteTopicUserReference?
    public var dateModified: Date?

    public init(version: Int?, modifiedBy: WfmBuShortTermForecastUpdateCompleteTopicUserReference?, dateModified: Date?) {
        self.version = version
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
    }


}




public class WfmBulkShiftTradeStateUpdateNotificationTopicWfmVersionedEntityMetadata: Codable {







    public var version: Int?
    public var modifiedBy: WfmBulkShiftTradeStateUpdateNotificationTopicUserReference?
    public var dateModified: Date?

    public init(version: Int?, modifiedBy: WfmBulkShiftTradeStateUpdateNotificationTopicUserReference?, dateModified: Date?) {
        self.version = version
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
    }


}




public class WfmHistoricalAdherenceBulkUserDayMetrics: Codable {























    /** Start of day offset in seconds relative to query start time */
    public var dayStartOffsetSeconds: Int?
    /** Duration of schedule in seconds included for adherence percentage calculation */
    public var adherenceScheduleSeconds: Int?
    /** Total scheduled duration in seconds for OnQueue activities */
    public var conformanceScheduleSeconds: Int?
    /** Total actually worked duration in seconds for OnQueue activities */
    public var conformanceActualSeconds: Int?
    /** Total number of adherence exceptions for this user */
    public var exceptionCount: Int?
    /** Total duration in seconds of adherence exceptions for this user */
    public var exceptionDurationSeconds: Int?
    /** The impact duration in seconds of current adherence state for this user */
    public var impactSeconds: Int?
    /** Total duration in seconds for all scheduled activities */
    public var scheduleLengthSeconds: Int?
    /** Total duration in seconds for all actually worked activities */
    public var actualLengthSeconds: Int?
    /** Total adherence percentage for this user, in the scale of 0 - 100 */
    public var adherencePercentage: Double?
    /** Total conformance percentage for this user, in the scale of 0 - 100. Conformance percentage can be greater than 100 when the actual on queue time is greater than the scheduled on queue time for the same period. */
    public var conformancePercentage: Double?

    public init(dayStartOffsetSeconds: Int?, adherenceScheduleSeconds: Int?, conformanceScheduleSeconds: Int?, conformanceActualSeconds: Int?, exceptionCount: Int?, exceptionDurationSeconds: Int?, impactSeconds: Int?, scheduleLengthSeconds: Int?, actualLengthSeconds: Int?, adherencePercentage: Double?, conformancePercentage: Double?) {
        self.dayStartOffsetSeconds = dayStartOffsetSeconds
        self.adherenceScheduleSeconds = adherenceScheduleSeconds
        self.conformanceScheduleSeconds = conformanceScheduleSeconds
        self.conformanceActualSeconds = conformanceActualSeconds
        self.exceptionCount = exceptionCount
        self.exceptionDurationSeconds = exceptionDurationSeconds
        self.impactSeconds = impactSeconds
        self.scheduleLengthSeconds = scheduleLengthSeconds
        self.actualLengthSeconds = actualLengthSeconds
        self.adherencePercentage = adherencePercentage
        self.conformancePercentage = conformancePercentage
    }


}




public class WfmHistoricalAdherenceCalculationsCompleteTopicWfmHistoricalAdherenceCalculationsCompleteNotice: Codable {







    public enum QueryState: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }

    public var _id: String?
    public var downloadUrl: String?
    public var downloadUrls: [String]?
    public var queryState: QueryState?

    public init(_id: String?, downloadUrl: String?, downloadUrls: [String]?, queryState: QueryState?) {
        self._id = _id
        self.downloadUrl = downloadUrl
        self.downloadUrls = downloadUrls
        self.queryState = queryState
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case downloadUrl
        case downloadUrls
        case queryState
    }


}




public class WfmHistoricalAdherenceResultWrapper: Codable {







    /** The operation ID of the historical adherence query */
    public var entityId: String?
    /** The list of historical adherence query results */
    public var data: [HistoricalAdherenceQueryResult]?
    /** Map of secondary presence lookup ID to corresponding secondary presence ID */
    public var lookupIdToSecondaryPresenceId: [String:String]?

    public init(entityId: String?, data: [HistoricalAdherenceQueryResult]?, lookupIdToSecondaryPresenceId: [String:String]?) {
        self.entityId = entityId
        self.data = data
        self.lookupIdToSecondaryPresenceId = lookupIdToSecondaryPresenceId
    }


}




public class WfmHistoricalShrinkageCalculationsCompleteTopicHistoricalShrinkageCalculationsCompleteNotification: Codable {





    public enum State: String, Codable { 
        case unknown = "Unknown"
        case complete = "Complete"
        case error = "Error"
        case processing = "Processing"
    }

    public var operationId: String?
    public var downloadUrls: [String]?
    public var state: State?

    public init(operationId: String?, downloadUrls: [String]?, state: State?) {
        self.operationId = operationId
        self.downloadUrls = downloadUrls
        self.state = state
    }


}




public class WfmHistoricalShrinkageResponse: Codable {







    public enum State: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case error = "Error"
    }

    /** The operationId for which to listen */
    public var operationId: String?
    /** The url list to GET the results of the Historical Shrinkage query. This field is populated only if query state is Complete */
    public var downloadUrls: [String]?
    /** Result will always come via downloadUrls; however the schema is included for documentation */
    public var downloadResult: HistoricalShrinkageResultListing?
    /** The state of the shrinkage query */
    public var state: State?

    public init(operationId: String?, downloadUrls: [String]?, downloadResult: HistoricalShrinkageResultListing?, state: State?) {
        self.operationId = operationId
        self.downloadUrls = downloadUrls
        self.downloadResult = downloadResult
        self.state = state
    }


}




public class WfmIntegrationResponse: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Whether integration state is active */
    public var active: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, active: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.active = active
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case active
        case selfUri
    }


}




public class WfmIntradayDataUpdateTopicIntradayHistoricalQueueData: Codable {

















    public var offered: Int?
    public var completed: Int?
    public var answered: Int?
    public var abandoned: Int?
    public var averageTalkTimeSeconds: Double?
    public var averageAfterCallWorkSeconds: Double?
    public var serviceLevelPercent: Double?
    public var averageSpeedOfAnswerSeconds: Double?

    public init(offered: Int?, completed: Int?, answered: Int?, abandoned: Int?, averageTalkTimeSeconds: Double?, averageAfterCallWorkSeconds: Double?, serviceLevelPercent: Double?, averageSpeedOfAnswerSeconds: Double?) {
        self.offered = offered
        self.completed = completed
        self.answered = answered
        self.abandoned = abandoned
        self.averageTalkTimeSeconds = averageTalkTimeSeconds
        self.averageAfterCallWorkSeconds = averageAfterCallWorkSeconds
        self.serviceLevelPercent = serviceLevelPercent
        self.averageSpeedOfAnswerSeconds = averageSpeedOfAnswerSeconds
    }


}




public class WfmIntradayDataUpdateTopicIntradayMetric: Codable {

    public enum Category: String, Codable { 
        case historicalQueueData = "HistoricalQueueData"
        case historicalAgentData = "HistoricalAgentData"
        case forecastData = "ForecastData"
        case scheduleData = "ScheduleData"
        case performancePredictionAgentData = "PerformancePredictionAgentData"
        case performancePredictionQueueData = "PerformancePredictionQueueData"
    }



    public var category: Category?
    public var version: String?

    public init(category: Category?, version: String?) {
        self.category = category
        self.version = version
    }


}




public class WfmIntradayDataUpdateTopicIntradayPerformancePredictionAgentData: Codable {



    public var interactingTimeSeconds: Double?

    public init(interactingTimeSeconds: Double?) {
        self.interactingTimeSeconds = interactingTimeSeconds
    }


}




public class WfmMoveAgentsCompleteTopicWfmMoveAgentsComplete: Codable {







    public var requestingUser: WfmMoveAgentsCompleteTopicUserReference?
    public var destinationManagementUnit: WfmMoveAgentsCompleteTopicManagementUnit?
    public var results: [WfmMoveAgentsCompleteTopicWfmMoveAgentData]?

    public init(requestingUser: WfmMoveAgentsCompleteTopicUserReference?, destinationManagementUnit: WfmMoveAgentsCompleteTopicManagementUnit?, results: [WfmMoveAgentsCompleteTopicWfmMoveAgentData]?) {
        self.requestingUser = requestingUser
        self.destinationManagementUnit = destinationManagementUnit
        self.results = results
    }


}




public class WfmProcessUploadRequest: Codable {



    /** The uploadKey provided by the request to get an upload URL */
    public var uploadKey: String?

    public init(uploadKey: String?) {
        self.uploadKey = uploadKey
    }


}




public class WfmScheduleActivity: Codable {







    /** ID of user that the schedule is for */
    public var userReference: UserReference?
    /** List of user's scheduled activities */
    public var activities: [ScheduleActivity]?
    /** List of user's days off */
    public var fullDayTimeOffMarkers: [FullDayTimeOffMarker]?

    public init(userReference: UserReference?, activities: [ScheduleActivity]?, fullDayTimeOffMarkers: [FullDayTimeOffMarker]?) {
        self.userReference = userReference
        self.activities = activities
        self.fullDayTimeOffMarkers = fullDayTimeOffMarkers
    }


}




public class WfmServiceGoalImpactSettings: Codable {







    /** Allowed service level percent increase and decrease */
    public var serviceLevel: WfmServiceGoalImpact?
    /** Allowed average speed of answer percent increase and decrease */
    public var averageSpeedOfAnswer: WfmServiceGoalImpact?
    /** Allowed abandon rate percent increase and decrease */
    public var abandonRate: WfmServiceGoalImpact?

    public init(serviceLevel: WfmServiceGoalImpact?, averageSpeedOfAnswer: WfmServiceGoalImpact?, abandonRate: WfmServiceGoalImpact?) {
        self.serviceLevel = serviceLevel
        self.averageSpeedOfAnswer = averageSpeedOfAnswer
        self.abandonRate = abandonRate
    }


}




public class WfmUserNotificationTopicManagementUnit: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmUserNotificationTopicTimeOffRequestNotification: Codable {







    public enum Status: String, Codable { 
        case pending = "PENDING"
        case approved = "APPROVED"
        case denied = "DENIED"
        case canceled = "CANCELED"
    }





    public var timeOffRequestId: String?
    public var user: WfmUserNotificationTopicUserReference?
    public var isFullDayRequest: Bool?
    public var status: Status?
    public var partialDayStartDateTimes: [Date]?
    public var fullDayManagementUnitDates: [String]?

    public init(timeOffRequestId: String?, user: WfmUserNotificationTopicUserReference?, isFullDayRequest: Bool?, status: Status?, partialDayStartDateTimes: [Date]?, fullDayManagementUnitDates: [String]?) {
        self.timeOffRequestId = timeOffRequestId
        self.user = user
        self.isFullDayRequest = isFullDayRequest
        self.status = status
        self.partialDayStartDateTimes = partialDayStartDateTimes
        self.fullDayManagementUnitDates = fullDayManagementUnitDates
    }


}




public class WfmUserScheduleAdherenceUpdatedMuTopicUserScheduleAdherenceUpdate: Codable {















    public enum RoutingStatus: String, Codable { 
        case empty = "__EMPTY__"
        case offQueue = "OFF_QUEUE"
        case idle = "IDLE"
        case interacting = "INTERACTING"
        case notResponding = "NOT_RESPONDING"
        case communicating = "COMMUNICATING"
        case offline = "OFFLINE"
    }





    public enum AdherenceState: String, Codable { 
        case inAdherence = "InAdherence"
        case outOfAdherence = "OutOfAdherence"
        case unscheduled = "Unscheduled"
        case unknown = "Unknown"
        case ignored = "Ignored"
        case explained = "Explained"
    }















    public var user: WfmUserScheduleAdherenceUpdatedMuTopicUserReference?
    public var managementUnitId: String?
    public var team: WfmUserScheduleAdherenceUpdatedMuTopicUriReference?
    public var scheduledActivityCategory: String?
    public var scheduledActivityCode: WfmUserScheduleAdherenceUpdatedMuTopicActivityCodeReference?
    public var systemPresence: String?
    public var organizationSecondaryPresenceId: String?
    public var routingStatus: RoutingStatus?
    public var actualActivityCategory: String?
    public var isOutOfOffice: Bool?
    public var adherenceState: AdherenceState?
    public var impact: String?
    public var adherenceExplanation: WfmUserScheduleAdherenceUpdatedMuTopicRealTimeAdherenceExplanation?
    public var adherenceChangeTime: Date?
    public var presenceUpdateTime: Date?
    public var activeQueues: [WfmUserScheduleAdherenceUpdatedMuTopicQueueReference]?
    public var activeQueuesModifiedTime: Date?
    public var removedFromManagementUnit: Bool?

    public init(user: WfmUserScheduleAdherenceUpdatedMuTopicUserReference?, managementUnitId: String?, team: WfmUserScheduleAdherenceUpdatedMuTopicUriReference?, scheduledActivityCategory: String?, scheduledActivityCode: WfmUserScheduleAdherenceUpdatedMuTopicActivityCodeReference?, systemPresence: String?, organizationSecondaryPresenceId: String?, routingStatus: RoutingStatus?, actualActivityCategory: String?, isOutOfOffice: Bool?, adherenceState: AdherenceState?, impact: String?, adherenceExplanation: WfmUserScheduleAdherenceUpdatedMuTopicRealTimeAdherenceExplanation?, adherenceChangeTime: Date?, presenceUpdateTime: Date?, activeQueues: [WfmUserScheduleAdherenceUpdatedMuTopicQueueReference]?, activeQueuesModifiedTime: Date?, removedFromManagementUnit: Bool?) {
        self.user = user
        self.managementUnitId = managementUnitId
        self.team = team
        self.scheduledActivityCategory = scheduledActivityCategory
        self.scheduledActivityCode = scheduledActivityCode
        self.systemPresence = systemPresence
        self.organizationSecondaryPresenceId = organizationSecondaryPresenceId
        self.routingStatus = routingStatus
        self.actualActivityCategory = actualActivityCategory
        self.isOutOfOffice = isOutOfOffice
        self.adherenceState = adherenceState
        self.impact = impact
        self.adherenceExplanation = adherenceExplanation
        self.adherenceChangeTime = adherenceChangeTime
        self.presenceUpdateTime = presenceUpdateTime
        self.activeQueues = activeQueues
        self.activeQueuesModifiedTime = activeQueuesModifiedTime
        self.removedFromManagementUnit = removedFromManagementUnit
    }


}




public class WfmUserScheduleAdherenceUpdatedTeamTopicRealTimeAdherenceExplanation: Codable {







    public enum Status: String, Codable { 
        case pending = "Pending"
        case approved = "Approved"
        case denied = "Denied"
    }

    public var _id: String?
    public var startDate: Date?
    public var lengthMinutes: Int?
    public var status: Status?

    public init(_id: String?, startDate: Date?, lengthMinutes: Int?, status: Status?) {
        self._id = _id
        self.startDate = startDate
        self.lengthMinutes = lengthMinutes
        self.status = status
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case startDate
        case lengthMinutes
        case status
    }


}




public class WfmUserScheduleAdherenceUpdatedTopicQueueReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmUserScheduleAdherenceUpdatedTopicSecondaryPresenceReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}



/** A WhatsApp messaging template definition as defined in the WhatsApp Business Manager */

public class WhatsAppDefinition: Codable {







    /** The messaging template name. */
    public var name: String?
    /** The messaging template namespace. */
    public var namespace: String?
    /** The messaging template language configured for this template. This is a WhatsApp specific value. For example, 'en_US' */
    public var language: String?

    public init(name: String?, namespace: String?, language: String?) {
        self.name = name
        self.namespace = namespace
        self.language = language
    }


}




public class WhatsAppIntegrationEntityListing: Codable {





















    public var entities: [WhatsAppIntegration]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [WhatsAppIntegration]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class WidgetDeploymentEntityListing: Codable {







    public var total: Int64?
    public var entities: [WidgetDeployment]?
    public var selfUri: String?

    public init(total: Int64?, entities: [WidgetDeployment]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class WorkPlanBidRanks: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Work plan bidding agent performance ranking. The range of values is between 0 and 9999. */
    public var workPlanBiddingPerformance: Int?
    /** Custom agent ranking metric that some customers can use. */
    public var biddingTieBreaker: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, workPlanBiddingPerformance: Int?, biddingTieBreaker: String?, selfUri: String?) {
        self._id = _id
        self.workPlanBiddingPerformance = workPlanBiddingPerformance
        self.biddingTieBreaker = biddingTieBreaker
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case workPlanBiddingPerformance
        case biddingTieBreaker
        case selfUri
    }


}




public class WorkPlanRotationListResponse: Codable {



    public var entities: [WorkPlanRotationResponse]?

    public init(entities: [WorkPlanRotationResponse]?) {
        self.entities = entities
    }


}




public class WorkitemsEventsNotificationAssignmentSegment: Codable {

    public enum StartState: String, Codable { 
        case unknown = "Unknown"
        case idle = "Idle"
        case acdStarted = "AcdStarted"
        case alerting = "Alerting"
        case alertTimeout = "AlertTimeout"
        case declined = "Declined"
        case connected = "Connected"
        case disconnected = "Disconnected"
        case parked = "Parked"
        case held = "Held"
        case acdCancelled = "AcdCancelled"
        case terminated = "Terminated"
        case acdExpired = "AcdExpired"
    }

    public enum EndState: String, Codable { 
        case unknown = "Unknown"
        case idle = "Idle"
        case acdStarted = "AcdStarted"
        case alerting = "Alerting"
        case alertTimeout = "AlertTimeout"
        case declined = "Declined"
        case connected = "Connected"
        case disconnected = "Disconnected"
        case parked = "Parked"
        case held = "Held"
        case acdCancelled = "AcdCancelled"
        case terminated = "Terminated"
        case acdExpired = "AcdExpired"
    }



    public var startState: StartState?
    public var endState: EndState?
    public var durationMs: Int?

    public init(startState: StartState?, endState: EndState?, durationMs: Int?) {
        self.startState = startState
        self.endState = endState
        self.durationMs = durationMs
    }


}




public class WorkitemsQueueEventsNotificationDelta: Codable {

    public enum Op: String, Codable { 
        case add = "add"
        case remove = "remove"
        case replace = "replace"
        case unknown = "unknown"
    }







    public var op: Op?
    public var field: String?
    public var oldValue: String?
    public var newValue: String?

    public init(op: Op?, field: String?, oldValue: String?, newValue: String?) {
        self.op = op
        self.field = field
        self.oldValue = oldValue
        self.newValue = newValue
    }


}




public class WorkitemsQueueEventsNotificationSession: Codable {

    public enum ModelType: String, Codable { 
        case unknown = "Unknown"
        case agent = "Agent"
        case queueAssignment = "QueueAssignment"
        case directAssignment = "DirectAssignment"
    }



    public enum Status: String, Codable { 
        case unknown = "Unknown"
        case active = "Active"
        case completed = "Completed"
    }







    public var type: ModelType?
    public var _id: String?
    public var status: Status?
    public var dateSessionStart: String?
    public var dateSessionEnd: String?
    public var assignmentSegments: [WorkitemsQueueEventsNotificationAssignmentSegment]?

    public init(type: ModelType?, _id: String?, status: Status?, dateSessionStart: String?, dateSessionEnd: String?, assignmentSegments: [WorkitemsQueueEventsNotificationAssignmentSegment]?) {
        self.type = type
        self._id = _id
        self.status = status
        self.dateSessionStart = dateSessionStart
        self.dateSessionEnd = dateSessionEnd
        self.assignmentSegments = assignmentSegments
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case _id = "id"
        case status
        case dateSessionStart
        case dateSessionEnd
        case assignmentSegments
    }


}




public class WorkitemsQueueEventsNotificationWorkitem: Codable {





























    public enum StatusCategory: String, Codable { 
        case unknown = "Unknown"
        case _open = "Open"
        case inProgress = "InProgress"
        case waiting = "Waiting"
        case closed = "Closed"
    }

















    public enum Operation: String, Codable { 
        case unknown = "unknown"
        case add = "add"
        case edit = "edit"
        case delete = "delete"
        case view = "view"
        case upload = "upload"
        case download = "download"
        case activate = "activate"
        case deactivate = "deactivate"
        case purge = "purge"
        case processed = "processed"
        case published = "published"
        case assigned = "assigned"
        case unassigned = "unassigned"
        case reset = "reset"
        case reassigned = "reassigned"
        case reassign = "reassign"
        case archive = "archive"
        case unarchive = "unarchive"
        case reschedule = "reschedule"
    }



    public enum AssignmentState: String, Codable { 
        case unknown = "Unknown"
        case idle = "Idle"
        case acdStarted = "AcdStarted"
        case alerting = "Alerting"
        case alertTimeout = "AlertTimeout"
        case declined = "Declined"
        case connected = "Connected"
        case disconnected = "Disconnected"
        case parked = "Parked"
        case held = "Held"
        case acdCancelled = "AcdCancelled"
        case terminated = "Terminated"
        case acdExpired = "AcdExpired"
    }















    public var _id: String?
    public var name: String?
    public var typeId: String?
    public var _description: String?
    public var languageId: String?
    public var priority: Int?
    public var dateCreated: String?
    public var dateModified: String?
    public var dateDue: String?
    public var dateExpires: String?
    public var dateAssignmentStateChanged: String?
    public var durationSeconds: Int?
    public var ttl: Int?
    public var statusId: String?
    public var statusCategory: StatusCategory?
    public var dateClosed: String?
    public var workbinId: String?
    public var reporterId: String?
    public var assigneeId: String?
    public var externalContactId: String?
    public var externalTag: String?
    public var wrapupId: String?
    public var modifiedBy: String?
    public var operation: Operation?
    public var changes: [WorkitemsQueueEventsNotificationDelta]?
    public var assignmentState: AssignmentState?
    public var assignmentId: String?
    public var alertTimeoutSeconds: Int?
    public var queueId: String?
    public var customFields: [String:WorkitemsQueueEventsNotificationCustomAttribute]?
    public var wrapup: WorkitemsQueueEventsNotificationWrapup?
    public var sessions: [WorkitemsQueueEventsNotificationSession]?
    public var skillIds: [String]?

    public init(_id: String?, name: String?, typeId: String?, _description: String?, languageId: String?, priority: Int?, dateCreated: String?, dateModified: String?, dateDue: String?, dateExpires: String?, dateAssignmentStateChanged: String?, durationSeconds: Int?, ttl: Int?, statusId: String?, statusCategory: StatusCategory?, dateClosed: String?, workbinId: String?, reporterId: String?, assigneeId: String?, externalContactId: String?, externalTag: String?, wrapupId: String?, modifiedBy: String?, operation: Operation?, changes: [WorkitemsQueueEventsNotificationDelta]?, assignmentState: AssignmentState?, assignmentId: String?, alertTimeoutSeconds: Int?, queueId: String?, customFields: [String:WorkitemsQueueEventsNotificationCustomAttribute]?, wrapup: WorkitemsQueueEventsNotificationWrapup?, sessions: [WorkitemsQueueEventsNotificationSession]?, skillIds: [String]?) {
        self._id = _id
        self.name = name
        self.typeId = typeId
        self._description = _description
        self.languageId = languageId
        self.priority = priority
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.dateDue = dateDue
        self.dateExpires = dateExpires
        self.dateAssignmentStateChanged = dateAssignmentStateChanged
        self.durationSeconds = durationSeconds
        self.ttl = ttl
        self.statusId = statusId
        self.statusCategory = statusCategory
        self.dateClosed = dateClosed
        self.workbinId = workbinId
        self.reporterId = reporterId
        self.assigneeId = assigneeId
        self.externalContactId = externalContactId
        self.externalTag = externalTag
        self.wrapupId = wrapupId
        self.modifiedBy = modifiedBy
        self.operation = operation
        self.changes = changes
        self.assignmentState = assignmentState
        self.assignmentId = assignmentId
        self.alertTimeoutSeconds = alertTimeoutSeconds
        self.queueId = queueId
        self.customFields = customFields
        self.wrapup = wrapup
        self.sessions = sessions
        self.skillIds = skillIds
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case typeId
        case _description = "description"
        case languageId
        case priority
        case dateCreated
        case dateModified
        case dateDue
        case dateExpires
        case dateAssignmentStateChanged
        case durationSeconds
        case ttl
        case statusId
        case statusCategory
        case dateClosed
        case workbinId
        case reporterId
        case assigneeId
        case externalContactId
        case externalTag
        case wrapupId
        case modifiedBy
        case operation
        case changes
        case assignmentState
        case assignmentId
        case alertTimeoutSeconds
        case queueId
        case customFields
        case wrapup
        case sessions
        case skillIds
    }


}




public class WorkitemsUserEventsNotificationAssignmentSegment: Codable {

    public enum StartState: String, Codable { 
        case unknown = "Unknown"
        case idle = "Idle"
        case acdStarted = "AcdStarted"
        case alerting = "Alerting"
        case alertTimeout = "AlertTimeout"
        case declined = "Declined"
        case connected = "Connected"
        case disconnected = "Disconnected"
        case parked = "Parked"
        case held = "Held"
        case acdCancelled = "AcdCancelled"
        case terminated = "Terminated"
        case acdExpired = "AcdExpired"
    }

    public enum EndState: String, Codable { 
        case unknown = "Unknown"
        case idle = "Idle"
        case acdStarted = "AcdStarted"
        case alerting = "Alerting"
        case alertTimeout = "AlertTimeout"
        case declined = "Declined"
        case connected = "Connected"
        case disconnected = "Disconnected"
        case parked = "Parked"
        case held = "Held"
        case acdCancelled = "AcdCancelled"
        case terminated = "Terminated"
        case acdExpired = "AcdExpired"
    }



    public var startState: StartState?
    public var endState: EndState?
    public var durationMs: Int?

    public init(startState: StartState?, endState: EndState?, durationMs: Int?) {
        self.startState = startState
        self.endState = endState
        self.durationMs = durationMs
    }


}




public class WritableStarrableDivision: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}

