//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation


/** Input parameter for a CX infrastructure as code accelerator */

public class AcceleratorParameter: Codable {





    /** Parameter Name */
    public var name: String?
    /** Parameter Value */
    public var value: String?

    public init(name: String?, value: String?) {
        self.name = name
        self.value = value
    }


}




public class AcdStartDetailEventTopicAcdStartEvent: Codable {









    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
    }



    public enum Direction: String, Codable { 
        case unknown = "UNKNOWN"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }

















    public enum MessageType: String, Codable { 
        case unknown = "UNKNOWN"
        case sms = "SMS"
        case twitter = "TWITTER"
        case facebook = "FACEBOOK"
        case line = "LINE"
        case whatsapp = "WHATSAPP"
        case webmessaging = "WEBMESSAGING"
        case _open = "OPEN"
        case instagram = "INSTAGRAM"
    }









    public var eventTime: Int?
    public var conversationId: String?
    public var participantId: String?
    public var sessionId: String?
    public var mediaType: MediaType?
    public var provider: String?
    public var direction: Direction?
    public var ani: String?
    public var dnis: String?
    public var addressTo: String?
    public var addressFrom: String?
    public var callbackUserName: String?
    public var callbackNumbers: [String]?
    public var callbackScheduledTime: Int?
    public var subject: String?
    public var messageType: MessageType?
    public var queueId: String?
    public var divisionId: String?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?

    public init(eventTime: Int?, conversationId: String?, participantId: String?, sessionId: String?, mediaType: MediaType?, provider: String?, direction: Direction?, ani: String?, dnis: String?, addressTo: String?, addressFrom: String?, callbackUserName: String?, callbackNumbers: [String]?, callbackScheduledTime: Int?, subject: String?, messageType: MessageType?, queueId: String?, divisionId: String?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.sessionId = sessionId
        self.mediaType = mediaType
        self.provider = provider
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.addressTo = addressTo
        self.addressFrom = addressFrom
        self.callbackUserName = callbackUserName
        self.callbackNumbers = callbackNumbers
        self.callbackScheduledTime = callbackScheduledTime
        self.subject = subject
        self.messageType = messageType
        self.queueId = queueId
        self.divisionId = divisionId
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
    }


}



/** Details for an mTLS certificate */

public class ActionCertificate: Codable {

    public enum SigningAuthority: String, Codable { 
        case digiCert = "DigiCert"
        case genesys = "Genesys"
    }



    public enum Status: String, Codable { 
        case current = "Current"
        case upcoming = "Upcoming"
    }

    public enum ModelType: String, Codable { 
        case client = "Client"
    }

    /** The Signing Authority for the certificate */
    public var signingAuthority: SigningAuthority?
    /** The certificate string */
    public var certificate: String?
    /** The certificate status */
    public var status: Status?
    /** The certificate type */
    public var type: ModelType?

    public init(signingAuthority: SigningAuthority?, certificate: String?, status: Status?, type: ModelType?) {
        self.signingAuthority = signingAuthority
        self.certificate = certificate
        self.status = status
        self.type = type
    }


}




public class ActionCertificateListing: Codable {





















    public var entities: [ActionCertificate]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ActionCertificate]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** Defines components of the Action Config. */

public class ActionConfig: Codable {







    /** Optional 1-60 second timeout enforced on the execution or test of this action. This setting is invalid for Custom Authentication Actions. */
    public var timeoutSeconds: Int?
    /** Configuration of outbound request. */
    public var request: RequestConfig?
    /** Configuration of response processing. */
    public var response: ResponseConfig?

    public init(timeoutSeconds: Int?, request: RequestConfig?, response: ResponseConfig?) {
        self.timeoutSeconds = timeoutSeconds
        self.request = request
        self.response = response
    }


}



/** Contract definition. */

public class ActionContractInput: Codable {





    /** Execution input contract */
    public var input: PostInputContract?
    /** Execution output contract */
    public var output: PostOutputContract?

    public init(input: PostInputContract?, output: PostOutputContract?) {
        self.input = input
        self.output = output
    }


}



/** Input requirements of Action. */

public class ActionInput: Codable {







    /** JSON Schema that defines the body of the request that the client (edge/architect/postman) is sending to the service, on the /execute path. If the 'flatten' query parameter is omitted or false, this field will be returned. Either inputSchema or inputSchemaFlattened will be returned, not both. */
    public var inputSchema: JsonSchemaDocument?
    /** JSON Schema that defines the body of the request that the client (edge/architect/postman) is sending to the service, on the /execute path. The schema is transformed based on Architect's flattened format. If the 'flatten' query parameter is supplied as true, this field will be returned. Either inputSchema or inputSchemaFlattened will be returned, not both. */
    public var inputSchemaFlattened: JsonSchemaDocument?
    /** The URI of the input schema */
    public var inputSchemaUri: String?

    public init(inputSchema: JsonSchemaDocument?, inputSchemaFlattened: JsonSchemaDocument?, inputSchemaUri: String?) {
        self.inputSchema = inputSchema
        self.inputSchemaFlattened = inputSchemaFlattened
        self.inputSchemaUri = inputSchemaUri
    }


}




public class ActionMapEstimateResult: Codable {









    /** Number of sessions qualified for Action map. */
    public var qualifiedSessionCount: Int?
    /** Total number of sessions. */
    public var totalSessionCount: Int?
    /** Number of sessions qualified for Action map per segment. */
    public var perSegmentCounts: [SegmentEstimateCount]?
    /** Difference made by outcome criteria to number of sessions qualified for Action map. */
    public var outcomesScoresCount: Int?

    public init(qualifiedSessionCount: Int?, totalSessionCount: Int?, perSegmentCounts: [SegmentEstimateCount]?, outcomesScoresCount: Int?) {
        self.qualifiedSessionCount = qualifiedSessionCount
        self.totalSessionCount = totalSessionCount
        self.perSegmentCounts = perSegmentCounts
        self.outcomesScoresCount = outcomesScoresCount
    }


}




public class ActionTemplate: Codable {









    public enum MediaType: String, Codable { 
        case webchat = "webchat"
        case webmessagingoffer = "webMessagingOffer"
        case contentoffer = "contentOffer"
        case integrationaction = "integrationAction"
        case architectflow = "architectFlow"
        case openaction = "openAction"
    }

    public enum State: String, Codable { 
        case active = "Active"
        case inactive = "Inactive"
        case deleted = "Deleted"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Name of the action template. */
    public var name: String?
    /** Description of the action template's functionality. */
    public var _description: String?
    /** The version of the action template. */
    public var version: Int?
    /** Media type of action described by the action template. */
    public var mediaType: MediaType?
    /** Whether the action template is currently active, inactive or deleted. */
    public var state: State?
    /** Properties used to configure an action of type content offer */
    public var contentOffer: ContentOffer?
    /** The URI for this object */
    public var selfUri: String?
    /** Date when action template was created in ISO-8601 format. */
    public var createdDate: Date?
    /** Date when action template was last modified in ISO-8601 format. */
    public var modifiedDate: Date?

    public init(_id: String?, name: String?, _description: String?, version: Int?, mediaType: MediaType?, state: State?, contentOffer: ContentOffer?, selfUri: String?, createdDate: Date?, modifiedDate: Date?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.version = version
        self.mediaType = mediaType
        self.state = state
        self.contentOffer = contentOffer
        self.selfUri = selfUri
        self.createdDate = createdDate
        self.modifiedDate = modifiedDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case version
        case mediaType
        case state
        case contentOffer
        case selfUri
        case createdDate
        case modifiedDate
    }


}




public class ActionTemplateListing: Codable {





















    public var entities: [ActionTemplate]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ActionTemplate]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ActiveAlertCount: Codable {



    /** The count of active alerts for a user. */
    public var count: Int?

    public init(count: Int?) {
        self.count = count
    }


}




public class ActivityCode: Codable {











    public enum Category: String, Codable { 
        case onQueueWork = "OnQueueWork"
        case _break = "Break"
        case meal = "Meal"
        case meeting = "Meeting"
        case offQueueWork = "OffQueueWork"
        case timeOff = "TimeOff"
        case training = "Training"
        case unavailable = "Unavailable"
        case unscheduled = "Unscheduled"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?
    /** The name of the activity code. Default activity codes will be created with an empty name */
    public var name: String?
    /** Whether this activity code is active or has been deleted */
    public var isActive: Bool?
    /** Whether this is a default activity code */
    public var isDefault: Bool?
    /** The activity code's category. */
    public var category: Category?
    /** The default length of the activity in minutes */
    public var lengthInMinutes: Int?
    /** Whether an agent is paid while performing this activity */
    public var countsAsPaidTime: Bool?
    /** Indicates whether or not the activity should be counted as contiguous work time for calculating daily constraints */
    public var countsAsWorkTime: Bool?
    /** Whether an agent can select this activity code when creating or editing a time off request. Null if the activity's category is not time off. */
    public var agentTimeOffSelectable: Bool?
    /** Version metadata for the associated management unit's list of activity codes */
    public var metadata: WfmVersionedEntityMetadata?

    public init(_id: String?, selfUri: String?, name: String?, isActive: Bool?, isDefault: Bool?, category: Category?, lengthInMinutes: Int?, countsAsPaidTime: Bool?, countsAsWorkTime: Bool?, agentTimeOffSelectable: Bool?, metadata: WfmVersionedEntityMetadata?) {
        self._id = _id
        self.selfUri = selfUri
        self.name = name
        self.isActive = isActive
        self.isDefault = isDefault
        self.category = category
        self.lengthInMinutes = lengthInMinutes
        self.countsAsPaidTime = countsAsPaidTime
        self.countsAsWorkTime = countsAsWorkTime
        self.agentTimeOffSelectable = agentTimeOffSelectable
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case name
        case isActive
        case isDefault
        case category
        case lengthInMinutes
        case countsAsPaidTime
        case countsAsWorkTime
        case agentTimeOffSelectable
        case metadata
    }


}




public class AcwDetailEventTopicAfterCallWorkEvent: Codable {









    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
    }



    public enum Direction: String, Codable { 
        case unknown = "UNKNOWN"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }

















    public enum MessageType: String, Codable { 
        case unknown = "UNKNOWN"
        case sms = "SMS"
        case twitter = "TWITTER"
        case facebook = "FACEBOOK"
        case line = "LINE"
        case whatsapp = "WHATSAPP"
        case webmessaging = "WEBMESSAGING"
        case _open = "OPEN"
        case instagram = "INSTAGRAM"
    }















    public var eventTime: Int?
    public var conversationId: String?
    public var participantId: String?
    public var sessionId: String?
    public var mediaType: MediaType?
    public var provider: String?
    public var direction: Direction?
    public var ani: String?
    public var dnis: String?
    public var addressTo: String?
    public var addressFrom: String?
    public var callbackUserName: String?
    public var callbackNumbers: [String]?
    public var callbackScheduledTime: Int?
    public var subject: String?
    public var messageType: MessageType?
    public var userId: String?
    public var queueId: String?
    public var wrapupCode: String?
    public var wrapupNotes: String?
    public var wrapupDurationMs: Int?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?

    public init(eventTime: Int?, conversationId: String?, participantId: String?, sessionId: String?, mediaType: MediaType?, provider: String?, direction: Direction?, ani: String?, dnis: String?, addressTo: String?, addressFrom: String?, callbackUserName: String?, callbackNumbers: [String]?, callbackScheduledTime: Int?, subject: String?, messageType: MessageType?, userId: String?, queueId: String?, wrapupCode: String?, wrapupNotes: String?, wrapupDurationMs: Int?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.sessionId = sessionId
        self.mediaType = mediaType
        self.provider = provider
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.addressTo = addressTo
        self.addressFrom = addressFrom
        self.callbackUserName = callbackUserName
        self.callbackNumbers = callbackNumbers
        self.callbackScheduledTime = callbackScheduledTime
        self.subject = subject
        self.messageType = messageType
        self.userId = userId
        self.queueId = queueId
        self.wrapupCode = wrapupCode
        self.wrapupNotes = wrapupNotes
        self.wrapupDurationMs = wrapupDurationMs
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
    }


}




public class AddAdherenceExplanationAdminRequest: Codable {

    public enum ModelType: String, Codable { 
        case late = "Late"
    }







    public enum Status: String, Codable { 
        case pending = "Pending"
        case approved = "Approved"
        case denied = "Denied"
    }

    /** The type of the adherence explanation */
    public var type: ModelType?
    /** The start timestamp of the adherence explanation in ISO-8601 format */
    public var startDate: Date?
    /** The length of the adherence explanation in minutes */
    public var lengthMinutes: Int?
    /** Notes about the adherence explanation */
    public var notes: String?
    /** The status of the adherence explanation */
    public var status: Status?

    public init(type: ModelType?, startDate: Date?, lengthMinutes: Int?, notes: String?, status: Status?) {
        self.type = type
        self.startDate = startDate
        self.lengthMinutes = lengthMinutes
        self.notes = notes
        self.status = status
    }


}




public class AddressableLicenseDefinition: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class AdherenceExplanationJobReference: Codable {



    public enum ModelType: String, Codable { 
        case addExplanation = "AddExplanation"
        case updateExplanation = "UpdateExplanation"
        case queryAgentExplanations = "QueryAgentExplanations"
        case queryBuExplanations = "QueryBuExplanations"
    }

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case error = "Error"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The type of the adherence explanation job */
    public var type: ModelType?
    /** The status of the adherence explanation job */
    public var status: Status?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, type: ModelType?, status: Status?, selfUri: String?) {
        self._id = _id
        self.type = type
        self.status = status
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
        case status
        case selfUri
    }


}




public class AdherenceExplanationListingBuQueryResponse: Codable {



    public var entities: [AdherenceExplanationResponse]?

    public init(entities: [AdherenceExplanationResponse]?) {
        self.entities = entities
    }


}




public class AdherenceSettings: Codable {













    /** The threshold in minutes where an alert will be triggered when an agent is considered severely out of adherence */
    public var severeAlertThresholdMinutes: Int?
    /** Target adherence percentage */
    public var adherenceTargetPercent: Int?
    /** The threshold in seconds for which agents should not be penalized for being momentarily out of adherence */
    public var adherenceExceptionThresholdSeconds: Int?
    /** Whether to treat all non-on-queue activities as equivalent for adherence purposes */
    public var nonOnQueueActivitiesEquivalent: Bool?
    /** Whether to track on-queue activities */
    public var trackOnQueueActivity: Bool?
    /** Activity categories that should be ignored for adherence purposes */
    public var ignoredActivityCategories: IgnoredActivityCategories?

    public init(severeAlertThresholdMinutes: Int?, adherenceTargetPercent: Int?, adherenceExceptionThresholdSeconds: Int?, nonOnQueueActivitiesEquivalent: Bool?, trackOnQueueActivity: Bool?, ignoredActivityCategories: IgnoredActivityCategories?) {
        self.severeAlertThresholdMinutes = severeAlertThresholdMinutes
        self.adherenceTargetPercent = adherenceTargetPercent
        self.adherenceExceptionThresholdSeconds = adherenceExceptionThresholdSeconds
        self.nonOnQueueActivitiesEquivalent = nonOnQueueActivitiesEquivalent
        self.trackOnQueueActivity = trackOnQueueActivity
        self.ignoredActivityCategories = ignoredActivityCategories
    }


}




public class AdhocRecordingTopicRecordingDataV2: Codable {



































    public var _id: String?
    public var name: String?
    public var dateCreated: Date?
    public var dateModified: Date?
    public var workspace: AdhocRecordingTopicWorkspaceData?
    public var createdBy: AdhocRecordingTopicUserData?
    public var contentType: String?
    public var contentLength: Int?
    public var filename: String?
    public var changeNumber: Int?
    public var dateUploaded: Date?
    public var uploadedBy: AdhocRecordingTopicUserData?
    public var lockInfo: AdhocRecordingTopicLockData?
    public var selfUri: String?
    public var durationMillieconds: Int?
    public var conversation: AdhocRecordingTopicConversationData?
    public var read: Bool?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, workspace: AdhocRecordingTopicWorkspaceData?, createdBy: AdhocRecordingTopicUserData?, contentType: String?, contentLength: Int?, filename: String?, changeNumber: Int?, dateUploaded: Date?, uploadedBy: AdhocRecordingTopicUserData?, lockInfo: AdhocRecordingTopicLockData?, selfUri: String?, durationMillieconds: Int?, conversation: AdhocRecordingTopicConversationData?, read: Bool?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.workspace = workspace
        self.createdBy = createdBy
        self.contentType = contentType
        self.contentLength = contentLength
        self.filename = filename
        self.changeNumber = changeNumber
        self.dateUploaded = dateUploaded
        self.uploadedBy = uploadedBy
        self.lockInfo = lockInfo
        self.selfUri = selfUri
        self.durationMillieconds = durationMillieconds
        self.conversation = conversation
        self.read = read
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case workspace
        case createdBy
        case contentType
        case contentLength
        case filename
        case changeNumber
        case dateUploaded
        case uploadedBy
        case lockInfo
        case selfUri
        case durationMillieconds
        case conversation
        case read
    }


}




public class Adjacents: Codable {







    public var superiors: [User]?
    public var siblings: [User]?
    public var directReports: [User]?

    public init(superiors: [User]?, siblings: [User]?, directReports: [User]?) {
        self.superiors = superiors
        self.siblings = siblings
        self.directReports = directReports
    }


}




public class AgentActivityChangedTopicOutOfOffice: Codable {





    public var active: Bool?
    public var modifiedDate: Date?

    public init(active: Bool?, modifiedDate: Date?) {
        self.active = active
        self.modifiedDate = modifiedDate
    }


}




public class AgentActivityChangedTopicPresence: Codable {







    public var presenceDefinition: AgentActivityChangedTopicOrganizationPresence?
    public var presenceMessage: String?
    public var modifiedDate: Date?

    public init(presenceDefinition: AgentActivityChangedTopicOrganizationPresence?, presenceMessage: String?, modifiedDate: Date?) {
        self.presenceDefinition = presenceDefinition
        self.presenceMessage = presenceMessage
        self.modifiedDate = modifiedDate
    }


}




public class AlertListing: Codable {





















    public var entities: [CommonAlert]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CommonAlert]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class AgentPossibleWorkShiftsResponse: Codable {











    /** Start date of requested effective work plan. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var weekStartDate: Date?
    /** Each element is the ID of an effective work plan for a specific week */
    public var pattern: [Int]?
    /** Each element is a weekly effective work plan that can be used for multiple weeks */
    public var weeklyPossibleWorkShifts: [PossibleWorkShiftsForWeek]?
    /** Number of minutes in each interval in the intervalScheduleProbabilities */
    public var schedulerIntervalLengthMinutes: Int?
    /** The time zone of the business unit */
    public var timeZone: String?

    public init(weekStartDate: Date?, pattern: [Int]?, weeklyPossibleWorkShifts: [PossibleWorkShiftsForWeek]?, schedulerIntervalLengthMinutes: Int?, timeZone: String?) {
        self.weekStartDate = weekStartDate
        self.pattern = pattern
        self.weeklyPossibleWorkShifts = weeklyPossibleWorkShifts
        self.schedulerIntervalLengthMinutes = schedulerIntervalLengthMinutes
        self.timeZone = timeZone
    }


}




public class AgentQueryAdherenceExplanationsRequest: Codable {





    /** The start date of the range to query. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** The end date of the range to query. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endDate: Date?

    public init(startDate: Date?, endDate: Date?) {
        self.startDate = startDate
        self.endDate = endDate
    }


}




public class AlertNotification: Codable {




    public enum NotificationTypes: String, Codable { 
        case sms = "Sms"
        case device = "Device"
        case email = "Email"
        case push = "Push"
    }


    /** The entity to receive the notification. */
    public var recipient: String?
    /** The notification types the user will receive. */
    public var notificationTypes: [NotificationTypes]?
    /** The locale whose language will be used when sending alerts.  Locale should be in theformat language_COUNTRY where language is always lower case and country is always upper case. */
    public var locale: String?

    public init(recipient: String?, notificationTypes: [NotificationTypes]?, locale: String?) {
        self.recipient = recipient
        self.notificationTypes = notificationTypes
        self.locale = locale
    }


}




public class AlertRequest: Codable {

    public enum ModelType: String, Codable { 
        case mute = "Mute"
        case snooze = "Snooze"
        case unread = "Unread"
    }









    /** The action being taken on the alert. */
    public var type: ModelType?
    /** The start date of the mute/snooze period. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?
    /** The end date of the mute/snooze period. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateEnd: Date?
    /** The fields need for an unread update requests */
    public var unread: UnreadFields?
    public var validRequest: Bool?

    public init(type: ModelType?, dateStart: Date?, dateEnd: Date?, unread: UnreadFields?, validRequest: Bool?) {
        self.type = type
        self.dateStart = dateStart
        self.dateEnd = dateEnd
        self.unread = unread
        self.validRequest = validRequest
    }


}




public class AlertSummary: Codable {





    public enum MetricType: String, Codable { 
        case interval = "Interval"
        case instance = "Instance"
    }



    /** The entities who violated the rule condition over the duration of the alert. */
    public var entities: [AlertSummaryEntity]?
    /** The id of the conversation that triggered the alert.  Only used for alerts based on instance-based conversation metrics. */
    public var conversation: AddressableEntityRef?
    /** The metric type that is monitored. */
    public var metricType: MetricType?
    /** Flag that indicated whether or not the alert is for a rule with a condition for all members of a team. */
    public var entitiesAreTeamMembers: Bool?

    public init(entities: [AlertSummaryEntity]?, conversation: AddressableEntityRef?, metricType: MetricType?, entitiesAreTeamMembers: Bool?) {
        self.entities = entities
        self.conversation = conversation
        self.metricType = metricType
        self.entitiesAreTeamMembers = entitiesAreTeamMembers
    }


}




public class AnalyticsConversationSegment: Codable {









    public enum DisconnectType: String, Codable { 
        case client = "client"
        case conferencetransfer = "conferenceTransfer"
        case consulttransfer = "consultTransfer"
        case dndendpoint = "dndEndpoint"
        case dndtransfer = "dndTransfer"
        case endpoint = "endpoint"
        case endpointdnd = "endpointDnd"
        case error = "error"
        case forwardtransfer = "forwardTransfer"
        case noanswertransfer = "noAnswerTransfer"
        case notavailabletransfer = "notAvailableTransfer"
        case other = "other"
        case peer = "peer"
        case spam = "spam"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferdnd = "transferDnd"
        case transportfailure = "transportFailure"
        case uncallable = "uncallable"
    }



















    public enum SegmentType: String, Codable { 
        case alert = "alert"
        case barging = "barging"
        case callback = "callback"
        case coaching = "coaching"
        case contacting = "contacting"
        case converting = "converting"
        case delay = "delay"
        case dialing = "dialing"
        case hold = "hold"
        case interact = "interact"
        case ivr = "ivr"
        case monitoring = "monitoring"
        case parked = "parked"
        case scheduled = "scheduled"
        case sharing = "sharing"
        case system = "system"
        case transmitting = "transmitting"
        case unknown = "unknown"
        case uploading = "uploading"
        case voicemail = "voicemail"
        case wrapup = "wrapup"
    }





















    /** Flag indicating if audio is muted or not (true/false) */
    public var audioMuted: Bool?
    /** Indicates whether the segment was a conference */
    public var conference: Bool?
    /** The unique identifier of a new conversation when a conversation is ended for a conference */
    public var destinationConversationId: String?
    /** The unique identifier of a new session when a session is ended for a conference */
    public var destinationSessionId: String?
    /** The session disconnect type */
    public var disconnectType: DisconnectType?
    /** A code corresponding to the error that occurred */
    public var errorCode: String?
    /** Unique identifier for a PureCloud group */
    public var groupId: String?
    /** Q.850 response code(s) */
    public var q850ResponseCodes: [Int64]?
    /** Queue identifier */
    public var queueId: String?
    /** Unique identifier for the language requested for an interaction */
    public var requestedLanguageId: String?
    /** Unique identifier(s) for skill(s) requested for an interaction */
    public var requestedRoutingSkillIds: [String]?
    /** Unique identifier(s) for agent(s) requested for an interaction */
    public var requestedRoutingUserIds: [String]?
    /** The end time of a segment. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var segmentEnd: Date?
    /** The start time of a segment. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var segmentStart: Date?
    /** The activity that takes place in the segment, such as hold or interact */
    public var segmentType: SegmentType?
    /** SIP response code(s) */
    public var sipResponseCodes: [Int64]?
    /** The unique identifier of the previous conversation when a new conversation is created for a conference */
    public var sourceConversationId: String?
    /** The unique identifier of the previous session when a new session is created for a conference */
    public var sourceSessionId: String?
    /** The subject for the initial email that started this conversation */
    public var subject: String?
    /** Flag indicating if video is muted/paused or not (true/false) */
    public var videoMuted: Bool?
    /** Wrap up code */
    public var wrapUpCode: String?
    /** Note entered by an agent during after-call work */
    public var wrapUpNote: String?
    /** Tag(s) assigned during after-call work */
    public var wrapUpTags: [String]?
    /** Scored agents */
    public var scoredAgents: [AnalyticsScoredAgent]?
    /** Additional segment properties */
    public var properties: [AnalyticsProperty]?

    public init(audioMuted: Bool?, conference: Bool?, destinationConversationId: String?, destinationSessionId: String?, disconnectType: DisconnectType?, errorCode: String?, groupId: String?, q850ResponseCodes: [Int64]?, queueId: String?, requestedLanguageId: String?, requestedRoutingSkillIds: [String]?, requestedRoutingUserIds: [String]?, segmentEnd: Date?, segmentStart: Date?, segmentType: SegmentType?, sipResponseCodes: [Int64]?, sourceConversationId: String?, sourceSessionId: String?, subject: String?, videoMuted: Bool?, wrapUpCode: String?, wrapUpNote: String?, wrapUpTags: [String]?, scoredAgents: [AnalyticsScoredAgent]?, properties: [AnalyticsProperty]?) {
        self.audioMuted = audioMuted
        self.conference = conference
        self.destinationConversationId = destinationConversationId
        self.destinationSessionId = destinationSessionId
        self.disconnectType = disconnectType
        self.errorCode = errorCode
        self.groupId = groupId
        self.q850ResponseCodes = q850ResponseCodes
        self.queueId = queueId
        self.requestedLanguageId = requestedLanguageId
        self.requestedRoutingSkillIds = requestedRoutingSkillIds
        self.requestedRoutingUserIds = requestedRoutingUserIds
        self.segmentEnd = segmentEnd
        self.segmentStart = segmentStart
        self.segmentType = segmentType
        self.sipResponseCodes = sipResponseCodes
        self.sourceConversationId = sourceConversationId
        self.sourceSessionId = sourceSessionId
        self.subject = subject
        self.videoMuted = videoMuted
        self.wrapUpCode = wrapUpCode
        self.wrapUpNote = wrapUpNote
        self.wrapUpTags = wrapUpTags
        self.scoredAgents = scoredAgents
        self.properties = properties
    }


}




public class AnalyticsEvaluation: Codable {













    public enum EvaluationStatus: String, Codable { 
        case finished = "Finished"
        case inProgress = "InProgress"
        case inReview = "InReview"
        case pending = "Pending"
        case retracted = "Retracted"
    }





















    /** Indicates whether an assignee is applicable for the evaluation. Set to false when assignee is not applicable */
    public var assigneeApplicable: Bool?
    /** UserId of the assignee */
    public var assigneeId: String?
    /** The calibration ID used for the purpose of training evaluators */
    public var calibrationId: String?
    /** A unique identifier for an evaluation form, regardless of version */
    public var contextId: String?
    /** Whether the evaluation has been deleted */
    public var deleted: Bool?
    /** Unique identifier for the evaluation */
    public var evaluationId: String?
    /** Status of evaluation */
    public var evaluationStatus: EvaluationStatus?
    /** A unique identifier of the user who evaluated the interaction */
    public var evaluatorId: String?
    /** Specifies when an evaluation occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventTime: Date?
    /** ID of the evaluation form used */
    public var formId: String?
    /** Name of the evaluation form used */
    public var formName: String?
    /** The ID of the associated queue */
    public var queueId: String?
    /** Whether the evaluation has been released */
    public var released: Bool?
    /** Whether the evaluation has been rescored at least once */
    public var rescored: Bool?
    /** ID of the agent the evaluation was performed against */
    public var userId: String?
    public var oTotalCriticalScore: Int64?
    public var oTotalScore: Int64?

    public init(assigneeApplicable: Bool?, assigneeId: String?, calibrationId: String?, contextId: String?, deleted: Bool?, evaluationId: String?, evaluationStatus: EvaluationStatus?, evaluatorId: String?, eventTime: Date?, formId: String?, formName: String?, queueId: String?, released: Bool?, rescored: Bool?, userId: String?, oTotalCriticalScore: Int64?, oTotalScore: Int64?) {
        self.assigneeApplicable = assigneeApplicable
        self.assigneeId = assigneeId
        self.calibrationId = calibrationId
        self.contextId = contextId
        self.deleted = deleted
        self.evaluationId = evaluationId
        self.evaluationStatus = evaluationStatus
        self.evaluatorId = evaluatorId
        self.eventTime = eventTime
        self.formId = formId
        self.formName = formName
        self.queueId = queueId
        self.released = released
        self.rescored = rescored
        self.userId = userId
        self.oTotalCriticalScore = oTotalCriticalScore
        self.oTotalScore = oTotalScore
    }


}




public class AnalyticsFlow: Codable {





    public enum EntryType: String, Codable { 
        case agent = "agent"
        case direct = "direct"
        case dnis = "dnis"
        case flow = "flow"
        case outbound = "outbound"
    }







    public enum FlowType: String, Codable { 
        case bot = "BOT"
        case commonmodule = "COMMONMODULE"
        case digitalbot = "DIGITALBOT"
        case inboundcall = "INBOUNDCALL"
        case inboundchat = "INBOUNDCHAT"
        case inboundemail = "INBOUNDEMAIL"
        case inboundshortmessage = "INBOUNDSHORTMESSAGE"
        case inqueuecall = "INQUEUECALL"
        case inqueueemail = "INQUEUEEMAIL"
        case inqueueshortmessage = "INQUEUESHORTMESSAGE"
        case outboundcall = "OUTBOUNDCALL"
        case securecall = "SECURECALL"
        case speech = "SPEECH"
        case surveyinvite = "SURVEYINVITE"
        case voice = "VOICE"
        case voicemail = "VOICEMAIL"
        case voicesurvey = "VOICESURVEY"
        case workflow = "WORKFLOW"
        case workitem = "WORKITEM"
    }

















    /** Flow ending language, e.g. en-us */
    public var endingLanguage: String?
    /** The particular entry reason for this flow, e.g. an address, userId, or flowId */
    public var entryReason: String?
    /** The entry type for this flow, e.g. dnis, dialer, agent, flow, or direct */
    public var entryType: EntryType?
    /** The exit reason for this flow, e.g. DISCONNECT */
    public var exitReason: String?
    /** The unique identifier of this flow */
    public var flowId: String?
    /** The name of this flow at the time of flow execution */
    public var flowName: String?
    /** The type of this flow */
    public var flowType: FlowType?
    /** The version of this flow */
    public var flowVersion: String?
    /** Flag indicating whether the flow issued a callback */
    public var issuedCallback: Bool?
    /** The recognition failure reason causing to exit/disconnect */
    public var recognitionFailureReason: String?
    /** Flow starting language, e.g. en-us */
    public var startingLanguage: String?
    /** The address of a flow transfer target, e.g. a phone number, an email address, or a queueId */
    public var transferTargetAddress: String?
    /** The name of a flow transfer target */
    public var transferTargetName: String?
    /** The type of transfer for flows that ended with a transfer */
    public var transferType: String?
    /** Flow outcomes */
    public var outcomes: [AnalyticsFlowOutcome]?

    public init(endingLanguage: String?, entryReason: String?, entryType: EntryType?, exitReason: String?, flowId: String?, flowName: String?, flowType: FlowType?, flowVersion: String?, issuedCallback: Bool?, recognitionFailureReason: String?, startingLanguage: String?, transferTargetAddress: String?, transferTargetName: String?, transferType: String?, outcomes: [AnalyticsFlowOutcome]?) {
        self.endingLanguage = endingLanguage
        self.entryReason = entryReason
        self.entryType = entryType
        self.exitReason = exitReason
        self.flowId = flowId
        self.flowName = flowName
        self.flowType = flowType
        self.flowVersion = flowVersion
        self.issuedCallback = issuedCallback
        self.recognitionFailureReason = recognitionFailureReason
        self.startingLanguage = startingLanguage
        self.transferTargetAddress = transferTargetAddress
        self.transferTargetName = transferTargetName
        self.transferType = transferType
        self.outcomes = outcomes
    }


}




public class AnalyticsReportingSettings: Codable {







    /** Indication of whether or not personal data is masked in data export and the Analytics/Reporting UI */
    public var piiMaskingEnabled: Bool?
    /** Indication of whether or not to obfuscate export data from the Queue Agent Details view based on User ACL */
    public var queueAgentAccessObfuscation: Bool?
    /** Indicates whether PII data is masked in My Interaction export and the Analytics/Reporting UI */
    public var myInteractionsPiiMaskingEnabled: Bool?

    public init(piiMaskingEnabled: Bool?, queueAgentAccessObfuscation: Bool?, myInteractionsPiiMaskingEnabled: Bool?) {
        self.piiMaskingEnabled = piiMaskingEnabled
        self.queueAgentAccessObfuscation = queueAgentAccessObfuscation
        self.myInteractionsPiiMaskingEnabled = myInteractionsPiiMaskingEnabled
    }


}




public class AnalyticsScoredAgent: Codable {





    /** Assigned agent score for this conversation (0 - 100, higher being better) */
    public var agentScore: Int?
    /** Unique identifier for the agent that was scored for this conversation */
    public var scoredAgentId: String?

    public init(agentScore: Int?, scoredAgentId: String?) {
        self.agentScore = agentScore
        self.scoredAgentId = scoredAgentId
    }


}




public class AnalyticsUserPresenceRecord: Codable {





    public enum SystemPresence: String, Codable { 
        case available = "AVAILABLE"
        case away = "AWAY"
        case busy = "BUSY"
        case offline = "OFFLINE"
        case idle = "IDLE"
        case onQueue = "ON_QUEUE"
        case meal = "MEAL"
        case training = "TRAINING"
        case meeting = "MEETING"
        case _break = "BREAK"
    }



    /** The start time of the record. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startTime: Date?
    /** The end time of the record. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?
    /** The user's system presence */
    public var systemPresence: SystemPresence?
    /** The identifier for the user's organization presence */
    public var organizationPresenceId: String?

    public init(startTime: Date?, endTime: Date?, systemPresence: SystemPresence?, organizationPresenceId: String?) {
        self.startTime = startTime
        self.endTime = endTime
        self.systemPresence = systemPresence
        self.organizationPresenceId = organizationPresenceId
    }


}




public class ApiUsageClientQuery: Codable {



    public enum Granularity: String, Codable { 
        case day = "Day"
        case week = "Week"
        case month = "Month"
    }

    public enum Metrics: String, Codable { 
        case status200 = "Status200"
        case status300 = "Status300"
        case status400 = "Status400"
        case status500 = "Status500"
        case status429 = "Status429"
        case requests = "Requests"
    }

    public enum GroupBy: String, Codable { 
        case oauthclientid = "OAuthClientId"
        case organizationId = "OrganizationId"
        case templateUri = "TemplateUri"
        case httpMethod = "HttpMethod"
    }

    /** Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Date granularity of the results */
    public var granularity: Granularity?
    /** Behaves like a SQL SELECT clause. Enables retrieving only named metrics. If omitted, all metrics that are available will be returned (like SELECT *). */
    public var metrics: [Metrics]?
    /** Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group. */
    public var groupBy: [GroupBy]?

    public init(interval: String?, granularity: Granularity?, metrics: [Metrics]?, groupBy: [GroupBy]?) {
        self.interval = interval
        self.granularity = granularity
        self.metrics = metrics
        self.groupBy = groupBy
    }


}




public class ApiUsageSimpleSearch: Codable {



    public enum Metrics: String, Codable { 
        case date = "Date"
        case clientName = "ClientName"
        case httpMethod = "HttpMethod"
        case templateUri = "TemplateUri"
        case status200 = "Status200"
        case status300 = "Status300"
        case status400 = "Status400"
        case status500 = "Status500"
        case status429 = "Status429"
    }



    public enum HttpMethods: String, Codable { 
        case _get = "GET"
        case post = "POST"
        case delete = "DELETE"
        case patch = "PATCH"
        case put = "PUT"
        case head = "HEAD"
        case connect = "CONNECT"
        case options = "OPTIONS"
        case trace = "TRACE"
    }



    /** Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Behaves like a SQL SELECT clause. Enables retrieving only named metrics. If omitted, all metrics that are available will be returned (like SELECT *). */
    public var metrics: [Metrics]?
    /** Behaves like a SQL WHERE with multiple IN operators. Specifies a list of OAuth client names to be queried. */
    public var oauthClientNames: [String]?
    /** Behaves like a SQL WHERE with multiple IN operators. Specifies a list of HTTP methods to be queried. */
    public var httpMethods: [HttpMethods]?
    /** Behaves like a SQL WHERE with multiple IN operators. Specifies a list of Template Uris to be queried. */
    public var templateUris: [String]?

    public init(interval: String?, metrics: [Metrics]?, oauthClientNames: [String]?, httpMethods: [HttpMethods]?, templateUris: [String]?) {
        self.interval = interval
        self.metrics = metrics
        self.oauthClientNames = oauthClientNames
        self.httpMethods = httpMethods
        self.templateUris = templateUris
    }


}



/** The client who initiated the change. */

public class ArchitectDependencyTrackingBuildNotificationClient: Codable {





    /** The ID of the client. */
    public var _id: String?
    /** The name of the client, if available. */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class ArchitectDependencyTrackingBuildNotificationHomeOrganization: Codable {







    public var _id: String?
    public var name: String?
    public var thirdPartyOrgName: String?

    public init(_id: String?, name: String?, thirdPartyOrgName: String?) {
        self._id = _id
        self.name = name
        self.thirdPartyOrgName = thirdPartyOrgName
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case thirdPartyOrgName
    }


}



/** The client who initiated the change. */

public class ArchitectFlowNotificationClient: Codable {





    /** The ID of the client. */
    public var _id: String?
    /** The name of the client, if available. */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class ArchitectFlowNotificationErrorDetail: Codable {









    public var errorCode: String?
    public var entityId: String?
    public var entityName: String?
    public var fieldName: String?

    public init(errorCode: String?, entityId: String?, entityName: String?, fieldName: String?) {
        self.errorCode = errorCode
        self.entityId = entityId
        self.entityName = entityName
        self.fieldName = fieldName
    }


}




public class ArchitectFlowNotificationHomeOrganization: Codable {







    public var _id: String?
    public var name: String?
    public var thirdPartyOrgName: String?

    public init(_id: String?, name: String?, thirdPartyOrgName: String?) {
        self._id = _id
        self.name = name
        self.thirdPartyOrgName = thirdPartyOrgName
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case thirdPartyOrgName
    }


}




public class ArchitectFlowOutcomeNotificationFlowOutcomeNotification: Codable {









    /** The flow outcome ID */
    public var _id: String?
    /** The flow outcome name */
    public var name: String?
    /** The flow outcome description */
    public var _description: String?
    public var currentOperation: ArchitectFlowOutcomeNotificationArchitectOperation?

    public init(_id: String?, name: String?, _description: String?, currentOperation: ArchitectFlowOutcomeNotificationArchitectOperation?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.currentOperation = currentOperation
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case currentOperation
    }


}



/** The user who initiated the change. */

public class ArchitectFlowOutcomeNotificationUser: Codable {







    /** The ID of the user. */
    public var _id: String?
    /** The name of the user, if available. */
    public var name: String?
    public var homeOrg: ArchitectFlowOutcomeNotificationHomeOrganization?

    public init(_id: String?, name: String?, homeOrg: ArchitectFlowOutcomeNotificationHomeOrganization?) {
        self._id = _id
        self.name = name
        self.homeOrg = homeOrg
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case homeOrg
    }


}



/** The error message params, if the action failed */

public class ArchitectPromptNotificationErrorMessageParams: Codable {



    public var additionalProperties: [String:String]?

    public init(additionalProperties: [String:String]?) {
        self.additionalProperties = additionalProperties
    }


}




public class ArticleContent: Codable {



    /** Body of the article content. */
    public var body: ArticleContentBody?

    public init(body: ArticleContentBody?) {
        self.body = body
    }


}



/** Learning module response */

public class AssignedLearningModule: Codable {



















    public enum Source: String, Codable { 
        case userCreated = "UserCreated"
        case genesysBeyond = "GenesysBeyond"
    }















    public enum ModelType: String, Codable { 
        case informational = "Informational"
        case assessedContent = "AssessedContent"
        case assessment = "Assessment"
        case external = "External"
    }













    public enum ArchivalMode: String, Codable { 
        case graceful = "Graceful"
        case immediate = "Immediate"
    }

    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of learning module */
    public var name: String?
    /** If true, learning module is excluded when retrieving modules for manual assignment */
    public var excludedFromCatalog: Bool?
    /** The user who created learning module */
    public var createdBy: UserReference?
    /** The date/time learning module was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The user who modified learning module */
    public var modifiedBy: UserReference?
    /** The date/time learning module was modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The version of published learning module */
    public var version: Int?
    /** The external ID of the learning module */
    public var externalId: String?
    /** The source of the learning module */
    public var source: Source?
    /** The rule for learning module; read-only, and only populated when requested via expand param. */
    public var rule: LearningModuleRule?
    /** The current assignments for the requested users */
    public var currentAssignments: [LearningAssignment]?
    /** The URI for this object */
    public var selfUri: String?
    /** If true, learning module is archived */
    public var isArchived: Bool?
    /** If true, learning module is published */
    public var isPublished: Bool?
    /** The description of learning module */
    public var _description: String?
    /** The completion time of learning module in days */
    public var completionTimeInDays: Int?
    /** The type for the learning module */
    public var type: ModelType?
    /** The list of inform steps in a learning module */
    public var informSteps: [LearningModuleInformStep]?
    /** The assessment form for learning module */
    public var assessmentForm: AssessmentForm?
    /** The learning module summary data */
    public var summaryData: LearningModuleSummary?
    /** The learning module reassign summary data */
    public var reassignSummaryData: LearningModuleReassignSummary?
    /** The cover art for the learning module */
    public var coverArt: LearningModuleCoverArtResponse?
    /** The recommended time in minutes to complete the module */
    public var lengthInMinutes: Int?
    /** The mode of archival for learning module */
    public var archivalMode: ArchivalMode?

    public init(_id: String?, name: String?, excludedFromCatalog: Bool?, createdBy: UserReference?, dateCreated: Date?, modifiedBy: UserReference?, dateModified: Date?, version: Int?, externalId: String?, source: Source?, rule: LearningModuleRule?, currentAssignments: [LearningAssignment]?, selfUri: String?, isArchived: Bool?, isPublished: Bool?, _description: String?, completionTimeInDays: Int?, type: ModelType?, informSteps: [LearningModuleInformStep]?, assessmentForm: AssessmentForm?, summaryData: LearningModuleSummary?, reassignSummaryData: LearningModuleReassignSummary?, coverArt: LearningModuleCoverArtResponse?, lengthInMinutes: Int?, archivalMode: ArchivalMode?) {
        self._id = _id
        self.name = name
        self.excludedFromCatalog = excludedFromCatalog
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
        self.version = version
        self.externalId = externalId
        self.source = source
        self.rule = rule
        self.currentAssignments = currentAssignments
        self.selfUri = selfUri
        self.isArchived = isArchived
        self.isPublished = isPublished
        self._description = _description
        self.completionTimeInDays = completionTimeInDays
        self.type = type
        self.informSteps = informSteps
        self.assessmentForm = assessmentForm
        self.summaryData = summaryData
        self.reassignSummaryData = reassignSummaryData
        self.coverArt = coverArt
        self.lengthInMinutes = lengthInMinutes
        self.archivalMode = archivalMode
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case excludedFromCatalog
        case createdBy
        case dateCreated
        case modifiedBy
        case dateModified
        case version
        case externalId
        case source
        case rule
        case currentAssignments
        case selfUri
        case isArchived
        case isPublished
        case _description = "description"
        case completionTimeInDays
        case type
        case informSteps
        case assessmentForm
        case summaryData
        case reassignSummaryData
        case coverArt
        case lengthInMinutes
        case archivalMode
    }


}




public class Assignment: Codable {







    /** The list of users successfully assigned to the custom performance profile */
    public var assignedMembers: [UserReference]?
    /** The list of users successfully removed from the custom performance profile */
    public var removedMembers: [UserReference]?
    /** The list of users failed assignment or removal for the custom performance profile */
    public var assignmentErrors: [AssignmentError]?

    public init(assignedMembers: [UserReference]?, removedMembers: [UserReference]?, assignmentErrors: [AssignmentError]?) {
        self.assignedMembers = assignedMembers
        self.removedMembers = removedMembers
        self.assignmentErrors = assignmentErrors
    }


}




public class AssignmentValidation: Codable {









    /** The list of users that are not assigned to any custom performance profile */
    public var membersNotAssigned: [UserReference]?
    /** The list of users that are already assigned to the requesting custom performance profile */
    public var membersAlreadyAssigned: [UserReference]?
    /** The list of users that are already assigned to other custom performance profiles */
    public var membersAlreadyAssignedToOther: [OtherProfileAssignment]?
    /** The list of user id that are invalid for the gamfication service to handle */
    public var invalidMemberAssignments: [InvalidAssignment]?

    public init(membersNotAssigned: [UserReference]?, membersAlreadyAssigned: [UserReference]?, membersAlreadyAssignedToOther: [OtherProfileAssignment]?, invalidMemberAssignments: [InvalidAssignment]?) {
        self.membersNotAssigned = membersNotAssigned
        self.membersAlreadyAssigned = membersAlreadyAssigned
        self.membersAlreadyAssignedToOther = membersAlreadyAssignedToOther
        self.invalidMemberAssignments = invalidMemberAssignments
    }


}




public class AsyncConversationQuery: Codable {











    public enum Order: String, Codable { 
        case asc = "asc"
        case desc = "desc"
        case unordered = "unordered"
    }

    public enum OrderBy: String, Codable { 
        case conversationstart = "conversationStart"
        case conversationend = "conversationEnd"
        case segmentstart = "segmentStart"
        case segmentend = "segmentEnd"
    }







    /** Filters that target conversation-level data */
    public var conversationFilters: [ConversationDetailQueryFilter]?
    /** Filters that target individual segments within a conversation */
    public var segmentFilters: [SegmentDetailQueryFilter]?
    /** Filters that target evaluations */
    public var evaluationFilters: [EvaluationDetailQueryFilter]?
    /** Filters that target surveys */
    public var surveyFilters: [SurveyDetailQueryFilter]?
    /** Filters that target resolutions */
    public var resolutionFilters: [ResolutionDetailQueryFilter]?
    /** Sort the result set in ascending/descending order. Default is ascending */
    public var order: Order?
    /** Specify which data element within the result set to use for sorting. The options  to use as a basis for sorting the results: conversationStart, segmentStart, and segmentEnd. If not specified, the default is conversationStart */
    public var orderBy: OrderBy?
    /** Specifies the date and time range of data being queried. Results will include all conversations that had activity during the interval. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Specify number of results to be returned */
    public var limit: Int?
    /** Add a filter to only include conversations that started after the beginning of the interval start date (UTC) */
    public var startOfDayIntervalMatching: Bool?

    public init(conversationFilters: [ConversationDetailQueryFilter]?, segmentFilters: [SegmentDetailQueryFilter]?, evaluationFilters: [EvaluationDetailQueryFilter]?, surveyFilters: [SurveyDetailQueryFilter]?, resolutionFilters: [ResolutionDetailQueryFilter]?, order: Order?, orderBy: OrderBy?, interval: String?, limit: Int?, startOfDayIntervalMatching: Bool?) {
        self.conversationFilters = conversationFilters
        self.segmentFilters = segmentFilters
        self.evaluationFilters = evaluationFilters
        self.surveyFilters = surveyFilters
        self.resolutionFilters = resolutionFilters
        self.order = order
        self.orderBy = orderBy
        self.interval = interval
        self.limit = limit
        self.startOfDayIntervalMatching = startOfDayIntervalMatching
    }


}




public class AsyncUserDetailsQuery: Codable {









    public enum Order: String, Codable { 
        case asc = "asc"
        case desc = "desc"
        case unordered = "unordered"
    }



    /** Specifies the date and time range of data being queried. Conversations MUST have started within this time range to potentially be included within the result set. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Filters that target the users to retrieve data for */
    public var userFilters: [UserDetailQueryFilter]?
    /** Filters that target system and organization presence-level data */
    public var presenceFilters: [PresenceDetailQueryFilter]?
    /** Filters that target agent routing status-level data */
    public var routingStatusFilters: [RoutingStatusDetailQueryFilter]?
    /** Sort the result set in ascending/descending order. Default is ascending */
    public var order: Order?
    /** Specify number of results to be returned */
    public var limit: Int?

    public init(interval: String?, userFilters: [UserDetailQueryFilter]?, presenceFilters: [PresenceDetailQueryFilter]?, routingStatusFilters: [RoutingStatusDetailQueryFilter]?, order: Order?, limit: Int?) {
        self.interval = interval
        self.userFilters = userFilters
        self.presenceFilters = presenceFilters
        self.routingStatusFilters = routingStatusFilters
        self.order = order
        self.limit = limit
    }


}




public class AttendanceStatus: Codable {



    public enum AttendanceStatusType: String, Codable { 
        case hasData = "HasData"
        case scheduled = "Scheduled"
        case absent = "Absent"
        case present = "Present"
        case noSchedule = "NoSchedule"
    }

    public enum HasEvaluation: String, Codable { 
        case hasQualityEvaluation = "HasQualityEvaluation"
        case noQualityEvaluation = "NoQualityEvaluation"
    }

    /** the workday date of this attendance status. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateWorkday: Date?
    /** the attendance status */
    public var attendanceStatusType: AttendanceStatusType?
    /** the quality evaluation score status */
    public var hasEvaluation: HasEvaluation?

    public init(dateWorkday: Date?, attendanceStatusType: AttendanceStatusType?, hasEvaluation: HasEvaluation?) {
        self.dateWorkday = dateWorkday
        self.attendanceStatusType = attendanceStatusType
        self.hasEvaluation = hasEvaluation
    }


}




public class AttendanceStatusListing: Codable {



    public var entities: [AttendanceStatus]?

    public init(entities: [AttendanceStatus]?) {
        self.entities = entities
    }


}




public class AttributeDetailEventTopicCommunication: Codable {



    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
    }

    public var _id: String?
    public var mediaType: MediaType?

    public init(_id: String?, mediaType: MediaType?) {
        self._id = _id
        self.mediaType = mediaType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case mediaType
    }


}




public class AtzmTimeSlot: Codable {





    /** The earliest time to dial a contact. Valid format is HH:mm */
    public var earliestCallableTime: String?
    /** The latest time to dial a contact. Valid format is HH:mm */
    public var latestCallableTime: String?

    public init(earliestCallableTime: String?, latestCallableTime: String?) {
        self.earliestCallableTime = earliestCallableTime
        self.latestCallableTime = latestCallableTime
    }


}




public class AuditQueryEntity: Codable {





    /** Name of the Entity */
    public var name: String?
    /** List of Actions */
    public var actions: [String]?

    public init(name: String?, actions: [String]?) {
        self.name = name
        self.actions = actions
    }


}




public class AuditQueryServiceMapping: Codable {



    /** List of Services */
    public var services: [AuditQueryService]?

    public init(services: [AuditQueryService]?) {
        self.services = services
    }


}




public class AuditTopicMessageInfo: Codable {









    public var localizableMessageCode: String?
    public var message: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?

    public init(localizableMessageCode: String?, message: String?, messageWithParams: String?, messageParams: [String:String]?) {
        self.localizableMessageCode = localizableMessageCode
        self.message = message
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
    }


}




public class AuthzGrantRole: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var _description: String?
    public var policies: [AuthzGrantPolicy]?
    public var _default: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, policies: [AuthzGrantPolicy]?, _default: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.policies = policies
        self._default = _default
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case policies
        case _default = "default"
        case selfUri
    }


}




public class AuthzSubject: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var grants: [AuthzGrant]?
    public var version: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, grants: [AuthzGrant]?, version: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.grants = grants
        self.version = version
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case grants
        case version
        case selfUri
    }


}




public class AvailableTimeOffRequest: Codable {





    /** The ID for activity code to query available time off minutes */
    public var activityCodeId: String?
    /** A list of date ranges of available time off minutes. A maximum number of date ranges is 30. The maximum total number of days in all ranges is 366. If no ranges are specified, then only the presence of the associated time off limit object will be checked. In such case, if the association exists, then the response will contain a list with of a single element filled with timeOffLimitId only. */
    public var dateRanges: [LocalDateRange]?

    public init(activityCodeId: String?, dateRanges: [LocalDateRange]?) {
        self.activityCodeId = activityCodeId
        self.dateRanges = dateRanges
    }


}




public class AvailableTranslations: Codable {





    public var orgSpecific: [String]?
    public var builtin: [String]?

    public init(orgSpecific: [String]?, builtin: [String]?) {
        self.orgSpecific = orgSpecific
        self.builtin = builtin
    }


}




public class BaseProgramEntity: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}



/** A maximum of 100 events are allowed per request */

public class BatchUserRoutingStatusEventRequest: Codable {



    /** UserRoutingStatus events for this batch */
    public var userRoutingStatusEvents: [UserRoutingStatusEvent]?

    public init(userRoutingStatusEvents: [UserRoutingStatusEvent]?) {
        self.userRoutingStatusEvents = userRoutingStatusEvents
    }


}




public class BotAggregateQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [BotAggregateQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [BotAggregateQueryPredicate]?

    public init(type: ModelType?, clauses: [BotAggregateQueryClause]?, predicates: [BotAggregateQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class BotConnectorBotVersionSummaryEntityListing: Codable {





















    public var entities: [BotVersionSummary]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [BotVersionSummary]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** Model for setting the launch configuration for a Nuance bot available to Genesys Cloud */

public class BotExecutionConfiguration: Codable {







    /** The Nuance bot ID */
    public var botId: String?
    /** The hostname to use when contacting Nuance to execute this bot */
    public var executionHost: String?
    /** The bot's launch credentials */
    public var botCredentials: NuanceBotCredentials?

    public init(botId: String?, executionHost: String?, botCredentials: NuanceBotCredentials?) {
        self.botId = botId
        self.executionHost = executionHost
        self.botCredentials = botCredentials
    }


}



/** A botConnector's bot intention */

public class BotIntent: Codable {





    /** The name of this intent.  This can be up to 100 characters long and must be comprised of displayable characters without leading or trailing whitespace */
    public var name: String?
    /** Optional returned data values associated with this intent, limit of 50. */
    public var slots: [String:BotSlot]?

    public init(name: String?, slots: [String:BotSlot]?) {
        self.name = name
        self.slots = slots
    }


}




public class BuAverageSpeedOfAnswer: Codable {





    /** Whether to include average speed of answer (ASA) in the associated configuration */
    public var include: Bool?
    /** The target average speed of answer (ASA) in seconds. Required if include == true */
    public var seconds: Int?

    public init(include: Bool?, seconds: Int?) {
        self.include = include
        self.seconds = seconds
    }


}




public class BuForecastGenerationPlanningGroupResult: Codable {





    /** The ID of the planning group */
    public var planningGroupId: String?
    /** The generation results for the associated planning group */
    public var metricResults: [BuForecastTimeSeriesResult]?

    public init(planningGroupId: String?, metricResults: [BuForecastTimeSeriesResult]?) {
        self.planningGroupId = planningGroupId
        self.metricResults = metricResults
    }


}




public class BuForecastStaffingRequirementsResultResponse: Codable {











    public enum State: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case error = "Error"
    }



    /** The ID of the business unit to which the forecast staffing requirements belongs */
    public var businessUnitId: String?
    /** The forecast reference */
    public var forecast: BuShortTermForecastReference?
    /** The reference start date for interval-based data for this forecast as an ISO-8601 string */
    public var referenceStartDate: Date?
    /** The number of weeks in this forecast */
    public var weekCount: Int?
    /** The period/interval in minutes for which to aggregate the data */
    public var intervalLengthMinutes: Int?
    /** The state of the staffing requirements generation */
    public var state: State?
    /** The forecast staffing requirement results, Will be populated when state == 'Complete' */
    public var results: [BuForecastStaffingRequirementsResult]?

    public init(businessUnitId: String?, forecast: BuShortTermForecastReference?, referenceStartDate: Date?, weekCount: Int?, intervalLengthMinutes: Int?, state: State?, results: [BuForecastStaffingRequirementsResult]?) {
        self.businessUnitId = businessUnitId
        self.forecast = forecast
        self.referenceStartDate = referenceStartDate
        self.weekCount = weekCount
        self.intervalLengthMinutes = intervalLengthMinutes
        self.state = state
        self.results = results
    }


}




public class BuFullDayTimeOffMarker: Codable {

















    /** The date of the time off marker, interpreted in the business unit's time zone. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var businessUnitDate: Date?
    /** The length of the time off marker in minutes */
    public var lengthMinutes: Int?
    /** The description of the time off marker */
    public var _description: String?
    /** The ID of the activity code associated with the time off marker */
    public var activityCodeId: String?
    /** Whether the time off marker is paid */
    public var paid: Bool?
    /** Payable minutes for the time off marker */
    public var payableMinutes: Int?
    /** The ID of the time off request */
    public var timeOffRequestId: String?
    /** The sync version of the full day time off request for which the scheduled activity is associated */
    public var timeOffRequestSyncVersion: Int?

    public init(businessUnitDate: Date?, lengthMinutes: Int?, _description: String?, activityCodeId: String?, paid: Bool?, payableMinutes: Int?, timeOffRequestId: String?, timeOffRequestSyncVersion: Int?) {
        self.businessUnitDate = businessUnitDate
        self.lengthMinutes = lengthMinutes
        self._description = _description
        self.activityCodeId = activityCodeId
        self.paid = paid
        self.payableMinutes = payableMinutes
        self.timeOffRequestId = timeOffRequestId
        self.timeOffRequestSyncVersion = timeOffRequestSyncVersion
    }

    public enum CodingKeys: String, CodingKey { 
        case businessUnitDate
        case lengthMinutes
        case _description = "description"
        case activityCodeId
        case paid
        case payableMinutes
        case timeOffRequestId
        case timeOffRequestSyncVersion
    }


}




public class BuHeadcountForecast: Codable {





    public var entities: [BuPlanningGroupHeadcountForecast]?
    /** Reference start date for the interval values in each forecast entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var referenceStartDate: Date?

    public init(entities: [BuPlanningGroupHeadcountForecast]?, referenceStartDate: Date?) {
        self.entities = entities
        self.referenceStartDate = referenceStartDate
    }


}




public class BuIntradayDataGroup: Codable {

    public enum MediaType: String, Codable { 
        case voice = "Voice"
        case chat = "Chat"
        case email = "Email"
        case callback = "Callback"
        case message = "Message"
    }













    /** The media type associated with this intraday group */
    public var mediaType: MediaType?
    /** Forecast data summary for this date range */
    public var forecastDataSummary: BuIntradayForecastData?
    /** Forecast data per interval for this date range */
    public var forecastDataPerInterval: [BuIntradayForecastData]?
    /** Schedule data summary for this date range */
    public var scheduleDataSummary: BuIntradayScheduleData?
    /** Schedule data per interval for this date range */
    public var scheduleDataPerInterval: [BuIntradayScheduleData]?
    /** Performance prediction data summary for this date range */
    public var performancePredictionDataSummary: IntradayPerformancePredictionData?
    /** Performance prediction data per interval for this date range */
    public var performancePredictionDataPerInterval: [IntradayPerformancePredictionData]?

    public init(mediaType: MediaType?, forecastDataSummary: BuIntradayForecastData?, forecastDataPerInterval: [BuIntradayForecastData]?, scheduleDataSummary: BuIntradayScheduleData?, scheduleDataPerInterval: [BuIntradayScheduleData]?, performancePredictionDataSummary: IntradayPerformancePredictionData?, performancePredictionDataPerInterval: [IntradayPerformancePredictionData]?) {
        self.mediaType = mediaType
        self.forecastDataSummary = forecastDataSummary
        self.forecastDataPerInterval = forecastDataPerInterval
        self.scheduleDataSummary = scheduleDataSummary
        self.scheduleDataPerInterval = scheduleDataPerInterval
        self.performancePredictionDataSummary = performancePredictionDataSummary
        self.performancePredictionDataPerInterval = performancePredictionDataPerInterval
    }


}




public class BuQueryAdherenceExplanationsResponse: Codable {







    /** The asynchronous job handling the query */
    public var job: AdherenceExplanationJobReference?
    /** The result of the query. May come via notification */
    public var result: AdherenceExplanationListingBuQueryResponse?
    /** The URL from which to download the result. May come via notification */
    public var downloadUrl: String?

    public init(job: AdherenceExplanationJobReference?, result: AdherenceExplanationListingBuQueryResponse?, downloadUrl: String?) {
        self.job = job
        self.result = result
        self.downloadUrl = downloadUrl
    }


}




public class BuSchedulingSettingsResponse: Codable {




    public enum SyncTimeOffProperties: String, Codable { 
        case payableMinutes = "PayableMinutes"
    }




    /** Schedule generation message severity configuration */
    public var messageSeverities: [SchedulerMessageTypeSeverity]?
    /** Synchronize set of time off properties from scheduled activities to time off requests when the schedule is published. */
    public var syncTimeOffProperties: [SyncTimeOffProperties]?
    /** Configures the max percent increase and decrease of service goals for this business unit */
    public var serviceGoalImpact: WfmServiceGoalImpactSettings?
    /** Indicates whether or not per minute granularity for scheduling will be enabled for this business unit. Defaults to false. */
    public var allowWorkPlanPerMinuteGranularity: Bool?

    public init(messageSeverities: [SchedulerMessageTypeSeverity]?, syncTimeOffProperties: [SyncTimeOffProperties]?, serviceGoalImpact: WfmServiceGoalImpactSettings?, allowWorkPlanPerMinuteGranularity: Bool?) {
        self.messageSeverities = messageSeverities
        self.syncTimeOffProperties = syncTimeOffProperties
        self.serviceGoalImpact = serviceGoalImpact
        self.allowWorkPlanPerMinuteGranularity = allowWorkPlanPerMinuteGranularity
    }


}




public class BuSearchAgentSchedulesRequest: Codable {







    /** Start date of the range to search. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** End date of the range to search. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endDate: Date?
    /** IDs of the users for whose schedules to search */
    public var userIds: [String]?

    public init(startDate: Date?, endDate: Date?, userIds: [String]?) {
        self.startDate = startDate
        self.endDate = endDate
        self.userIds = userIds
    }


}




public class BuShortTermForecastingSettings: Codable {



    /** The number of historical weeks to consider when creating a forecast. This setting is only used for legacy weighted average forecasts */
    public var defaultHistoryWeeks: Int?

    public init(defaultHistoryWeeks: Int?) {
        self.defaultHistoryWeeks = defaultHistoryWeeks
    }


}




public class BulkContactsRequest: Codable {



    public var entities: [ExternalContact]?

    public init(entities: [ExternalContact]?) {
        self.entities = entities
    }


}




public class BulkErrorExternalOrganization: Codable {













    public var code: String?
    public var message: String?
    public var status: Int?
    public var retryable: Bool?
    public var entity: ExternalOrganization?
    public var details: [BulkErrorDetail]?

    public init(code: String?, message: String?, status: Int?, retryable: Bool?, entity: ExternalOrganization?, details: [BulkErrorDetail]?) {
        self.code = code
        self.message = message
        self.status = status
        self.retryable = retryable
        self.entity = entity
        self.details = details
    }


}




public class BulkFetchOrganizationsResponse: Codable {







    public var results: [BulkResponseResultExternalOrganizationEntity]?
    public var errorCount: Int?
    public var errorIndexes: [Int]?

    public init(results: [BulkResponseResultExternalOrganizationEntity]?, errorCount: Int?, errorIndexes: [Int]?) {
        self.results = results
        self.errorCount = errorCount
        self.errorIndexes = errorIndexes
    }


}




public class BulkNotesRequest: Codable {



    public var entities: [Note]?

    public init(entities: [Note]?) {
        self.entities = entities
    }


}




public class BulkOrganizationsResponse: Codable {







    public var results: [BulkResponseResultExternalOrganizationExternalOrganization]?
    public var errorCount: Int?
    public var errorIndexes: [Int]?

    public init(results: [BulkResponseResultExternalOrganizationExternalOrganization]?, errorCount: Int?, errorIndexes: [Int]?) {
        self.results = results
        self.errorCount = errorCount
        self.errorIndexes = errorIndexes
    }


}




public class BulkRelationshipsRequest: Codable {



    public var entities: [Relationship]?

    public init(entities: [Relationship]?) {
        self.entities = entities
    }


}




public class BusinessUnitActivityCode: Codable {









    public enum Category: String, Codable { 
        case onQueueWork = "OnQueueWork"
        case _break = "Break"
        case meal = "Meal"
        case meeting = "Meeting"
        case offQueueWork = "OffQueueWork"
        case timeOff = "TimeOff"
        case training = "Training"
        case unavailable = "Unavailable"
        case unscheduled = "Unscheduled"
    }





















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Whether this activity code is active or has been deleted */
    public var active: Bool?
    /** Whether this is a default activity code */
    public var defaultCode: Bool?
    /** The category of the activity code */
    public var category: Category?
    /** The default length of the activity in minutes */
    public var lengthInMinutes: Int?
    /** Whether an agent is paid while performing this activity */
    public var countsAsPaidTime: Bool?
    /** Indicates whether or not the activity should be counted as contiguous work time for calculating daily constraints */
    public var countsAsWorkTime: Bool?
    /** Whether an agent can select this activity code when creating or editing a time off request. Null if the activity's category is not time off. */
    public var agentTimeOffSelectable: Bool?
    /** Whether or not this activity code counts toward shrinkage calculations */
    public var countsTowardShrinkage: Bool?
    /** Whether this activity code is considered planned or unplanned shrinkage */
    public var plannedShrinkage: Bool?
    /** Whether this activity code is considered interruptible */
    public var interruptible: Bool?
    /** The secondary presences of this activity code */
    public var secondaryPresences: [SecondaryPresence]?
    /** Version metadata of this activity code */
    public var metadata: WfmVersionedEntityMetadata?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, active: Bool?, defaultCode: Bool?, category: Category?, lengthInMinutes: Int?, countsAsPaidTime: Bool?, countsAsWorkTime: Bool?, agentTimeOffSelectable: Bool?, countsTowardShrinkage: Bool?, plannedShrinkage: Bool?, interruptible: Bool?, secondaryPresences: [SecondaryPresence]?, metadata: WfmVersionedEntityMetadata?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.active = active
        self.defaultCode = defaultCode
        self.category = category
        self.lengthInMinutes = lengthInMinutes
        self.countsAsPaidTime = countsAsPaidTime
        self.countsAsWorkTime = countsAsWorkTime
        self.agentTimeOffSelectable = agentTimeOffSelectable
        self.countsTowardShrinkage = countsTowardShrinkage
        self.plannedShrinkage = plannedShrinkage
        self.interruptible = interruptible
        self.secondaryPresences = secondaryPresences
        self.metadata = metadata
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case active
        case defaultCode
        case category
        case lengthInMinutes
        case countsAsPaidTime
        case countsAsWorkTime
        case agentTimeOffSelectable
        case countsTowardShrinkage
        case plannedShrinkage
        case interruptible
        case secondaryPresences
        case metadata
        case selfUri
    }


}




public class BusinessUnitActivityCodeListing: Codable {





    public var entities: [BusinessUnitActivityCode]?
    /** URL from which to fetch results for requests with a large result set. If populated, the downloaded data will conform to the same schema as would normally be returned, excepting downloaded data will never itself contain a downloadUrl */
    public var downloadUrl: String?

    public init(entities: [BusinessUnitActivityCode]?, downloadUrl: String?) {
        self.entities = entities
        self.downloadUrl = downloadUrl
    }


}




public class CachedMediaItemEntityListing: Codable {





















    public var entities: [CachedMediaItem]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CachedMediaItem]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CalibrationCreate: Codable {

































    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var calibrator: User?
    public var agent: User?
    /** The conversation to use for the calibration. */
    public var conversation: ConversationReference?
    public var evaluationForm: EvaluationForm?
    public var contextId: String?
    public var averageScore: Int?
    public var highScore: Int?
    public var lowScore: Int?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    public var evaluations: [Evaluation]?
    public var evaluators: [User]?
    public var scoringIndex: Evaluation?
    public var expertEvaluator: User?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, calibrator: User?, agent: User?, conversation: ConversationReference?, evaluationForm: EvaluationForm?, contextId: String?, averageScore: Int?, highScore: Int?, lowScore: Int?, createdDate: Date?, evaluations: [Evaluation]?, evaluators: [User]?, scoringIndex: Evaluation?, expertEvaluator: User?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.calibrator = calibrator
        self.agent = agent
        self.conversation = conversation
        self.evaluationForm = evaluationForm
        self.contextId = contextId
        self.averageScore = averageScore
        self.highScore = highScore
        self.lowScore = lowScore
        self.createdDate = createdDate
        self.evaluations = evaluations
        self.evaluators = evaluators
        self.scoringIndex = scoringIndex
        self.expertEvaluator = expertEvaluator
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case calibrator
        case agent
        case conversation
        case evaluationForm
        case contextId
        case averageScore
        case highScore
        case lowScore
        case createdDate
        case evaluations
        case evaluators
        case scoringIndex
        case expertEvaluator
        case selfUri
    }


}




public class CallHistoryConversation: Codable {







    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }



















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The list of participants involved in the conversation. */
    public var participants: [CallHistoryParticipant]?
    /** The direction of the call relating to the current user */
    public var direction: Direction?
    /** Did the call end in the current user's voicemail */
    public var wentToVoicemail: Bool?
    /** Did the user not answer this conversation */
    public var missedCall: Bool?
    /** The time the user joined the conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startTime: Date?
    /** Was this conversation a conference */
    public var wasConference: Bool?
    /** Was this conversation a callback */
    public var wasCallback: Bool?
    /** Did this conversation have a screen share session */
    public var hadScreenShare: Bool?
    /** Did this conversation have a cobrowse session */
    public var hadCobrowse: Bool?
    /** Was this conversation associated with an outbound campaign */
    public var wasOutboundCampaign: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, participants: [CallHistoryParticipant]?, direction: Direction?, wentToVoicemail: Bool?, missedCall: Bool?, startTime: Date?, wasConference: Bool?, wasCallback: Bool?, hadScreenShare: Bool?, hadCobrowse: Bool?, wasOutboundCampaign: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.direction = direction
        self.wentToVoicemail = wentToVoicemail
        self.missedCall = missedCall
        self.startTime = startTime
        self.wasConference = wasConference
        self.wasCallback = wasCallback
        self.hadScreenShare = hadScreenShare
        self.hadCobrowse = hadCobrowse
        self.wasOutboundCampaign = wasOutboundCampaign
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case direction
        case wentToVoicemail
        case missedCall
        case startTime
        case wasConference
        case wasCallback
        case hadScreenShare
        case hadCobrowse
        case wasOutboundCampaign
        case selfUri
    }


}




public class CallMediaPolicy: Codable {





    /** Actions applied when specified conditions are met */
    public var actions: PolicyActions?
    /** Conditions for when actions should be applied */
    public var conditions: CallMediaPolicyConditions?

    public init(actions: PolicyActions?, conditions: CallMediaPolicyConditions?) {
        self.actions = actions
        self.conditions = conditions
    }


}




public class CallMediaPolicyConditions: Codable {















    public enum Directions: String, Codable { 
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }



    public var forUsers: [User]?
    public var dateRanges: [String]?
    public var forQueues: [Queue]?
    public var wrapupCodes: [WrapupCode]?
    public var languages: [Language]?
    public var timeAllowed: TimeAllowed?
    /** Teams to match conversations against */
    public var teams: [Team]?
    public var directions: [Directions]?
    public var duration: DurationCondition?

    public init(forUsers: [User]?, dateRanges: [String]?, forQueues: [Queue]?, wrapupCodes: [WrapupCode]?, languages: [Language]?, timeAllowed: TimeAllowed?, teams: [Team]?, directions: [Directions]?, duration: DurationCondition?) {
        self.forUsers = forUsers
        self.dateRanges = dateRanges
        self.forQueues = forQueues
        self.wrapupCodes = wrapupCodes
        self.languages = languages
        self.timeAllowed = timeAllowed
        self.teams = teams
        self.directions = directions
        self.duration = duration
    }


}




public class CallableContactsDiagnostic: Codable {









    /** Attempt limits for the campaign's contact list */
    public var attemptLimits: DomainEntityRef?
    /** Do not call lists for the campaign */
    public var dncLists: [DomainEntityRef]?
    /** Callable time sets for the campaign */
    public var callableTimeSet: DomainEntityRef?
    /** Rule sets for the campaign */
    public var ruleSets: [DomainEntityRef]?

    public init(attemptLimits: DomainEntityRef?, dncLists: [DomainEntityRef]?, callableTimeSet: DomainEntityRef?, ruleSets: [DomainEntityRef]?) {
        self.attemptLimits = attemptLimits
        self.dncLists = dncLists
        self.callableTimeSet = callableTimeSet
        self.ruleSets = ruleSets
    }


}




public class CampaignDiagnostics: Codable {















    /** Campaign properties that can impact which contacts are callable */
    public var callableContacts: CallableContactsDiagnostic?
    /** Information regarding the campaign's queue */
    public var queueUtilizationDiagnostic: QueueUtilizationDiagnostic?
    /** Information regarding the campaign's rule sets */
    public var ruleSetDiagnostics: [RuleSetDiagnostic]?
    /** Current number of outstanding interactions on the campaign */
    public var outstandingInteractionsCount: Int?
    /** Current number of scheduled interactions on the campaign */
    public var scheduledInteractionsCount: Int?
    /** Current number of time zone rescheduled calls on the campaign */
    public var timeZoneRescheduledCallsCount: Int?
    /** Information regarding the campaign's skills */
    public var campaignSkillStatistics: CampaignSkillStatistics?

    public init(callableContacts: CallableContactsDiagnostic?, queueUtilizationDiagnostic: QueueUtilizationDiagnostic?, ruleSetDiagnostics: [RuleSetDiagnostic]?, outstandingInteractionsCount: Int?, scheduledInteractionsCount: Int?, timeZoneRescheduledCallsCount: Int?, campaignSkillStatistics: CampaignSkillStatistics?) {
        self.callableContacts = callableContacts
        self.queueUtilizationDiagnostic = queueUtilizationDiagnostic
        self.ruleSetDiagnostics = ruleSetDiagnostics
        self.outstandingInteractionsCount = outstandingInteractionsCount
        self.scheduledInteractionsCount = scheduledInteractionsCount
        self.timeZoneRescheduledCallsCount = timeZoneRescheduledCallsCount
        self.campaignSkillStatistics = campaignSkillStatistics
    }


}




public class CampaignRuleAction: Codable {





    public enum ActionType: String, Codable { 
        case turnoncampaign = "turnOnCampaign"
        case turnoffcampaign = "turnOffCampaign"
        case turnonsequence = "turnOnSequence"
        case turnoffsequence = "turnOffSequence"
        case setcampaignpriority = "setCampaignPriority"
        case recyclecampaign = "recycleCampaign"
        case setcampaigndialingmode = "setCampaignDialingMode"
    }



    public var _id: String?
    /** The parameters for the CampaignRuleAction. Required for certain actionTypes. */
    public var parameters: CampaignRuleParameters?
    /** The action to take on the campaignRuleActionEntities. */
    public var actionType: ActionType?
    /** The list of entities that this action will apply to. */
    public var campaignRuleActionEntities: CampaignRuleActionEntities?

    public init(_id: String?, parameters: CampaignRuleParameters?, actionType: ActionType?, campaignRuleActionEntities: CampaignRuleActionEntities?) {
        self._id = _id
        self.parameters = parameters
        self.actionType = actionType
        self.campaignRuleActionEntities = campaignRuleActionEntities
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case parameters
        case actionType
        case campaignRuleActionEntities
    }


}



/** A card action that a user can take. */

public class CardAction: Codable {

    public enum ModelType: String, Codable { 
        case link = "Link"
        case postback = "Postback"
    }









    /** Describes the type of action. */
    public var type: ModelType?
    /** The response text from the button click. */
    public var text: String?
    /** Content of the textback payload after clicking a button. */
    public var payload: String?
    /** The location of the image file associated with action. */
    public var url: String?
    /** Indicates if the card option is selected by end customer. */
    public var isSelected: Bool?

    public init(type: ModelType?, text: String?, payload: String?, url: String?, isSelected: Bool?) {
        self.type = type
        self.text = text
        self.payload = payload
        self.url = url
        self.isSelected = isSelected
    }


}




public class CertificateAuthorityEntityListing: Codable {





















    public var entities: [DomainCertificateAuthority]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DomainCertificateAuthority]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ChannelEntityListing: Codable {



    public var entities: [Channel]?

    public init(entities: [Channel]?) {
        self.entities = entities
    }


}




public class Chat: Codable {



    public var jabberId: String?

    public init(jabberId: String?) {
        self.jabberId = jabberId
    }


}




public class ChatConversation: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The list of participants involved in the conversation. */
    public var participants: [ChatMediaParticipant]?
    /** The list of other media channels involved in the conversation. */
    public var otherMediaUris: [String]?
    /** The list of the most recent 20 transfer commands applied to this conversation. */
    public var recentTransfers: [TransferResponse]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, participants: [ChatMediaParticipant]?, otherMediaUris: [String]?, recentTransfers: [TransferResponse]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
        self.recentTransfers = recentTransfers
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
        case recentTransfers
        case selfUri
    }


}




public class ClonedUserEntityListing: Codable {







    public var total: Int64?
    public var entities: [ClonedUser]?
    public var selfUri: String?

    public init(total: Int64?, entities: [ClonedUser]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class CoachingAnnotationList: Codable {





















    public var entities: [CoachingAnnotation]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CoachingAnnotation]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CoachingAppointmentReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class CoachingAppointmentStatusResponse: Codable {







    public enum Status: String, Codable { 
        case scheduled = "Scheduled"
        case inProgress = "InProgress"
        case completed = "Completed"
        case invalidSchedule = "InvalidSchedule"
    }

    /** The coaching appointment this status belongs to */
    public var appointment: CoachingAppointmentReference?
    /** User who updated the status */
    public var createdBy: UserReference?
    /** Creation time of the status. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The status of the coaching appointment */
    public var status: Status?

    public init(appointment: CoachingAppointmentReference?, createdBy: UserReference?, dateCreated: Date?, status: Status?) {
        self.appointment = appointment
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.status = status
    }


}




public class CoachingSlot: Codable {







    public enum DifferenceRating: String, Codable { 
        case poor = "Poor"
        case neutral = "Neutral"
        case good = "Good"
    }



    /** Start date and time of scheduled coaching appointment slot. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?
    /** Length of coaching appointment slot in minutes */
    public var lengthInMinutes: Int?
    /** Difference between scheduled and forecast headcount for this slot after scheduling the coaching appointment */
    public var staffingDifference: Double?
    /** Rating based on the staffing difference for scheduled slot */
    public var differenceRating: DifferenceRating?
    /** Workforce Management schedule information associated with the slot */
    public var wfmSchedule: WfmScheduleReference?

    public init(dateStart: Date?, lengthInMinutes: Int?, staffingDifference: Double?, differenceRating: DifferenceRating?, wfmSchedule: WfmScheduleReference?) {
        self.dateStart = dateStart
        self.lengthInMinutes = lengthInMinutes
        self.staffingDifference = staffingDifference
        self.differenceRating = differenceRating
        self.wfmSchedule = wfmSchedule
    }


}




public class CoachingSlotsRequest: Codable {











    /** Range of time to get slots for scheduling coaching appointments. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** The duration of coaching appointment to schedule in 15 minutes granularity up to maximum of 60 minutes */
    public var lengthInMinutes: Int?
    /** List of attendees to determine coaching appointment slots */
    public var attendeeIds: [String]?
    /** List of facilitators to determine coaching appointment slots */
    public var facilitatorIds: [String]?
    /** List of appointment ids to exclude from consideration when determining blocked slots */
    public var interruptibleAppointmentIds: [String]?

    public init(interval: String?, lengthInMinutes: Int?, attendeeIds: [String]?, facilitatorIds: [String]?, interruptibleAppointmentIds: [String]?) {
        self.interval = interval
        self.lengthInMinutes = lengthInMinutes
        self.attendeeIds = attendeeIds
        self.facilitatorIds = facilitatorIds
        self.interruptibleAppointmentIds = interruptibleAppointmentIds
    }


}




public class CommandStatusEntityListing: Codable {





















    public var entities: [CommandStatus]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CommandStatus]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CommonCampaignEntityListing: Codable {





















    public var entities: [CommonCampaign]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [CommonCampaign]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class CommonRuleBulkUpdateNotificationsRequest: Codable {






    public enum TypesToAdd: String, Codable { 
        case sms = "Sms"
        case device = "Device"
        case email = "Email"
        case push = "Push"
    }

    public enum TypesToRemove: String, Codable { 
        case sms = "Sms"
        case device = "Device"
        case email = "Email"
        case push = "Push"
    }
    /** The user supplied rules ids to be updated */
    public var ruleIds: [String]?
    /** The rule properties to be updated */
    public var properties: ModifiableRuleProperties?
    /** Collection of alerting notification types to add for all entities in the rules */
    public var typesToAdd: [TypesToAdd]?
    /** Collection of alerting notification types to remove for all entities in the rules */
    public var typesToRemove: [TypesToRemove]?

    public init(ruleIds: [String]?, properties: ModifiableRuleProperties?, typesToAdd: [TypesToAdd]?, typesToRemove: [TypesToRemove]?) {
        self.ruleIds = ruleIds
        self.properties = properties
        self.typesToAdd = typesToAdd
        self.typesToRemove = typesToRemove
    }


}




public class Compliance: Codable {







    /** List of configurations for 'StopSettings' compliance */
    public var stopSettings: [StopSettings]?
    /** List of configurations for 'OptInSettings' compliance */
    public var optInSettings: [OptInSettings]?
    /** List of configurations for 'HelpSettings' compliance */
    public var helpSettings: [HelpSettings]?

    public init(stopSettings: [StopSettings]?, optInSettings: [OptInSettings]?, helpSettings: [HelpSettings]?) {
        self.stopSettings = stopSettings
        self.optInSettings = optInSettings
        self.helpSettings = helpSettings
    }


}




public class ConditionalGroupRouting: Codable {



    /** The set of rules that defines Conditional Group Routing for this queue */
    public var rules: [ConditionalGroupRoutingRule]?

    public init(rules: [ConditionalGroupRoutingRule]?) {
        self.rules = rules
    }


}




public class ConfusionInfo: Codable {



    /** Confusion details between this utterance and other intents. */
    public var intents: [ConfusionIntentInfo]?

    public init(intents: [ConfusionIntentInfo]?) {
        self.intents = intents
    }


}




public class ConfusionIntentDetails: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Number of utterances in this intent which are similar to parent utterance. */
    public var utteranceCount: Int?
    /** List of utterance which are similar to parent utterance. */
    public var utterances: [ConfusionUtterance]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, utteranceCount: Int?, utterances: [ConfusionUtterance]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.utteranceCount = utteranceCount
        self.utterances = utterances
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case utteranceCount
        case utterances
        case selfUri
    }


}




public class ConsumingResourcesEntityListing: Codable {





















    public var entities: [Dependency]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Dependency]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ContactCenterSettings: Codable {



    /** Strip skills from transfer */
    public var removeSkillsFromBlindTransfer: Bool?

    public init(removeSkillsFromBlindTransfer: Bool?) {
        self.removeSkillsFromBlindTransfer = removeSkillsFromBlindTransfer
    }


}




public class ContactColumnTimeZone: Codable {



    public enum ColumnType: String, Codable { 
        case phone = "PHONE"
        case zip = "ZIP"
    }

    /** Time zone that the column matched to. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var timeZone: String?
    /** Column Type will be either PHONE or ZIP */
    public var columnType: ColumnType?

    public init(timeZone: String?, columnType: ColumnType?) {
        self.timeZone = timeZone
        self.columnType = columnType
    }


}




public class ContactListFilterEntityListing: Codable {





















    public var entities: [ContactListFilter]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ContactListFilter]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ContactableStatus: Codable {





    /** Indicates whether or not the entire contact is contactable for the associated media type. */
    public var contactable: Bool?
    /** A map of individual contact method columns to whether the individual column is contactable for the associated media type. */
    public var columnStatus: [String:ColumnStatus]?

    public init(contactable: Bool?, columnStatus: [String:ColumnStatus]?) {
        self.contactable = contactable
        self.columnStatus = columnStatus
    }


}



/** Attachment object. */

public class ContentAttachment: Codable {



    public enum MediaType: String, Codable { 
        case image = "Image"
        case video = "Video"
        case audio = "Audio"
        case file = "File"
        case link = "Link"
    }











    /** Provider specific ID for attachment. For example, a LINE sticker ID. */
    public var _id: String?
    /** The type of attachment this instance represents. */
    public var mediaType: MediaType?
    /** URL of the attachment. */
    public var url: String?
    /** Attachment mime type (https://www.iana.org/assignments/media-types/media-types.xhtml). */
    public var mime: String?
    /** Text associated with attachment such as an image caption. */
    public var text: String?
    /** Secure hash of the attachment content. */
    public var sha256: String?
    /** Suggested file name for attachment. */
    public var filename: String?

    public init(_id: String?, mediaType: MediaType?, url: String?, mime: String?, text: String?, sha256: String?, filename: String?) {
        self._id = _id
        self.mediaType = mediaType
        self.url = url
        self.mime = mime
        self.text = text
        self.sha256 = sha256
        self.filename = filename
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case mediaType
        case url
        case mime
        case text
        case sha256
        case filename
    }


}



/** Button response object representing the click of a structured message button, such as a quick reply. */

public class ContentButtonResponse: Codable {



    public enum ModelType: String, Codable { 
        case button = "Button"
        case quickReply = "QuickReply"
    }





    /** An ID assigned to the button response (Deprecated). */
    public var _id: String?
    /** Describes the button that resulted in the Button Response. */
    public var type: ModelType?
    /** The response text from the button click. */
    public var text: String?
    /** The response payload associated with the clicked button. */
    public var payload: String?

    public init(_id: String?, type: ModelType?, text: String?, payload: String?) {
        self._id = _id
        self.type = type
        self.text = text
        self.payload = payload
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
        case text
        case payload
    }


}



/** Card content object. */

public class ContentCard: Codable {













    /** Text to show in the title. */
    public var title: String?
    /** Text to show in the description. */
    public var _description: String?
    /** URL of an image. */
    public var image: String?
    /** URL of a video. */
    public var video: String?
    /** The default button action. */
    public var defaultAction: ContentCardAction?
    /** An array of action objects. */
    public var actions: [ContentCardAction]?

    public init(title: String?, _description: String?, image: String?, video: String?, defaultAction: ContentCardAction?, actions: [ContentCardAction]?) {
        self.title = title
        self._description = _description
        self.image = image
        self.video = video
        self.defaultAction = defaultAction
        self.actions = actions
    }

    public enum CodingKeys: String, CodingKey { 
        case title
        case _description = "description"
        case image
        case video
        case defaultAction
        case actions
    }


}




public class ContentFilterItem: Codable {



    public enum ModelType: String, Codable { 
        case number = "NUMBER"
        case string = "STRING"
        case date = "DATE"
        case boolean = "BOOLEAN"
        case list = "LIST"
    }

    public enum Operator: String, Codable { 
        case _in = "IN"
        case range = "RANGE"
        case equals = "EQUALS"
        case notequals = "NOTEQUALS"
        case lessthan = "LESSTHAN"
        case lessthanequals = "LESSTHANEQUALS"
        case greaterthan = "GREATERTHAN"
        case greaterthanequals = "GREATERTHANEQUALS"
        case contains = "CONTAINS"
    }



    public var name: String?
    public var type: ModelType?
    public var _operator: Operator?
    public var values: [String]?

    public init(name: String?, type: ModelType?, _operator: Operator?, values: [String]?) {
        self.name = name
        self.type = type
        self._operator = _operator
        self.values = values
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case type
        case _operator = "operator"
        case values
    }


}




public class ContentManagementSingleDocumentTopicDocumentDataV2: Codable {





























    public var _id: String?
    public var name: String?
    public var dateCreated: Date?
    public var dateModified: Date?
    public var workspace: ContentManagementSingleDocumentTopicWorkspaceData?
    public var createdBy: ContentManagementSingleDocumentTopicUserData?
    public var contentType: String?
    public var contentLength: Int?
    public var filename: String?
    public var changeNumber: Int?
    public var dateUploaded: Date?
    public var uploadedBy: ContentManagementSingleDocumentTopicUserData?
    public var lockInfo: ContentManagementSingleDocumentTopicLockData?
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, workspace: ContentManagementSingleDocumentTopicWorkspaceData?, createdBy: ContentManagementSingleDocumentTopicUserData?, contentType: String?, contentLength: Int?, filename: String?, changeNumber: Int?, dateUploaded: Date?, uploadedBy: ContentManagementSingleDocumentTopicUserData?, lockInfo: ContentManagementSingleDocumentTopicLockData?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.workspace = workspace
        self.createdBy = createdBy
        self.contentType = contentType
        self.contentLength = contentLength
        self.filename = filename
        self.changeNumber = changeNumber
        self.dateUploaded = dateUploaded
        self.uploadedBy = uploadedBy
        self.lockInfo = lockInfo
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case workspace
        case createdBy
        case contentType
        case contentLength
        case filename
        case changeNumber
        case dateUploaded
        case uploadedBy
        case lockInfo
        case selfUri
    }


}



/** Template notification object. */

public class ContentNotificationTemplate: Codable {











    /** The messaging provider template ID. For WhatsApp, 'namespace@name'. */
    public var _id: String?
    /** Template language. */
    public var language: String?
    /** The template header. */
    public var header: NotificationTemplateHeader?
    /** The template body. */
    public var body: NotificationTemplateBody?
    /** The template footer. */
    public var footer: NotificationTemplateFooter?

    public init(_id: String?, language: String?, header: NotificationTemplateHeader?, body: NotificationTemplateBody?, footer: NotificationTemplateFooter?) {
        self._id = _id
        self.language = language
        self.header = header
        self.body = body
        self.footer = footer
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case language
        case header
        case body
        case footer
    }


}




public class ContentOffer: Codable {



    public enum DisplayMode: String, Codable { 
        case modal = "Modal"
        case overlay = "Overlay"
        case toast = "Toast"
    }

    public enum LayoutMode: String, Codable { 
        case textOnly = "TextOnly"
        case imageOnly = "ImageOnly"
        case leftText = "LeftText"
        case rightText = "RightText"
        case topText = "TopText"
        case bottomText = "BottomText"
    }











    /** URL for image displayed to the customer when displaying content offer. */
    public var imageUrl: String?
    /** The display mode of Genesys Widgets when displaying content offer. */
    public var displayMode: DisplayMode?
    /** The layout mode of the text shown to the user when displaying content offer. */
    public var layoutMode: LayoutMode?
    /** Title used in the header of the content offer. */
    public var title: String?
    /** Headline displayed above the body text of the content offer. */
    public var headline: String?
    /** Body text of the content offer. */
    public var body: String?
    /** Properties customizing the call to action button on the content offer. */
    public var callToAction: CallToAction?
    /** Properties customizing the styling of the content offer. */
    public var style: ContentOfferStylingConfiguration?

    public init(imageUrl: String?, displayMode: DisplayMode?, layoutMode: LayoutMode?, title: String?, headline: String?, body: String?, callToAction: CallToAction?, style: ContentOfferStylingConfiguration?) {
        self.imageUrl = imageUrl
        self.displayMode = displayMode
        self.layoutMode = layoutMode
        self.title = title
        self.headline = headline
        self.body = body
        self.callToAction = callToAction
        self.style = style
    }


}



/** Postback response object representing the click of a rich media button (Deprecated). */

public class ContentPostback: Codable {







    /** An ID assigned to the button response. */
    public var _id: String?
    /** The response text from the button click. */
    public var text: String?
    /** The response payload associated with the clicked button. */
    public var payload: String?

    public init(_id: String?, text: String?, payload: String?) {
        self._id = _id
        self.text = text
        self.payload = payload
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case text
        case payload
    }


}



/** Quick reply object. */

public class ContentQuickReply: Codable {









    public enum Action: String, Codable { 
        case message = "Message"
    }

    /** A unique ID assigned to the quick reply (Deprecated). */
    public var _id: String?
    /** Text to show inside the quick reply. This is also used as the response text after clicking on the quick reply. */
    public var text: String?
    /** Content of the payload included in the quick reply response. Could be an ID identifying the quick reply response. */
    public var payload: String?
    /** URL of an image associated with the quick reply. */
    public var image: String?
    /** Specifies the type of action that is triggered upon clicking the quick reply. */
    public var action: Action?

    public init(_id: String?, text: String?, payload: String?, image: String?, action: Action?) {
        self._id = _id
        self.text = text
        self.payload = payload
        self.image = image
        self.action = action
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case text
        case payload
        case image
        case action
    }


}




public class ConversationAggregateQueryResponse: Codable {



    public var results: [ConversationAggregateDataContainer]?

    public init(results: [ConversationAggregateDataContainer]?) {
        self.results = results
    }


}




public class ConversationAggregationView: Codable {

    public enum Target: String, Codable { 
        case nblindtransferred = "nBlindTransferred"
        case nbotinteractions = "nBotInteractions"
        case ncobrowsesessions = "nCobrowseSessions"
        case nconnected = "nConnected"
        case nconsult = "nConsult"
        case nconsulttransferred = "nConsultTransferred"
        case nerror = "nError"
        case noffered = "nOffered"
        case noutbound = "nOutbound"
        case noutboundabandoned = "nOutboundAbandoned"
        case noutboundattempted = "nOutboundAttempted"
        case noutboundconnected = "nOutboundConnected"
        case noversla = "nOverSla"
        case nstatetransitionerror = "nStateTransitionError"
        case ntransferred = "nTransferred"
        case oexternalmediacount = "oExternalMediaCount"
        case omediacount = "oMediaCount"
        case omessageturn = "oMessageTurn"
        case oservicelevel = "oServiceLevel"
        case oservicetarget = "oServiceTarget"
        case tabandon = "tAbandon"
        case tacd = "tAcd"
        case tactivecallback = "tActiveCallback"
        case tactivecallbackcomplete = "tActiveCallbackComplete"
        case tacw = "tAcw"
        case tagentresponsetime = "tAgentResponseTime"
        case talert = "tAlert"
        case tanswered = "tAnswered"
        case tbarging = "tBarging"
        case tcoaching = "tCoaching"
        case tcoachingcomplete = "tCoachingComplete"
        case tconnected = "tConnected"
        case tcontacting = "tContacting"
        case tdialing = "tDialing"
        case tfirstconnect = "tFirstConnect"
        case tfirstdial = "tFirstDial"
        case tflowout = "tFlowOut"
        case thandle = "tHandle"
        case theld = "tHeld"
        case theldcomplete = "tHeldComplete"
        case tivr = "tIvr"
        case tmonitoring = "tMonitoring"
        case tmonitoringcomplete = "tMonitoringComplete"
        case tnotresponding = "tNotResponding"
        case tpark = "tPark"
        case tparkcomplete = "tParkComplete"
        case tshortabandon = "tShortAbandon"
        case ttalk = "tTalk"
        case ttalkcomplete = "tTalkComplete"
        case tuserresponsetime = "tUserResponseTime"
        case tvoicemail = "tVoicemail"
        case twait = "tWait"
    }



    public enum Function: String, Codable { 
        case rangebound = "rangeBound"
    }



    /** Target metric name */
    public var target: Target?
    /** A unique name for this view. Must be distinct from other views and built-in metric names. */
    public var name: String?
    /** Type of view you wish to create */
    public var function: Function?
    /** Range of numbers for slicing up data */
    public var range: AggregationRange?

    public init(target: Target?, name: String?, function: Function?, range: AggregationRange?) {
        self.target = target
        self.name = name
        self.function = function
        self.range = range
    }


}




public class ConversationAssociation: Codable {







    public enum MediaType: String, Codable { 
        case call = "CALL"
        case callback = "CALLBACK"
        case chat = "CHAT"
        case cobrowse = "COBROWSE"
        case email = "EMAIL"
        case message = "MESSAGE"
        case socialExpression = "SOCIAL_EXPRESSION"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
    }

    /** An external contact ID.  If not supplied, implies the conversation should be disassociated with any external contact. */
    public var externalContactId: String?
    /** Conversation ID */
    public var conversationId: String?
    /** Communication ID */
    public var communicationId: String?
    /** Media type */
    public var mediaType: MediaType?

    public init(externalContactId: String?, conversationId: String?, communicationId: String?, mediaType: MediaType?) {
        self.externalContactId = externalContactId
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.mediaType = mediaType
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class ConversationCallEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: ConversationCallEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: ConversationCallEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}




public class ConversationCallEventTopicJourneyContext: Codable {







    public var customer: ConversationCallEventTopicJourneyCustomer?
    public var customerSession: ConversationCallEventTopicJourneyCustomerSession?
    public var triggeringAction: ConversationCallEventTopicJourneyAction?

    public init(customer: ConversationCallEventTopicJourneyCustomer?, customerSession: ConversationCallEventTopicJourneyCustomerSession?, triggeringAction: ConversationCallEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class ConversationCallEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationCallbackEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationCallbackEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}




public class ConversationCallbackEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: ConversationCallbackEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int?

    public init(agent: ConversationCallbackEventTopicUriReference?, score: Int?) {
        self.agent = agent
        self.score = score
    }


}




public class ConversationChat: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }











    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case uncallable = "uncallable"
        case timeout = "timeout"
    }



























    /** The connection state of this communication. */
    public var state: State?
    /** The initial connection state of this communication. */
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The room id for the chat. */
    public var roomId: String?
    /** A globally unique identifier for the recording associated with this chat. */
    public var recordingId: String?
    /** The time line of the participant's chat, divided into activity segments. */
    public var segments: [Segment]?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** The direction of the chat */
    public var direction: Direction?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the chat was placed on hold in the cloud clock if the chat is currently on hold. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startHoldTime: Date?
    /** The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAlertingTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var disconnectedTime: Date?
    /** The source provider for the email. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** If available, the URI to the avatar image of this communication. */
    public var avatarImageUrl: String?
    /** A subset of the Journey System's data relevant to a part of a conversation (for external linkage and internal usage/context). */
    public var journeyContext: JourneyContext?
    /** Call wrap up or disposition data. */
    public var wrapup: Wrapup?
    /** After-call work for the communication. */
    public var afterCallWork: AfterCallWork?
    /** Indicates if after-call work is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue settings for this media type. */
    public var queueMediaSettings: ConversationQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _id: String?, roomId: String?, recordingId: String?, segments: [Segment]?, held: Bool?, direction: Direction?, disconnectType: DisconnectType?, startHoldTime: Date?, startAlertingTime: Date?, connectedTime: Date?, disconnectedTime: Date?, provider: String?, scriptId: String?, peerId: String?, avatarImageUrl: String?, journeyContext: JourneyContext?, wrapup: Wrapup?, afterCallWork: AfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: ConversationQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.roomId = roomId
        self.recordingId = recordingId
        self.segments = segments
        self.held = held
        self.direction = direction
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.startAlertingTime = startAlertingTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.avatarImageUrl = avatarImageUrl
        self.journeyContext = journeyContext
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case roomId
        case recordingId
        case segments
        case held
        case direction
        case disconnectType
        case startHoldTime
        case startAlertingTime
        case connectedTime
        case disconnectedTime
        case provider
        case scriptId
        case peerId
        case avatarImageUrl
        case journeyContext
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}




public class ConversationChatEventTopicChatMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case timeout = "timeout"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }







































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }















    public var _id: String?
    public var name: String?
    public var address: String?
    public var startTime: Date?
    public var connectedTime: Date?
    public var endTime: Date?
    public var startHoldTime: Date?
    public var purpose: String?
    public var state: State?
    public var initialState: InitialState?
    public var direction: Direction?
    public var disconnectType: DisconnectType?
    public var held: Bool?
    public var wrapupRequired: Bool?
    public var wrapupPrompt: String?
    public var user: ConversationChatEventTopicUriReference?
    public var queue: ConversationChatEventTopicUriReference?
    public var team: ConversationChatEventTopicUriReference?
    public var attributes: [String:String]?
    public var errorInfo: ConversationChatEventTopicErrorBody?
    public var script: ConversationChatEventTopicUriReference?
    public var wrapupTimeoutMs: Int?
    public var wrapupSkipped: Bool?
    public var alertingTimeoutMs: Int?
    public var provider: String?
    public var externalContact: ConversationChatEventTopicUriReference?
    public var externalOrganization: ConversationChatEventTopicUriReference?
    public var wrapup: ConversationChatEventTopicWrapup?
    public var conversationRoutingData: ConversationChatEventTopicConversationRoutingData?
    public var peer: String?
    public var screenRecordingState: String?
    public var flaggedReason: FlaggedReason?
    public var journeyContext: ConversationChatEventTopicJourneyContext?
    public var startAcwTime: Date?
    public var endAcwTime: Date?
    public var mediaRoles: [String]?
    public var queueMediaSettings: ConversationChatEventTopicQueueMediaSettings?
    public var roomId: String?
    public var avatarImageUrl: String?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, initialState: InitialState?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, user: ConversationChatEventTopicUriReference?, queue: ConversationChatEventTopicUriReference?, team: ConversationChatEventTopicUriReference?, attributes: [String:String]?, errorInfo: ConversationChatEventTopicErrorBody?, script: ConversationChatEventTopicUriReference?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, alertingTimeoutMs: Int?, provider: String?, externalContact: ConversationChatEventTopicUriReference?, externalOrganization: ConversationChatEventTopicUriReference?, wrapup: ConversationChatEventTopicWrapup?, conversationRoutingData: ConversationChatEventTopicConversationRoutingData?, peer: String?, screenRecordingState: String?, flaggedReason: FlaggedReason?, journeyContext: ConversationChatEventTopicJourneyContext?, startAcwTime: Date?, endAcwTime: Date?, mediaRoles: [String]?, queueMediaSettings: ConversationChatEventTopicQueueMediaSettings?, roomId: String?, avatarImageUrl: String?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.conversationRoutingData = conversationRoutingData
        self.peer = peer
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.mediaRoles = mediaRoles
        self.queueMediaSettings = queueMediaSettings
        self.roomId = roomId
        self.avatarImageUrl = avatarImageUrl
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case initialState
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalOrganization
        case wrapup
        case conversationRoutingData
        case peer
        case screenRecordingState
        case flaggedReason
        case journeyContext
        case startAcwTime
        case endAcwTime
        case mediaRoles
        case queueMediaSettings
        case roomId
        case avatarImageUrl
    }


}




public class ConversationChatEventTopicDetail: Codable {









    public var errorCode: String?
    public var fieldName: String?
    public var entityId: String?
    public var entityName: String?

    public init(errorCode: String?, fieldName: String?, entityId: String?, entityName: String?) {
        self.errorCode = errorCode
        self.fieldName = fieldName
        self.entityId = entityId
        self.entityName = entityName
    }


}




public class ConversationChatEventTopicErrorBody: Codable {





















    public var message: String?
    public var code: String?
    public var status: Int?
    public var entityId: String?
    public var entityName: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var contextId: String?
    public var details: [ConversationChatEventTopicDetail]?
    public var errors: [ConversationChatEventTopicErrorBody]?

    public init(message: String?, code: String?, status: Int?, entityId: String?, entityName: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, details: [ConversationChatEventTopicDetail]?, errors: [ConversationChatEventTopicErrorBody]?) {
        self.message = message
        self.code = code
        self.status = status
        self.entityId = entityId
        self.entityName = entityName
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.details = details
        self.errors = errors
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class ConversationChatEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int?

    public init(_id: String?, version: Int?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}




public class ConversationChatEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationCobrowseEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class ConversationCobrowseEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}




public class ConversationCobrowseEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: ConversationCobrowseEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int?

    public init(agent: ConversationCobrowseEventTopicUriReference?, score: Int?) {
        self.agent = agent
        self.score = score
    }


}



/** Attachment object. */

public class ConversationContentAttachment: Codable {



    public enum MediaType: String, Codable { 
        case image = "Image"
        case video = "Video"
        case audio = "Audio"
        case file = "File"
        case link = "Link"
    }













    /** Provider specific ID for attachment. For example, a LINE sticker ID. */
    public var _id: String?
    /** The type of attachment this instance represents. */
    public var mediaType: MediaType?
    /** URL of the attachment. */
    public var url: String?
    /** Attachment mime type (https://www.iana.org/assignments/media-types/media-types.xhtml). */
    public var mime: String?
    /** Text associated with attachment such as an image caption. */
    public var text: String?
    /** Secure hash of the attachment content. */
    public var sha256: String?
    /** Suggested file name for attachment. */
    public var filename: String?
    /** Size in bytes of the attachment content. */
    public var contentSizeBytes: Int64?

    public init(_id: String?, mediaType: MediaType?, url: String?, mime: String?, text: String?, sha256: String?, filename: String?, contentSizeBytes: Int64?) {
        self._id = _id
        self.mediaType = mediaType
        self.url = url
        self.mime = mime
        self.text = text
        self.sha256 = sha256
        self.filename = filename
        self.contentSizeBytes = contentSizeBytes
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case mediaType
        case url
        case mime
        case text
        case sha256
        case filename
        case contentSizeBytes
    }


}



/** Button response object representing the click of a structured message button, such as a quick reply. */

public class ConversationContentButtonResponse: Codable {

    public enum ModelType: String, Codable { 
        case button = "Button"
        case quickReply = "QuickReply"
    }





    /** Describes the button that resulted in the Button Response. */
    public var type: ModelType?
    /** The response text from the button click. */
    public var text: String?
    /** The response payload associated with the clicked button. */
    public var payload: String?

    public init(type: ModelType?, text: String?, payload: String?) {
        self.type = type
        self.text = text
        self.payload = payload
    }


}



/** Card content object. */

public class ConversationContentCard: Codable {













    /** Text to show in the title. */
    public var title: String?
    /** Text to show in the description. */
    public var _description: String?
    /** URL of an image. */
    public var image: String?
    /** URL of a video. */
    public var video: String?
    /** The default button action. */
    public var defaultAction: ConversationContentCardAction?
    /** An array of action objects. */
    public var actions: [ConversationContentCardAction]?

    public init(title: String?, _description: String?, image: String?, video: String?, defaultAction: ConversationContentCardAction?, actions: [ConversationContentCardAction]?) {
        self.title = title
        self._description = _description
        self.image = image
        self.video = video
        self.defaultAction = defaultAction
        self.actions = actions
    }

    public enum CodingKeys: String, CodingKey { 
        case title
        case _description = "description"
        case image
        case video
        case defaultAction
        case actions
    }


}



/** Template notification object. */

public class ConversationContentNotificationTemplate: Codable {











    /** The identifier of the message template in 'your-namespace@your-template-id/name' format. For External vendor (e.g WhatsApp), 'your-namespace@your-template-name'. For GenesysCloud canned response message template use 'cannedresponse' as your-namespace and use response ID as your-template-id (e.g. response ID=1234 then 'cannedresponse@1234') */
    public var _id: String?
    /** Template language. */
    public var language: String?
    /** The template header. */
    public var header: ConversationNotificationTemplateHeader?
    /** The template body. */
    public var body: ConversationNotificationTemplateBody?
    /** The template footer. */
    public var footer: ConversationNotificationTemplateFooter?

    public init(_id: String?, language: String?, header: ConversationNotificationTemplateHeader?, body: ConversationNotificationTemplateBody?, footer: ConversationNotificationTemplateFooter?) {
        self._id = _id
        self.language = language
        self.header = header
        self.body = body
        self.footer = footer
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case language
        case header
        case body
        case footer
    }


}



/** Quick reply object. */

public class ConversationContentQuickReply: Codable {







    public enum Action: String, Codable { 
        case message = "Message"
    }

    /** Text to show inside the quick reply. This is also used as the response text after clicking on the quick reply. */
    public var text: String?
    /** Content of the payload included in the quick reply response. Could be an ID identifying the quick reply response. */
    public var payload: String?
    /** URL of an image associated with the quick reply. */
    public var image: String?
    /** Specifies the type of action that is triggered upon clicking the quick reply. */
    public var action: Action?

    public init(text: String?, payload: String?, image: String?, action: Action?) {
        self.text = text
        self.payload = payload
        self.image = image
        self.action = action
    }


}




public class ConversationDetailQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [ConversationDetailQueryPredicate]?

    public init(type: ModelType?, predicates: [ConversationDetailQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class ConversationEmailEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}




public class ConversationEventTopicChat: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferForward = "transfer.forward"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }

















    public var state: State?
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The source provider of the chat. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The room id for the chat. */
    public var roomId: String?
    /** The avatar for the chat (if available). */
    public var avatarImageUrl: String?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the chat was placed on hold in the cloud clock if the chat is currently on hold. */
    public var startHoldTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    public var journeyContext: ConversationEventTopicJourneyContext?
    /** Call wrap up or disposition data. */
    public var wrapup: ConversationEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: ConversationEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: ConversationEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _id: String?, provider: String?, scriptId: String?, peerId: String?, roomId: String?, avatarImageUrl: String?, held: Bool?, disconnectType: DisconnectType?, startHoldTime: Date?, connectedTime: Date?, disconnectedTime: Date?, journeyContext: ConversationEventTopicJourneyContext?, wrapup: ConversationEventTopicWrapup?, afterCallWork: ConversationEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: ConversationEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.roomId = roomId
        self.avatarImageUrl = avatarImageUrl
        self.held = held
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.journeyContext = journeyContext
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case provider
        case scriptId
        case peerId
        case roomId
        case avatarImageUrl
        case held
        case disconnectType
        case startHoldTime
        case connectedTime
        case disconnectedTime
        case journeyContext
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}



/** Fields identifying the destination of a given conversation command. */

public class ConversationEventTopicDestination: Codable {





    /** The id of the user if the command destination is a user. */
    public var userId: String?
    /** The destination address if the command destination is an endpoint. */
    public var address: String?

    public init(userId: String?, address: String?) {
        self.userId = userId
        self.address = address
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class ConversationEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: ConversationEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: ConversationEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}



/** A subset of the Journey System's data relevant to a part of a conversation (for external linkage and internal usage/context). */

public class ConversationEventTopicJourneyContext: Codable {







    public var customer: ConversationEventTopicJourneyCustomer?
    public var customerSession: ConversationEventTopicJourneyCustomerSession?
    public var triggeringAction: ConversationEventTopicJourneyAction?

    public init(customer: ConversationEventTopicJourneyCustomer?, customerSession: ConversationEventTopicJourneyCustomerSession?, triggeringAction: ConversationEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class ConversationEventTopicMessage: Codable {



    public enum State: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case disconnected = "disconnected"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case disconnected = "disconnected"
    }

    public enum Direction: String, Codable { 
        case outbound = "outbound"
        case inbound = "inbound"
    }











    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }















    public enum ModelType: String, Codable { 
        case unknown = "unknown"
        case sms = "sms"
        case twitter = "twitter"
        case facebook = "facebook"
        case line = "line"
        case viber = "viber"
        case wechat = "wechat"
        case whatsapp = "whatsapp"
        case telegram = "telegram"
        case kakao = "kakao"
        case webmessaging = "webmessaging"
        case _open = "open"
        case instagram = "instagram"
    }



















    /** A globally unique identifier for this communication. */
    public var _id: String?
    public var state: State?
    public var initialState: InitialState?
    /** Whether a message is inbound or outbound. */
    public var direction: Direction?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** Detailed information about an error response. */
    public var errorInfo: ConversationEventTopicErrorDetails?
    /** The source provider of the email. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the email was placed on hold in the cloud clock if the email is currently on hold. */
    public var startHoldTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** Address and name data for a call endpoint. */
    public var toAddress: ConversationEventTopicAddress?
    /** Address and name data for a call endpoint. */
    public var fromAddress: ConversationEventTopicAddress?
    /** The messages sent on this communication channel. */
    public var messages: [ConversationEventTopicMessageDetails]?
    /** the messages transcript file uri. */
    public var messagesTranscriptUri: String?
    /** Indicates the type of message platform from which the message originated. */
    public var type: ModelType?
    /** Indicates the country where the recipient is associated in ISO 3166-1 alpha-2 format. */
    public var recipientCountry: String?
    /** The type of the recipient. Eg: Provisioned phoneNumber is the recipient for sms message type. */
    public var recipientType: String?
    /** A subset of the Journey System's data relevant to a part of a conversation (for external linkage and internal usage/context). */
    public var journeyContext: ConversationEventTopicJourneyContext?
    /** Call wrap up or disposition data. */
    public var wrapup: ConversationEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: ConversationEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** UUID of virtual agent assistant that provide suggestions to the agent participant during the conversation. */
    public var agentAssistantId: String?
    public var byoSmsIntegrationId: String?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: ConversationEventTopicQueueMediaSettings?

    public init(_id: String?, state: State?, initialState: InitialState?, direction: Direction?, held: Bool?, errorInfo: ConversationEventTopicErrorDetails?, provider: String?, scriptId: String?, peerId: String?, disconnectType: DisconnectType?, startHoldTime: Date?, connectedTime: Date?, disconnectedTime: Date?, toAddress: ConversationEventTopicAddress?, fromAddress: ConversationEventTopicAddress?, messages: [ConversationEventTopicMessageDetails]?, messagesTranscriptUri: String?, type: ModelType?, recipientCountry: String?, recipientType: String?, journeyContext: ConversationEventTopicJourneyContext?, wrapup: ConversationEventTopicWrapup?, afterCallWork: ConversationEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, agentAssistantId: String?, byoSmsIntegrationId: String?, queueMediaSettings: ConversationEventTopicQueueMediaSettings?) {
        self._id = _id
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.held = held
        self.errorInfo = errorInfo
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.toAddress = toAddress
        self.fromAddress = fromAddress
        self.messages = messages
        self.messagesTranscriptUri = messagesTranscriptUri
        self.type = type
        self.recipientCountry = recipientCountry
        self.recipientType = recipientType
        self.journeyContext = journeyContext
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.agentAssistantId = agentAssistantId
        self.byoSmsIntegrationId = byoSmsIntegrationId
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case initialState
        case direction
        case held
        case errorInfo
        case provider
        case scriptId
        case peerId
        case disconnectType
        case startHoldTime
        case connectedTime
        case disconnectedTime
        case toAddress
        case fromAddress
        case messages
        case messagesTranscriptUri
        case type
        case recipientCountry
        case recipientType
        case journeyContext
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case agentAssistantId
        case byoSmsIntegrationId
        case queueMediaSettings
    }


}




public class ConversationEventTopicMessageDetails: Codable {





    public enum MessageStatus: String, Codable { 
        case queued = "queued"
        case sent = "sent"
        case failed = "failed"
        case received = "received"
        case deliverySuccess = "delivery-success"
        case deliveryFailed = "delivery-failed"
        case read = "read"
        case removed = "removed"
    }











    /** UUID identifying the message media. */
    public var messageId: String?
    /** The time when the message was sent or received. */
    public var messageTime: Date?
    /** Indicates the delivery status of the message. */
    public var messageStatus: MessageStatus?
    /** The message segment count, greater than 1 if the message content was split into multiple parts for this message type, e.g. SMS character limits. */
    public var messageSegmentCount: Int?
    /** The media (images, files, etc) associated with this message, if any */
    public var media: [ConversationEventTopicMessageMedia]?
    /** Detailed information about an error response. */
    public var errorInfo: ConversationEventTopicErrorDetails?
    /** A list of stickers included in the message */
    public var stickers: [ConversationEventTopicMessageSticker]?
    public var messageMetadata: ConversationEventTopicMessageMetadata?

    public init(messageId: String?, messageTime: Date?, messageStatus: MessageStatus?, messageSegmentCount: Int?, media: [ConversationEventTopicMessageMedia]?, errorInfo: ConversationEventTopicErrorDetails?, stickers: [ConversationEventTopicMessageSticker]?, messageMetadata: ConversationEventTopicMessageMetadata?) {
        self.messageId = messageId
        self.messageTime = messageTime
        self.messageStatus = messageStatus
        self.messageSegmentCount = messageSegmentCount
        self.media = media
        self.errorInfo = errorInfo
        self.stickers = stickers
        self.messageMetadata = messageMetadata
    }


}




public class ConversationEventTopicMessageMedia: Codable {











    /** The location of the media, useful for retrieving it */
    public var url: String?
    /** The optional internet media type of the the media object.  If null then the media type should be dictated by the url */
    public var mediaType: String?
    /** The optional content length of the the media object, in bytes. */
    public var contentLengthBytes: Int?
    /** The optional name of the the media object. */
    public var name: String?
    /** The optional id of the the media object. */
    public var _id: String?

    public init(url: String?, mediaType: String?, contentLengthBytes: Int?, name: String?, _id: String?) {
        self.url = url
        self.mediaType = mediaType
        self.contentLengthBytes = contentLengthBytes
        self.name = name
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case url
        case mediaType
        case contentLengthBytes
        case name
        case _id = "id"
    }


}




public class ConversationEventTopicMessageMetadataEvent: Codable {





    /** Type of this event element. */
    public var eventType: String?
    /** Event subtype, if any */
    public var subType: String?

    public init(eventType: String?, subType: String?) {
        self.eventType = eventType
        self.subType = subType
    }


}




public class ConversationEventTopicMessageSticker: Codable {





    /** The location of the sticker, useful for retrieving it */
    public var url: String?
    /** The unique id of the the sticker object. */
    public var _id: String?

    public init(url: String?, _id: String?) {
        self.url = url
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case url
        case _id = "id"
    }


}




public class ConversationEventTopicScreenshare: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }













    public var state: State?
    public var initialState: InitialState?
    /** Address and name data for a call endpoint. */
    public var _self: ConversationEventTopicAddress?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The room id context (xmpp jid) for the conference session. */
    public var context: String?
    /** Indicates whether this participant is sharing their screen to the session. */
    public var sharing: Bool?
    /** The source provider of the screen share. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The number of peer participants from the perspective of the participant in the conference. */
    public var peerCount: JSON?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** Call wrap up or disposition data. */
    public var wrapup: ConversationEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: ConversationEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: ConversationEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _self: ConversationEventTopicAddress?, _id: String?, context: String?, sharing: Bool?, provider: String?, scriptId: String?, peerId: String?, peerCount: JSON?, disconnectType: DisconnectType?, connectedTime: Date?, disconnectedTime: Date?, wrapup: ConversationEventTopicWrapup?, afterCallWork: ConversationEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: ConversationEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._self = _self
        self._id = _id
        self.context = context
        self.sharing = sharing
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.peerCount = peerCount
        self.disconnectType = disconnectType
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _self = "self"
        case _id = "id"
        case context
        case sharing
        case provider
        case scriptId
        case peerId
        case peerCount
        case disconnectType
        case connectedTime
        case disconnectedTime
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}



/** Information about the workflow. */

public class ConversationEventTopicWorkflow: Codable {



    /** The id of the workflow */
    public var workflowId: String?

    public init(workflowId: String?) {
        self.workflowId = workflowId
    }


}



/** Call wrap up or disposition data. */

public class ConversationEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}



/** A Typing event. */

public class ConversationEventTyping: Codable {

    public enum ModelType: String, Codable { 
        case on = "On"
    }



    /** Describes the type of Typing event. */
    public var type: ModelType?
    /** The duration of the Typing event in milliseconds. */
    public var duration: Int64?

    public init(type: ModelType?, duration: Int64?) {
        self.type = type
        self.duration = duration
    }


}




public class ConversationMessageEventTopicDetail: Codable {









    public var errorCode: String?
    public var fieldName: String?
    public var entityId: String?
    public var entityName: String?

    public init(errorCode: String?, fieldName: String?, entityId: String?, entityName: String?) {
        self.errorCode = errorCode
        self.fieldName = fieldName
        self.entityId = entityId
        self.entityName = entityName
    }


}




public class ConversationMessageEventTopicErrorBody: Codable {





















    public var message: String?
    public var code: String?
    public var status: Int?
    public var entityId: String?
    public var entityName: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var contextId: String?
    public var details: [ConversationMessageEventTopicDetail]?
    public var errors: [ConversationMessageEventTopicErrorBody]?

    public init(message: String?, code: String?, status: Int?, entityId: String?, entityName: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, details: [ConversationMessageEventTopicDetail]?, errors: [ConversationMessageEventTopicErrorBody]?) {
        self.message = message
        self.code = code
        self.status = status
        self.entityId = entityId
        self.entityName = entityName
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.details = details
        self.errors = errors
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class ConversationMessageEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int?

    public init(_id: String?, version: Int?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}




public class ConversationMessageEventTopicMessageMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case timeout = "timeout"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }







































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }













    public enum ModelType: String, Codable { 
        case unknown = "unknown"
        case sms = "sms"
        case twitter = "twitter"
        case facebook = "facebook"
        case line = "line"
        case viber = "viber"
        case wechat = "wechat"
        case whatsapp = "whatsapp"
        case telegram = "telegram"
        case kakao = "kakao"
        case webmessaging = "webmessaging"
        case _open = "open"
        case instagram = "instagram"
    }









    public var _id: String?
    public var name: String?
    public var address: String?
    public var startTime: Date?
    public var connectedTime: Date?
    public var endTime: Date?
    public var startHoldTime: Date?
    public var purpose: String?
    public var state: State?
    public var initialState: InitialState?
    public var direction: Direction?
    public var disconnectType: DisconnectType?
    public var held: Bool?
    public var wrapupRequired: Bool?
    public var wrapupPrompt: String?
    public var user: ConversationMessageEventTopicUriReference?
    public var queue: ConversationMessageEventTopicUriReference?
    public var team: ConversationMessageEventTopicUriReference?
    public var attributes: [String:String]?
    public var errorInfo: ConversationMessageEventTopicErrorBody?
    public var script: ConversationMessageEventTopicUriReference?
    public var wrapupTimeoutMs: Int?
    public var wrapupSkipped: Bool?
    public var alertingTimeoutMs: Int?
    public var provider: String?
    public var externalContact: ConversationMessageEventTopicUriReference?
    public var externalOrganization: ConversationMessageEventTopicUriReference?
    public var wrapup: ConversationMessageEventTopicWrapup?
    public var conversationRoutingData: ConversationMessageEventTopicConversationRoutingData?
    public var peer: String?
    public var screenRecordingState: String?
    public var flaggedReason: FlaggedReason?
    public var journeyContext: ConversationMessageEventTopicJourneyContext?
    public var startAcwTime: Date?
    public var endAcwTime: Date?
    public var mediaRoles: [String]?
    public var queueMediaSettings: ConversationMessageEventTopicQueueMediaSettings?
    public var messages: [ConversationMessageEventTopicMessageDetails]?
    public var type: ModelType?
    public var recipientCountry: String?
    public var recipientType: String?
    public var byoSmsIntegrationId: String?
    public var monitoredParticipantId: String?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, initialState: InitialState?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, user: ConversationMessageEventTopicUriReference?, queue: ConversationMessageEventTopicUriReference?, team: ConversationMessageEventTopicUriReference?, attributes: [String:String]?, errorInfo: ConversationMessageEventTopicErrorBody?, script: ConversationMessageEventTopicUriReference?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, alertingTimeoutMs: Int?, provider: String?, externalContact: ConversationMessageEventTopicUriReference?, externalOrganization: ConversationMessageEventTopicUriReference?, wrapup: ConversationMessageEventTopicWrapup?, conversationRoutingData: ConversationMessageEventTopicConversationRoutingData?, peer: String?, screenRecordingState: String?, flaggedReason: FlaggedReason?, journeyContext: ConversationMessageEventTopicJourneyContext?, startAcwTime: Date?, endAcwTime: Date?, mediaRoles: [String]?, queueMediaSettings: ConversationMessageEventTopicQueueMediaSettings?, messages: [ConversationMessageEventTopicMessageDetails]?, type: ModelType?, recipientCountry: String?, recipientType: String?, byoSmsIntegrationId: String?, monitoredParticipantId: String?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.conversationRoutingData = conversationRoutingData
        self.peer = peer
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.mediaRoles = mediaRoles
        self.queueMediaSettings = queueMediaSettings
        self.messages = messages
        self.type = type
        self.recipientCountry = recipientCountry
        self.recipientType = recipientType
        self.byoSmsIntegrationId = byoSmsIntegrationId
        self.monitoredParticipantId = monitoredParticipantId
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case initialState
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalOrganization
        case wrapup
        case conversationRoutingData
        case peer
        case screenRecordingState
        case flaggedReason
        case journeyContext
        case startAcwTime
        case endAcwTime
        case mediaRoles
        case queueMediaSettings
        case messages
        case type
        case recipientCountry
        case recipientType
        case byoSmsIntegrationId
        case monitoredParticipantId
    }


}




public class ConversationMessageEventTopicMessageMetadata: Codable {







    /** Message type. */
    public var type: String?
    /** List of message events, if any */
    public var events: [ConversationMessageEventTopicMessageMetadataEvent]?
    /** List of message content, if any */
    public var content: [ConversationMessageEventTopicMessageMetadataContent]?

    public init(type: String?, events: [ConversationMessageEventTopicMessageMetadataEvent]?, content: [ConversationMessageEventTopicMessageMetadataContent]?) {
        self.type = type
        self.events = events
        self.content = content
    }


}




public class ConversationMessageEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}



/** Metadata information about a message event. */

public class ConversationMessageMetadataEvent: Codable {

    public enum EventType: String, Codable { 
        case coBrowse = "CoBrowse"
        case typing = "Typing"
        case presence = "Presence"
        case unknown = "Unknown"
    }

    public enum SubType: String, Codable { 
        case on = "On"
        case join = "Join"
        case offering = "Offering"
        case offeringExpired = "OfferingExpired"
        case offeringAccepted = "OfferingAccepted"
        case offeringRejected = "OfferingRejected"
        case disconnect = "Disconnect"
        case clear = "Clear"
        case signIn = "SignIn"
        case unknown = "Unknown"
    }

    /** Type of this event element */
    public var eventType: EventType?
    /** Event subtype */
    public var subType: SubType?

    public init(eventType: EventType?, subType: SubType?) {
        self.eventType = eventType
        self.subType = subType
    }


}



/** General rich media message structure with normalized feature support across many messaging channels. */

public class ConversationNormalizedMessage: Codable {





    public enum ModelType: String, Codable { 
        case text = "Text"
        case structured = "Structured"
        case receipt = "Receipt"
        case event = "Event"
        case message = "Message"
        case unknown = "Unknown"
    }







    public enum Status: String, Codable { 
        case sent = "Sent"
        case delivered = "Delivered"
        case read = "Read"
        case failed = "Failed"
        case published = "Published"
        case removed = "Removed"
    }



    public enum OriginatingEntity: String, Codable { 
        case human = "Human"
        case bot = "Bot"
    }



    public enum Direction: String, Codable { 
        case inbound = "Inbound"
        case outbound = "Outbound"
    }





    /** Unique ID of the message. Message receipts will have the same ID as the message they reference. */
    public var _id: String?
    /** Channel-specific information that describes the message and the message channel/provider. */
    public var channel: ConversationMessagingChannel?
    /** Message type. */
    public var type: ModelType?
    /** Message text. */
    public var text: String?
    /** List of content elements. */
    public var content: [ConversationMessageContent]?
    /** List of event elements. */
    public var events: [ConversationMessageEvent]?
    /** Message receipt status, only used with type Receipt. */
    public var status: Status?
    /** List of reasons for a message receipt that indicates the message has failed. Only used with Failed status. */
    public var reasons: [ConversationReason]?
    /** Specifies if this message was sent by a human agent or bot. The platform may use this to apply appropriate provider policies. */
    public var originatingEntity: OriginatingEntity?
    /** Indicates if this is the last message receipt for this message, or if another message receipt can be expected. */
    public var isFinalReceipt: Bool?
    /** The direction of the message. */
    public var direction: Direction?
    /** Additional metadata about this message. */
    public var metadata: [String:String]?
    /** The internal id representing the customer supplied sms integration message. */
    public var byoSmsIntegrationId: String?

    public init(_id: String?, channel: ConversationMessagingChannel?, type: ModelType?, text: String?, content: [ConversationMessageContent]?, events: [ConversationMessageEvent]?, status: Status?, reasons: [ConversationReason]?, originatingEntity: OriginatingEntity?, isFinalReceipt: Bool?, direction: Direction?, metadata: [String:String]?, byoSmsIntegrationId: String?) {
        self._id = _id
        self.channel = channel
        self.type = type
        self.text = text
        self.content = content
        self.events = events
        self.status = status
        self.reasons = reasons
        self.originatingEntity = originatingEntity
        self.isFinalReceipt = isFinalReceipt
        self.direction = direction
        self.metadata = metadata
        self.byoSmsIntegrationId = byoSmsIntegrationId
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case channel
        case type
        case text
        case content
        case events
        case status
        case reasons
        case originatingEntity
        case isFinalReceipt
        case direction
        case metadata
        case byoSmsIntegrationId
    }


}




public class ConversationParticipantSearchRequest: Codable {

    public enum SortOrder: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
        case score = "SCORE"
    }











    /** The sort order for results */
    public var sortOrder: SortOrder?
    /** The field in the resource that you want to sort the results by */
    public var sortBy: String?
    /** Multi-value sort order, list of multiple sort values */
    public var sort: [SearchSort]?
    public var returnFields: [String]?
    public var query: [ConversationParticipantSearchCriteria]?
    public var cursor: String?

    public init(sortOrder: SortOrder?, sortBy: String?, sort: [SearchSort]?, returnFields: [String]?, query: [ConversationParticipantSearchCriteria]?, cursor: String?) {
        self.sortOrder = sortOrder
        self.sortBy = sortBy
        self.sort = sort
        self.returnFields = returnFields
        self.query = query
        self.cursor = cursor
    }


}




public class ConversationProperties: Codable {























    /** Indicates filtering for waiting */
    public var isWaiting: Bool?
    /** Indicates filtering for active */
    public var isActive: Bool?
    /** Indicates filtering for Acd */
    public var isAcd: Bool?
    /** Indicates filtering for Preferred Agent Routing */
    public var isPreferred: Bool?
    /** Indicates filtering for screenshare */
    public var isScreenshare: Bool?
    /** Indicates filtering for Cobrowse */
    public var isCobrowse: Bool?
    /** Indicates filtering for Voice mail */
    public var isVoicemail: Bool?
    /** Indicates filtering for flagged */
    public var isFlagged: Bool?
    /** Indicates filtering for monitored */
    public var isMonitored: Bool?
    /** Indicates filtering for WrapUpNotes */
    public var filterWrapUpNotes: Bool?
    /** Indicates comparison operation, TRUE indicates filters will use AND logic, FALSE indicates OR logic */
    public var matchAll: Bool?

    public init(isWaiting: Bool?, isActive: Bool?, isAcd: Bool?, isPreferred: Bool?, isScreenshare: Bool?, isCobrowse: Bool?, isVoicemail: Bool?, isFlagged: Bool?, isMonitored: Bool?, filterWrapUpNotes: Bool?, matchAll: Bool?) {
        self.isWaiting = isWaiting
        self.isActive = isActive
        self.isAcd = isAcd
        self.isPreferred = isPreferred
        self.isScreenshare = isScreenshare
        self.isCobrowse = isCobrowse
        self.isVoicemail = isVoicemail
        self.isFlagged = isFlagged
        self.isMonitored = isMonitored
        self.filterWrapUpNotes = filterWrapUpNotes
        self.matchAll = matchAll
    }


}




public class ConversationQuery: Codable {











    public enum Order: String, Codable { 
        case asc = "asc"
        case desc = "desc"
        case unordered = "unordered"
    }

    public enum OrderBy: String, Codable { 
        case conversationstart = "conversationStart"
        case conversationend = "conversationEnd"
        case segmentstart = "segmentStart"
        case segmentend = "segmentEnd"
    }







    /** Filters that target conversation-level data */
    public var conversationFilters: [ConversationDetailQueryFilter]?
    /** Filters that target individual segments within a conversation */
    public var segmentFilters: [SegmentDetailQueryFilter]?
    /** Filters that target evaluations */
    public var evaluationFilters: [EvaluationDetailQueryFilter]?
    /** Filters that target surveys */
    public var surveyFilters: [SurveyDetailQueryFilter]?
    /** Filters that target resolutions */
    public var resolutionFilters: [ResolutionDetailQueryFilter]?
    /** Sort the result set in ascending/descending order. Default is ascending */
    public var order: Order?
    /** Specify which data element within the result set to use for sorting. The options  to use as a basis for sorting the results: conversationStart, segmentStart, and segmentEnd. If not specified, the default is conversationStart */
    public var orderBy: OrderBy?
    /** Specifies the date and time range of data being queried. Results will only include conversations that started on a day touched by the interval. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Include faceted search and aggregate roll-ups describing your search results. This does not function as a filter, but rather, summary data about the data matching your filters */
    public var aggregations: [AnalyticsQueryAggregation]?
    /** Page size and number to control iterating through large result sets. Default page size is 25 */
    public var paging: PagingSpec?

    public init(conversationFilters: [ConversationDetailQueryFilter]?, segmentFilters: [SegmentDetailQueryFilter]?, evaluationFilters: [EvaluationDetailQueryFilter]?, surveyFilters: [SurveyDetailQueryFilter]?, resolutionFilters: [ResolutionDetailQueryFilter]?, order: Order?, orderBy: OrderBy?, interval: String?, aggregations: [AnalyticsQueryAggregation]?, paging: PagingSpec?) {
        self.conversationFilters = conversationFilters
        self.segmentFilters = segmentFilters
        self.evaluationFilters = evaluationFilters
        self.surveyFilters = surveyFilters
        self.resolutionFilters = resolutionFilters
        self.order = order
        self.orderBy = orderBy
        self.interval = interval
        self.aggregations = aggregations
        self.paging = paging
    }


}




public class ConversationScreenShareEventTopicConversationRoutingData: Codable {











    /** A UriReference for a resource */
    public var queue: ConversationScreenShareEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: ConversationScreenShareEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int?
    /** The skills to use for routing decisions */
    public var skills: [ConversationScreenShareEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [ConversationScreenShareEventTopicScoredAgent]?

    public init(queue: ConversationScreenShareEventTopicUriReference?, language: ConversationScreenShareEventTopicUriReference?, priority: Int?, skills: [ConversationScreenShareEventTopicUriReference]?, scoredAgents: [ConversationScreenShareEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}




public class ConversationScreenShareEventTopicScreenShareConversation: Codable {









    public var _id: String?
    public var name: String?
    public var participants: [ConversationScreenShareEventTopicScreenShareMediaParticipant]?
    public var otherMediaUris: [String]?

    public init(_id: String?, name: String?, participants: [ConversationScreenShareEventTopicScreenShareMediaParticipant]?, otherMediaUris: [String]?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class ConversationSocialExpressionEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: ConversationSocialExpressionEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: ConversationSocialExpressionEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}




public class ConversationSocialExpressionEventTopicJourneyContext: Codable {







    public var customer: ConversationSocialExpressionEventTopicJourneyCustomer?
    public var customerSession: ConversationSocialExpressionEventTopicJourneyCustomerSession?
    public var triggeringAction: ConversationSocialExpressionEventTopicJourneyAction?

    public init(customer: ConversationSocialExpressionEventTopicJourneyCustomer?, customerSession: ConversationSocialExpressionEventTopicJourneyCustomerSession?, triggeringAction: ConversationSocialExpressionEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class ConversationSocialExpressionEventTopicSocialMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case timeout = "timeout"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }







































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }



















    public var _id: String?
    public var name: String?
    public var address: String?
    public var startTime: Date?
    public var connectedTime: Date?
    public var endTime: Date?
    public var startHoldTime: Date?
    public var purpose: String?
    public var state: State?
    public var initialState: InitialState?
    public var direction: Direction?
    public var disconnectType: DisconnectType?
    public var held: Bool?
    public var wrapupRequired: Bool?
    public var wrapupPrompt: String?
    public var user: ConversationSocialExpressionEventTopicUriReference?
    public var queue: ConversationSocialExpressionEventTopicUriReference?
    public var team: ConversationSocialExpressionEventTopicUriReference?
    public var attributes: [String:String]?
    public var errorInfo: ConversationSocialExpressionEventTopicErrorBody?
    public var script: ConversationSocialExpressionEventTopicUriReference?
    public var wrapupTimeoutMs: Int?
    public var wrapupSkipped: Bool?
    public var alertingTimeoutMs: Int?
    public var provider: String?
    public var externalContact: ConversationSocialExpressionEventTopicUriReference?
    public var externalOrganization: ConversationSocialExpressionEventTopicUriReference?
    public var wrapup: ConversationSocialExpressionEventTopicWrapup?
    public var conversationRoutingData: ConversationSocialExpressionEventTopicConversationRoutingData?
    public var peer: String?
    public var screenRecordingState: String?
    public var flaggedReason: FlaggedReason?
    public var journeyContext: ConversationSocialExpressionEventTopicJourneyContext?
    public var startAcwTime: Date?
    public var endAcwTime: Date?
    public var mediaRoles: [String]?
    public var queueMediaSettings: ConversationSocialExpressionEventTopicQueueMediaSettings?
    public var socialMediaId: String?
    public var socialMediaHub: String?
    public var socialUserName: String?
    public var previewText: String?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, initialState: InitialState?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, user: ConversationSocialExpressionEventTopicUriReference?, queue: ConversationSocialExpressionEventTopicUriReference?, team: ConversationSocialExpressionEventTopicUriReference?, attributes: [String:String]?, errorInfo: ConversationSocialExpressionEventTopicErrorBody?, script: ConversationSocialExpressionEventTopicUriReference?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, alertingTimeoutMs: Int?, provider: String?, externalContact: ConversationSocialExpressionEventTopicUriReference?, externalOrganization: ConversationSocialExpressionEventTopicUriReference?, wrapup: ConversationSocialExpressionEventTopicWrapup?, conversationRoutingData: ConversationSocialExpressionEventTopicConversationRoutingData?, peer: String?, screenRecordingState: String?, flaggedReason: FlaggedReason?, journeyContext: ConversationSocialExpressionEventTopicJourneyContext?, startAcwTime: Date?, endAcwTime: Date?, mediaRoles: [String]?, queueMediaSettings: ConversationSocialExpressionEventTopicQueueMediaSettings?, socialMediaId: String?, socialMediaHub: String?, socialUserName: String?, previewText: String?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.conversationRoutingData = conversationRoutingData
        self.peer = peer
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.mediaRoles = mediaRoles
        self.queueMediaSettings = queueMediaSettings
        self.socialMediaId = socialMediaId
        self.socialMediaHub = socialMediaHub
        self.socialUserName = socialUserName
        self.previewText = previewText
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case initialState
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalOrganization
        case wrapup
        case conversationRoutingData
        case peer
        case screenRecordingState
        case flaggedReason
        case journeyContext
        case startAcwTime
        case endAcwTime
        case mediaRoles
        case queueMediaSettings
        case socialMediaId
        case socialMediaHub
        case socialUserName
        case previewText
    }


}




public class ConversationSocialExpressionEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}




public class ConversationThreadingWindowSetting: Codable {

    public enum MessengerType: String, Codable { 
        case sms = "sms"
        case facebook = "facebook"
        case twitter = "twitter"
        case line = "line"
        case whatsapp = "whatsapp"
        case webmessaging = "webmessaging"
        case instagram = "instagram"
        case _open = "open"
    }



    /** The type of messenger */
    public var messengerType: MessengerType?
    /** The conversation threading window timeout (Minutes) of specified messenger type */
    public var timeoutInMinutes: Int64?

    public init(messengerType: MessengerType?, timeoutInMinutes: Int64?) {
        self.messengerType = messengerType
        self.timeoutInMinutes = timeoutInMinutes
    }


}




public class ConversationVideoEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}




public class CopyAttachmentsRequest: Codable {





    /** A reference to the email message within the current conversation that owns the attachments to be copied */
    public var sourceMessage: DomainEntityRef?
    /** A list of attachments that will be copied from the source message to the current draft */
    public var attachments: [Attachment]?

    public init(sourceMessage: DomainEntityRef?, attachments: [Attachment]?) {
        self.sourceMessage = sourceMessage
        self.attachments = attachments
    }


}




public class CreateBenefitAssessmentRequest: Codable {



    /** The list of queue ids that are to be assessed for Predictive Routing benefit. */
    public var queueIds: [String]?

    public init(queueIds: [String]?) {
        self.queueIds = queueIds
    }


}




public class CreateCallbackOnConversationCommand: Codable {























    /** The identifier of the script to be used for the callback */
    public var scriptId: String?
    /** The identifier of the queue to be used for the callback. Either queueId or routingData is required. */
    public var queueId: String?
    /** The routing data to be used for the callback. Either queueId or routingData is required. */
    public var routingData: RoutingData?
    /** The name of the party to be called back. */
    public var callbackUserName: String?
    /** A list of phone numbers for the callback. */
    public var callbackNumbers: [String]?
    /** The scheduled date-time for the callback as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss.SSSZ */
    public var callbackScheduledTime: Date?
    /** The country code to be associated with the callback numbers. */
    public var countryCode: String?
    /** Whether or not to validate the callback numbers for phone number format. */
    public var validateCallbackNumbers: Bool?
    /** A map of key-value pairs containing additional data that can be associated to the callback. These values will appear in the attributes property on the conversation participant. Example: { \"notes\": \"ready to close the deal!\", \"customerPreferredName\": \"Doc\" } */
    public var data: [String:String]?
    /** The phone number displayed to recipients when a phone call is placed as part of the callback. Must conform to the E.164 format. May be overridden by other settings in the system such as external trunk settings. Telco support for \"callerId\" varies. */
    public var callerId: String?
    /** The name displayed to recipients when a phone call is placed as part of the callback. May be overridden by other settings in the system such as external trunk settings. Telco support for \"callerIdName\" varies. */
    public var callerIdName: String?

    public init(scriptId: String?, queueId: String?, routingData: RoutingData?, callbackUserName: String?, callbackNumbers: [String]?, callbackScheduledTime: Date?, countryCode: String?, validateCallbackNumbers: Bool?, data: [String:String]?, callerId: String?, callerIdName: String?) {
        self.scriptId = scriptId
        self.queueId = queueId
        self.routingData = routingData
        self.callbackUserName = callbackUserName
        self.callbackNumbers = callbackNumbers
        self.callbackScheduledTime = callbackScheduledTime
        self.countryCode = countryCode
        self.validateCallbackNumbers = validateCallbackNumbers
        self.data = data
        self.callerId = callerId
        self.callerIdName = callerIdName
    }


}




public class CreateCallbackResponse: Codable {





    /** The conversation associated with the callback */
    public var conversation: DomainEntityRef?
    /** The list of communication identifiers for the callback participants */
    public var callbackIdentifiers: [CallbackIdentifier]?

    public init(conversation: DomainEntityRef?, callbackIdentifiers: [CallbackIdentifier]?) {
        self.conversation = conversation
        self.callbackIdentifiers = callbackIdentifiers
    }


}



/** Create coaching appointment request */

public class CreateCoachingAppointmentRequest: Codable {





















    /** The name of coaching appointment. */
    public var name: String?
    /** The description of coaching appointment. */
    public var _description: String?
    /** The date/time the coaching appointment starts. Times will be rounded down to the minute. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?
    /** The duration of coaching appointment in minutes. */
    public var lengthInMinutes: Int?
    /** The facilitator ID of coaching appointment. */
    public var facilitatorId: String?
    /** IDs of attendees in the coaching appointment. */
    public var attendeeIds: [String]?
    /** IDs of conversations associated with this coaching appointment. */
    public var conversationIds: [String]?
    /** IDs of documents associated with this coaching appointment. */
    public var documentIds: [String]?
    /** The Workforce Management schedule the appointment is associated with. */
    public var wfmSchedule: WfmScheduleReference?
    /** The list of external links related to the appointment */
    public var externalLinks: [String]?

    public init(name: String?, _description: String?, dateStart: Date?, lengthInMinutes: Int?, facilitatorId: String?, attendeeIds: [String]?, conversationIds: [String]?, documentIds: [String]?, wfmSchedule: WfmScheduleReference?, externalLinks: [String]?) {
        self.name = name
        self._description = _description
        self.dateStart = dateStart
        self.lengthInMinutes = lengthInMinutes
        self.facilitatorId = facilitatorId
        self.attendeeIds = attendeeIds
        self.conversationIds = conversationIds
        self.documentIds = documentIds
        self.wfmSchedule = wfmSchedule
        self.externalLinks = externalLinks
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _description = "description"
        case dateStart
        case lengthInMinutes
        case facilitatorId
        case attendeeIds
        case conversationIds
        case documentIds
        case wfmSchedule
        case externalLinks
    }


}




public class CreateEmailRequest: Codable {

























    public enum Direction: String, Codable { 
        case outbound = "OUTBOUND"
        case inbound = "INBOUND"
    }







    /** The ID of the queue to use for routing the email conversation. This field is mutually exclusive with flowId */
    public var queueId: String?
    /** The ID of the flow to use for routing email conversation. This field is mutually exclusive with queueId */
    public var flowId: String?
    /** The name of the provider that is sourcing the emails. The Provider \"PureCloud Email\" is reserved for native emails. */
    public var provider: String?
    /** The list of skill ID's to use for routing. */
    public var skillIds: [String]?
    /** The ID of the language to use for routing. */
    public var languageId: String?
    /** The priority to assign to the conversation for routing. */
    public var priority: Int64?
    /** The list of attributes to associate with the customer participant. */
    public var attributes: [String:String]?
    /** The email address of the recipient of the email. */
    public var toAddress: String?
    /** The name of the recipient of the email. */
    public var toName: String?
    /** The email address of the sender of the email. */
    public var fromAddress: String?
    /** The name of the sender of the email. */
    public var fromName: String?
    /** The subject of the email */
    public var subject: String?
    /** Specify OUTBOUND to send an email on behalf of a queue, or INBOUND to create an external conversation. An external conversation is one where the provider is not PureCloud based. */
    public var direction: Direction?
    /** An HTML body content of the email. */
    public var htmlBody: String?
    /** A text body content of the email. */
    public var textBody: String?
    /** The external contact with which the email should be associated. This field is only valid for OUTBOUND email. */
    public var externalContactId: String?

    public init(queueId: String?, flowId: String?, provider: String?, skillIds: [String]?, languageId: String?, priority: Int64?, attributes: [String:String]?, toAddress: String?, toName: String?, fromAddress: String?, fromName: String?, subject: String?, direction: Direction?, htmlBody: String?, textBody: String?, externalContactId: String?) {
        self.queueId = queueId
        self.flowId = flowId
        self.provider = provider
        self.skillIds = skillIds
        self.languageId = languageId
        self.priority = priority
        self.attributes = attributes
        self.toAddress = toAddress
        self.toName = toName
        self.fromAddress = fromAddress
        self.fromName = fromName
        self.subject = subject
        self.direction = direction
        self.htmlBody = htmlBody
        self.textBody = textBody
        self.externalContactId = externalContactId
    }


}




public class CreateObjective: Codable {











    public enum MediaTypes: String, Codable { 
        case callback = "callback"
        case chat = "chat"
        case cobrowse = "cobrowse"
        case email = "email"
        case message = "message"
        case screenshare = "screenshare"
        case unknown = "unknown"
        case video = "video"
        case voice = "voice"
    }



    public enum TopicIdsFilterType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The id of this objective's base template */
    public var templateId: String?
    /** Objective zone specifies min,max points and values for the associated metric */
    public var zones: [ObjectiveZone]?
    /** A flag for whether this objective is enabled for the related metric */
    public var enabled: Bool?
    /** A list of topic ids for detected topic metrics */
    public var topicIds: [String]?
    /** A list of media types for the metric */
    public var mediaTypes: [MediaTypes]?
    /** A list of queue ids for the metric */
    public var queueIds: [String]?
    /** A filter type for topic Ids. It's only used for objectives with topicIds. Default filter behavior is \"or\". */
    public var topicIdsFilterType: TopicIdsFilterType?
    /** The ids of associated evaluation form context, for Quality Evaluation Score metrics */
    public var evaluationFormContextIds: [String]?
    /** start date of the objective. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStart: Date?

    public init(_id: String?, templateId: String?, zones: [ObjectiveZone]?, enabled: Bool?, topicIds: [String]?, mediaTypes: [MediaTypes]?, queueIds: [String]?, topicIdsFilterType: TopicIdsFilterType?, evaluationFormContextIds: [String]?, dateStart: Date?) {
        self._id = _id
        self.templateId = templateId
        self.zones = zones
        self.enabled = enabled
        self.topicIds = topicIds
        self.mediaTypes = mediaTypes
        self.queueIds = queueIds
        self.topicIdsFilterType = topicIdsFilterType
        self.evaluationFormContextIds = evaluationFormContextIds
        self.dateStart = dateStart
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case templateId
        case zones
        case enabled
        case topicIds
        case mediaTypes
        case queueIds
        case topicIdsFilterType
        case evaluationFormContextIds
        case dateStart
    }


}




public class CreatePlanningGroupRequest: Codable {







    /** The name of the planning group */
    public var name: String?
    /** Set of route paths to associate with the planning group */
    public var routePaths: [RoutePathRequest]?
    /** The ID of the service goal template to associate with this planning group */
    public var serviceGoalTemplateId: String?

    public init(name: String?, routePaths: [RoutePathRequest]?, serviceGoalTemplateId: String?) {
        self.name = name
        self.routePaths = routePaths
        self.serviceGoalTemplateId = serviceGoalTemplateId
    }


}




public class CreateTimeOffLimitRequest: Codable {

    public enum Granularity: String, Codable { 
        case daily = "Daily"
    }



    /** Granularity choice for time off limit. If not specified, 'Daily' is assumed */
    public var granularity: Granularity?
    /** The default limit value in minutes per granularity. If not specified, then 0 is assumed, which means there are no time off minutes available */
    public var defaultLimitMinutes: Int?

    public init(granularity: Granularity?, defaultLimitMinutes: Int?) {
        self.granularity = granularity
        self.defaultLimitMinutes = defaultLimitMinutes
    }


}




public class Credential: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The type of credential. */
    public var type: CredentialType?
    public var credentialFields: [String:String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, type: CredentialType?, credentialFields: [String:String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.type = type
        self.credentialFields = credentialFields
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case type
        case credentialFields
        case selfUri
    }


}



/** Specifies the requirements for a credential that can be provided for configuring an integration */

public class CredentialSpecification: Codable {







    /** Indicates if the credential must be provided in order for the integration configuration to be valid. */
    public var _required: Bool?
    /** Title describing the usage for this credential. */
    public var title: String?
    /** List of acceptable credential types that can be provided for this credential. */
    public var credentialTypes: [String]?

    public init(_required: Bool?, title: String?, credentialTypes: [String]?) {
        self._required = _required
        self.title = title
        self.credentialTypes = credentialTypes
    }

    public enum CodingKeys: String, CodingKey { 
        case _required = "required"
        case title
        case credentialTypes
    }


}




public class Criteria: Codable {







    public enum Operator: String, Codable { 
        case containsall = "containsAll"
        case containsany = "containsAny"
        case notcontainsall = "notContainsAll"
        case notcontainsany = "notContainsAny"
        case equal = "equal"
        case notequal = "notEqual"
        case greaterthan = "greaterThan"
        case greaterthanorequal = "greaterThanOrEqual"
        case lessthan = "lessThan"
        case lessthanorequal = "lessThanOrEqual"
        case startswith = "startsWith"
        case endswith = "endsWith"
    }

    /** The criteria key. */
    public var key: String?
    /** The criteria values. */
    public var values: [String]?
    /** Should criteria be case insensitive. */
    public var shouldIgnoreCase: Bool?
    /** The comparison operator. */
    public var _operator: Operator?

    public init(key: String?, values: [String]?, shouldIgnoreCase: Bool?, _operator: Operator?) {
        self.key = key
        self.values = values
        self.shouldIgnoreCase = shouldIgnoreCase
        self._operator = _operator
    }

    public enum CodingKeys: String, CodingKey { 
        case key
        case values
        case shouldIgnoreCase
        case _operator = "operator"
    }


}



/** A group of logical or a singular criteria used to create a query of executionData */

public class CriteriaGroup: Codable {









    /** These criteriaItems will be AND'd together to find a match. */
    public var and: [CriteriaItem]?
    /** These criteriaItems will be OR'd together to find a match. */
    public var or: [CriteriaItem]?
    /** These criteriaItems must all be false to find a match. */
    public var not: [CriteriaItem]?
    /** A singular critieriaItem to match. */
    public var criteria: CriteriaItem?

    public init(and: [CriteriaItem]?, or: [CriteriaItem]?, not: [CriteriaItem]?, criteria: CriteriaItem?) {
        self.and = and
        self.or = or
        self.not = not
        self.criteria = criteria
    }


}




public class CrossPlatformPolicyActions: Codable {





















    /** true to retain the recording associated with the conversation. Default = true */
    public var retainRecording: Bool?
    /** true to delete the recording associated with the conversation. If retainRecording = true, this will be ignored. Default = false */
    public var deleteRecording: Bool?
    /** true to delete the recording associated with the conversation regardless of the values of retainRecording or deleteRecording. Default = false */
    public var alwaysDelete: Bool?
    public var assignEvaluations: [EvaluationAssignment]?
    public var assignMeteredEvaluations: [MeteredEvaluationAssignment]?
    public var assignMeteredAssignmentByAgent: [MeteredAssignmentByAgent]?
    public var assignCalibrations: [CalibrationAssignment]?
    public var retentionDuration: RetentionDuration?
    public var mediaTranscriptions: [MediaTranscription]?
    /** Policy action for exporting recordings using an integration to 3rd party s3. */
    public var integrationExport: IntegrationExport?

    public init(retainRecording: Bool?, deleteRecording: Bool?, alwaysDelete: Bool?, assignEvaluations: [EvaluationAssignment]?, assignMeteredEvaluations: [MeteredEvaluationAssignment]?, assignMeteredAssignmentByAgent: [MeteredAssignmentByAgent]?, assignCalibrations: [CalibrationAssignment]?, retentionDuration: RetentionDuration?, mediaTranscriptions: [MediaTranscription]?, integrationExport: IntegrationExport?) {
        self.retainRecording = retainRecording
        self.deleteRecording = deleteRecording
        self.alwaysDelete = alwaysDelete
        self.assignEvaluations = assignEvaluations
        self.assignMeteredEvaluations = assignMeteredEvaluations
        self.assignMeteredAssignmentByAgent = assignMeteredAssignmentByAgent
        self.assignCalibrations = assignCalibrations
        self.retentionDuration = retentionDuration
        self.mediaTranscriptions = mediaTranscriptions
        self.integrationExport = integrationExport
    }


}




public class CrossPlatformPolicyCreate: Codable {

























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The policy name. */
    public var name: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    public var order: Int?
    public var _description: String?
    public var enabled: Bool?
    /** Conditions and actions per media type */
    public var mediaPolicies: CrossPlatformMediaPolicies?
    /** Conditions */
    public var conditions: PolicyConditions?
    /** Actions */
    public var actions: CrossPlatformPolicyActions?
    public var policyErrors: PolicyErrors?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, modifiedDate: Date?, createdDate: Date?, order: Int?, _description: String?, enabled: Bool?, mediaPolicies: CrossPlatformMediaPolicies?, conditions: PolicyConditions?, actions: CrossPlatformPolicyActions?, policyErrors: PolicyErrors?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.modifiedDate = modifiedDate
        self.createdDate = createdDate
        self.order = order
        self._description = _description
        self.enabled = enabled
        self.mediaPolicies = mediaPolicies
        self.conditions = conditions
        self.actions = actions
        self.policyErrors = policyErrors
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case modifiedDate
        case createdDate
        case order
        case _description = "description"
        case enabled
        case mediaPolicies
        case conditions
        case actions
        case policyErrors
        case selfUri
    }


}




public class CrossPlatformPolicyUpdate: Codable {



    public var enabled: Bool?

    public init(enabled: Bool?) {
        self.enabled = enabled
    }


}




public class CtaButtonStyleProperties: Codable {







    public enum TextAlign: String, Codable { 
        case _left = "Left"
        case _right = "Right"
        case center = "Center"
    }



    /** Color of the text. (eg. #FFFFFF) */
    public var color: String?
    /** Font of the text. (eg. Helvetica) */
    public var font: String?
    /** Font size of the text. (eg. '12') */
    public var fontSize: String?
    /** Text alignment. */
    public var textAlign: TextAlign?
    /** Background color of the CTA button. (eg. #FF0000) */
    public var backgroundColor: String?

    public init(color: String?, font: String?, fontSize: String?, textAlign: TextAlign?, backgroundColor: String?) {
        self.color = color
        self.font = font
        self.fontSize = fontSize
        self.textAlign = textAlign
        self.backgroundColor = backgroundColor
    }


}




public class CursorContactListing: Codable {











    public var entities: [ExternalContact]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?
    /** The cursor that points to the next set of entities being returned. */
    public var cursors: Cursors?

    public init(entities: [ExternalContact]?, nextUri: String?, selfUri: String?, previousUri: String?, cursors: Cursors?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
        self.cursors = cursors
    }


}




public class CursorNoteListing: Codable {











    public var entities: [Note]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?
    /** The cursor that points to the next set of entities being returned. */
    public var cursors: Cursors?

    public init(entities: [Note]?, nextUri: String?, selfUri: String?, previousUri: String?, cursors: Cursors?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
        self.cursors = cursors
    }


}




public class CursorRelationshipListing: Codable {











    public var entities: [Relationship]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?
    /** The cursor that points to the next set of entities being returned. */
    public var cursors: Cursors?

    public init(entities: [Relationship]?, nextUri: String?, selfUri: String?, previousUri: String?, cursors: Cursors?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
        self.cursors = cursors
    }


}




public class CustomEventAttributeList: Codable {





    /** The data type of the custom attributes. */
    public var dataType: String?
    /** The list of custom event attribute values. */
    public var values: [String]?

    public init(dataType: String?, values: [String]?) {
        self.dataType = dataType
        self.values = values
    }


}




public class DID: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }











    public enum OwnerType: String, Codable { 
        case user = "USER"
        case phone = "PHONE"
        case ivrConfig = "IVR_CONFIG"
        case group = "GROUP"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    public var phoneNumber: String?
    public var didPool: DomainEntityRef?
    /** A Uri reference to the owner of this DID, which is either a User or an IVR */
    public var owner: DomainEntityRef?
    public var ownerType: OwnerType?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, phoneNumber: String?, didPool: DomainEntityRef?, owner: DomainEntityRef?, ownerType: OwnerType?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.phoneNumber = phoneNumber
        self.didPool = didPool
        self.owner = owner
        self.ownerType = ownerType
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case phoneNumber
        case didPool
        case owner
        case ownerType
        case selfUri
    }


}




public class DIDPool: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }











    public enum Provider: String, Codable { 
        case pureCloud = "PURE_CLOUD"
        case pureCloudVoice = "PURE_CLOUD_VOICE"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** The starting phone number for the range of this DID pool. Must be in E.164 format */
    public var startPhoneNumber: String?
    /** The ending phone number for the range of this DID pool. Must be in E.164 format */
    public var endPhoneNumber: String?
    public var comments: String?
    /** The provider for this DID pool */
    public var provider: Provider?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, startPhoneNumber: String?, endPhoneNumber: String?, comments: String?, provider: Provider?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.startPhoneNumber = startPhoneNumber
        self.endPhoneNumber = endPhoneNumber
        self.comments = comments
        self.provider = provider
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case startPhoneNumber
        case endPhoneNumber
        case comments
        case provider
        case selfUri
    }


}



/** State information for an import job of rows to a datatable */

public class DataTableImportJob: Codable {







    public enum Status: String, Codable { 
        case waitingForUpload = "WaitingForUpload"
        case processing = "Processing"
        case failed = "Failed"
        case succeeded = "Succeeded"
    }







    public enum ImportMode: String, Codable { 
        case replaceAll = "ReplaceAll"
        case append = "Append"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The PureCloud user who started the import job */
    public var owner: AddressableEntityRef?
    /** The status of the import job */
    public var status: Status?
    /** The timestamp of when the import began. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The timestamp of when the import stopped (either successfully or unsuccessfully). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCompleted: Date?
    /** The URL of the location at which the caller can upload the file to be imported */
    public var uploadURI: String?
    /** The indication of whether the processing should remove rows that don't appear in the import file */
    public var importMode: ImportMode?
    /** Any error information, or null of the processing is not in an error state */
    public var errorInformation: ErrorBody?
    /** The current count of the number of records processed */
    public var countRecordsUpdated: Int?
    /** The current count of the number of records deleted */
    public var countRecordsDeleted: Int?
    /** The current count of the number of records that failed to import */
    public var countRecordsFailed: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, owner: AddressableEntityRef?, status: Status?, dateCreated: Date?, dateCompleted: Date?, uploadURI: String?, importMode: ImportMode?, errorInformation: ErrorBody?, countRecordsUpdated: Int?, countRecordsDeleted: Int?, countRecordsFailed: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.owner = owner
        self.status = status
        self.dateCreated = dateCreated
        self.dateCompleted = dateCompleted
        self.uploadURI = uploadURI
        self.importMode = importMode
        self.errorInformation = errorInformation
        self.countRecordsUpdated = countRecordsUpdated
        self.countRecordsDeleted = countRecordsDeleted
        self.countRecordsFailed = countRecordsFailed
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case owner
        case status
        case dateCreated
        case dateCompleted
        case uploadURI
        case importMode
        case errorInformation
        case countRecordsUpdated
        case countRecordsDeleted
        case countRecordsFailed
        case selfUri
    }


}




public class DateRangeWithOptionalEnd: Codable {





    /** The start date for work plan rotation or an agent, interpreted in the business unit's time zone. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var startBusinessUnitDate: Date?
    /** The end date for work plan rotation or an agent, interpreted in the business unit's time zone. Null denotes open ended date range. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var endBusinessUnitDate: Date?

    public init(startBusinessUnitDate: Date?, endBusinessUnitDate: Date?) {
        self.startBusinessUnitDate = startBusinessUnitDate
        self.endBusinessUnitDate = endBusinessUnitDate
    }


}




public class DeletableUserReference: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** If marked true, the user will be removed an associated entity */
    public var delete: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, delete: Bool?, selfUri: String?) {
        self._id = _id
        self.delete = delete
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case delete
        case selfUri
    }


}




public class DependencyObjectEntityListing: Codable {





















    public var entities: [DependencyObject]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DependencyObject]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DeploymentWebAction: Codable {



    public enum MediaType: String, Codable { 
        case webchat = "webchat"
        case webmessagingoffer = "webMessagingOffer"
        case contentoffer = "contentOffer"
        case integrationaction = "integrationAction"
        case architectflow = "architectFlow"
        case openaction = "openAction"
    }

















    /** System-generated UUID for the action. */
    public var _id: String?
    /** Action media type used to deliver the action. */
    public var mediaType: MediaType?
    /** ID string of the customer that the action was triggered for. */
    public var customerId: String?
    /** Type of the customer ID that the action was triggered for. */
    public var customerIdType: String?
    /** ID of the action map that triggered the action. */
    public var actionMapId: String?
    /** Version of the action map that triggered the action. */
    public var actionMapVersion: Int?
    /** ID of the session that the action was triggered for. */
    public var sessionId: String?
    /** Web messaging offer specific properties. */
    public var webMessagingOfferProperties: WebMessagingOfferProperties?
    /** Content offer specific properties. */
    public var contentOfferProperties: ContentOffer?
    /** Open action specific properties. */
    public var openActionProperties: OpenActionProperties?

    public init(_id: String?, mediaType: MediaType?, customerId: String?, customerIdType: String?, actionMapId: String?, actionMapVersion: Int?, sessionId: String?, webMessagingOfferProperties: WebMessagingOfferProperties?, contentOfferProperties: ContentOffer?, openActionProperties: OpenActionProperties?) {
        self._id = _id
        self.mediaType = mediaType
        self.customerId = customerId
        self.customerIdType = customerIdType
        self.actionMapId = actionMapId
        self.actionMapVersion = actionMapVersion
        self.sessionId = sessionId
        self.webMessagingOfferProperties = webMessagingOfferProperties
        self.contentOfferProperties = contentOfferProperties
        self.openActionProperties = openActionProperties
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case mediaType
        case customerId
        case customerIdType
        case actionMapId
        case actionMapVersion
        case sessionId
        case webMessagingOfferProperties
        case contentOfferProperties
        case openActionProperties
    }


}




public class Destination: Codable {









    /** Address or phone number. */
    public var address: String?
    public var name: String?
    public var userId: String?
    public var queueId: String?

    public init(address: String?, name: String?, userId: String?, queueId: String?) {
        self.address = address
        self.name = name
        self.userId = userId
        self.queueId = queueId
    }


}




public class DetectedDialogAct: Codable {





    /** The name of the detected dialog act. */
    public var name: String?
    /** The probability of the detected dialog act. */
    public var probability: Double?

    public init(name: String?, probability: Double?) {
        self.name = name
        self.probability = probability
    }


}




public class DetectedNamedEntity: Codable {









    /** The name of the detected named entity. */
    public var name: String?
    /** The type of the detected named entity. */
    public var entityType: String?
    /** The probability of the detected named entity. */
    public var probability: Double?
    /** The value of the detected named entity. */
    public var value: DetectedNamedEntityValue?

    public init(name: String?, entityType: String?, probability: Double?, value: DetectedNamedEntityValue?) {
        self.name = name
        self.entityType = entityType
        self.probability = probability
        self.value = value
    }


}




public class DialerAction: Codable {

    public enum ModelType: String, Codable { 
        case action = "Action"
        case modifycontactattribute = "modifyContactAttribute"
        case dataactionbehavior = "dataActionBehavior"
    }

    public enum ActionTypeName: String, Codable { 
        case doNotDial = "DO_NOT_DIAL"
        case modifyContactAttribute = "MODIFY_CONTACT_ATTRIBUTE"
        case switchToPreview = "SWITCH_TO_PREVIEW"
        case appendNumberToDncList = "APPEND_NUMBER_TO_DNC_LIST"
        case appendCustomEntryToDncList = "APPEND_CUSTOM_ENTRY_TO_DNC_LIST"
        case scheduleCallback = "SCHEDULE_CALLBACK"
        case contactUncallable = "CONTACT_UNCALLABLE"
        case numberUncallable = "NUMBER_UNCALLABLE"
        case setCallerId = "SET_CALLER_ID"
        case setSkills = "SET_SKILLS"
        case dataAction = "DATA_ACTION"
    }

    public enum UpdateOption: String, Codable { 
        case _set = "SET"
        case increment = "INCREMENT"
        case decrement = "DECREMENT"
        case currentTime = "CURRENT_TIME"
    }













    /** The type of this DialerAction. */
    public var type: ModelType?
    /** Additional type specification for this DialerAction. */
    public var actionTypeName: ActionTypeName?
    /** Specifies how a contact attribute should be updated. Required for MODIFY_CONTACT_ATTRIBUTE. */
    public var updateOption: UpdateOption?
    /** A map of key-value pairs pertinent to the DialerAction. Different types of DialerActions require different properties. MODIFY_CONTACT_ATTRIBUTE with an updateOption of SET takes a contact column as the key and accepts any value. SCHEDULE_CALLBACK takes a key 'callbackOffset' that specifies how far in the future the callback should be scheduled, in minutes. SET_CALLER_ID takes two keys: 'callerAddress', which should be the caller id phone number, and 'callerName'. For either key, you can also specify a column on the contact to get the value from. To do this, specify 'contact.Column', where 'Column' is the name of the contact column from which to get the value. SET_SKILLS takes a key 'skills' with an array of skill ids wrapped into a string (Example: {'skills': '['skillIdHere']'} ). */
    public var properties: [String:String]?
    /** The Data Action to use for this action. Required for a dataActionBehavior. */
    public var dataAction: DomainEntityRef?
    /** A list of mappings defining which contact data fields will be passed to which data action input fields for this condition. Valid for a dataActionBehavior. */
    public var contactColumnToDataActionFieldMappings: [ContactColumnToDataActionFieldMapping]?
    /** The input field from the data action that the contactId will be passed to for this condition. Valid for a dataActionBehavior. */
    public var contactIdField: String?
    /** The input field from the data action that the callAnalysisResult will be passed to for this condition. Valid for a wrapup dataActionBehavior. */
    public var callAnalysisResultField: String?
    /** The input field from the data action that the agentWrapup will be passed to for this condition. Valid for a wrapup dataActionBehavior. */
    public var agentWrapupField: String?

    public init(type: ModelType?, actionTypeName: ActionTypeName?, updateOption: UpdateOption?, properties: [String:String]?, dataAction: DomainEntityRef?, contactColumnToDataActionFieldMappings: [ContactColumnToDataActionFieldMapping]?, contactIdField: String?, callAnalysisResultField: String?, agentWrapupField: String?) {
        self.type = type
        self.actionTypeName = actionTypeName
        self.updateOption = updateOption
        self.properties = properties
        self.dataAction = dataAction
        self.contactColumnToDataActionFieldMappings = contactColumnToDataActionFieldMappings
        self.contactIdField = contactIdField
        self.callAnalysisResultField = callAnalysisResultField
        self.agentWrapupField = agentWrapupField
    }


}




public class DialerAttemptLimitsConfigChangeRecallEntry: Codable {







    /** The number of recall attempts to make */
    public var nbrAttempts: Int?
    /** How long to wait between recall attempts */
    public var minutesBetweenAttempts: Int?
    public var additionalProperties: [String:JSON]?

    public init(nbrAttempts: Int?, minutesBetweenAttempts: Int?, additionalProperties: [String:JSON]?) {
        self.nbrAttempts = nbrAttempts
        self.minutesBetweenAttempts = minutesBetweenAttempts
        self.additionalProperties = additionalProperties
    }


}




public class DialerCampaignConfigChangeRestErrorDetail: Codable {







    /** name of the error */
    public var error: String?
    /** additional information regarding the error */
    public var details: String?
    public var additionalProperties: [String:JSON]?

    public init(error: String?, details: String?, additionalProperties: [String:JSON]?) {
        self.error = error
        self.details = details
        self.additionalProperties = additionalProperties
    }


}




public class DialerCampaignRuleConfigChangeCampaignRule: Codable {























    public var campaignRuleEntities: DialerCampaignRuleConfigChangeCampaignRuleEntities?
    /** The list of conditions that will trigger this Campaign Rule */
    public var campaignRuleConditions: [DialerCampaignRuleConfigChangeCampaignRuleCondition]?
    /** The list of actions that will be taken when this Campaign Rule's conditions are met */
    public var campaignRuleActions: [DialerCampaignRuleConfigChangeCampaignRuleAction]?
    /** Whether this Campaign Rule should match any conditions (inclusive OR) or match all conditions (ALL) */
    public var matchAnyConditions: Bool?
    /** Whether this campaign rule is enabled */
    public var enabled: Bool?
    public var additionalProperties: [String:JSON]?
    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The UI-visible name of the object */
    public var name: String?
    /** Creation time of the entity */
    public var dateCreated: Date?
    /** Last modified time of the entity */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?

    public init(campaignRuleEntities: DialerCampaignRuleConfigChangeCampaignRuleEntities?, campaignRuleConditions: [DialerCampaignRuleConfigChangeCampaignRuleCondition]?, campaignRuleActions: [DialerCampaignRuleConfigChangeCampaignRuleAction]?, matchAnyConditions: Bool?, enabled: Bool?, additionalProperties: [String:JSON]?, _id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?) {
        self.campaignRuleEntities = campaignRuleEntities
        self.campaignRuleConditions = campaignRuleConditions
        self.campaignRuleActions = campaignRuleActions
        self.matchAnyConditions = matchAnyConditions
        self.enabled = enabled
        self.additionalProperties = additionalProperties
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case campaignRuleEntities
        case campaignRuleConditions
        case campaignRuleActions
        case matchAnyConditions
        case enabled
        case additionalProperties
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
    }


}




public class DialerCampaignRuleConfigChangeCampaignRuleCondition: Codable {





    public enum ConditionType: String, Codable { 
        case campaignprogress = "campaignProgress"
        case campaignagents = "campaignAgents"
    }



    /** The globally unique identifier for the condition */
    public var _id: String?
    /** The parameters to match this condition */
    public var parameters: [String:String]?
    /** The type of this condition */
    public var conditionType: ConditionType?
    public var additionalProperties: [String:JSON]?

    public init(_id: String?, parameters: [String:String]?, conditionType: ConditionType?, additionalProperties: [String:JSON]?) {
        self._id = _id
        self.parameters = parameters
        self.conditionType = conditionType
        self.additionalProperties = additionalProperties
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case parameters
        case conditionType
        case additionalProperties
    }


}




public class DialerCampaignScheduleConfigChangeCampaignSchedule: Codable {



















    /** a list of start and end times */
    public var intervals: [DialerCampaignScheduleConfigChangeScheduleInterval]?
    /** time zone identifier to be applied to the intervals; for example Africa/Abidjan */
    public var timeZone: String?
    public var campaign: DialerCampaignScheduleConfigChangeUriReference?
    public var additionalProperties: [String:JSON]?
    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The UI-visible name of the object */
    public var name: String?
    /** Creation time of the entity */
    public var dateCreated: Date?
    /** Last modified time of the entity */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?

    public init(intervals: [DialerCampaignScheduleConfigChangeScheduleInterval]?, timeZone: String?, campaign: DialerCampaignScheduleConfigChangeUriReference?, additionalProperties: [String:JSON]?, _id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?) {
        self.intervals = intervals
        self.timeZone = timeZone
        self.campaign = campaign
        self.additionalProperties = additionalProperties
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case intervals
        case timeZone
        case campaign
        case additionalProperties
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
    }


}




public class DialerContact: Codable {





























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The identifier of the contact list containing this contact. */
    public var contactListId: String?
    /** An ordered map of the contact's columns and corresponding values. */
    public var data: [String:String]?
    /** A map of call records for the contact phone columns. */
    public var callRecords: [String:CallRecord]?
    /** A map of SMS records for the contact phone columns. */
    public var latestSmsEvaluations: [String:MessageEvaluation]?
    /** A map of email records for the contact email columns. */
    public var latestEmailEvaluations: [String:MessageEvaluation]?
    /** Indicates whether or not the contact can be called. */
    public var callable: Bool?
    /** A map of phone number columns to PhoneNumberStatuses, which indicate if the phone number is callable or not. */
    public var phoneNumberStatus: [String:PhoneNumberStatus]?
    /** A map of media types (Voice, SMS and Email) to ContactableStatus, which indicates if the contact can be contacted using the specified media type. */
    public var contactableStatus: [String:ContactableStatus]?
    /** Map containing data about the timezone the contact is mapped to. This will only be populated if the contact list has automatic timezone mapping turned on. The key is the column name. The value is the timezone it mapped to and the type of column: Phone or Zip */
    public var contactColumnTimeZones: [String:ContactColumnTimeZone]?
    /** the priority property within ConfigurationOverides indicates whether or not the contact to be placed in front of the queue or at the end of the queue */
    public var configurationOverrides: ConfigurationOverrides?
    /** Timestamp for when the contact was added. Contacts added prior to 2023 September 1 may be missing this value. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, contactListId: String?, data: [String:String]?, callRecords: [String:CallRecord]?, latestSmsEvaluations: [String:MessageEvaluation]?, latestEmailEvaluations: [String:MessageEvaluation]?, callable: Bool?, phoneNumberStatus: [String:PhoneNumberStatus]?, contactableStatus: [String:ContactableStatus]?, contactColumnTimeZones: [String:ContactColumnTimeZone]?, configurationOverrides: ConfigurationOverrides?, dateCreated: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.contactListId = contactListId
        self.data = data
        self.callRecords = callRecords
        self.latestSmsEvaluations = latestSmsEvaluations
        self.latestEmailEvaluations = latestEmailEvaluations
        self.callable = callable
        self.phoneNumberStatus = phoneNumberStatus
        self.contactableStatus = contactableStatus
        self.contactColumnTimeZones = contactColumnTimeZones
        self.configurationOverrides = configurationOverrides
        self.dateCreated = dateCreated
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case contactListId
        case data
        case callRecords
        case latestSmsEvaluations
        case latestEmailEvaluations
        case callable
        case phoneNumberStatus
        case contactableStatus
        case contactColumnTimeZones
        case configurationOverrides
        case dateCreated
        case selfUri
    }


}




public class DialerContactlistConfigChangeContactPhoneNumberColumn: Codable {









    /** name of the phone column */
    public var columnName: String?
    /** type of the phone column, for example, 'cell' or 'home' */
    public var type: String?
    /** name of the column indicating the timezone to be considered for determining callable times */
    public var callableTimeColumn: String?
    public var additionalProperties: [String:JSON]?

    public init(columnName: String?, type: String?, callableTimeColumn: String?, additionalProperties: [String:JSON]?) {
        self.columnName = columnName
        self.type = type
        self.callableTimeColumn = callableTimeColumn
        self.additionalProperties = additionalProperties
    }


}



/** A UriReference for a resource */

public class DialerContactlistfilterConfigChangeUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}



/** A UriReference for a resource */

public class DialerDnclistConfigChangeUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class DialerEventEntityListing: Codable {





















    public var entities: [EventLog]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [EventLog]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** The time interval to place outbound calls */

public class DialerOutboundSettingsConfigChangeAtzmTimeSlot: Codable {





    /** The earliest time to dial a contact */
    public var earliestCallableTime: String?
    /** The latest time to dial a contact */
    public var latestCallableTime: String?

    public init(earliestCallableTime: String?, latestCallableTime: String?) {
        self.earliestCallableTime = earliestCallableTime
        self.latestCallableTime = latestCallableTime
    }


}




public class DialerResponsesetConfigChangeResponseSet: Codable {

















    /** Map of disposition identifiers to reactions. For example: {\"disposition.classification.callable.person\": {\"reactionType\": \"transfer\"}} */
    public var responses: [String:DialerResponsesetConfigChangeReaction]?
    /** When beep detection is enabled, answering machine detection will wait for the beep before transferring the call */
    public var beepDetectionEnabled: Bool?
    public var additionalProperties: [String:JSON]?
    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The UI-visible name of the object */
    public var name: String?
    /** Creation time of the entity */
    public var dateCreated: Date?
    /** Last modified time of the entity */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?

    public init(responses: [String:DialerResponsesetConfigChangeReaction]?, beepDetectionEnabled: Bool?, additionalProperties: [String:JSON]?, _id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?) {
        self.responses = responses
        self.beepDetectionEnabled = beepDetectionEnabled
        self.additionalProperties = additionalProperties
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case responses
        case beepDetectionEnabled
        case additionalProperties
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
    }


}




public class DialerRulesetConfigChangeAction: Codable {











    /** Type of the action */
    public var type: String?
    /** Identifier of the action */
    public var actionTypeName: String?
    /** Indicator of the type of update action (applicable only to certain types of actions) */
    public var updateOption: String?
    /** Map of key-value pairs pertinent to the action (different actions require different properties) */
    public var properties: [String:String]?
    public var additionalProperties: [String:JSON]?

    public init(type: String?, actionTypeName: String?, updateOption: String?, properties: [String:String]?, additionalProperties: [String:JSON]?) {
        self.type = type
        self.actionTypeName = actionTypeName
        self.updateOption = updateOption
        self.properties = properties
        self.additionalProperties = additionalProperties
    }


}




public class DialerSequenceScheduleConfigChangeSequenceSchedule: Codable {



















    /** a list of start and end times */
    public var intervals: [DialerSequenceScheduleConfigChangeScheduleInterval]?
    /** time zone identifier to be applied to the intervals; for example Africa/Abidjan */
    public var timeZone: String?
    public var sequence: DialerSequenceScheduleConfigChangeUriReference?
    public var additionalProperties: [String:JSON]?
    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The UI-visible name of the object */
    public var name: String?
    /** Creation time of the entity */
    public var dateCreated: Date?
    /** Last modified time of the entity */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?

    public init(intervals: [DialerSequenceScheduleConfigChangeScheduleInterval]?, timeZone: String?, sequence: DialerSequenceScheduleConfigChangeUriReference?, additionalProperties: [String:JSON]?, _id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?) {
        self.intervals = intervals
        self.timeZone = timeZone
        self.sequence = sequence
        self.additionalProperties = additionalProperties
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case intervals
        case timeZone
        case sequence
        case additionalProperties
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
    }


}




public class DialogflowAgentSummaryEntityListing: Codable {





















    public var entities: [DialogflowAgentSummary]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DialogflowAgentSummary]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DialogflowCXAgentSummaryEntityListing: Codable {





















    public var entities: [DialogflowCXAgentSummary]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DialogflowCXAgentSummary]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DialogflowCXProject: Codable {





    public var _id: String?
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class DialogflowProject: Codable {





    public var _id: String?
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class DictionaryFeedback: Codable {









    public enum Source: String, Codable { 
        case manual = "Manual"
    }















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The dictionary term which needs to be added to dictionary feedback system */
    public var term: String?
    /** The dialect for the given term, dialect format is {language}-{country} where language follows ISO 639-1 standard and country follows ISO 3166-1 alpha 2 standard */
    public var dialect: String?
    /** A weighted value assigned to a phrase. The higher the value, the higher the likelihood that the system will choose the word or phrase from the possible alternatives. Boost range is from 1.0 to 10.0. Default is 2.0 */
    public var boostValue: Float?
    /** The source of the given dictionary feedback */
    public var source: Source?
    /** The Timestamp when dictionary feedback created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The Id of the user who created the dictionary feedback */
    public var createdBy: UserReference?
    /** The Timestamp when dictionary feedback modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The Id of the user who modified the dictionary feedback */
    public var modifiedBy: UserReference?
    /** A list of at least 3 and up to 20 unique phrases that are example usage of the term */
    public var examplePhrases: [DictionaryFeedbackExamplePhrase]?
    /** A list of up to 10 terms that give examples of how the term sounds */
    public var soundsLike: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, term: String?, dialect: String?, boostValue: Float?, source: Source?, dateCreated: Date?, createdBy: UserReference?, dateModified: Date?, modifiedBy: UserReference?, examplePhrases: [DictionaryFeedbackExamplePhrase]?, soundsLike: [String]?, selfUri: String?) {
        self._id = _id
        self.term = term
        self.dialect = dialect
        self.boostValue = boostValue
        self.source = source
        self.dateCreated = dateCreated
        self.createdBy = createdBy
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.examplePhrases = examplePhrases
        self.soundsLike = soundsLike
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case term
        case dialect
        case boostValue
        case source
        case dateCreated
        case createdBy
        case dateModified
        case modifiedBy
        case examplePhrases
        case soundsLike
        case selfUri
    }


}




public class DigitalDataActionConditionPredicate: Codable {



    public enum OutputOperator: String, Codable { 
        case equals = "Equals"
        case lessThan = "LessThan"
        case lessThanEquals = "LessThanEquals"
        case greaterThan = "GreaterThan"
        case greaterThanEquals = "GreaterThanEquals"
        case contains = "Contains"
        case beginsWith = "BeginsWith"
        case endsWith = "EndsWith"
        case before = "Before"
        case after = "After"
    }







    /** The name of an output field from the data action's output to use for this condition */
    public var outputField: String?
    /** The operation with which to evaluate this condition */
    public var outputOperator: OutputOperator?
    /** The value to compare against for this condition */
    public var comparisonValue: String?
    /** If true, inverts the result of evaluating this Predicate. Default is false. */
    public var inverted: Bool?
    /** The result of this predicate if the requested output field is missing from the data action's result */
    public var outputFieldMissingResolution: Bool?

    public init(outputField: String?, outputOperator: OutputOperator?, comparisonValue: String?, inverted: Bool?, outputFieldMissingResolution: Bool?) {
        self.outputField = outputField
        self.outputOperator = outputOperator
        self.comparisonValue = comparisonValue
        self.inverted = inverted
        self.outputFieldMissingResolution = outputFieldMissingResolution
    }


}




public class DncList: Codable {















    public enum DncSourceType: String, Codable { 
        case rds = "rds"
        case rdsCustom = "rds_custom"
        case dncCom = "dnc.com"
        case gryphon = "gryphon"
    }

    public enum ContactMethod: String, Codable { 
        case email = "Email"
        case phone = "Phone"
        case any = "Any"
    }















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the DncList. */
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** The status of the import process */
    public var importStatus: ImportStatus?
    /** The total number of phone numbers in the DncList. */
    public var size: Int64?
    /** The type of the DncList. */
    public var dncSourceType: DncSourceType?
    /** The contact method. Required if dncSourceType is rds. */
    public var contactMethod: ContactMethod?
    /** A dnc.com loginId. Required if the dncSourceType is dnc.com. */
    public var loginId: String?
    /** A dnc.com campaignId. Optional if the dncSourceType is dnc.com. */
    public var campaignId: String?
    /** The list of dnc.com codes to be treated as DNC. Required if the dncSourceType is dnc.com. */
    public var dncCodes: [String]?
    /** A gryphon license number. Required if the dncSourceType is gryphon. */
    public var licenseId: String?
    /** The division this DncList belongs to. */
    public var division: DomainEntityRef?
    /** The column to evaluate exclusion against. Required if the dncSourceType is rds_custom. */
    public var customExclusionColumn: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, importStatus: ImportStatus?, size: Int64?, dncSourceType: DncSourceType?, contactMethod: ContactMethod?, loginId: String?, campaignId: String?, dncCodes: [String]?, licenseId: String?, division: DomainEntityRef?, customExclusionColumn: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.importStatus = importStatus
        self.size = size
        self.dncSourceType = dncSourceType
        self.contactMethod = contactMethod
        self.loginId = loginId
        self.campaignId = campaignId
        self.dncCodes = dncCodes
        self.licenseId = licenseId
        self.division = division
        self.customExclusionColumn = customExclusionColumn
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case importStatus
        case size
        case dncSourceType
        case contactMethod
        case loginId
        case campaignId
        case dncCodes
        case licenseId
        case division
        case customExclusionColumn
        case selfUri
    }


}




public class DncPatchCustomExclusionColumnsRequest: Codable {

    public enum Action: String, Codable { 
        case add = "Add"
        case remove = "Remove"
    }





    /** The action to perform */
    public var action: Action?
    /** The list of custom exclusion column entries to Add to / Remove from the DNC list  */
    public var customExclusionColumnEntries: [String]?
    /** Expiration date for DNC customExclusionColumnEntries in yyyy-MM-ddTHH:mmZ format */
    public var expirationDateTime: String?

    public init(action: Action?, customExclusionColumnEntries: [String]?, expirationDateTime: String?) {
        self.action = action
        self.customExclusionColumnEntries = customExclusionColumnEntries
        self.expirationDateTime = expirationDateTime
    }


}




public class DnclistImportStatusImportStatus: Codable {

    public enum ImportState: String, Codable { 
        case inProgress = "IN_PROGRESS"
        case failed = "FAILED"
    }















    /** current status of the import */
    public var importState: ImportState?
    /** total number of records to be imported */
    public var totalRecords: Int?
    /** number of records finished importing */
    public var completedRecords: Int?
    /** percentage of records finished importing */
    public var percentageComplete: Int?
    /** if the import has failed, the reason for the failure */
    public var failureReason: String?
    /** The ids for target contact lists */
    public var targetContactListIds: [String]?
    /** The prefix used for target contact list names */
    public var listNamePrefix: String?
    public var additionalProperties: [String:JSON]?

    public init(importState: ImportState?, totalRecords: Int?, completedRecords: Int?, percentageComplete: Int?, failureReason: String?, targetContactListIds: [String]?, listNamePrefix: String?, additionalProperties: [String:JSON]?) {
        self.importState = importState
        self.totalRecords = totalRecords
        self.completedRecords = completedRecords
        self.percentageComplete = percentageComplete
        self.failureReason = failureReason
        self.targetContactListIds = targetContactListIds
        self.listNamePrefix = listNamePrefix
        self.additionalProperties = additionalProperties
    }


}




public class DocumentArticle: Codable {







    /** The title of the Article. */
    public var title: String?
    /** The content of the Article. */
    public var content: ArticleContent?
    /** List of Alternative questions related to the title which helps in improving the likelihood of a match to user query. */
    public var alternatives: [String]?

    public init(title: String?, content: ArticleContent?, alternatives: [String]?) {
        self.title = title
        self.content = content
        self.alternatives = alternatives
    }


}




public class DocumentAttribute: Codable {





    public var attribute: Attribute?
    public var values: [String]?

    public init(attribute: Attribute?, values: [String]?) {
        self.attribute = attribute
        self.values = values
    }


}




public class DocumentBody: Codable {



    /** The list of building blocks for the document body. */
    public var blocks: [DocumentBodyBlock]?

    public init(blocks: [DocumentBodyBlock]?) {
        self.blocks = blocks
    }


}




public class DocumentBodyListItemProperties: Codable {



    public enum Align: String, Codable { 
        case center = "Center"
        case _left = "Left"
        case _right = "Right"
        case justify = "Justify"
    }



    public enum FontSize: String, Codable { 
        case xxSmall = "XxSmall"
        case xsmall = "XSmall"
        case small = "Small"
        case medium = "Medium"
        case large = "Large"
        case xlarge = "XLarge"
        case xxLarge = "XxLarge"
        case xxxLarge = "XxxLarge"
    }

    public enum FontType: String, Codable { 
        case paragraph = "Paragraph"
        case heading1 = "Heading1"
        case heading2 = "Heading2"
        case heading3 = "Heading3"
        case heading4 = "Heading4"
        case heading5 = "Heading5"
        case heading6 = "Heading6"
        case preformatted = "Preformatted"
    }



    public enum UnorderedType: String, Codable { 
        case normal = "Normal"
        case square = "Square"
        case circle = "Circle"
        case _none = "None"
    }

    public enum OrderedType: String, Codable { 
        case number = "Number"
        case lowerAlpha = "LowerAlpha"
        case lowerGreek = "LowerGreek"
        case lowerRoman = "LowerRoman"
        case upperAlpha = "UpperAlpha"
        case upperRoman = "UpperRoman"
        case _none = "None"
    }

    /** The background color for the list item. The valid values in hex color code representation. For example black color - #000000 */
    public var backgroundColor: String?
    /** The align type for the list item. */
    public var align: Align?
    /** The indentation property for the list item. The valid values in 'em'. */
    public var indentation: Float?
    /** The font size for the list item. The valid values in 'em'. */
    public var fontSize: FontSize?
    /** The font type for the list item. */
    public var fontType: FontType?
    /** The text color for the list item. The valid values in hex color code representation. For example black color - #000000 */
    public var textColor: String?
    /** The type of icon for the unordered list. */
    public var unorderedType: UnorderedType?
    /** The type of icon for the ordered list. */
    public var orderedType: OrderedType?

    public init(backgroundColor: String?, align: Align?, indentation: Float?, fontSize: FontSize?, fontType: FontType?, textColor: String?, unorderedType: UnorderedType?, orderedType: OrderedType?) {
        self.backgroundColor = backgroundColor
        self.align = align
        self.indentation = indentation
        self.fontSize = fontSize
        self.fontType = fontType
        self.textColor = textColor
        self.unorderedType = unorderedType
        self.orderedType = orderedType
    }


}




public class DocumentBodyTableCaptionItem: Codable {

    public enum ModelType: String, Codable { 
        case text = "Text"
        case paragraph = "Paragraph"
        case image = "Image"
        case video = "Video"
        case orderedList = "OrderedList"
        case unorderedList = "UnorderedList"
    }











    /** The type of the caption item. */
    public var type: ModelType?
    /** Text. It must contain a value if the type of the block is Text. */
    public var text: DocumentText?
    /** Paragraph. It must contain a value if the type of the block is Paragraph. */
    public var paragraph: DocumentBodyParagraph?
    /** Image. It must contain a value if the type of the block is Image. */
    public var image: DocumentBodyImage?
    /** Video. It must contain a value if the type of the block is Video. */
    public var video: DocumentBodyVideo?
    /** List. It must contain a value if the type of the block is UnorderedList or OrderedList. */
    public var list: DocumentBodyList?

    public init(type: ModelType?, text: DocumentText?, paragraph: DocumentBodyParagraph?, image: DocumentBodyImage?, video: DocumentBodyVideo?, list: DocumentBodyList?) {
        self.type = type
        self.text = text
        self.paragraph = paragraph
        self.image = image
        self.video = video
        self.list = list
    }


}




public class DocumentBodyTableRowBlockProperties: Codable {

    public enum RowType: String, Codable { 
        case header = "Header"
        case footer = "Footer"
        case body = "Body"
    }

    public enum Alignment: String, Codable { 
        case center = "Center"
        case _left = "Left"
        case _right = "Right"
    }



    public enum BorderStyle: String, Codable { 
        case solid = "Solid"
        case dotted = "Dotted"
        case dashed = "Dashed"
        case double = "Double"
        case groove = "Groove"
        case ridge = "Ridge"
        case inset = "Inset"
        case outset = "Outset"
        case hidden = "Hidden"
        case _none = "None"
    }





    /** The type of the table row. */
    public var rowType: RowType?
    /** The alignment for the table row. */
    public var alignment: Alignment?
    /** The height for the table row. */
    public var height: Float?
    /** The border style for the table row. */
    public var borderStyle: BorderStyle?
    /** The border color for the table row. For example black color - #000000 */
    public var borderColor: String?
    /** The background color for the table row. For example black color - #000000 */
    public var backgroundColor: String?

    public init(rowType: RowType?, alignment: Alignment?, height: Float?, borderStyle: BorderStyle?, borderColor: String?, backgroundColor: String?) {
        self.rowType = rowType
        self.alignment = alignment
        self.height = height
        self.borderStyle = borderStyle
        self.borderColor = borderColor
        self.backgroundColor = backgroundColor
    }


}




public class DocumentCategoryInput: Codable {



    /** KnowledgeBase Category ID */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class DocumentUpload: Codable {









    /** The name of the document */
    public var name: String?
    /** The workspace the document will be uploaded to */
    public var workspace: DomainEntityRef?
    public var tags: [String]?
    public var tagIds: [String]?

    public init(name: String?, workspace: DomainEntityRef?, tags: [String]?, tagIds: [String]?) {
        self.name = name
        self.workspace = workspace
        self.tags = tags
        self.tagIds = tagIds
    }


}




public class DocumentationResult: Codable {









































    /** The globally unique identifier for the object. */
    public var _id: Int?
    /** The category of the documentation entity. Will be returned in responses for certain entities. */
    public var categories: [Int]?
    /** The description of the documentation entity. Will be returned in responses for certain entities. */
    public var _description: String?
    /** The text or html content for the documentation entity. Will be returned in responses for certain entities. */
    public var content: String?
    /** The excerpt of the documentation entity. Will be returned in responses for certain entities. */
    public var excerpt: String?
    /** URL link for the documentation entity. Will be returned in responses for certain entities. */
    public var link: String?
    /** The modified date for the documentation entity. Will be returned in responses for certain entities. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modified: Date?
    /** The name of the documentation entity. Will be returned in responses for certain entities. */
    public var name: String?
    /** The service of the documentation entity. Will be returned in responses for certain entities. */
    public var service: [Int]?
    /** The slug of the documentation entity. Will be returned in responses for certain entities. */
    public var slug: String?
    /** The title of the documentation entity. Will be returned in responses for certain entities. */
    public var title: String?
    /** The search type. Will be returned in responses for certain entities. */
    public var getType: String?
    /** The facet feature of the documentation entity. Will be returned in responses for certain entities. */
    public var facetFeature: [Int]?
    /** The facet role of the documentation entity. Will be returned in responses for certain entities. */
    public var facetRole: [Int]?
    /** The facet service of the documentation entity. Will be returned in responses for certain entities. */
    public var facetService: [Int]?
    /** The faq categories of the documentation entity. Will be returned in responses for certain entities. */
    public var faqCategories: [Int]?
    /** The releasenote category of the documentation entity. Will be returned in responses for certain entities. */
    public var releasenoteCategory: [Int]?
    /** The releasenote tag of the documentation entity. Will be returned in responses for certain entities. */
    public var releasenoteTag: [Int]?
    /** The service area of the documentation entity. Will be returned in responses for certain entities. */
    public var serviceArea: [Int]?
    /** The video categories of the documentation entity. Will be returned in responses for certain entities. */
    public var videoCategories: [Int]?

    public init(_id: Int?, categories: [Int]?, _description: String?, content: String?, excerpt: String?, link: String?, modified: Date?, name: String?, service: [Int]?, slug: String?, title: String?, getType: String?, facetFeature: [Int]?, facetRole: [Int]?, facetService: [Int]?, faqCategories: [Int]?, releasenoteCategory: [Int]?, releasenoteTag: [Int]?, serviceArea: [Int]?, videoCategories: [Int]?) {
        self._id = _id
        self.categories = categories
        self._description = _description
        self.content = content
        self.excerpt = excerpt
        self.link = link
        self.modified = modified
        self.name = name
        self.service = service
        self.slug = slug
        self.title = title
        self.getType = getType
        self.facetFeature = facetFeature
        self.facetRole = facetRole
        self.facetService = facetService
        self.faqCategories = faqCategories
        self.releasenoteCategory = releasenoteCategory
        self.releasenoteTag = releasenoteTag
        self.serviceArea = serviceArea
        self.videoCategories = videoCategories
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case categories
        case _description = "description"
        case content
        case excerpt
        case link
        case modified
        case name
        case service
        case slug
        case title
        case getType = "get_type"
        case facetFeature = "facet_feature"
        case facetRole = "facet_role"
        case facetService = "facet_service"
        case faqCategories = "faq_categories"
        case releasenoteCategory = "releasenote_category"
        case releasenoteTag = "releasenote_tag"
        case serviceArea = "service-area"
        case videoCategories = "video_categories"
    }


}




public class DomainEntityListingEvaluationForm: Codable {





















    public var entities: [EvaluationForm]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [EvaluationForm]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class DomainPermissionPolicy: Codable {

















    public var domain: String?
    public var entityName: String?
    public var policyName: String?
    public var policyDescription: String?
    public var actionSet: [String]?
    public var namedResources: [String]?
    public var allowConditions: Bool?
    public var resourceConditionNode: DomainResourceConditionNode?

    public init(domain: String?, entityName: String?, policyName: String?, policyDescription: String?, actionSet: [String]?, namedResources: [String]?, allowConditions: Bool?, resourceConditionNode: DomainResourceConditionNode?) {
        self.domain = domain
        self.entityName = entityName
        self.policyName = policyName
        self.policyDescription = policyDescription
        self.actionSet = actionSet
        self.namedResources = namedResources
        self.allowConditions = allowConditions
        self.resourceConditionNode = resourceConditionNode
    }


}




public class DomainResourceConditionValue: Codable {







    public enum ModelType: String, Codable { 
        case scalar = "SCALAR"
        case variable = "VARIABLE"
        case user = "USER"
        case queue = "QUEUE"
    }

    public var user: User?
    public var queue: Queue?
    public var value: String?
    public var type: ModelType?

    public init(user: User?, queue: Queue?, value: String?, type: ModelType?) {
        self.user = user
        self.queue = queue
        self.value = value
        self.type = type
    }


}




public class DynamicContactQueueingSettings: Codable {



    /** Whether to sort contacts dynamically */
    public var sort: Bool?

    public init(sort: Bool?) {
        self.sort = sort
    }


}




public class EdgeChangeTopicEdge: Codable {



    public enum OnlineStatus: String, Codable { 
        case online = "ONLINE"
        case offline = "OFFLINE"
    }

    public var _id: String?
    public var onlineStatus: OnlineStatus?

    public init(_id: String?, onlineStatus: OnlineStatus?) {
        self._id = _id
        self.onlineStatus = onlineStatus
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case onlineStatus
    }


}




public class EdgeConnectionInfo: Codable {















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Interface used for the connection on the edge */
    public var interfaceName: String?
    /** IP address of the interface */
    public var interfaceIpAddress: String?
    /** Connection errors */
    public var connectionErrors: [String]?
    public var site: AddressableEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, interfaceName: String?, interfaceIpAddress: String?, connectionErrors: [String]?, site: AddressableEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.interfaceName = interfaceName
        self.interfaceIpAddress = interfaceIpAddress
        self.connectionErrors = connectionErrors
        self.site = site
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case interfaceName
        case interfaceIpAddress
        case connectionErrors
        case site
        case selfUri
    }


}




public class EdgeLogsJobUploadRequest: Codable {



    /** A list of file ids to upload. */
    public var fileIds: [String]?

    public init(fileIds: [String]?) {
        self.fileIds = fileIds
    }


}




public class EdgeMetricsTopicEdgeMetricMemory: Codable {







    public var type: String?
    public var availableBytes: Int?
    public var totalBytes: Int?

    public init(type: String?, availableBytes: Int?, totalBytes: Int?) {
        self.type = type
        self.availableBytes = availableBytes
        self.totalBytes = totalBytes
    }


}




public class EdgeTrunkBase: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }









    public enum TrunkType: String, Codable { 
        case external = "EXTERNAL"
        case phone = "PHONE"
        case edge = "EDGE"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** The meta-base this trunk is based on. */
    public var trunkMetabase: DomainEntityRef?
    public var properties: [String:JSON]?
    /** The type of this trunk base. */
    public var trunkType: TrunkType?
    /** Used to determine the media regions for inbound and outbound calls through a trunk. Also determines the dial plan to use for calls that came in on a trunk and have to be sent out on it as well. */
    public var site: DomainEntityRef?
    /** Allows a customer to set the site to which inbound calls will be routed */
    public var inboundSite: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, trunkMetabase: DomainEntityRef?, properties: [String:JSON]?, trunkType: TrunkType?, site: DomainEntityRef?, inboundSite: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.trunkMetabase = trunkMetabase
        self.properties = properties
        self.trunkType = trunkType
        self.site = site
        self.inboundSite = inboundSite
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case trunkMetabase
        case properties
        case trunkType
        case site
        case inboundSite
        case selfUri
    }


}




public class Education: Codable {











    public var school: String?
    public var fieldOfStudy: String?
    /** Notes about education has a 2000 character limit */
    public var notes: String?
    /** Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStart: Date?
    /** Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEnd: Date?

    public init(school: String?, fieldOfStudy: String?, notes: String?, dateStart: Date?, dateEnd: Date?) {
        self.school = school
        self.fieldOfStudy = fieldOfStudy
        self.notes = notes
        self.dateStart = dateStart
        self.dateEnd = dateEnd
    }


}




public class EmailCommunicationDispositionAppliedEvent: Codable {















    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication */
    public var communicationId: String?
    /** The wrapup-code (V4 UUID) used to disposition this interaction. If this value is not provided the disposition is considered skipped. */
    public var code: String?
    /** Text entered by the agent to describe the interaction or disposition. Ignored if the disposition is considered skipped. */
    public var notes: String?
    /** The list of tags selected by the agent to describe the interaction or disposition. Ignored if the disposition is considered skipped. */
    public var tags: [String]?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, code: String?, notes: String?, tags: [String]?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.code = code
        self.notes = notes
        self.tags = tags
    }


}




public class EmailHoldUpdatedEvent: Codable {











    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication */
    public var communicationId: String?
    /** Indicates whether this communication is held. */
    public var held: Bool?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, held: Bool?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.held = held
    }


}




public class EmailMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case parked = "parked"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case endpointDonotdisturb = "endpoint.donotdisturb"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferDonotdisturb = "transfer.donotdisturb"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
    }





































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }





















    /** The unique participant ID. */
    public var _id: String?
    /** The display friendly name of the participant. */
    public var name: String?
    /** The participant address. */
    public var address: String?
    /** The time when this participant first joined the conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startTime: Date?
    /** The time when this participant went connected for this media (eg: video connected time). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** The time when this participant went disconnected for this media (eg: video disconnected time). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?
    /** The time when this participant's hold started. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startHoldTime: Date?
    /** The participant's purpose.  Values can be: 'agent', 'user', 'customer', 'external', 'acd', 'ivr */
    public var purpose: String?
    /** The participant's state.  Values can be: 'alerting', 'connected', 'disconnected', 'dialing', 'contacting */
    public var state: State?
    /** The participant's direction.  Values can be: 'inbound' or 'outbound' */
    public var direction: Direction?
    /** The reason the participant was disconnected from the conversation. */
    public var disconnectType: DisconnectType?
    /** Value is true when the participant is on hold. */
    public var held: Bool?
    /** Value is true when the participant requires wrap-up. */
    public var wrapupRequired: Bool?
    /** The wrap-up prompt indicating the type of wrap-up to be performed. */
    public var wrapupPrompt: String?
    /** List of roles this participant's media has had on the conversation, ie monitor, coach, etc */
    public var mediaRoles: [String]?
    /** The PureCloud user for this participant. */
    public var user: DomainEntityRef?
    /** The PureCloud queue for this participant. */
    public var queue: DomainEntityRef?
    /** The PureCloud team for this participant. */
    public var team: DomainEntityRef?
    /** A list of ad-hoc attributes for the participant. */
    public var attributes: [String:String]?
    /** If the conversation ends in error, contains additional error details. */
    public var errorInfo: ErrorInfo?
    /** The Engage script that should be used by this participant. */
    public var script: DomainEntityRef?
    /** The amount of time the participant has to complete wrap-up. */
    public var wrapupTimeoutMs: Int?
    /** Value is true when the participant has skipped wrap-up. */
    public var wrapupSkipped: Bool?
    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutMs: Int?
    /** The source provider for the communication. */
    public var provider: String?
    /** If this participant represents an external contact, then this will be the reference for the external contact. */
    public var externalContact: DomainEntityRef?
    /** If this participant represents an external org, then this will be the reference for the external org. */
    public var externalOrganization: DomainEntityRef?
    /** Wrapup for this participant, if it has been applied. */
    public var wrapup: Wrapup?
    /** The peer communication corresponding to a matching leg for this communication. */
    public var peer: String?
    /** The reason specifying why participant flagged the conversation. */
    public var flaggedReason: FlaggedReason?
    /** Journey System data/context that is applicable to this communication.  When used for historical purposes, the context should be immutable.  When null, there is no applicable Journey System context. */
    public var journeyContext: JourneyContext?
    /** Information on how a communication should be routed to an agent. */
    public var conversationRoutingData: ConversationRoutingData?
    /** The timestamp when this participant started after-call work. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAcwTime: Date?
    /** The timestamp when this participant ended after-call work. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endAcwTime: Date?
    /** The subject of the email. */
    public var subject: String?
    /** The number of messages that have been sent in this email conversation. */
    public var messagesSent: Int?
    /** Indicates that the email was auto-generated like an Out of Office reply. */
    public var autoGenerated: Bool?
    /** A list of uploaded attachments on the email draft. */
    public var draftAttachments: [Attachment]?
    /** Indicates if the inbound email was marked as spam. */
    public var spam: Bool?
    /** A globally unique identifier for the stored content of this communication. */
    public var messageId: String?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, mediaRoles: [String]?, user: DomainEntityRef?, queue: DomainEntityRef?, team: DomainEntityRef?, attributes: [String:String]?, errorInfo: ErrorInfo?, script: DomainEntityRef?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, alertingTimeoutMs: Int?, provider: String?, externalContact: DomainEntityRef?, externalOrganization: DomainEntityRef?, wrapup: Wrapup?, peer: String?, flaggedReason: FlaggedReason?, journeyContext: JourneyContext?, conversationRoutingData: ConversationRoutingData?, startAcwTime: Date?, endAcwTime: Date?, subject: String?, messagesSent: Int?, autoGenerated: Bool?, draftAttachments: [Attachment]?, spam: Bool?, messageId: String?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.mediaRoles = mediaRoles
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.peer = peer
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.conversationRoutingData = conversationRoutingData
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.subject = subject
        self.messagesSent = messagesSent
        self.autoGenerated = autoGenerated
        self.draftAttachments = draftAttachments
        self.spam = spam
        self.messageId = messageId
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case mediaRoles
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalOrganization
        case wrapup
        case peer
        case flaggedReason
        case journeyContext
        case conversationRoutingData
        case startAcwTime
        case endAcwTime
        case subject
        case messagesSent
        case autoGenerated
        case draftAttachments
        case spam
        case messageId
    }


}




public class EmailRoutingEstablishedEvent: Codable {





















    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** A unique Id (V4 UUID) identifying this communication. */
    public var communicationId: String?
    /** The id of the queue that is routing this conversation. */
    public var queueId: String?
    /** The unique identifiers for the skills that should be used to determine the destination for the conversation. */
    public var skillIds: [String]?
    /** The unique identifier for the language that should be used to determine the destination for the conversation. */
    public var languageId: String?
    /** An optional label that categorizes the conversation. Max-utilization settings can be configured at a per-label level. */
    public var label: String?
    /** Metadata about this communication. */
    public var initialConfiguration: EmailInitialConfiguration?
    /** Metadata about the source of this communication's interaction. */
    public var sourceConfiguration: SourceConfiguration?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, communicationId: String?, queueId: String?, skillIds: [String]?, languageId: String?, label: String?, initialConfiguration: EmailInitialConfiguration?, sourceConfiguration: SourceConfiguration?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.queueId = queueId
        self.skillIds = skillIds
        self.languageId = languageId
        self.label = label
        self.initialConfiguration = initialConfiguration
        self.sourceConfiguration = sourceConfiguration
    }


}




public class EmailUserTransferEvent: Codable {







    public enum TransferType: String, Codable { 
        case attended = "Attended"
        case unattended = "Unattended"
    }











    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** Indicates the desired type of transfer. */
    public var transferType: TransferType?
    /** The id (V4 UUID) used by the external platform to refer to the transfer in subsequent Transfer events. */
    public var commandId: String?
    /** The id (V4 UUID) of the communication representing the participant that is initiating the transfer. */
    public var initiatingCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred away from. In many cases this will be the same as the `initiatingCommunicationId`. */
    public var targetCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred. */
    public var objectCommunicationId: String?
    /** The id (V4 UUID) of the desired destination user that the object communication should be transferred to. */
    public var destinationUserId: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, transferType: TransferType?, commandId: String?, initiatingCommunicationId: String?, targetCommunicationId: String?, objectCommunicationId: String?, destinationUserId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.transferType = transferType
        self.commandId = commandId
        self.initiatingCommunicationId = initiatingCommunicationId
        self.targetCommunicationId = targetCommunicationId
        self.objectCommunicationId = objectCommunicationId
        self.destinationUserId = destinationUserId
    }


}




public class EmbeddedIntegration: Codable {





    public var enableWhitelist: Bool?
    public var domainWhitelist: [String]?

    public init(enableWhitelist: Bool?, domainWhitelist: [String]?) {
        self.enableWhitelist = enableWhitelist
        self.domainWhitelist = domainWhitelist
    }


}




public class EncryptionKey: Codable {













    public enum KeyConfigurationType: String, Codable { 
        case kmsSymmetric = "KmsSymmetric"
        case localKeyManager = "LocalKeyManager"
        case native = "Native"
        case _none = "None"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** create date of the key pair. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createDate: Date?
    /** key data summary (base 64 encoded public key) */
    public var keydataSummary: String?
    /** user that requested generation of public key */
    public var user: User?
    /** Local configuration */
    public var localEncryptionConfiguration: LocalEncryptionConfiguration?
    /** Key type used in this configuration */
    public var keyConfigurationType: KeyConfigurationType?
    /** ARN of internal key to be wrapped by AWS KMS Symmetric key */
    public var kmsKeyArn: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, createDate: Date?, keydataSummary: String?, user: User?, localEncryptionConfiguration: LocalEncryptionConfiguration?, keyConfigurationType: KeyConfigurationType?, kmsKeyArn: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.createDate = createDate
        self.keydataSummary = keydataSummary
        self.user = user
        self.localEncryptionConfiguration = localEncryptionConfiguration
        self.keyConfigurationType = keyConfigurationType
        self.kmsKeyArn = kmsKeyArn
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case createDate
        case keydataSummary
        case user
        case localEncryptionConfiguration
        case keyConfigurationType
        case kmsKeyArn
        case selfUri
    }


}




public class EndConsultTransferEvent: Codable {







    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
    }


}




public class EntityChange: Codable {











    /** Id of the entity that was changed */
    public var entityId: String?
    /** Name of the entity that was changed */
    public var entityName: String?
    /** Type of the entity that was changed */
    public var entityType: String?
    /** Previous values for the entity. */
    public var oldValues: [String]?
    /** New values for the entity. */
    public var newValues: [String]?

    public init(entityId: String?, entityName: String?, entityType: String?, oldValues: [String]?, newValues: [String]?) {
        self.entityId = entityId
        self.entityName = entityName
        self.entityType = entityType
        self.oldValues = oldValues
        self.newValues = newValues
    }


}




public class EntityTypeCriteria: Codable {







    public enum Operator: String, Codable { 
        case containsall = "containsAll"
        case containsany = "containsAny"
        case notcontainsall = "notContainsAll"
        case notcontainsany = "notContainsAny"
        case equal = "equal"
        case notequal = "notEqual"
        case greaterthan = "greaterThan"
        case greaterthanorequal = "greaterThanOrEqual"
        case lessthan = "lessThan"
        case lessthanorequal = "lessThanOrEqual"
        case startswith = "startsWith"
        case endswith = "endsWith"
    }

    public enum EntityType: String, Codable { 
        case visit = "visit"
    }

    /** The criteria key. */
    public var key: String?
    /** The criteria values. */
    public var values: [String]?
    /** Should criteria be case insensitive. */
    public var shouldIgnoreCase: Bool?
    /** The comparison operator. */
    public var _operator: Operator?
    /** The entity to match the pattern against. */
    public var entityType: EntityType?

    public init(key: String?, values: [String]?, shouldIgnoreCase: Bool?, _operator: Operator?, entityType: EntityType?) {
        self.key = key
        self.values = values
        self.shouldIgnoreCase = shouldIgnoreCase
        self._operator = _operator
        self.entityType = entityType
    }

    public enum CodingKeys: String, CodingKey { 
        case key
        case values
        case shouldIgnoreCase
        case _operator = "operator"
        case entityType
    }


}




public class EstimateAvailableTimeOffResponse: Codable {











    /** Full day dates. partialDayDates must be empty if this field is populated */
    public var fullDayDates: [EstimateAvailableFullDayTimeOffResponse]?
    /** Partial day dates. fullDayDates must be empty if this field is populated */
    public var partialDayDates: [EstimateAvailablePartialDayTimeOffResponse]?
    /** The user to whom the time off request belongs */
    public var user: UserReference?
    /** The ID of the activity code associated with the time off request. Activity code must be of the TimeOff category */
    public var activityCodeId: String?
    /** Whether this estimate is for a paid time off request */
    public var paid: Bool?

    public init(fullDayDates: [EstimateAvailableFullDayTimeOffResponse]?, partialDayDates: [EstimateAvailablePartialDayTimeOffResponse]?, user: UserReference?, activityCodeId: String?, paid: Bool?) {
        self.fullDayDates = fullDayDates
        self.partialDayDates = partialDayDates
        self.user = user
        self.activityCodeId = activityCodeId
        self.paid = paid
    }


}




public class EvaluationAggregateQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [EvaluationAggregateQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [EvaluationAggregateQueryPredicate]?

    public init(type: ModelType?, clauses: [EvaluationAggregateQueryClause]?, predicates: [EvaluationAggregateQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class EvaluationCreateConversation: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class EvaluationCreateUser: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class EvaluationFormResponse: Codable {













    public enum WeightMode: String, Codable { 
        case scaled = "SCALED"
        case off = "OFF"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The evaluation form name */
    public var name: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    public var published: Bool?
    public var contextId: String?
    /** A list of question groups */
    public var questionGroups: [EvaluationQuestionGroup]?
    /** Mode for evaluation form weight */
    public var weightMode: WeightMode?
    /** A list of the published versions of this form. Not populated by default, its availability depends on the endpoint. Use the 'expand=publishHistory' query parameter to retrieve this data where applicable (refer to the endpoint description to see if it is applicable). */
    public var publishedVersions: DomainEntityListingEvaluationForm?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, modifiedDate: Date?, published: Bool?, contextId: String?, questionGroups: [EvaluationQuestionGroup]?, weightMode: WeightMode?, publishedVersions: DomainEntityListingEvaluationForm?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.modifiedDate = modifiedDate
        self.published = published
        self.contextId = contextId
        self.questionGroups = questionGroups
        self.weightMode = weightMode
        self.publishedVersions = publishedVersions
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case modifiedDate
        case published
        case contextId
        case questionGroups
        case weightMode
        case publishedVersions
        case selfUri
    }


}




public class EvaluationQualityV2TopicEvaluationReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class EvaluationQualityV2TopicEvaluationV2: Codable {



















    public enum Status: String, Codable { 
        case pending = "Pending"
        case inProgress = "InProgress"
        case finished = "Finished"
        case inReview = "InReview"
        case retracted = "Retracted"
    }







































    public enum PreviousStatus: String, Codable { 
        case pending = "Pending"
        case inProgress = "InProgress"
        case finished = "Finished"
        case inReview = "InReview"
        case retracted = "Retracted"
    }















    public var _id: String?
    public var conversationId: String?
    public var agent: EvaluationQualityV2TopicUser?
    public var evaluator: EvaluationQualityV2TopicUser?
    public var eventTime: Date?
    public var evaluationFormId: String?
    public var formName: String?
    public var scoringSet: EvaluationQualityV2TopicEvaluationScoringSet?
    public var contextId: String?
    public var status: Status?
    public var agentHasRead: Bool?
    public var releaseDate: Date?
    public var assignedDate: Date?
    public var changedDate: Date?
    public var eventType: String?
    public var resourceId: String?
    public var resourceType: String?
    public var divisionIds: [String]?
    public var rescore: Bool?
    public var conversationDate: Date?
    public var mediaType: [String]?
    public var calibration: EvaluationQualityV2TopicCalibration?
    public var evaluationSource: EvaluationQualityV2TopicEvaluationSource?
    public var assigneeUserId: String?
    public var previousAssigneeUserId: String?
    public var assigneeApplicable: Bool?
    public var evaluationContextId: String?
    public var disputeCount: Int?
    public var version: Int?
    public var previousStatus: PreviousStatus?
    public var declinedReview: Bool?
    public var retractedEvaluation: EvaluationQualityV2TopicEvaluationReference?
    public var rescoreCount: Int?
    public var evaluatorCommentHasUpdated: Bool?
    public var agentCommentHasUpdated: Bool?
    public var previousRescoreCount: Int?
    public var previousEvaluatorUserId: String?

    public init(_id: String?, conversationId: String?, agent: EvaluationQualityV2TopicUser?, evaluator: EvaluationQualityV2TopicUser?, eventTime: Date?, evaluationFormId: String?, formName: String?, scoringSet: EvaluationQualityV2TopicEvaluationScoringSet?, contextId: String?, status: Status?, agentHasRead: Bool?, releaseDate: Date?, assignedDate: Date?, changedDate: Date?, eventType: String?, resourceId: String?, resourceType: String?, divisionIds: [String]?, rescore: Bool?, conversationDate: Date?, mediaType: [String]?, calibration: EvaluationQualityV2TopicCalibration?, evaluationSource: EvaluationQualityV2TopicEvaluationSource?, assigneeUserId: String?, previousAssigneeUserId: String?, assigneeApplicable: Bool?, evaluationContextId: String?, disputeCount: Int?, version: Int?, previousStatus: PreviousStatus?, declinedReview: Bool?, retractedEvaluation: EvaluationQualityV2TopicEvaluationReference?, rescoreCount: Int?, evaluatorCommentHasUpdated: Bool?, agentCommentHasUpdated: Bool?, previousRescoreCount: Int?, previousEvaluatorUserId: String?) {
        self._id = _id
        self.conversationId = conversationId
        self.agent = agent
        self.evaluator = evaluator
        self.eventTime = eventTime
        self.evaluationFormId = evaluationFormId
        self.formName = formName
        self.scoringSet = scoringSet
        self.contextId = contextId
        self.status = status
        self.agentHasRead = agentHasRead
        self.releaseDate = releaseDate
        self.assignedDate = assignedDate
        self.changedDate = changedDate
        self.eventType = eventType
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.divisionIds = divisionIds
        self.rescore = rescore
        self.conversationDate = conversationDate
        self.mediaType = mediaType
        self.calibration = calibration
        self.evaluationSource = evaluationSource
        self.assigneeUserId = assigneeUserId
        self.previousAssigneeUserId = previousAssigneeUserId
        self.assigneeApplicable = assigneeApplicable
        self.evaluationContextId = evaluationContextId
        self.disputeCount = disputeCount
        self.version = version
        self.previousStatus = previousStatus
        self.declinedReview = declinedReview
        self.retractedEvaluation = retractedEvaluation
        self.rescoreCount = rescoreCount
        self.evaluatorCommentHasUpdated = evaluatorCommentHasUpdated
        self.agentCommentHasUpdated = agentCommentHasUpdated
        self.previousRescoreCount = previousRescoreCount
        self.previousEvaluatorUserId = previousEvaluatorUserId
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case conversationId
        case agent
        case evaluator
        case eventTime
        case evaluationFormId
        case formName
        case scoringSet
        case contextId
        case status
        case agentHasRead
        case releaseDate
        case assignedDate
        case changedDate
        case eventType
        case resourceId
        case resourceType
        case divisionIds
        case rescore
        case conversationDate
        case mediaType
        case calibration
        case evaluationSource
        case assigneeUserId
        case previousAssigneeUserId
        case assigneeApplicable
        case evaluationContextId
        case disputeCount
        case version
        case previousStatus
        case declinedReview
        case retractedEvaluation
        case rescoreCount
        case evaluatorCommentHasUpdated
        case agentCommentHasUpdated
        case previousRescoreCount
        case previousEvaluatorUserId
    }


}




public class EvaluationQuestion: Codable {







    public enum ModelType: String, Codable { 
        case multiplechoicequestion = "multipleChoiceQuestion"
        case freetextquestion = "freeTextQuestion"
        case npsquestion = "npsQuestion"
        case readonlytextblockquestion = "readOnlyTextBlockQuestion"
    }













    public var _id: String?
    public var text: String?
    public var helpText: String?
    public var type: ModelType?
    public var naEnabled: Bool?
    public var commentsRequired: Bool?
    public var visibilityCondition: VisibilityCondition?
    /** Options from which to choose an answer for this question. Only used by Multiple Choice type questions. */
    public var answerOptions: [AnswerOption]?
    public var isKill: Bool?
    public var isCritical: Bool?

    public init(_id: String?, text: String?, helpText: String?, type: ModelType?, naEnabled: Bool?, commentsRequired: Bool?, visibilityCondition: VisibilityCondition?, answerOptions: [AnswerOption]?, isKill: Bool?, isCritical: Bool?) {
        self._id = _id
        self.text = text
        self.helpText = helpText
        self.type = type
        self.naEnabled = naEnabled
        self.commentsRequired = commentsRequired
        self.visibilityCondition = visibilityCondition
        self.answerOptions = answerOptions
        self.isKill = isKill
        self.isCritical = isCritical
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case text
        case helpText
        case type
        case naEnabled
        case commentsRequired
        case visibilityCondition
        case answerOptions
        case isKill
        case isCritical
    }


}




public class EvaluationQuestionGroup: Codable {





















    public var _id: String?
    public var name: String?
    public var type: String?
    public var defaultAnswersToHighest: Bool?
    public var defaultAnswersToNA: Bool?
    public var naEnabled: Bool?
    public var weight: Float?
    public var manualWeight: Bool?
    public var questions: [EvaluationQuestion]?
    public var visibilityCondition: VisibilityCondition?

    public init(_id: String?, name: String?, type: String?, defaultAnswersToHighest: Bool?, defaultAnswersToNA: Bool?, naEnabled: Bool?, weight: Float?, manualWeight: Bool?, questions: [EvaluationQuestion]?, visibilityCondition: VisibilityCondition?) {
        self._id = _id
        self.name = name
        self.type = type
        self.defaultAnswersToHighest = defaultAnswersToHighest
        self.defaultAnswersToNA = defaultAnswersToNA
        self.naEnabled = naEnabled
        self.weight = weight
        self.manualWeight = manualWeight
        self.questions = questions
        self.visibilityCondition = visibilityCondition
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case type
        case defaultAnswersToHighest
        case defaultAnswersToNA
        case naEnabled
        case weight
        case manualWeight
        case questions
        case visibilityCondition
    }


}




public class EvaluationReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class EvaluatorActivityEntityListing: Codable {





















    public var entities: [EvaluatorActivity]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [EvaluatorActivity]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class EventCondition: Codable {





    public enum Operator: String, Codable { 
        case containsall = "containsAll"
        case containsany = "containsAny"
        case notcontainsall = "notContainsAll"
        case notcontainsany = "notContainsAny"
        case equal = "equal"
        case notequal = "notEqual"
        case greaterthan = "greaterThan"
        case greaterthanorequal = "greaterThanOrEqual"
        case lessthan = "lessThan"
        case lessthanorequal = "lessThanOrEqual"
        case startswith = "startsWith"
        case endswith = "endsWith"
    }

    public enum StreamType: String, Codable { 
        case web = "Web"
        case custom = "Custom"
        case conversation = "Conversation"
        case app = "App"
    }





    /** The event key. */
    public var key: String?
    /** The event values. */
    public var values: [String]?
    /** The comparison operator. */
    public var _operator: Operator?
    /** The stream type for which this condition can be satisfied. */
    public var streamType: StreamType?
    /** The session type for which this condition can be satisfied. */
    public var sessionType: String?
    /** The name of the event for which this condition can be satisfied. */
    public var eventName: String?

    public init(key: String?, values: [String]?, _operator: Operator?, streamType: StreamType?, sessionType: String?, eventName: String?) {
        self.key = key
        self.values = values
        self._operator = _operator
        self.streamType = streamType
        self.sessionType = sessionType
        self.eventName = eventName
    }

    public enum CodingKeys: String, CodingKey { 
        case key
        case values
        case _operator = "operator"
        case streamType
        case sessionType
        case eventName
    }


}




public class EventLog: Codable {











    public enum Level: String, Codable { 
        case info = "INFO"
        case warning = "WARNING"
        case error = "ERROR"
    }

    public enum Category: String, Codable { 
        case callback = "CALLBACK"
        case callRestriction = "CALL_RESTRICTION"
        case callRule = "CALL_RULE"
        case campaign = "CAMPAIGN"
        case campaignRule = "CAMPAIGN_RULE"
        case contact = "CONTACT"
        case contactListFilter = "CONTACT_LIST_FILTER"
        case digitalRule = "DIGITAL_RULE"
        case dncList = "DNC_LIST"
        case entityLimit = "ENTITY_LIMIT"
        case importError = "IMPORT_ERROR"
        case messageRestriction = "MESSAGE_RESTRICTION"
        case messagingCampaign = "MESSAGING_CAMPAIGN"
        case importTemplate = "IMPORT_TEMPLATE"
        case organizationConfiguration = "ORGANIZATION_CONFIGURATION"
        case schedule = "SCHEDULE"
        case messagingCampaignSchedule = "MESSAGING_CAMPAIGN_SCHEDULE"
        case emailCampaignSchedule = "EMAIL_CAMPAIGN_SCHEDULE"
    }







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var errorEntity: DomainEntityRef?
    public var relatedEntity: DomainEntityRef?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var timestamp: Date?
    public var level: Level?
    public var category: Category?
    public var correlationId: String?
    public var eventMessage: EventMessage?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, errorEntity: DomainEntityRef?, relatedEntity: DomainEntityRef?, timestamp: Date?, level: Level?, category: Category?, correlationId: String?, eventMessage: EventMessage?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.errorEntity = errorEntity
        self.relatedEntity = relatedEntity
        self.timestamp = timestamp
        self.level = level
        self.category = category
        self.correlationId = correlationId
        self.eventMessage = eventMessage
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case errorEntity
        case relatedEntity
        case timestamp
        case level
        case category
        case correlationId
        case eventMessage
        case selfUri
    }


}




public class ExpiredEdgeListing: Codable {



    public var entities: [DomainEntityRef]?

    public init(entities: [DomainEntityRef]?) {
        self.entities = entities
    }


}




public class ExtensionEntityListing: Codable {





















    public var entities: [Extension]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Extension]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ExtensionPoolEntityListing: Codable {





















    public var entities: [ExtensionPool]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ExtensionPool]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ExternalContactsContactChangedTopicExternalOrganization: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class ExternalContactsUnresolvedContactChangedTopicContact: Codable {







    public enum ModelType: String, Codable { 
        case ephemeral = "Ephemeral"
        case identified = "Identified"
        case curated = "Curated"
    }

















































    public var _id: String?
    public var division: ExternalContactsUnresolvedContactChangedTopicDivision?
    public var externalOrganization: ExternalContactsUnresolvedContactChangedTopicExternalOrganization?
    public var type: ModelType?
    public var firstName: String?
    public var middleName: String?
    public var lastName: String?
    public var salutation: String?
    public var title: String?
    public var workPhone: ExternalContactsUnresolvedContactChangedTopicPhoneNumber?
    public var cellPhone: ExternalContactsUnresolvedContactChangedTopicPhoneNumber?
    public var homePhone: ExternalContactsUnresolvedContactChangedTopicPhoneNumber?
    public var otherPhone: ExternalContactsUnresolvedContactChangedTopicPhoneNumber?
    public var workEmail: String?
    public var personalEmail: String?
    public var otherEmail: String?
    public var address: ExternalContactsUnresolvedContactChangedTopicContactAddress?
    public var surveyOptOut: Bool?
    public var externalSystemUrl: String?
    public var twitterId: ExternalContactsUnresolvedContactChangedTopicTwitterId?
    public var lineId: ExternalContactsUnresolvedContactChangedTopicLineId?
    public var whatsAppId: ExternalContactsUnresolvedContactChangedTopicWhatsAppId?
    public var facebookId: ExternalContactsUnresolvedContactChangedTopicFacebookId?
    public var instagramId: ExternalContactsUnresolvedContactChangedTopicInstagramId?
    public var schema: ExternalContactsUnresolvedContactChangedTopicDataSchema?
    public var customFields: [String:JSON]?
    public var createDate: Date?
    public var modifyDate: Date?

    public init(_id: String?, division: ExternalContactsUnresolvedContactChangedTopicDivision?, externalOrganization: ExternalContactsUnresolvedContactChangedTopicExternalOrganization?, type: ModelType?, firstName: String?, middleName: String?, lastName: String?, salutation: String?, title: String?, workPhone: ExternalContactsUnresolvedContactChangedTopicPhoneNumber?, cellPhone: ExternalContactsUnresolvedContactChangedTopicPhoneNumber?, homePhone: ExternalContactsUnresolvedContactChangedTopicPhoneNumber?, otherPhone: ExternalContactsUnresolvedContactChangedTopicPhoneNumber?, workEmail: String?, personalEmail: String?, otherEmail: String?, address: ExternalContactsUnresolvedContactChangedTopicContactAddress?, surveyOptOut: Bool?, externalSystemUrl: String?, twitterId: ExternalContactsUnresolvedContactChangedTopicTwitterId?, lineId: ExternalContactsUnresolvedContactChangedTopicLineId?, whatsAppId: ExternalContactsUnresolvedContactChangedTopicWhatsAppId?, facebookId: ExternalContactsUnresolvedContactChangedTopicFacebookId?, instagramId: ExternalContactsUnresolvedContactChangedTopicInstagramId?, schema: ExternalContactsUnresolvedContactChangedTopicDataSchema?, customFields: [String:JSON]?, createDate: Date?, modifyDate: Date?) {
        self._id = _id
        self.division = division
        self.externalOrganization = externalOrganization
        self.type = type
        self.firstName = firstName
        self.middleName = middleName
        self.lastName = lastName
        self.salutation = salutation
        self.title = title
        self.workPhone = workPhone
        self.cellPhone = cellPhone
        self.homePhone = homePhone
        self.otherPhone = otherPhone
        self.workEmail = workEmail
        self.personalEmail = personalEmail
        self.otherEmail = otherEmail
        self.address = address
        self.surveyOptOut = surveyOptOut
        self.externalSystemUrl = externalSystemUrl
        self.twitterId = twitterId
        self.lineId = lineId
        self.whatsAppId = whatsAppId
        self.facebookId = facebookId
        self.instagramId = instagramId
        self.schema = schema
        self.customFields = customFields
        self.createDate = createDate
        self.modifyDate = modifyDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case division
        case externalOrganization
        case type
        case firstName
        case middleName
        case lastName
        case salutation
        case title
        case workPhone
        case cellPhone
        case homePhone
        case otherPhone
        case workEmail
        case personalEmail
        case otherEmail
        case address
        case surveyOptOut
        case externalSystemUrl
        case twitterId
        case lineId
        case whatsAppId
        case facebookId
        case instagramId
        case schema
        case customFields
        case createDate
        case modifyDate
    }


}




public class ExternalContactsUnresolvedContactChangedTopicContactAddress: Codable {













    public var address1: String?
    public var address2: String?
    public var city: String?
    public var state: String?
    public var postalCode: String?
    public var countryCode: String?

    public init(address1: String?, address2: String?, city: String?, state: String?, postalCode: String?, countryCode: String?) {
        self.address1 = address1
        self.address2 = address2
        self.city = city
        self.state = state
        self.postalCode = postalCode
        self.countryCode = countryCode
    }


}




public class ExternalContactsUnresolvedContactChangedTopicDataSchema: Codable {





    public var _id: String?
    public var version: Int?

    public init(_id: String?, version: Int?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}




public class ExternalContactsUnresolvedContactChangedTopicWhatsAppId: Codable {





    public var phoneNumber: ExternalContactsUnresolvedContactChangedTopicPhoneNumber?
    public var displayName: String?

    public init(phoneNumber: ExternalContactsUnresolvedContactChangedTopicPhoneNumber?, displayName: String?) {
        self.phoneNumber = phoneNumber
        self.displayName = displayName
    }


}




public class ExternalMetricDataItem: Codable {













    public enum ModelType: String, Codable { 
        case total = "Total"
        case cumulative = "Cumulative"
    }

    /** The user ID. Must provide either userId or userEmail, but not both. */
    public var userId: String?
    /** The user main email used in user's GenesysCloud account. Must provide either userId or userEmail, but not both. */
    public var userEmail: String?
    /** The ID of the external metric definition */
    public var metricId: String?
    /** The date of the metric data. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateOccurred: Date?
    /** The value of the metric data. When value is null, the metric data will be deleted. */
    public var value: Double?
    /** The number of data points. The default value is 0 when type is Cumulative and the metric data already exists, otherwise 1. When total count reaches 0, the metric data will be deleted. */
    public var count: Int?
    /** The type of the metric data. The default value is Total. */
    public var type: ModelType?

    public init(userId: String?, userEmail: String?, metricId: String?, dateOccurred: Date?, value: Double?, count: Int?, type: ModelType?) {
        self.userId = userId
        self.userEmail = userEmail
        self.metricId = metricId
        self.dateOccurred = dateOccurred
        self.value = value
        self.count = count
        self.type = type
    }


}




public class ExternalOrganization: Codable {













































    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the company. */
    public var name: String?
    public var companyType: String?
    public var industry: String?
    public var primaryContactId: String?
    public var address: ContactAddress?
    public var phoneNumber: PhoneNumber?
    public var faxNumber: PhoneNumber?
    public var employeeCount: Int64?
    public var revenue: Int64?
    public var tags: [String]?
    public var websites: [String]?
    public var tickers: [Ticker]?
    public var twitterId: TwitterId?
    /** A string that identifies an external system-of-record resource that may have more detailed information on the organization. It should be a valid URL (including the http/https protocol, port, and path [if any]). The value is automatically trimmed of any leading and trailing whitespace. */
    public var externalSystemUrl: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifyDate: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createDate: Date?
    public var trustor: Trustor?
    /** The schema defining custom fields for this contact */
    public var schema: DataSchema?
    /** Custom fields defined in the schema referenced by schemaId and schemaVersion. */
    public var customFields: [String:JSON]?
    /** Links to the sources of data (e.g. one source might be a CRM) that contributed data to this record.  Read-only, and only populated when requested via expand param. */
    public var externalDataSources: [ExternalDataSource]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, companyType: String?, industry: String?, primaryContactId: String?, address: ContactAddress?, phoneNumber: PhoneNumber?, faxNumber: PhoneNumber?, employeeCount: Int64?, revenue: Int64?, tags: [String]?, websites: [String]?, tickers: [Ticker]?, twitterId: TwitterId?, externalSystemUrl: String?, modifyDate: Date?, createDate: Date?, trustor: Trustor?, schema: DataSchema?, customFields: [String:JSON]?, externalDataSources: [ExternalDataSource]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.companyType = companyType
        self.industry = industry
        self.primaryContactId = primaryContactId
        self.address = address
        self.phoneNumber = phoneNumber
        self.faxNumber = faxNumber
        self.employeeCount = employeeCount
        self.revenue = revenue
        self.tags = tags
        self.websites = websites
        self.tickers = tickers
        self.twitterId = twitterId
        self.externalSystemUrl = externalSystemUrl
        self.modifyDate = modifyDate
        self.createDate = createDate
        self.trustor = trustor
        self.schema = schema
        self.customFields = customFields
        self.externalDataSources = externalDataSources
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case companyType
        case industry
        case primaryContactId
        case address
        case phoneNumber
        case faxNumber
        case employeeCount
        case revenue
        case tags
        case websites
        case tickers
        case twitterId
        case externalSystemUrl
        case modifyDate
        case createDate
        case trustor
        case schema
        case customFields
        case externalDataSources
        case selfUri
    }


}




public class ExternalOrganizationListing: Codable {























    public var entities: [ExternalOrganization]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var partialResults: Bool?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ExternalOrganization]?, pageSize: Int?, pageNumber: Int?, total: Int64?, partialResults: Bool?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.partialResults = partialResults
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class FacetInfo: Codable {





    /** The name of the field that was faceted on. */
    public var name: String?
    /** The entries resulting from this facet. */
    public var entries: [Entry]?

    public init(name: String?, entries: [Entry]?) {
        self.name = name
        self.entries = entries
    }


}




public class FaxTopicFaxDataV2: Codable {



































    public var _id: String?
    public var name: String?
    public var dateCreated: Date?
    public var dateModified: Date?
    public var workspace: FaxTopicWorkspaceData?
    public var createdBy: FaxTopicUserData?
    public var contentType: String?
    public var contentLength: Int?
    public var filename: String?
    public var changeNumber: Int?
    public var dateUploaded: Date?
    public var uploadedBy: FaxTopicUserData?
    public var lockInfo: FaxTopicLockData?
    public var selfUri: String?
    public var callerAddress: String?
    public var receiverAddress: String?
    public var read: Bool?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, workspace: FaxTopicWorkspaceData?, createdBy: FaxTopicUserData?, contentType: String?, contentLength: Int?, filename: String?, changeNumber: Int?, dateUploaded: Date?, uploadedBy: FaxTopicUserData?, lockInfo: FaxTopicLockData?, selfUri: String?, callerAddress: String?, receiverAddress: String?, read: Bool?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.workspace = workspace
        self.createdBy = createdBy
        self.contentType = contentType
        self.contentLength = contentLength
        self.filename = filename
        self.changeNumber = changeNumber
        self.dateUploaded = dateUploaded
        self.uploadedBy = uploadedBy
        self.lockInfo = lockInfo
        self.selfUri = selfUri
        self.callerAddress = callerAddress
        self.receiverAddress = receiverAddress
        self.read = read
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case workspace
        case createdBy
        case contentType
        case contentLength
        case filename
        case changeNumber
        case dateUploaded
        case uploadedBy
        case lockInfo
        case selfUri
        case callerAddress
        case receiverAddress
        case read
    }


}




public class FaxTopicLockData: Codable {







    public var lockedBy: FaxTopicUserData?
    public var dateCreated: Date?
    public var dateExpires: Date?

    public init(lockedBy: FaxTopicUserData?, dateCreated: Date?, dateExpires: Date?) {
        self.lockedBy = lockedBy
        self.dateCreated = dateCreated
        self.dateExpires = dateExpires
    }


}




public class FaxTopicWorkspaceData: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class FeatureState: Codable {



    public var enabled: Bool?

    public init(enabled: Bool?) {
        self.enabled = enabled
    }


}




public class FileSpecificationTemplateEntityListing: Codable {





















    public var entities: [FileSpecificationTemplate]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [FileSpecificationTemplate]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class Filter: Codable {









    /** The name of the field by which to filter. */
    public var name: String?
    /** The type of the filter, DATE or STRING. */
    public var type: String?
    /** The operation that the filter performs. */
    public var _operator: String?
    /** The values to make the filter comparison against. */
    public var values: [String]?

    public init(name: String?, type: String?, _operator: String?, values: [String]?) {
        self.name = name
        self.type = type
        self._operator = _operator
        self.values = values
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case type
        case _operator = "operator"
        case values
    }


}




public class FilterPreviewResponse: Codable {







    public var filteredContacts: Int64?
    public var totalContacts: Int64?
    public var preview: [DialerContact]?

    public init(filteredContacts: Int64?, totalContacts: Int64?, preview: [DialerContact]?) {
        self.filteredContacts = filteredContacts
        self.totalContacts = totalContacts
        self.preview = preview
    }


}




public class FlowAggregateQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [FlowAggregateQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [FlowAggregateQueryPredicate]?

    public init(type: ModelType?, clauses: [FlowAggregateQueryClause]?, predicates: [FlowAggregateQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}



/** Parameters for launching a flow. */

public class FlowExecutionLaunchRequest: Codable {









    /** ID of the flow to launch. */
    public var flowId: String?
    /** The version of the flow to launch. Omit this value (or supply null/empty) to use the latest published version. */
    public var flowVersion: String?
    /** Input values to the flow. Valid values are defined by a flow's input JSON schema. */
    public var inputData: [String:JSON]?
    /** A displayable name to assign to the new flow execution */
    public var name: String?

    public init(flowId: String?, flowVersion: String?, inputData: [String:JSON]?, name: String?) {
        self.flowId = flowId
        self.flowVersion = flowVersion
        self.inputData = inputData
        self.name = name
    }


}




public class FlowHealthErrorInfo: Codable {









    public var message: String?
    public var code: String?
    /** Error message with params included. */
    public var messageWithParams: String?
    /** Map of variables and params for the error message. */
    public var messageParams: [String:JSON]?

    public init(message: String?, code: String?, messageWithParams: String?, messageParams: [String:JSON]?) {
        self.message = message
        self.code = code
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
    }


}




public class FlowHealthVersionInfo: Codable {





    /** Given flow's Version Info. */
    public var flowVersion: AddressableEntityRef?
    /** NLU Domain Info for this flow version. */
    public var nluDomain: AddressableEntityRef?

    public init(flowVersion: AddressableEntityRef?, nluDomain: AddressableEntityRef?) {
        self.flowVersion = flowVersion
        self.nluDomain = nluDomain
    }


}




public class FlowObservationQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case flowid = "flowId"
        case mediatype = "mediaType"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension predicates */
    public var value: String?
    /** Right hand side for dimension predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case _operator = "operator"
        case value
        case range
    }


}




public class FlowOutcomeDetailEventTopicFlowOutcomeEvent: Codable {









    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
    }



    public enum Direction: String, Codable { 
        case unknown = "UNKNOWN"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }











    public enum MessageType: String, Codable { 
        case unknown = "UNKNOWN"
        case sms = "SMS"
        case twitter = "TWITTER"
        case facebook = "FACEBOOK"
        case line = "LINE"
        case whatsapp = "WHATSAPP"
        case webmessaging = "WEBMESSAGING"
        case _open = "OPEN"
        case instagram = "INSTAGRAM"
    }

    public enum FlowType: String, Codable { 
        case unknown = "UNKNOWN"
        case inboundcall = "INBOUNDCALL"
        case outboundcall = "OUTBOUNDCALL"
        case inqueuecall = "INQUEUECALL"
        case securecall = "SECURECALL"
        case inboundemail = "INBOUNDEMAIL"
        case surveyinvite = "SURVEYINVITE"
        case inboundshortmessage = "INBOUNDSHORTMESSAGE"
        case inboundchat = "INBOUNDCHAT"
        case workflow = "WORKFLOW"
        case bot = "BOT"
        case digitalbot = "DIGITALBOT"
        case commonmodule = "COMMONMODULE"
        case inqueueemail = "INQUEUEEMAIL"
        case inqueueshortmessage = "INQUEUESHORTMESSAGE"
        case voice = "VOICE"
        case voicemail = "VOICEMAIL"
        case workitem = "WORKITEM"
    }













    public enum FlowOutcomeValue: String, Codable { 
        case unknown = "UNKNOWN"
        case success = "SUCCESS"
        case failure = "FAILURE"
    }







    public var eventTime: Int?
    public var conversationId: String?
    public var participantId: String?
    public var sessionId: String?
    public var mediaType: MediaType?
    public var provider: String?
    public var direction: Direction?
    public var ani: String?
    public var dnis: String?
    public var addressTo: String?
    public var addressFrom: String?
    public var subject: String?
    public var messageType: MessageType?
    public var flowType: FlowType?
    public var flowId: String?
    public var divisionId: String?
    public var flowVersion: String?
    public var flowOutcomeId: String?
    public var flowOutcomeStartTime: Int?
    public var flowOutcomeEndTime: Int?
    public var flowOutcomeValue: FlowOutcomeValue?
    public var flowMilestones: [FlowOutcomeDetailEventTopicFlowMilestone]?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?

    public init(eventTime: Int?, conversationId: String?, participantId: String?, sessionId: String?, mediaType: MediaType?, provider: String?, direction: Direction?, ani: String?, dnis: String?, addressTo: String?, addressFrom: String?, subject: String?, messageType: MessageType?, flowType: FlowType?, flowId: String?, divisionId: String?, flowVersion: String?, flowOutcomeId: String?, flowOutcomeStartTime: Int?, flowOutcomeEndTime: Int?, flowOutcomeValue: FlowOutcomeValue?, flowMilestones: [FlowOutcomeDetailEventTopicFlowMilestone]?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.sessionId = sessionId
        self.mediaType = mediaType
        self.provider = provider
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.addressTo = addressTo
        self.addressFrom = addressFrom
        self.subject = subject
        self.messageType = messageType
        self.flowType = flowType
        self.flowId = flowId
        self.divisionId = divisionId
        self.flowVersion = flowVersion
        self.flowOutcomeId = flowOutcomeId
        self.flowOutcomeStartTime = flowOutcomeStartTime
        self.flowOutcomeEndTime = flowOutcomeEndTime
        self.flowOutcomeValue = flowOutcomeValue
        self.flowMilestones = flowMilestones
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
    }


}




public class FlowResultEntityListing: Codable {





















    public var entities: [FlowExecutionDataQueryResult]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [FlowExecutionDataQueryResult]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ForecastPlanningGroupData: Codable {







    /** The ID of the planning group to which this data applies. Note this is a snapshot of the planning group at the time of forecast creation and may not correspond to the current configuration */
    public var planningGroupId: String?
    /** Forecast offered counts per 15 minute interval for this week of the forecast */
    public var offeredPerInterval: [Double]?
    /** Forecast average handle time per 15 minute interval in seconds */
    public var averageHandleTimeSecondsPerInterval: [Double]?

    public init(planningGroupId: String?, offeredPerInterval: [Double]?, averageHandleTimeSecondsPerInterval: [Double]?) {
        self.planningGroupId = planningGroupId
        self.offeredPerInterval = offeredPerInterval
        self.averageHandleTimeSecondsPerInterval = averageHandleTimeSecondsPerInterval
    }


}




public class ForecastServiceGoalTemplateImpactOverrideResponse: Codable {







    /** Allowed service level percent increase and decrease; undefined if the goal is not enabled */
    public var serviceLevel: WfmServiceGoalImpact?
    /** Allowed average speed of answer percent increase and decrease; undefined if the goal is not enabled */
    public var averageSpeedOfAnswer: WfmServiceGoalImpact?
    /** Allowed abandon rate percent increase and decrease; undefined if the goal is not enabled */
    public var abandonRate: WfmServiceGoalImpact?

    public init(serviceLevel: WfmServiceGoalImpact?, averageSpeedOfAnswer: WfmServiceGoalImpact?, abandonRate: WfmServiceGoalImpact?) {
        self.serviceLevel = serviceLevel
        self.averageSpeedOfAnswer = averageSpeedOfAnswer
        self.abandonRate = abandonRate
    }


}



/** Details about a forms tracking event trigger */

public class FormsTrackTrigger: Codable {









    /** Form element that triggers the form submitted or abandoned event. */
    public var selector: String?
    /** Prefix for the form submitted or abandoned event name. */
    public var formName: String?
    /** Whether to capture the form data in the form abandoned event. */
    public var captureDataOnFormAbandon: Bool?
    /** Whether to capture the form data in the form submitted event. */
    public var captureDataOnFormSubmit: Bool?

    public init(selector: String?, formName: String?, captureDataOnFormAbandon: Bool?, captureDataOnFormSubmit: Bool?) {
        self.selector = selector
        self.formName = formName
        self.captureDataOnFormAbandon = captureDataOnFormAbandon
        self.captureDataOnFormSubmit = captureDataOnFormSubmit
    }


}




public class GDPRJourneyCustomer: Codable {





    /** The type of the customerId within the Journey System (e.g. cookie). Required if `id` is defined. */
    public var type: String?
    /** An ID of a customer within the Journey System at a point-in-time. Required if `type` is defined. */
    public var _id: String?

    public init(type: String?, _id: String?) {
        self.type = type
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case _id = "id"
    }


}




public class GKNDocumentationSearchResponse: Codable {



















    /** The total number of results found */
    public var total: Int64?
    /** The total number of pages */
    public var pageCount: Int?
    /** The current page size */
    public var pageSize: Int?
    /** The current page number */
    public var pageNumber: Int?
    /** Q64 value for the previous page of results */
    public var previousPage: String?
    /** Q64 value for the current page of results */
    public var currentPage: String?
    /** Q64 value for the next page of results */
    public var nextPage: String?
    /** Resource types the search was performed against */
    public var types: [String]?
    /** Search results */
    public var results: [GKNDocumentationResult]?

    public init(total: Int64?, pageCount: Int?, pageSize: Int?, pageNumber: Int?, previousPage: String?, currentPage: String?, nextPage: String?, types: [String]?, results: [GKNDocumentationResult]?) {
        self.total = total
        self.pageCount = pageCount
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.previousPage = previousPage
        self.currentPage = currentPage
        self.nextPage = nextPage
        self.types = types
        self.results = results
    }


}




public class GenericTemplate: Codable {











    /** Text to show in the title. */
    public var title: String?
    /** Text to show in the description. */
    public var _description: String?
    /** URL of an image. */
    public var url: String?
    /** List of button components offered with this message content. */
    public var components: [RecordingButtonComponent]?
    /** Actions to be taken. */
    public var actions: RecordingContentActions?

    public init(title: String?, _description: String?, url: String?, components: [RecordingButtonComponent]?, actions: RecordingContentActions?) {
        self.title = title
        self._description = _description
        self.url = url
        self.components = components
        self.actions = actions
    }

    public enum CodingKeys: String, CodingKey { 
        case title
        case _description = "description"
        case url
        case components
        case actions
    }


}




public class GeolocationEventGeolocation: Codable {











    public var userId: String?
    public var type: String?
    public var country: String?
    public var region: String?
    public var city: String?

    public init(userId: String?, type: String?, country: String?, region: String?, city: String?) {
        self.userId = userId
        self.type = type
        self.country = country
        self.region = region
        self.city = city
    }


}




public class GeolocationSettings: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var enabled: Bool?
    public var mapboxKey: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, enabled: Bool?, mapboxKey: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.enabled = enabled
        self.mapboxKey = mapboxKey
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case enabled
        case mapboxKey
        case selfUri
    }


}



/** This is a list of executionData links that can be used to download the complete executionData */

public class GetFlowExecutionDataJobResult: Codable {







    public enum JobState: String, Codable { 
        case registered = "Registered"
        case running = "Running"
        case success = "Success"
        case failed = "Failed"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** On jobState = Success this field will be populated with the list of results of files for download. */
    public var entities: [ExecutionDataEntity]?
    /** The state of the backend process to prep the files for download. */
    public var jobState: JobState?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, entities: [ExecutionDataEntity]?, jobState: JobState?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.entities = entities
        self.jobState = jobState
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case entities
        case jobState
        case selfUri
    }


}




public class GreetingOwner: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}




public class GroupGreetingEventGreetingOwner: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class HealthInfo: Codable {

    public enum Status: String, Codable { 
        case inProgress = "InProgress"
        case completed = "Completed"
        case error = "Error"
    }







    public enum StaticValidationResults: String, Codable { 
        case tooFewUtterances = "TooFewUtterances"
        case tooManyUtterances = "TooManyUtterances"
        case utteranceTooShort = "UtteranceTooShort"
        case utteranceTooLong = "UtteranceTooLong"
    }



    /** Status of health computation for this intent. */
    public var status: Status?
    /** Error details for the intent, if any. */
    public var errorInfo: FlowHealthErrorInfo?
    /** Overall health score for the intent ranged between 0 and 100 as 100 is the perfect health score. */
    public var overallScore: Float?
    /** Number of issues found in the intent. */
    public var issueCount: Int64?
    /** Validation results for the intent. */
    public var staticValidationResults: [StaticValidationResults]?
    /** Utterances for this intent. */
    public var utterances: [FlowHealthIntentUtterance]?

    public init(status: Status?, errorInfo: FlowHealthErrorInfo?, overallScore: Float?, issueCount: Int64?, staticValidationResults: [StaticValidationResults]?, utterances: [FlowHealthIntentUtterance]?) {
        self.status = status
        self.errorInfo = errorInfo
        self.overallScore = overallScore
        self.issueCount = issueCount
        self.staticValidationResults = staticValidationResults
        self.utterances = utterances
    }


}




public class HistoricalAdherenceActuals: Codable {

    public enum ActualActivityCategory: String, Codable { 
        case onQueueWork = "OnQueueWork"
        case _break = "Break"
        case meal = "Meal"
        case meeting = "Meeting"
        case offQueueWork = "OffQueueWork"
        case timeOff = "TimeOff"
        case training = "Training"
        case unavailable = "Unavailable"
        case unscheduled = "Unscheduled"
    }







    /** Activity in which the user is actually engaged */
    public var actualActivityCategory: ActualActivityCategory?
    /** The lookup ID used to retrieve the actual secondary status from map of lookup ID to corresponding secondary presence ID */
    public var actualSecondaryPresenceLookupId: String?
    /** Actual start offset in seconds relative to query start time */
    public var startOffsetSeconds: Int?
    /** Actual end offset in seconds relative to query start time */
    public var endOffsetSeconds: Int?

    public init(actualActivityCategory: ActualActivityCategory?, actualSecondaryPresenceLookupId: String?, startOffsetSeconds: Int?, endOffsetSeconds: Int?) {
        self.actualActivityCategory = actualActivityCategory
        self.actualSecondaryPresenceLookupId = actualSecondaryPresenceLookupId
        self.startOffsetSeconds = startOffsetSeconds
        self.endOffsetSeconds = endOffsetSeconds
    }


}




public class HistoryEntry: Codable {

    public enum Action: String, Codable { 
        case checkin = "CHECKIN"
        case checkout = "CHECKOUT"
        case create = "CREATE"
        case deactivate = "DEACTIVATE"
        case debug = "DEBUG"
        case delete = "DELETE"
        case publish = "PUBLISH"
        case revert = "REVERT"
        case save = "SAVE"
        case transcode = "TRANSCODE"
        case update = "UPDATE"
        case upload = "UPLOAD"
    }













    /** The action performed */
    public var action: Action?
    /** For actions performed not on the item itself, but on a sub-item, this field identifies the sub-item by name.  For example, for actions performed on prompt resources, this will be the prompt resource name. */
    public var resource: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var timestamp: Date?
    /** User associated with this entry. */
    public var user: User?
    /** OAuth client associated with this entry. */
    public var client: DomainEntityRef?
    public var version: String?
    public var secure: Bool?

    public init(action: Action?, resource: String?, timestamp: Date?, user: User?, client: DomainEntityRef?, version: String?, secure: Bool?) {
        self.action = action
        self.resource = resource
        self.timestamp = timestamp
        self.user = user
        self.client = client
        self.version = version
        self.secure = secure
    }


}




public class HistoryListing: Codable {

















    public enum ActionName: String, Codable { 
        case create = "CREATE"
        case checkin = "CHECKIN"
        case checkout = "CHECKOUT"
        case debug = "DEBUG"
        case delete = "DELETE"
        case history = "HISTORY"
        case publish = "PUBLISH"
        case revert = "REVERT"
        case save = "SAVE"
        case stateChange = "STATE_CHANGE"
        case update = "UPDATE"
        case validate = "VALIDATE"
    }

    public enum ActionStatus: String, Codable { 
        case locked = "LOCKED"
        case unlocked = "UNLOCKED"
        case started = "STARTED"
        case pendingGeneration = "PENDING_GENERATION"
        case pendingBackendNotification = "PENDING_BACKEND_NOTIFICATION"
        case success = "SUCCESS"
        case failure = "FAILURE"
    }





















    public var _id: String?
    public var complete: Bool?
    public var user: User?
    public var client: DomainEntityRef?
    public var errorMessage: String?
    public var errorCode: String?
    public var errorDetails: [Detail]?
    public var errorMessageParams: [String:String]?
    /** Action name */
    public var actionName: ActionName?
    /** Action status */
    public var actionStatus: ActionStatus?
    public var name: String?
    public var _description: String?
    public var system: Bool?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var started: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var completed: Date?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var entities: [HistoryEntry]?
    public var pageCount: Int?

    public init(_id: String?, complete: Bool?, user: User?, client: DomainEntityRef?, errorMessage: String?, errorCode: String?, errorDetails: [Detail]?, errorMessageParams: [String:String]?, actionName: ActionName?, actionStatus: ActionStatus?, name: String?, _description: String?, system: Bool?, started: Date?, completed: Date?, pageSize: Int?, pageNumber: Int?, total: Int64?, entities: [HistoryEntry]?, pageCount: Int?) {
        self._id = _id
        self.complete = complete
        self.user = user
        self.client = client
        self.errorMessage = errorMessage
        self.errorCode = errorCode
        self.errorDetails = errorDetails
        self.errorMessageParams = errorMessageParams
        self.actionName = actionName
        self.actionStatus = actionStatus
        self.name = name
        self._description = _description
        self.system = system
        self.started = started
        self.completed = completed
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.entities = entities
        self.pageCount = pageCount
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case complete
        case user
        case client
        case errorMessage
        case errorCode
        case errorDetails
        case errorMessageParams
        case actionName
        case actionStatus
        case name
        case _description = "description"
        case system
        case started
        case completed
        case pageSize
        case pageNumber
        case total
        case entities
        case pageCount
    }


}




public class HomerRecord: Codable {







































































































    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** metadata associated to the SIP calls. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var date: Date?
    /** metadata associated to the SIP calls */
    public var milliTs: String?
    /** metadata associated to the SIP calls */
    public var microTs: String?
    /** metadata associated to the SIP calls */
    public var method: String?
    /** metadata associated to the SIP calls */
    public var replyReason: String?
    /** metadata associated to the SIP calls */
    public var ruri: String?
    /** metadata associated to the SIP calls */
    public var ruriUser: String?
    /** metadata associated to the SIP calls */
    public var ruriDomain: String?
    /** metadata associated to the SIP calls */
    public var fromUser: String?
    /** metadata associated to the SIP calls */
    public var fromDomain: String?
    /** metadata associated to the SIP calls */
    public var fromTag: String?
    /** metadata associated to the SIP calls */
    public var toUser: String?
    /** metadata associated to the SIP calls */
    public var toDomain: String?
    /** metadata associated to the SIP calls */
    public var toTag: String?
    /** metadata associated to the SIP calls */
    public var pidUser: String?
    /** metadata associated to the SIP calls */
    public var contactUser: String?
    /** metadata associated to the SIP calls */
    public var authUser: String?
    /** metadata associated to the SIP calls */
    public var callid: String?
    /** metadata associated to the SIP calls */
    public var callidAleg: String?
    /** metadata associated to the SIP calls */
    public var via1: String?
    /** metadata associated to the SIP calls */
    public var via1Branch: String?
    /** metadata associated to the SIP calls */
    public var cseq: String?
    /** metadata associated to the SIP calls */
    public var diversion: String?
    /** metadata associated to the SIP calls */
    public var reason: String?
    /** metadata associated to the SIP calls */
    public var contentType: String?
    /** metadata associated to the SIP calls */
    public var auth: String?
    /** metadata associated to the SIP calls */
    public var userAgent: String?
    /** metadata associated to the SIP calls */
    public var sourceIp: String?
    /** metadata associated to the SIP calls */
    public var sourcePort: String?
    /** metadata associated to the SIP calls */
    public var destinationIp: String?
    /** metadata associated to the SIP calls */
    public var destinationPort: String?
    /** metadata associated to the SIP calls */
    public var contactIp: String?
    /** metadata associated to the SIP calls */
    public var contactPort: String?
    /** metadata associated to the SIP calls */
    public var originatorIp: String?
    /** metadata associated to the SIP calls */
    public var originatorPort: String?
    /** metadata associated to the SIP calls */
    public var correlationId: String?
    /** metadata associated to the SIP calls */
    public var proto: String?
    /** metadata associated to the SIP calls */
    public var family: String?
    /** metadata associated to the SIP calls */
    public var rtpStat: String?
    /** metadata associated to the SIP calls */
    public var type: String?
    /** metadata associated to the SIP calls */
    public var node: String?
    /** metadata associated to the SIP calls */
    public var trans: String?
    /** metadata associated to the SIP calls */
    public var dbnode: String?
    /** metadata associated to the SIP calls */
    public var msg: String?
    /** metadata associated to the SIP calls */
    public var sourceAlias: String?
    /** metadata associated to the SIP calls */
    public var destinationAlias: String?
    /** metadata associated to the SIP calls */
    public var conversationId: String?
    /** metadata associated to the SIP calls */
    public var participantId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, date: Date?, milliTs: String?, microTs: String?, method: String?, replyReason: String?, ruri: String?, ruriUser: String?, ruriDomain: String?, fromUser: String?, fromDomain: String?, fromTag: String?, toUser: String?, toDomain: String?, toTag: String?, pidUser: String?, contactUser: String?, authUser: String?, callid: String?, callidAleg: String?, via1: String?, via1Branch: String?, cseq: String?, diversion: String?, reason: String?, contentType: String?, auth: String?, userAgent: String?, sourceIp: String?, sourcePort: String?, destinationIp: String?, destinationPort: String?, contactIp: String?, contactPort: String?, originatorIp: String?, originatorPort: String?, correlationId: String?, proto: String?, family: String?, rtpStat: String?, type: String?, node: String?, trans: String?, dbnode: String?, msg: String?, sourceAlias: String?, destinationAlias: String?, conversationId: String?, participantId: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.date = date
        self.milliTs = milliTs
        self.microTs = microTs
        self.method = method
        self.replyReason = replyReason
        self.ruri = ruri
        self.ruriUser = ruriUser
        self.ruriDomain = ruriDomain
        self.fromUser = fromUser
        self.fromDomain = fromDomain
        self.fromTag = fromTag
        self.toUser = toUser
        self.toDomain = toDomain
        self.toTag = toTag
        self.pidUser = pidUser
        self.contactUser = contactUser
        self.authUser = authUser
        self.callid = callid
        self.callidAleg = callidAleg
        self.via1 = via1
        self.via1Branch = via1Branch
        self.cseq = cseq
        self.diversion = diversion
        self.reason = reason
        self.contentType = contentType
        self.auth = auth
        self.userAgent = userAgent
        self.sourceIp = sourceIp
        self.sourcePort = sourcePort
        self.destinationIp = destinationIp
        self.destinationPort = destinationPort
        self.contactIp = contactIp
        self.contactPort = contactPort
        self.originatorIp = originatorIp
        self.originatorPort = originatorPort
        self.correlationId = correlationId
        self.proto = proto
        self.family = family
        self.rtpStat = rtpStat
        self.type = type
        self.node = node
        self.trans = trans
        self.dbnode = dbnode
        self.msg = msg
        self.sourceAlias = sourceAlias
        self.destinationAlias = destinationAlias
        self.conversationId = conversationId
        self.participantId = participantId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case date
        case milliTs
        case microTs
        case method
        case replyReason
        case ruri
        case ruriUser
        case ruriDomain
        case fromUser
        case fromDomain
        case fromTag
        case toUser
        case toDomain
        case toTag
        case pidUser
        case contactUser
        case authUser
        case callid
        case callidAleg
        case via1
        case via1Branch
        case cseq
        case diversion
        case reason
        case contentType
        case auth
        case userAgent
        case sourceIp
        case sourcePort
        case destinationIp
        case destinationPort
        case contactIp
        case contactPort
        case originatorIp
        case originatorPort
        case correlationId
        case proto
        case family
        case rtpStat
        case type
        case node
        case trans
        case dbnode
        case msg
        case sourceAlias
        case destinationAlias
        case conversationId
        case participantId
        case selfUri
    }


}



/** An ivr. */

public class IVRDivisionView: Codable {









    /** The ivr identifier */
    public var _id: String?
    /** The ivr name */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case selfUri
    }


}




public class ImportScheduleUploadSchema: Codable {













    /** The description for the imported schedule */
    public var _description: String?
    /** The number of weeks the imported schedule will cover */
    public var weekCount: Int?
    /** Whether the imported schedule should be immediately published */
    public var published: Bool?
    /** The short term forecast to associate with the imported schedule */
    public var shortTermForecast: BuShortTermForecastReference?
    /** The headcount forecast to associate with the imported schedule */
    public var headcountForecast: BuHeadcountForecast?
    /** Individual agent schedules */
    public var agentSchedules: [BuImportAgentScheduleUploadSchema]?

    public init(_description: String?, weekCount: Int?, published: Bool?, shortTermForecast: BuShortTermForecastReference?, headcountForecast: BuHeadcountForecast?, agentSchedules: [BuImportAgentScheduleUploadSchema]?) {
        self._description = _description
        self.weekCount = weekCount
        self.published = published
        self.shortTermForecast = shortTermForecast
        self.headcountForecast = headcountForecast
        self.agentSchedules = agentSchedules
    }

    public enum CodingKeys: String, CodingKey { 
        case _description = "description"
        case weekCount
        case published
        case shortTermForecast
        case headcountForecast
        case agentSchedules
    }


}




public class ImportStatus: Codable {

    public enum State: String, Codable { 
        case inProgress = "IN_PROGRESS"
        case failed = "FAILED"
    }













    /** current status of the import */
    public var state: State?
    /** total number of records to be imported */
    public var totalRecords: Int64?
    /** number of records finished importing */
    public var completedRecords: Int64?
    /** percentage of records finished importing */
    public var percentComplete: Int?
    /** if the import has failed, the reason for the failure */
    public var failureReason: String?
    /** The contact list Ids for target contact lists. */
    public var targetContactListIds: [String]?
    /** The prefix for the contact list name */
    public var listNamePrefix: String?

    public init(state: State?, totalRecords: Int64?, completedRecords: Int64?, percentComplete: Int?, failureReason: String?, targetContactListIds: [String]?, listNamePrefix: String?) {
        self.state = state
        self.totalRecords = totalRecords
        self.completedRecords = completedRecords
        self.percentComplete = percentComplete
        self.failureReason = failureReason
        self.targetContactListIds = targetContactListIds
        self.listNamePrefix = listNamePrefix
    }


}




public class ImportStatusRequest: Codable {



    /** New status for existing import operation */
    public var status: String?

    public init(status: String?) {
        self.status = status
    }


}




public class InboundDomain: Codable {





    public enum MxRecordStatus: String, Codable { 
        case valid = "VALID"
        case invalid = "INVALID"
        case notAvailable = "NOT_AVAILABLE"
    }









    /** Unique Id of the domain such as: example.com */
    public var _id: String?
    public var name: String?
    /** Mx Record Status */
    public var mxRecordStatus: MxRecordStatus?
    /** Indicates if this a PureCloud sub-domain.  If true, then the appropriate DNS records are created for sending/receiving email. */
    public var subDomain: Bool?
    /** The DNS settings if the inbound domain is using a custom Mail From. These settings can only be used on InboundDomains where subDomain is false. */
    public var mailFromSettings: MailFromResult?
    /** The custom SMTP server integration to use when sending outbound emails from this domain. */
    public var customSMTPServer: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, mxRecordStatus: MxRecordStatus?, subDomain: Bool?, mailFromSettings: MailFromResult?, customSMTPServer: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.mxRecordStatus = mxRecordStatus
        self.subDomain = subDomain
        self.mailFromSettings = mailFromSettings
        self.customSMTPServer = customSMTPServer
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case mxRecordStatus
        case subDomain
        case mailFromSettings
        case customSMTPServer
        case selfUri
    }


}




public class InsightsDetailsOverallPeriodPoints: Codable {













    /** Points scored */
    public var points: Int?
    /** Max possible points */
    public var maxPoints: Int?
    /** Number of data points */
    public var dataPointCount: Int?
    /** Percentage of the goal */
    public var percentOfGoal: Double?
    /** The agent's rank in leader board for points on this metric */
    public var rankTotalPoints: Int?
    /** The agent's rank in leader board for percentage on this metric */
    public var rankPercentagePoints: Int?

    public init(points: Int?, maxPoints: Int?, dataPointCount: Int?, percentOfGoal: Double?, rankTotalPoints: Int?, rankPercentagePoints: Int?) {
        self.points = points
        self.maxPoints = maxPoints
        self.dataPointCount = dataPointCount
        self.percentOfGoal = percentOfGoal
        self.rankTotalPoints = rankTotalPoints
        self.rankPercentagePoints = rankPercentagePoints
    }


}




public class InsightsSummaryOverallPeriodPoints: Codable {









    /** Points scored */
    public var points: Int?
    /** Max possible points */
    public var maxPoints: Int?
    /** Number of data points */
    public var dataPointCount: Int?
    /** Percentage of the goal */
    public var percentOfGoal: Double?

    public init(points: Int?, maxPoints: Int?, dataPointCount: Int?, percentOfGoal: Double?) {
        self.points = points
        self.maxPoints = maxPoints
        self.dataPointCount = dataPointCount
        self.percentOfGoal = percentOfGoal
    }


}



/** Configuration for an Integration */

public class IntegrationConfiguration: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the integration, used to distinguish this integration from others of the same type. */
    public var name: String?
    /** Version number required for updates. */
    public var version: Int?
    /** Key-value configuration settings described by the schema in the propertiesSchemaUri field. */
    public var properties: JSON?
    /** Advanced configuration described by the schema in the advancedSchemaUri field. */
    public var advanced: JSON?
    /** Notes about the integration. */
    public var notes: String?
    /** Credentials required by the integration. The required keys are indicated in the credentials property of the Integration Type */
    public var credentials: [String:CredentialInfo]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, version: Int?, properties: JSON?, advanced: JSON?, notes: String?, credentials: [String:CredentialInfo]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.version = version
        self.properties = properties
        self.advanced = advanced
        self.notes = notes
        self.credentials = credentials
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case version
        case properties
        case advanced
        case notes
        case credentials
        case selfUri
    }


}



/** Descriptor for a type of Integration. */

public class IntegrationType: Codable {

















































    /** The ID of the integration type. */
    public var _id: String?
    public var name: String?
    /** Description of the integration type. */
    public var _description: String?
    /** PureCloud provider of the integration type. */
    public var provider: String?
    /** Category describing the integration type. */
    public var category: String?
    /** Collection of logos. */
    public var images: [UserImage]?
    /** URI of the schema describing the key-value properties needed to configure an integration of this type. */
    public var configPropertiesSchemaUri: String?
    /** URI of the schema describing the advanced JSON document needed to configure an integration of this type. */
    public var configAdvancedSchemaUri: String?
    /** URI of a page with more information about the integration type */
    public var helpUri: String?
    /** URI of a page with terms and conditions for the integration type */
    public var termsOfServiceUri: String?
    /** Name of the vendor of this integration type */
    public var vendorName: String?
    /** URI of the vendor's website */
    public var vendorWebsiteUri: String?
    /** URI of the marketplace listing for this integration type */
    public var marketplaceUri: String?
    /** URI of frequently asked questions about the integration type */
    public var faqUri: String?
    /** URI of a privacy policy for users of the integration type */
    public var privacyPolicyUri: String?
    /** URI for vendor support */
    public var supportContactUri: String?
    /** URI for vendor sales information */
    public var salesContactUri: String?
    /** List of links to additional help resources */
    public var helpLinks: [HelpLink]?
    /** Map of credentials for integrations of this type. The key is the name of a credential that can be provided in the credentials property of the integration configuration. */
    public var credentials: [String:CredentialSpecification]?
    /** Indicates if the integration type is installable or not. */
    public var nonInstallable: Bool?
    /** The maximum number of integration instances allowable for this integration type */
    public var maxInstances: Int?
    /** List of permissions required to permit user access to the integration type. */
    public var userPermissions: [String]?
    /** List of OAuth Client IDs that must be authorized when the integration is created. */
    public var vendorOAuthClientIds: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, provider: String?, category: String?, images: [UserImage]?, configPropertiesSchemaUri: String?, configAdvancedSchemaUri: String?, helpUri: String?, termsOfServiceUri: String?, vendorName: String?, vendorWebsiteUri: String?, marketplaceUri: String?, faqUri: String?, privacyPolicyUri: String?, supportContactUri: String?, salesContactUri: String?, helpLinks: [HelpLink]?, credentials: [String:CredentialSpecification]?, nonInstallable: Bool?, maxInstances: Int?, userPermissions: [String]?, vendorOAuthClientIds: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.provider = provider
        self.category = category
        self.images = images
        self.configPropertiesSchemaUri = configPropertiesSchemaUri
        self.configAdvancedSchemaUri = configAdvancedSchemaUri
        self.helpUri = helpUri
        self.termsOfServiceUri = termsOfServiceUri
        self.vendorName = vendorName
        self.vendorWebsiteUri = vendorWebsiteUri
        self.marketplaceUri = marketplaceUri
        self.faqUri = faqUri
        self.privacyPolicyUri = privacyPolicyUri
        self.supportContactUri = supportContactUri
        self.salesContactUri = salesContactUri
        self.helpLinks = helpLinks
        self.credentials = credentials
        self.nonInstallable = nonInstallable
        self.maxInstances = maxInstances
        self.userPermissions = userPermissions
        self.vendorOAuthClientIds = vendorOAuthClientIds
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case provider
        case category
        case images
        case configPropertiesSchemaUri
        case configAdvancedSchemaUri
        case helpUri
        case termsOfServiceUri
        case vendorName
        case vendorWebsiteUri
        case marketplaceUri
        case faqUri
        case privacyPolicyUri
        case supportContactUri
        case salesContactUri
        case helpLinks
        case credentials
        case nonInstallable
        case maxInstances
        case userPermissions
        case vendorOAuthClientIds
        case selfUri
    }


}




public class IntentDefinition: Codable {













    /** ID of the intent. */
    public var _id: String?
    /** The name of the intent. */
    public var name: String?
    /** The bindings for the named entity types used in this intent.This field is mutually exclusive with entityNameReferences and entities */
    public var entityTypeBindings: [NamedEntityTypeBinding]?
    /** The references for the named entity used in this intent.This field is mutually exclusive with entityTypeBindings */
    public var entityNameReferences: [String]?
    /** The utterances that act as training phrases for the intent. */
    public var utterances: [NluUtterance]?
    /** Additional languages for intents */
    public var additionalLanguages: [String:AdditionalLanguagesIntent]?

    public init(_id: String?, name: String?, entityTypeBindings: [NamedEntityTypeBinding]?, entityNameReferences: [String]?, utterances: [NluUtterance]?, additionalLanguages: [String:AdditionalLanguagesIntent]?) {
        self._id = _id
        self.name = name
        self.entityTypeBindings = entityTypeBindings
        self.entityNameReferences = entityNameReferences
        self.utterances = utterances
        self.additionalLanguages = additionalLanguages
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case entityTypeBindings
        case entityNameReferences
        case utterances
        case additionalLanguages
    }


}




public class IntentFeedback: Codable {







    public enum Assessment: String, Codable { 
        case incorrect = "Incorrect"
        case correct = "Correct"
        case unknown = "Unknown"
        case disabled = "Disabled"
    }

    /** The name of the detected intent. */
    public var name: String?
    /** The probability of the detected intent. */
    public var probability: Double?
    /** The collection of named entities detected. */
    public var entities: [DetectedNamedEntity]?
    /** The assessment on the detection for feedback text. */
    public var assessment: Assessment?

    public init(name: String?, probability: Double?, entities: [DetectedNamedEntity]?, assessment: Assessment?) {
        self.name = name
        self.probability = probability
        self.entities = entities
        self.assessment = assessment
    }


}




public class InteractionStatsAlertContainer: Codable {





















    public var entities: [InteractionStatsAlert]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [InteractionStatsAlert]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class Items: Codable {





    public var type: String?
    public var pattern: String?

    public init(type: String?, pattern: String?) {
        self.type = type
        self.pattern = pattern
    }


}




public class JourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    /** Details about the action map from the Journey System which triggered this action */
    public var actionMap: JourneyActionMap?

    public init(_id: String?, actionMap: JourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}




public class JourneyAggregateQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [JourneyAggregateQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [JourneyAggregateQueryPredicate]?

    public init(type: ModelType?, clauses: [JourneyAggregateQueryClause]?, predicates: [JourneyAggregateQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class JourneyAppEventsNotificationAppEventsNotification: Codable {















    public enum EventType: String, Codable { 
        case appEvent = "AppEvent"
        case outcomeAchievedEvent = "OutcomeAchievedEvent"
        case segmentAssignmentEvent = "SegmentAssignmentEvent"
    }







    public var _id: String?
    public var correlationId: String?
    public var externalContact: JourneyAppEventsNotificationExternalContact?
    public var createdDate: Date?
    public var customerId: String?
    public var customerIdType: String?
    public var session: JourneyAppEventsNotificationSession?
    public var eventType: EventType?
    public var appEvent: JourneyAppEventsNotificationAppMessage?
    public var outcomeAchievedEvent: JourneyAppEventsNotificationOutcomeAchievedMessage?
    public var segmentAssignmentEvent: JourneyAppEventsNotificationSegmentAssignmentMessage?

    public init(_id: String?, correlationId: String?, externalContact: JourneyAppEventsNotificationExternalContact?, createdDate: Date?, customerId: String?, customerIdType: String?, session: JourneyAppEventsNotificationSession?, eventType: EventType?, appEvent: JourneyAppEventsNotificationAppMessage?, outcomeAchievedEvent: JourneyAppEventsNotificationOutcomeAchievedMessage?, segmentAssignmentEvent: JourneyAppEventsNotificationSegmentAssignmentMessage?) {
        self._id = _id
        self.correlationId = correlationId
        self.externalContact = externalContact
        self.createdDate = createdDate
        self.customerId = customerId
        self.customerIdType = customerIdType
        self.session = session
        self.eventType = eventType
        self.appEvent = appEvent
        self.outcomeAchievedEvent = outcomeAchievedEvent
        self.segmentAssignmentEvent = segmentAssignmentEvent
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case correlationId
        case externalContact
        case createdDate
        case customerId
        case customerIdType
        case session
        case eventType
        case appEvent
        case outcomeAchievedEvent
        case segmentAssignmentEvent
    }


}




public class JourneyAppEventsNotificationAppMessage: Codable {



























    public var eventName: String?
    public var screenName: String?
    public var app: JourneyAppEventsNotificationApp?
    public var device: JourneyAppEventsNotificationDevice?
    public var ipAddress: String?
    public var ipOrganization: String?
    public var geolocation: JourneyAppEventsNotificationGeoLocation?
    public var sdkLibrary: JourneyAppEventsNotificationSdkLibrary?
    public var networkConnectivity: JourneyAppEventsNotificationNetworkConnectivity?
    public var mktCampaign: JourneyAppEventsNotificationMktCampaign?
    public var searchQuery: String?
    public var attributes: [String:JourneyAppEventsNotificationCustomEventAttribute]?
    public var traits: [String:JourneyAppEventsNotificationCustomEventAttribute]?

    public init(eventName: String?, screenName: String?, app: JourneyAppEventsNotificationApp?, device: JourneyAppEventsNotificationDevice?, ipAddress: String?, ipOrganization: String?, geolocation: JourneyAppEventsNotificationGeoLocation?, sdkLibrary: JourneyAppEventsNotificationSdkLibrary?, networkConnectivity: JourneyAppEventsNotificationNetworkConnectivity?, mktCampaign: JourneyAppEventsNotificationMktCampaign?, searchQuery: String?, attributes: [String:JourneyAppEventsNotificationCustomEventAttribute]?, traits: [String:JourneyAppEventsNotificationCustomEventAttribute]?) {
        self.eventName = eventName
        self.screenName = screenName
        self.app = app
        self.device = device
        self.ipAddress = ipAddress
        self.ipOrganization = ipOrganization
        self.geolocation = geolocation
        self.sdkLibrary = sdkLibrary
        self.networkConnectivity = networkConnectivity
        self.mktCampaign = mktCampaign
        self.searchQuery = searchQuery
        self.attributes = attributes
        self.traits = traits
    }


}




public class JourneyAppEventsNotificationAssociatedValue: Codable {

    public enum DataType: String, Codable { 
        case number = "Number"
        case integer = "Integer"
    }



    public var dataType: DataType?
    public var value: Double?

    public init(dataType: DataType?, value: Double?) {
        self.dataType = dataType
        self.value = value
    }


}




public class JourneyAppEventsNotificationGeoLocation: Codable {





















    public var country: String?
    public var countryName: String?
    public var latitude: Double?
    public var longitude: Double?
    public var locality: String?
    public var postalCode: String?
    public var region: String?
    public var regionName: String?
    public var timezone: String?
    public var source: String?

    public init(country: String?, countryName: String?, latitude: Double?, longitude: Double?, locality: String?, postalCode: String?, region: String?, regionName: String?, timezone: String?, source: String?) {
        self.country = country
        self.countryName = countryName
        self.latitude = latitude
        self.longitude = longitude
        self.locality = locality
        self.postalCode = postalCode
        self.region = region
        self.regionName = regionName
        self.timezone = timezone
        self.source = source
    }


}




public class JourneyAppEventsNotificationSegment: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneyContext: Codable {







    /** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */
    public var customer: JourneyCustomer?
    /** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */
    public var customerSession: JourneyCustomerSession?
    /** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */
    public var triggeringAction: JourneyAction?

    public init(customer: JourneyCustomer?, customerSession: JourneyCustomerSession?, triggeringAction: JourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class JourneyOutcomeEventsNotificationBrowser: Codable {





















    public var family: String?
    public var version: String?
    public var lang: String?
    public var fingerprint: String?
    public var viewHeight: Int?
    public var viewWidth: Int?
    public var featuresFlash: Bool?
    public var featuresJava: Bool?
    public var featuresPdf: Bool?
    public var featuresWebrtc: Bool?

    public init(family: String?, version: String?, lang: String?, fingerprint: String?, viewHeight: Int?, viewWidth: Int?, featuresFlash: Bool?, featuresJava: Bool?, featuresPdf: Bool?, featuresWebrtc: Bool?) {
        self.family = family
        self.version = version
        self.lang = lang
        self.fingerprint = fingerprint
        self.viewHeight = viewHeight
        self.viewWidth = viewWidth
        self.featuresFlash = featuresFlash
        self.featuresJava = featuresJava
        self.featuresPdf = featuresPdf
        self.featuresWebrtc = featuresWebrtc
    }


}




public class JourneyOutcomeEventsNotificationMktCampaign: Codable {















    public var content: String?
    public var medium: String?
    public var name: String?
    public var source: String?
    public var term: String?
    public var clickId: String?
    public var network: String?

    public init(content: String?, medium: String?, name: String?, source: String?, term: String?, clickId: String?, network: String?) {
        self.content = content
        self.medium = medium
        self.name = name
        self.source = source
        self.term = term
        self.clickId = clickId
        self.network = network
    }


}




public class JourneyOutcomeEventsNotificationSession: Codable {







    public var _id: String?
    public var selfUri: String?
    public var type: String?

    public init(_id: String?, selfUri: String?, type: String?) {
        self._id = _id
        self.selfUri = selfUri
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case type
    }


}




public class JourneyPage: Codable {





















    /** The page URL. */
    public var url: String?
    /** Title of the page. */
    public var title: String?
    /** Domain of the page's URL. */
    public var domain: String?
    /** Fragment or hash of the page's URL. */
    public var fragment: String?
    /** Hostname of the page's URL. */
    public var hostname: String?
    /** Keywords from the HTML {@code <meta>} tag of the page. */
    public var keywords: String?
    /** ISO 639-1 language code for the page as defined in the {@code <html>} tag. */
    public var lang: String?
    /** Path name of the page for the event. */
    public var pathname: String?
    /** Query string that is passed to the page in the current event. */
    public var queryString: String?
    /** Hierarchy of the current page in relation to the website's structure. */
    public var breadcrumb: [String]?

    public init(url: String?, title: String?, domain: String?, fragment: String?, hostname: String?, keywords: String?, lang: String?, pathname: String?, queryString: String?, breadcrumb: [String]?) {
        self.url = url
        self.title = title
        self.domain = domain
        self.fragment = fragment
        self.hostname = hostname
        self.keywords = keywords
        self.lang = lang
        self.pathname = pathname
        self.queryString = queryString
        self.breadcrumb = breadcrumb
    }


}




public class JourneySessionEventsNotificationConnectedQueue: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneySessionEventsNotificationConversationChannel: Codable {

    public enum ModelType: String, Codable { 
        case unknown = "Unknown"
        case voice = "Voice"
        case chat = "Chat"
        case email = "Email"
        case callback = "Callback"
        case cobrowse = "Cobrowse"
        case video = "Video"
        case screenshare = "Screenshare"
        case message = "Message"
    }

    public enum MessageType: String, Codable { 
        case unknown = "Unknown"
        case sms = "Sms"
        case twitter = "Twitter"
        case facebook = "Facebook"
        case line = "Line"
        case whatsApp = "WhatsApp"
        case webMessaging = "WebMessaging"
        case _open = "Open"
        case instagram = "Instagram"
    }



    public var type: ModelType?
    public var messageType: MessageType?
    public var platform: String?

    public init(type: ModelType?, messageType: MessageType?, platform: String?) {
        self.type = type
        self.messageType = messageType
        self.platform = platform
    }


}




public class JourneySessionEventsNotificationDevice: Codable {

















    public enum Category: String, Codable { 
        case desktop = "desktop"
        case mobile = "mobile"
        case tablet = "tablet"
        case other = "other"
    }



    public var type: String?
    public var isMobile: Bool?
    public var screenHeight: Int?
    public var screenWidth: Int?
    public var screenDensity: Int?
    public var fingerprint: String?
    public var osFamily: String?
    public var osVersion: String?
    public var category: Category?
    public var manufacturer: String?

    public init(type: String?, isMobile: Bool?, screenHeight: Int?, screenWidth: Int?, screenDensity: Int?, fingerprint: String?, osFamily: String?, osVersion: String?, category: Category?, manufacturer: String?) {
        self.type = type
        self.isMobile = isMobile
        self.screenHeight = screenHeight
        self.screenWidth = screenWidth
        self.screenDensity = screenDensity
        self.fingerprint = fingerprint
        self.osFamily = osFamily
        self.osVersion = osVersion
        self.category = category
        self.manufacturer = manufacturer
    }


}




public class JourneySessionEventsNotificationOutcome: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneySessionEventsNotificationSegmentAssignment: Codable {





    public var segment: JourneySessionEventsNotificationSegment?
    public var assignedDate: Date?

    public init(segment: JourneySessionEventsNotificationSegment?, assignedDate: Date?) {
        self.segment = segment
        self.assignedDate = assignedDate
    }


}




public class JourneyWebActionEventsNotificationActionMapPageUrlCondition: Codable {



    public enum Operator: String, Codable { 
        case unknown = "unknown"
        case equal = "equal"
        case notequal = "notEqual"
        case like = "like"
        case notlike = "notLike"
        case greaterthan = "greaterThan"
        case greaterthanorequal = "greaterThanOrEqual"
        case lessthan = "lessThan"
        case lessthanorequal = "lessThanOrEqual"
        case startswith = "startsWith"
        case endswith = "endsWith"
        case containsany = "containsAny"
        case notcontainsany = "notContainsAny"
        case containsall = "containsAll"
        case notcontainsal = "notContainsAl"
    }

    public var values: [String]?
    public var _operator: Operator?

    public init(values: [String]?, _operator: Operator?) {
        self.values = values
        self._operator = _operator
    }

    public enum CodingKeys: String, CodingKey { 
        case values
        case _operator = "operator"
    }


}




public class JourneyWebActionEventsNotificationBrowser: Codable {





















    public var family: String?
    public var version: String?
    public var lang: String?
    public var fingerprint: String?
    public var viewHeight: Int?
    public var viewWidth: Int?
    public var featuresFlash: Bool?
    public var featuresJava: Bool?
    public var featuresPdf: Bool?
    public var featuresWebrtc: Bool?

    public init(family: String?, version: String?, lang: String?, fingerprint: String?, viewHeight: Int?, viewWidth: Int?, featuresFlash: Bool?, featuresJava: Bool?, featuresPdf: Bool?, featuresWebrtc: Bool?) {
        self.family = family
        self.version = version
        self.lang = lang
        self.fingerprint = fingerprint
        self.viewHeight = viewHeight
        self.viewWidth = viewWidth
        self.featuresFlash = featuresFlash
        self.featuresJava = featuresJava
        self.featuresPdf = featuresPdf
        self.featuresWebrtc = featuresWebrtc
    }


}




public class JourneyWebActionEventsNotificationEventAction: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class JourneyWebActionEventsNotificationMktCampaign: Codable {















    public var content: String?
    public var medium: String?
    public var name: String?
    public var source: String?
    public var term: String?
    public var clickId: String?
    public var network: String?

    public init(content: String?, medium: String?, name: String?, source: String?, term: String?, clickId: String?, network: String?) {
        self.content = content
        self.medium = medium
        self.name = name
        self.source = source
        self.term = term
        self.clickId = clickId
        self.network = network
    }


}




public class JourneyWebActionEventsNotificationSession: Codable {







    public var _id: String?
    public var selfUri: String?
    public var type: String?

    public init(_id: String?, selfUri: String?, type: String?) {
        self._id = _id
        self.selfUri = selfUri
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case type
    }


}




public class JourneyWebEventsNotificationActionTarget: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneyWebEventsNotificationExternalContact: Codable {





    public var _id: String?
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class JourneyWebEventsNotificationPage: Codable {





















    public var url: String?
    public var title: String?
    public var domain: String?
    public var fragment: String?
    public var hostname: String?
    public var keywords: String?
    public var lang: String?
    public var pathname: String?
    public var queryString: String?
    public var breadcrumb: [String]?

    public init(url: String?, title: String?, domain: String?, fragment: String?, hostname: String?, keywords: String?, lang: String?, pathname: String?, queryString: String?, breadcrumb: [String]?) {
        self.url = url
        self.title = title
        self.domain = domain
        self.fragment = fragment
        self.hostname = hostname
        self.keywords = keywords
        self.lang = lang
        self.pathname = pathname
        self.queryString = queryString
        self.breadcrumb = breadcrumb
    }


}




public class JourneyWebEventsNotificationSegmentAssignmentMessage: Codable {



    public var segment: JourneyWebEventsNotificationSegment?

    public init(segment: JourneyWebEventsNotificationSegment?) {
        self.segment = segment
    }


}




public class JourneyWebEventsNotificationWebActionMessage: Codable {





























    public var action: JourneyWebEventsNotificationEventAction?
    public var actionTarget: JourneyWebEventsNotificationActionTarget?
    public var actionMap: JourneyWebEventsNotificationActionMap?
    public var errorCode: String?
    public var errorMessage: String?
    public var userAgentString: String?
    public var ipAddress: String?
    public var ipOrganization: String?
    public var browser: JourneyWebEventsNotificationBrowser?
    public var device: JourneyWebEventsNotificationDevice?
    public var geolocation: JourneyWebEventsNotificationGeoLocation?
    public var mktCampaign: JourneyWebEventsNotificationMktCampaign?
    public var visitReferrer: JourneyWebEventsNotificationReferrer?
    public var timeToDisposition: Int?

    public init(action: JourneyWebEventsNotificationEventAction?, actionTarget: JourneyWebEventsNotificationActionTarget?, actionMap: JourneyWebEventsNotificationActionMap?, errorCode: String?, errorMessage: String?, userAgentString: String?, ipAddress: String?, ipOrganization: String?, browser: JourneyWebEventsNotificationBrowser?, device: JourneyWebEventsNotificationDevice?, geolocation: JourneyWebEventsNotificationGeoLocation?, mktCampaign: JourneyWebEventsNotificationMktCampaign?, visitReferrer: JourneyWebEventsNotificationReferrer?, timeToDisposition: Int?) {
        self.action = action
        self.actionTarget = actionTarget
        self.actionMap = actionMap
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.userAgentString = userAgentString
        self.ipAddress = ipAddress
        self.ipOrganization = ipOrganization
        self.browser = browser
        self.device = device
        self.geolocation = geolocation
        self.mktCampaign = mktCampaign
        self.visitReferrer = visitReferrer
        self.timeToDisposition = timeToDisposition
    }


}



/** A JSON Schema document. */

public class JsonSchemaDocument: Codable {

















    public var _id: String?
    public var schema: String?
    public var title: String?
    public var _description: String?
    public var type: String?
    public var _required: [String]?
    public var properties: [String:JSON]?
    public var additionalProperties: JSON?

    public init(_id: String?, schema: String?, title: String?, _description: String?, type: String?, _required: [String]?, properties: [String:JSON]?, additionalProperties: JSON?) {
        self._id = _id
        self.schema = schema
        self.title = title
        self._description = _description
        self.type = type
        self._required = _required
        self.properties = properties
        self.additionalProperties = additionalProperties
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case schema = "$schema"
        case title
        case _description = "description"
        case type
        case _required = "required"
        case properties
        case additionalProperties
    }


}




public class KlaxonInteractionStatsRulesTopicNotificationUser: Codable {





    public var _id: String?
    public var displayName: String?

    public init(_id: String?, displayName: String?) {
        self._id = _id
        self.displayName = displayName
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case displayName
    }


}




public class KnowledgeAggregateQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [KnowledgeAggregateQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [KnowledgeAggregateQueryPredicate]?

    public init(type: ModelType?, clauses: [KnowledgeAggregateQueryClause]?, predicates: [KnowledgeAggregateQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class KnowledgeContextValueReference: Codable {





    /** The globally unique identifier for the knowledge context value. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class KnowledgeConversationContext: Codable {



    public enum MediaType: String, Codable { 
        case unknown = "Unknown"
        case callback = "Callback"
        case chat = "Chat"
        case cobrowse = "Cobrowse"
        case email = "Email"
        case message = "Message"
        case screenshare = "Screenshare"
        case video = "Video"
        case voice = "Voice"
    }





    /** The unique identifier of the conversation. */
    public var conversationId: String?
    /** The media type of the conversation. */
    public var mediaType: MediaType?
    /** The unique identifier of the queue used to assign the interaction to the user. */
    public var queueId: String?
    /** The external contact identifier of the end-user participant. */
    public var externalContactId: String?

    public init(conversationId: String?, mediaType: MediaType?, queueId: String?, externalContactId: String?) {
        self.conversationId = conversationId
        self.mediaType = mediaType
        self.queueId = queueId
        self.externalContactId = externalContactId
    }


}




public class KnowledgeDocument: Codable {





    public enum LanguageCode: String, Codable { 
        case enUs = "en-US"
        case enUk = "en-UK"
        case enAu = "en-AU"
        case enCa = "en-CA"
        case enHk = "en-HK"
        case enIn = "en-IN"
        case enIe = "en-IE"
        case enNz = "en-NZ"
        case enPh = "en-PH"
        case enSg = "en-SG"
        case enZa = "en-ZA"
        case deDe = "de-DE"
        case deAt = "de-AT"
        case deCh = "de-CH"
        case esAr = "es-AR"
        case esCo = "es-CO"
        case esMx = "es-MX"
        case esUs = "es-US"
        case esEs = "es-ES"
        case frFr = "fr-FR"
        case frBe = "fr-BE"
        case frCa = "fr-CA"
        case frCh = "fr-CH"
        case ptBr = "pt-BR"
        case ptPt = "pt-PT"
        case nlNl = "nl-NL"
        case nlBe = "nl-BE"
        case itIt = "it-IT"
        case caEs = "ca-ES"
        case trTr = "tr-TR"
        case svSe = "sv-SE"
        case fiFi = "fi-FI"
        case nbNo = "nb-NO"
        case daDk = "da-DK"
        case jaJp = "ja-JP"
        case arAe = "ar-AE"
    }

    public enum ModelType: String, Codable { 
        case faq = "Faq"
        case article = "Article"
    }

















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Language of the document */
    public var languageCode: LanguageCode?
    /** Document type */
    public var type: ModelType?
    /** FAQ document details */
    public var faq: DocumentFaq?
    /** Document creation date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Document last modification date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Document categories */
    public var categories: [KnowledgeCategory]?
    /** Knowledge base which document does belong to */
    public var knowledgeBase: KnowledgeBase?
    /** External URL to the document */
    public var externalUrl: String?
    /** Article */
    public var article: DocumentArticle?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, languageCode: LanguageCode?, type: ModelType?, faq: DocumentFaq?, dateCreated: Date?, dateModified: Date?, categories: [KnowledgeCategory]?, knowledgeBase: KnowledgeBase?, externalUrl: String?, article: DocumentArticle?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.languageCode = languageCode
        self.type = type
        self.faq = faq
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.categories = categories
        self.knowledgeBase = knowledgeBase
        self.externalUrl = externalUrl
        self.article = article
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case languageCode
        case type
        case faq
        case dateCreated
        case dateModified
        case categories
        case knowledgeBase
        case externalUrl
        case article
        case selfUri
    }


}




public class KnowledgeDocumentFeedbackResponse: Codable {





    public enum Rating: String, Codable { 
        case negative = "Negative"
        case positive = "Positive"
    }

    public enum Reason: String, Codable { 
        case documentContent = "DocumentContent"
        case searchResults = "SearchResults"
    }









    public enum QueryType: String, Codable { 
        case unknown = "Unknown"
        case article = "Article"
        case autoSearch = "AutoSearch"
        case category = "Category"
        case manualSearch = "ManualSearch"
        case recommendation = "Recommendation"
        case suggestion = "Suggestion"
    }

    public enum State: String, Codable { 
        case draft = "Draft"
        case _final = "Final"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The variation of the document on which feedback was given. */
    public var documentVariation: EntityReference?
    /** Feedback rating. */
    public var rating: Rating?
    /** Feedback reason. */
    public var reason: Reason?
    /** Free-text comment of the feedback. Maximum length: 2000 characters. */
    public var comment: String?
    /** The search that surfaced the document on which feedback was given. */
    public var search: EntityReference?
    /** Knowledge guest session ID. */
    public var sessionId: String?
    /** The date and time of the feedback. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The type of the query that surfaced the document on which the feedback was given. */
    public var queryType: QueryType?
    /** The state of the feedback. */
    public var state: State?
    /** The document on which feedback was given. */
    public var document: KnowledgeDocumentVersionReference?
    /** The client application from which feedback was given. */
    public var application: KnowledgeSearchClientApplication?
    /** Conversation context information if the feedback is given in the context of a conversation. */
    public var conversationContext: KnowledgeConversationContextResponse?
    /** The user who created the feedback. */
    public var user: AddressableEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, documentVariation: EntityReference?, rating: Rating?, reason: Reason?, comment: String?, search: EntityReference?, sessionId: String?, dateCreated: Date?, queryType: QueryType?, state: State?, document: KnowledgeDocumentVersionReference?, application: KnowledgeSearchClientApplication?, conversationContext: KnowledgeConversationContextResponse?, user: AddressableEntityRef?, selfUri: String?) {
        self._id = _id
        self.documentVariation = documentVariation
        self.rating = rating
        self.reason = reason
        self.comment = comment
        self.search = search
        self.sessionId = sessionId
        self.dateCreated = dateCreated
        self.queryType = queryType
        self.state = state
        self.document = document
        self.application = application
        self.conversationContext = conversationContext
        self.user = user
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case documentVariation
        case rating
        case reason
        case comment
        case search
        case sessionId
        case dateCreated
        case queryType
        case state
        case document
        case application
        case conversationContext
        case user
        case selfUri
    }


}




public class KnowledgeDocumentFeedbackResponseListing: Codable {









    public var entities: [KnowledgeDocumentFeedbackResponse]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [KnowledgeDocumentFeedbackResponse]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class KnowledgeDocumentRequest: Codable {

    public enum ModelType: String, Codable { 
        case faq = "Faq"
        case article = "Article"
    }









    /** Document type according to assigned template */
    public var type: ModelType?
    /** External Url to the document */
    public var externalUrl: String?
    /** Faq document details */
    public var faq: DocumentFaq?
    /** Document categories */
    public var categories: [DocumentCategoryInput]?
    /** Article details */
    public var article: DocumentArticle?

    public init(type: ModelType?, externalUrl: String?, faq: DocumentFaq?, categories: [DocumentCategoryInput]?, article: DocumentArticle?) {
        self.type = type
        self.externalUrl = externalUrl
        self.faq = faq
        self.categories = categories
        self.article = article
    }


}




public class KnowledgeGuestDocument: Codable {









    public enum State: String, Codable { 
        case draft = "Draft"
        case published = "Published"
        case archived = "Archived"
    }

























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Document title, having a limit of 500 words. */
    public var title: String?
    /** Indicates if the knowledge document should be included in search results. */
    public var visible: Bool?
    /** List of alternate phrases related to the title which improves search results. */
    public var alternatives: [KnowledgeDocumentAlternative]?
    /** State of the document. */
    public var state: State?
    /** Document creation date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Document last modification date-time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Document import date-time, or null if was not imported. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateImported: Date?
    /** The last published version number of the document. */
    public var lastPublishedVersionNumber: Int?
    /** The date on which the document was last published. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var datePublished: Date?
    /** The user who created the document. */
    public var createdBy: UserReference?
    /** The user who modified the document. */
    public var modifiedBy: UserReference?
    /** The version of the document. */
    public var documentVersion: AddressableEntityRef?
    /** Variations of the document. */
    public var variations: [KnowledgeGuestDocumentVariation]?
    /** ID of the guest session. */
    public var sessionId: String?
    /** The reference to category associated with the document. */
    public var category: GuestCategoryReference?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, title: String?, visible: Bool?, alternatives: [KnowledgeDocumentAlternative]?, state: State?, dateCreated: Date?, dateModified: Date?, dateImported: Date?, lastPublishedVersionNumber: Int?, datePublished: Date?, createdBy: UserReference?, modifiedBy: UserReference?, documentVersion: AddressableEntityRef?, variations: [KnowledgeGuestDocumentVariation]?, sessionId: String?, category: GuestCategoryReference?, selfUri: String?) {
        self._id = _id
        self.title = title
        self.visible = visible
        self.alternatives = alternatives
        self.state = state
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.dateImported = dateImported
        self.lastPublishedVersionNumber = lastPublishedVersionNumber
        self.datePublished = datePublished
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.documentVersion = documentVersion
        self.variations = variations
        self.sessionId = sessionId
        self.category = category
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case title
        case visible
        case alternatives
        case state
        case dateCreated
        case dateModified
        case dateImported
        case lastPublishedVersionNumber
        case datePublished
        case createdBy
        case modifiedBy
        case documentVersion
        case variations
        case sessionId
        case category
        case selfUri
    }


}




public class KnowledgeGuestSessionContext: Codable {





    /** The context id associated with the session. */
    public var _id: String?
    /** The list of knowledge context values associated with the session. */
    public var values: [Entity]?

    public init(_id: String?, values: [Entity]?) {
        self._id = _id
        self.values = values
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case values
    }


}




public class Language: Codable {







    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The language name. */
    public var name: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    public var state: State?
    public var version: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateModified: Date?, state: State?, version: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateModified = dateModified
        self.state = state
        self.version = version
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateModified
        case state
        case version
        case selfUri
    }


}




public class Leaderboard: Codable {















    /** The targeted division for this leaderboard */
    public var division: Division?
    /** The metric id if the leaderboard is about a specific metric */
    public var metric: AddressableEntityRef?
    /** Start workday used as the date range. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStartWorkday: Date?
    /** End workday used as the date range. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEndWorkday: Date?
    /** The list of leaders generated. */
    public var leaders: [LeaderboardItem]?
    /** The requesting user's rank */
    public var userRank: LeaderboardItem?
    /** The targeted performance profile for the average points */
    public var performanceProfile: AddressableEntityRef?

    public init(division: Division?, metric: AddressableEntityRef?, dateStartWorkday: Date?, dateEndWorkday: Date?, leaders: [LeaderboardItem]?, userRank: LeaderboardItem?, performanceProfile: AddressableEntityRef?) {
        self.division = division
        self.metric = metric
        self.dateStartWorkday = dateStartWorkday
        self.dateEndWorkday = dateEndWorkday
        self.leaders = leaders
        self.userRank = userRank
        self.performanceProfile = performanceProfile
    }


}




public class LearningAssignmentItem: Codable {





    /** The Learning Module ID associated with this assignment */
    public var moduleId: String?
    /** The User ID associated with this assignment */
    public var userId: String?

    public init(moduleId: String?, userId: String?) {
        self.moduleId = moduleId
        self.userId = userId
    }


}




public class LearningAssignmentRuleRunTopicLearningAssignmentsCreated: Codable {



    public var module: LearningAssignmentRuleRunTopicLearningModuleReference?

    public init(module: LearningAssignmentRuleRunTopicLearningModuleReference?) {
        self.module = module
    }


}




public class LearningAssignmentRuleRunTopicLearningModuleReference: Codable {





    public var _id: String?
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}



/** Learning module users query request model */

public class LearningAssignmentUserQuery: Codable {





    /** Learning module rule object */
    public var rule: LearningModuleRule?
    /** The user name to be searched for */
    public var searchTerm: String?

    public init(rule: LearningModuleRule?, searchTerm: String?) {
        self.rule = rule
        self.searchTerm = searchTerm
    }


}




public class LearningCoverArtThumbnail: Codable {





    /** Resolution of thumbnail */
    public var resolution: String?
    /** The URL for the thumbnail */
    public var url: String?

    public init(resolution: String?, url: String?) {
        self.resolution = resolution
        self.url = url
    }


}



/** Learning module publish response */

public class LearningModulePublishResponse: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The version of published learning module */
    public var version: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, version: Int?, selfUri: String?) {
        self._id = _id
        self.version = version
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
        case selfUri
    }


}



/** Learning assignment SCO (Shareable Content Object) */

public class LearningShareableContentObject: Codable {



    public enum LessonStatus: String, Codable { 
        case passed = "Passed"
        case completed = "Completed"
        case failed = "Failed"
        case incomplete = "Incomplete"
        case browsed = "Browsed"
        case notAttempted = "NotAttempted"
    }

    public enum Exit: String, Codable { 
        case timeout = "Timeout"
        case suspend = "Suspend"
        case logout = "Logout"
        case empty = "Empty"
    }











    public enum Credit: String, Codable { 
        case credit = "Credit"
        case noCredit = "NoCredit"
    }

    public enum Entry: String, Codable { 
        case abInitio = "AbInitio"
        case resume = "Resume"
        case empty = "Empty"
    }

    public enum Mode: String, Codable { 
        case browse = "Browse"
        case normal = "Normal"
        case review = "Review"
    }











    /** The ID of the SCO from the course manifest. */
    public var _id: String?
    /** The status of the SCO. Maps to the SCORM 1.2 cmi.core.lesson_status property. */
    public var lessonStatus: LessonStatus?
    /** Indicates how or why the learner left the SCO. Maps to the SCORM 1.2 cmi.core.exit property. */
    public var exit: Exit?
    /** The learners current location in the SCO. Maps to the SCORM 1.2 cmi.core.lesson_location property. */
    public var location: String?
    /** The score of the most recent attempt on the SCO. Maps to the SCORM 1.2 cmi.core.score.raw property. */
    public var scoreRaw: Float?
    /** The maximum score that could be achieved on the SCO. Maps to the SCORM 1.2 cmi.core.score.max property. */
    public var scoreMax: Float?
    /** The minimum score that could be achieved on the SCO. Maps to the SCORM 1.2 cmi.core.score.min property. */
    public var scoreMin: Float?
    /** The unique information generated by the SCO from previous uses. Maps to the SCORM 1.2 cmi.suspend_data property. */
    public var suspendData: String?
    /** Whether completing this course counts towards the overall assignment. Maps to the SCORM 1.2 cmi.core.credit property. */
    public var credit: Credit?
    /** Whether the learner has previously accessed this SCO. Maps to the SCORM 1.2 cmi.core.entry property. */
    public var entry: Entry?
    /** Identifies the mode in which the SCO should be presented to the learner. Maps to the SCORM 1.2 cmi.core.lesson_mode property. */
    public var mode: Mode?
    /** The total amount of time the learner has spent in the SCO expressed as an ISO 8601 Duration, for example PT2H10M3.5S. Maps to the SCORM 1.2 cmi.core.total_time property. */
    public var totalTime: String?
    /** The amount of time spent in the SCO in this session expressed as an ISO-8601 Duration, for example PT2H10M3.5S. Maps to the SCORM 1.2 cmi.core.session_time property. */
    public var sessionTime: String?
    /** The href from the course manifest for this SCO. */
    public var href: String?
    /** The parameters from the course manifest for this SCO. */
    public var parameters: String?
    /** The launch data from the course manifest for this SCO. */
    public var launchData: String?

    public init(_id: String?, lessonStatus: LessonStatus?, exit: Exit?, location: String?, scoreRaw: Float?, scoreMax: Float?, scoreMin: Float?, suspendData: String?, credit: Credit?, entry: Entry?, mode: Mode?, totalTime: String?, sessionTime: String?, href: String?, parameters: String?, launchData: String?) {
        self._id = _id
        self.lessonStatus = lessonStatus
        self.exit = exit
        self.location = location
        self.scoreRaw = scoreRaw
        self.scoreMax = scoreMax
        self.scoreMin = scoreMin
        self.suspendData = suspendData
        self.credit = credit
        self.entry = entry
        self.mode = mode
        self.totalTime = totalTime
        self.sessionTime = sessionTime
        self.href = href
        self.parameters = parameters
        self.launchData = launchData
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case lessonStatus
        case exit
        case location
        case scoreRaw
        case scoreMax
        case scoreMin
        case suspendData
        case credit
        case entry
        case mode
        case totalTime
        case sessionTime
        case href
        case parameters
        case launchData
    }


}




public class LearningSlot: Codable {







    public enum DifferenceRating: String, Codable { 
        case poor = "Poor"
        case neutral = "Neutral"
        case good = "Good"
    }

    /** Start date and time of scheduled Learning activity slot. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?
    /** Length of Learning activity slot in minutes */
    public var lengthInMinutes: Int?
    /** Difference between scheduled and forecast headcount for this slot after scheduling the Learning activity */
    public var staffingDifference: Double?
    /** Rating based on the staffing difference for scheduled slot */
    public var differenceRating: DifferenceRating?

    public init(dateStart: Date?, lengthInMinutes: Int?, staffingDifference: Double?, differenceRating: DifferenceRating?) {
        self.dateStart = dateStart
        self.lengthInMinutes = lengthInMinutes
        self.staffingDifference = staffingDifference
        self.differenceRating = differenceRating
    }


}




public class LexV2Intent: Codable {









    /** The intent name */
    public var intentName: String?
    /** A description of the intent */
    public var _description: String?
    /** An object mapping slot names to Slot objects */
    public var slots: [String:LexV2Slot]?
    /** The intent id */
    public var intentId: String?

    public init(intentName: String?, _description: String?, slots: [String:LexV2Slot]?, intentId: String?) {
        self.intentName = intentName
        self._description = _description
        self.slots = slots
        self.intentId = intentId
    }

    public enum CodingKeys: String, CodingKey { 
        case intentName
        case _description = "description"
        case slots
        case intentId
    }


}




public class LineEntityListing: Codable {





















    public var entities: [Line]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Line]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ListWrapperShiftStartVariance: Codable {



    public var values: [ShiftStartVariance]?

    public init(values: [ShiftStartVariance]?) {
        self.values = values
    }


}




public class ListedTopic: Codable {









    public enum Strictness: String, Codable { 
        case _1 = "1"
        case _55 = "55"
        case _65 = "65"
        case _72 = "72"
        case _85 = "85"
        case _90 = "90"
    }







    public enum Participants: String, Codable { 
        case external = "External"
        case _internal = "Internal"
        case all = "All"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var _description: String?
    public var published: Bool?
    public var strictness: Strictness?
    public var programsCount: Int?
    public var tags: [String]?
    public var dialect: String?
    public var participants: Participants?
    public var phrasesCount: Int?
    public var modifiedBy: AddressableEntityRef?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, published: Bool?, strictness: Strictness?, programsCount: Int?, tags: [String]?, dialect: String?, participants: Participants?, phrasesCount: Int?, modifiedBy: AddressableEntityRef?, dateModified: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.published = published
        self.strictness = strictness
        self.programsCount = programsCount
        self.tags = tags
        self.dialect = dialect
        self.participants = participants
        self.phrasesCount = phrasesCount
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case published
        case strictness
        case programsCount
        case tags
        case dialect
        case participants
        case phrasesCount
        case modifiedBy
        case dateModified
        case selfUri
    }


}



/** Contains localized labels used in messenger apps */

public class LocalizedLabels: Codable {

    public enum Key: String, Codable { 
        case messengerHomeHeaderTitle = "MessengerHomeHeaderTitle"
        case messengerHomeHeaderSubTitle = "MessengerHomeHeaderSubTitle"
    }



    /** Contains localized label key used in messenger homescreen */
    public var key: Key?
    /** Contains localized label value used in messenger homescreen */
    public var value: String?

    public init(key: Key?, value: String?) {
        self.key = key
        self.value = value
    }


}




public class LocationCreateDefinition: Codable {





    public enum State: String, Codable { 
        case active = "active"
        case deleted = "deleted"
    }











    /** The name of the Location. Required for creates, not required for updates */
    public var name: String?
    /** Current version of the location */
    public var version: Int?
    /** Current activity status of the location. */
    public var state: State?
    /** A list of ancestor ids */
    public var path: [String]?
    /** Notes for the location */
    public var notes: String?
    /** The user id of the location contact */
    public var contactUser: String?
    /** Emergency number for the location */
    public var emergencyNumber: LocationEmergencyNumber?
    /** Address of the location */
    public var address: LocationAddress?

    public init(name: String?, version: Int?, state: State?, path: [String]?, notes: String?, contactUser: String?, emergencyNumber: LocationEmergencyNumber?, address: LocationAddress?) {
        self.name = name
        self.version = version
        self.state = state
        self.path = path
        self.notes = notes
        self.contactUser = contactUser
        self.emergencyNumber = emergencyNumber
        self.address = address
    }


}




public class LocationEmergencyNumber: Codable {





    public enum ModelType: String, Codable { 
        case _default = "default"
        case elin = "elin"
    }

    public var e164: String?
    public var number: String?
    /** The type of emergency number. */
    public var type: ModelType?

    public init(e164: String?, number: String?, type: ModelType?) {
        self.e164 = e164
        self.number = number
        self.type = type
    }


}




public class LocationUpdateDefinition: Codable {





    public enum State: String, Codable { 
        case active = "active"
        case deleted = "deleted"
    }











    /** The name of the Location. Required for creates, not required for updates */
    public var name: String?
    /** Current version of the location */
    public var version: Int?
    /** Current activity status of the location. */
    public var state: State?
    /** A list of ancestor ids */
    public var path: [String]?
    /** Notes for the location */
    public var notes: String?
    /** The user id of the location contact */
    public var contactUser: String?
    /** Emergency number for the location */
    public var emergencyNumber: LocationEmergencyNumber?
    /** Address of the location */
    public var address: LocationAddress?

    public init(name: String?, version: Int?, state: State?, path: [String]?, notes: String?, contactUser: String?, emergencyNumber: LocationEmergencyNumber?, address: LocationAddress?) {
        self.name = name
        self.version = version
        self.state = state
        self.path = path
        self.notes = notes
        self.contactUser = contactUser
        self.emergencyNumber = emergencyNumber
        self.address = address
    }


}




public class LockInfo: Codable {







    public enum Action: String, Codable { 
        case update = "UPDATE"
        case delete = "DELETE"
        case copy = "COPY"
        case move = "MOVE"
        case replace = "REPLACE"
        case thumbnail = "THUMBNAIL"
        case textExtraction = "TEXT_EXTRACTION"
    }

    public var lockedBy: DomainEntityRef?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateExpires: Date?
    public var action: Action?

    public init(lockedBy: DomainEntityRef?, dateCreated: Date?, dateExpires: Date?, action: Action?) {
        self.lockedBy = lockedBy
        self.dateCreated = dateCreated
        self.dateExpires = dateExpires
        self.action = action
    }


}




public class LogicalInterfaceEntityListing: Codable {





















    public var entities: [DomainLogicalInterface]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DomainLogicalInterface]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}



/** Defines a SCIM manager. */

public class Manager: Codable {





    /** The ID of the manager. */
    public var value: String?
    /** The reference URI of the manager's user record. */
    public var ref: String?

    public init(value: String?, ref: String?) {
        self.value = value
        self.ref = ref
    }

    public enum CodingKeys: String, CodingKey { 
        case value
        case ref = "$ref"
    }


}




public class MatchShiftTradeRequest: Codable {







    /** The ID of the schedule with which the shift trade is associated */
    public var receivingScheduleId: String?
    /** The ID of the shift the receiving user is giving up in trade, if applicable */
    public var receivingShiftId: String?
    /** Version metadata for the shift trade */
    public var metadata: WfmVersionedEntityMetadata?

    public init(receivingScheduleId: String?, receivingShiftId: String?, metadata: WfmVersionedEntityMetadata?) {
        self.receivingScheduleId = receivingScheduleId
        self.receivingShiftId = receivingShiftId
        self.metadata = metadata
    }


}




public class MaxLength: Codable {





    /** A non-negative integer for a text-based schema field denoting the minimum largest length string the field can contain for a schema instance. */
    public var min: Int64?
    /** A non-negative integer for a text-based schema field denoting the maximum largest string the field can contain for a schema instance. */
    public var max: Int64?

    public init(min: Int64?, max: Int64?) {
        self.min = min
        self.max = max
    }


}




public class MediaPolicies: Codable {









    /** Conditions and actions for calls */
    public var callPolicy: CallMediaPolicy?
    /** Conditions and actions for chats */
    public var chatPolicy: ChatMediaPolicy?
    /** Conditions and actions for emails */
    public var emailPolicy: EmailMediaPolicy?
    /** Conditions and actions for messages */
    public var messagePolicy: MessageMediaPolicy?

    public init(callPolicy: CallMediaPolicy?, chatPolicy: ChatMediaPolicy?, emailPolicy: EmailMediaPolicy?, messagePolicy: MessageMediaPolicy?) {
        self.callPolicy = callPolicy
        self.chatPolicy = chatPolicy
        self.emailPolicy = emailPolicy
        self.messagePolicy = messagePolicy
    }


}




public class MediaResult: Codable {





    public var mediaUri: String?
    public var waveformData: [Float]?

    public init(mediaUri: String?, waveformData: [Float]?) {
        self.mediaUri = mediaUri
        self.waveformData = waveformData
    }


}




public class MediaSettings: Codable {













    /** Indicates if auto-answer is enabled for the given media type or subtype (default is false).  Subtype settings take precedence over media type settings. */
    public var enableAutoAnswer: Bool?
    /** The alerting timeout for the media type, in seconds */
    public var alertingTimeoutSeconds: Int?
    /** The targeted service level for the media type */
    public var serviceLevel: ServiceLevel?
    /** How long to play the alerting tone for an auto-answer interaction */
    public var autoAnswerAlertToneSeconds: Double?
    /** How long to play the alerting tone for a manual-answer interaction */
    public var manualAnswerAlertToneSeconds: Double?
    /** Map of media subtype to media subtype specific settings. */
    public var subTypeSettings: [String:BaseMediaSettings]?

    public init(enableAutoAnswer: Bool?, alertingTimeoutSeconds: Int?, serviceLevel: ServiceLevel?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, subTypeSettings: [String:BaseMediaSettings]?) {
        self.enableAutoAnswer = enableAutoAnswer
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.serviceLevel = serviceLevel
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.subTypeSettings = subTypeSettings
    }


}




public class Message: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case disconnected = "disconnected"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case disconnected = "disconnected"
    }







    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }





    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }













    public enum ModelType: String, Codable { 
        case unknown = "unknown"
        case sms = "sms"
        case twitter = "twitter"
        case facebook = "facebook"
        case line = "line"
        case whatsapp = "whatsapp"
        case telegram = "telegram"
        case kakao = "kakao"
        case webmessaging = "webmessaging"
        case _open = "open"
        case instagram = "instagram"
    }





























    /** The connection state of this communication. */
    public var state: State?
    /** The initial connection state of this communication. */
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** The time line of the participant's message, divided into activity segments. */
    public var segments: [Segment]?
    /** The direction of the message. */
    public var direction: Direction?
    /** A globally unique identifier for the recording associated with this message. */
    public var recordingId: String?
    public var errorInfo: ErrorBody?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the message was placed on hold in the cloud clock if the message is currently on hold. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startHoldTime: Date?
    /** The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAlertingTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var disconnectedTime: Date?
    /** The source provider for the message. */
    public var provider: String?
    /** If true, the participant member is authenticated. */
    public var authenticated: Bool?
    /** Indicates the type of message platform from which the message originated. */
    public var type: ModelType?
    /** Indicates the country where the recipient is associated in ISO 3166-1 alpha-2 format. */
    public var recipientCountry: String?
    /** The type of the recipient. Eg: Provisioned phoneNumber is the recipient for sms message type. */
    public var recipientType: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** Address and name data for a call endpoint. */
    public var toAddress: Address?
    /** Address and name data for a call endpoint. */
    public var fromAddress: Address?
    /** The messages sent on this communication channel. */
    public var messages: [MessageDetails]?
    /** A subset of the Journey System's data relevant to a part of a conversation (for external linkage and internal usage/context). */
    public var journeyContext: JourneyContext?
    /** Call wrap up or disposition data. */
    public var wrapup: Wrapup?
    /** After-call work for the communication. */
    public var afterCallWork: AfterCallWork?
    /** Indicates if after-call work is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** UUID of virtual agent assistant that provide suggestions to the agent participant during the conversation. */
    public var agentAssistantId: String?
    /** The internal id representing the customer supplied sms integration message. */
    public var byoSmsIntegrationId: String?
    /** Represents the queue settings for this media type. */
    public var queueMediaSettings: ConversationQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _id: String?, held: Bool?, segments: [Segment]?, direction: Direction?, recordingId: String?, errorInfo: ErrorBody?, disconnectType: DisconnectType?, startHoldTime: Date?, startAlertingTime: Date?, connectedTime: Date?, disconnectedTime: Date?, provider: String?, authenticated: Bool?, type: ModelType?, recipientCountry: String?, recipientType: String?, scriptId: String?, peerId: String?, toAddress: Address?, fromAddress: Address?, messages: [MessageDetails]?, journeyContext: JourneyContext?, wrapup: Wrapup?, afterCallWork: AfterCallWork?, afterCallWorkRequired: Bool?, agentAssistantId: String?, byoSmsIntegrationId: String?, queueMediaSettings: ConversationQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.held = held
        self.segments = segments
        self.direction = direction
        self.recordingId = recordingId
        self.errorInfo = errorInfo
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.startAlertingTime = startAlertingTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.provider = provider
        self.authenticated = authenticated
        self.type = type
        self.recipientCountry = recipientCountry
        self.recipientType = recipientType
        self.scriptId = scriptId
        self.peerId = peerId
        self.toAddress = toAddress
        self.fromAddress = fromAddress
        self.messages = messages
        self.journeyContext = journeyContext
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.agentAssistantId = agentAssistantId
        self.byoSmsIntegrationId = byoSmsIntegrationId
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case held
        case segments
        case direction
        case recordingId
        case errorInfo
        case disconnectType
        case startHoldTime
        case startAlertingTime
        case connectedTime
        case disconnectedTime
        case provider
        case authenticated
        case type
        case recipientCountry
        case recipientType
        case scriptId
        case peerId
        case toAddress
        case fromAddress
        case messages
        case journeyContext
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case agentAssistantId
        case byoSmsIntegrationId
        case queueMediaSettings
    }


}




public class MessageConversation: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The list of participants involved in the conversation. */
    public var participants: [MessageMediaParticipant]?
    /** The list of other media channels involved in the conversation. */
    public var otherMediaUris: [String]?
    /** The list of the most recent 20 transfer commands applied to this conversation. */
    public var recentTransfers: [TransferResponse]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, participants: [MessageMediaParticipant]?, otherMediaUris: [String]?, recentTransfers: [TransferResponse]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
        self.recentTransfers = recentTransfers
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
        case recentTransfers
        case selfUri
    }


}




public class MessageDetails: Codable {





    public enum MessageStatus: String, Codable { 
        case queued = "queued"
        case sent = "sent"
        case failed = "failed"
        case received = "received"
        case deliverySuccess = "delivery-success"
        case deliveryFailed = "delivery-failed"
        case read = "read"
        case removed = "removed"
    }













    /** UUID identifying the message media. */
    public var messageId: String?
    /** A URI for this message entity. */
    public var messageURI: String?
    /** Indicates the delivery status of the message. */
    public var messageStatus: MessageStatus?
    /** The message segment count, greater than 1 if the message content was split into multiple parts for this message type, e.g. SMS character limits. */
    public var messageSegmentCount: Int?
    /** The time when the message was sent or received. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var messageTime: Date?
    /** The media (images, files, etc) associated with this message, if any */
    public var media: [MessageMedia]?
    /** One or more stickers associated with this message, if any */
    public var stickers: [MessageSticker]?
    /** Information that describes the content of the message, if any */
    public var messageMetadata: ConversationMessageMetadata?
    /** Provider specific error information for a communication. */
    public var errorInfo: ErrorBody?

    public init(messageId: String?, messageURI: String?, messageStatus: MessageStatus?, messageSegmentCount: Int?, messageTime: Date?, media: [MessageMedia]?, stickers: [MessageSticker]?, messageMetadata: ConversationMessageMetadata?, errorInfo: ErrorBody?) {
        self.messageId = messageId
        self.messageURI = messageURI
        self.messageStatus = messageStatus
        self.messageSegmentCount = messageSegmentCount
        self.messageTime = messageTime
        self.media = media
        self.stickers = stickers
        self.messageMetadata = messageMetadata
        self.errorInfo = errorInfo
    }


}




public class MessageMedia: Codable {











    /** The location of the media, useful for retrieving it */
    public var url: String?
    /** The optional internet media type of the the media object.  If null then the media type should be dictated by the url */
    public var mediaType: String?
    /** The optional content length of the the media object, in bytes. */
    public var contentLengthBytes: Int?
    /** The optional name of the the media object. */
    public var name: String?
    /** The optional id of the the media object. */
    public var _id: String?

    public init(url: String?, mediaType: String?, contentLengthBytes: Int?, name: String?, _id: String?) {
        self.url = url
        self.mediaType = mediaType
        self.contentLengthBytes = contentLengthBytes
        self.name = name
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case url
        case mediaType
        case contentLengthBytes
        case name
        case _id = "id"
    }


}




public class MessageSticker: Codable {





    /** The location of the sticker, useful for retrieving it */
    public var url: String?
    /** The unique id of the the sticker object. */
    public var _id: String?

    public init(url: String?, _id: String?) {
        self.url = url
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case url
        case _id = "id"
    }


}




public class MessagingCampaignDivisionView: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case selfUri
    }


}




public class MessagingCampaignSchedule: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Creation time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Last modified time of the entity. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Required for updates, must match the version number of the most recent update */
    public var version: Int?
    /** A list of intervals during which to run the associated Campaign. */
    public var intervals: [ScheduleInterval]?
    /** The time zone for this messaging campaign schedule. */
    public var timeZone: String?
    /** The Campaign that this messaging campaign schedule is for. */
    public var messagingCampaign: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, version: Int?, intervals: [ScheduleInterval]?, timeZone: String?, messagingCampaign: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.version = version
        self.intervals = intervals
        self.timeZone = timeZone
        self.messagingCampaign = messagingCampaign
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case version
        case intervals
        case timeZone
        case messagingCampaign
        case selfUri
    }


}




public class MessagingConfigListing: Codable {





















    public var entities: [MessagingSetting]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [MessagingSetting]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class MessagingIntegrationEntityListing: Codable {





















    public var entities: [MessagingIntegration]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [MessagingIntegration]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class MessagingSettingDefaultRequest: Codable {



    /** Messaging Setting ID to be used as the default for this Organization. */
    public var settingId: String?

    public init(settingId: String?) {
        self.settingId = settingId
    }


}



/** The messaging template identifies a structured message templates supported by a messaging channel. */

public class MessagingTemplate: Codable {



    /** Defines a messaging template for a WhatsApp messaging channel */
    public var whatsApp: WhatsAppDefinition?

    public init(whatsApp: WhatsAppDefinition?) {
        self.whatsApp = whatsApp
    }


}




public class MessagingTemplateRequest: Codable {





    /** A Response Management response identifier for a messaging template defined response */
    public var responseId: String?
    /** A list of Response Management response substitutions for the response's messaging template */
    public var parameters: [TemplateParameter]?

    public init(responseId: String?, parameters: [TemplateParameter]?) {
        self.responseId = responseId
        self.parameters = parameters
    }


}




public class MetaData: Codable {







    public var pairingToken: String?
    public var pairingTrust: [String]?
    public var pairingUrl: String?

    public init(pairingToken: String?, pairingTrust: [String]?, pairingUrl: String?) {
        self.pairingToken = pairingToken
        self.pairingTrust = pairingTrust
        self.pairingUrl = pairingUrl
    }

    public enum CodingKeys: String, CodingKey { 
        case pairingToken = "pairing-token"
        case pairingTrust = "pairing-trust"
        case pairingUrl = "pairing-url"
    }


}



/** A description of the contents of a data gathering interface for an accelerator */

public class MetadataSchema: Codable {











    /** title for the data gathering page */
    public var title: String?
    /** description of the data being gathered on this page */
    public var _description: String?
    /** type of data being gathered */
    public var type: String?
    /** list of properties for which input is to be gathered, bother required and optional */
    public var properties: [[String:JSON]]?
    /** list of required properties */
    public var _required: [String]?

    public init(title: String?, _description: String?, type: String?, properties: [[String:JSON]]?, _required: [String]?) {
        self.title = title
        self._description = _description
        self.type = type
        self.properties = properties
        self._required = _required
    }

    public enum CodingKeys: String, CodingKey { 
        case title
        case _description = "description"
        case type
        case properties
        case _required = "required"
    }


}




public class MetricValueTrendAverage: Codable {



















    /** The targeted start workday. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStartWorkday: Date?
    /** The targeted end workday. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEndWorkday: Date?
    /** The targeted reference workday. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateReferenceWorkday: Date?
    /** The targeted division for the metrics */
    public var division: Division?
    /** The targeted user for the metrics */
    public var user: UserReference?
    /** The time zone used for aggregating metric values */
    public var timezone: String?
    /** The metric value trend and average */
    public var result: WorkdayValuesMetricItem?
    /** The targeted performance profile for the average points */
    public var performanceProfile: AddressableEntityRef?
    /** The targeted performance profile for the average points */
    public var metric: AddressableEntityRef?

    public init(dateStartWorkday: Date?, dateEndWorkday: Date?, dateReferenceWorkday: Date?, division: Division?, user: UserReference?, timezone: String?, result: WorkdayValuesMetricItem?, performanceProfile: AddressableEntityRef?, metric: AddressableEntityRef?) {
        self.dateStartWorkday = dateStartWorkday
        self.dateEndWorkday = dateEndWorkday
        self.dateReferenceWorkday = dateReferenceWorkday
        self.division = division
        self.user = user
        self.timezone = timezone
        self.result = result
        self.performanceProfile = performanceProfile
        self.metric = metric
    }


}




public class MinedIntentsListing: Codable {









    public var entities: [MinerIntent]?
    public var nextUri: String?
    public var selfUri: String?
    public var previousUri: String?

    public init(entities: [MinerIntent]?, nextUri: String?, selfUri: String?, previousUri: String?) {
        self.entities = entities
        self.nextUri = nextUri
        self.selfUri = selfUri
        self.previousUri = previousUri
    }


}




public class MinerTopicPhrase: Codable {













    /** The globally unique identifier for the object. */
    public var _id: String?
    /** Phrase name. */
    public var name: String?
    /** Topic associated with a phrase. */
    public var topic: MinerTopic?
    /** List of utterances related to a phrase. */
    public var utterances: [Utterance]?
    /** Number of utterances belonging to a phrase */
    public var utteranceCount: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, topic: MinerTopic?, utterances: [Utterance]?, utteranceCount: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.topic = topic
        self.utterances = utterances
        self.utteranceCount = utteranceCount
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case topic
        case utterances
        case utteranceCount
        case selfUri
    }


}



/** Contains information about a response. */

public class ModelResponse: Codable {















    public enum InteractionType: String, Codable { 
        case chat = "chat"
        case email = "email"
        case twitter = "twitter"
    }





    public enum ResponseType: String, Codable { 
        case messagingTemplate = "MessagingTemplate"
        case campaignSmsTemplate = "CampaignSmsTemplate"
        case campaignEmailTemplate = "CampaignEmailTemplate"
        case footer = "Footer"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Version number required for updates. */
    public var version: Int?
    /** One or more libraries response is associated with. */
    public var libraries: [DomainEntityRef]?
    /** One or more texts associated with the response. */
    public var texts: [ResponseText]?
    /** User that created the response */
    public var createdBy: User?
    /** The date and time the response was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The interaction type for this response. */
    public var interactionType: InteractionType?
    /** Details about any text substitutions used in the texts for this response. */
    public var substitutions: [ResponseSubstitution]?
    /** Metadata about the text substitutions in json schema format. */
    public var substitutionsSchema: JsonSchemaDocument?
    /** The response type represented by the response. */
    public var responseType: ResponseType?
    /** An optional messaging template definition for responseType.MessagingTemplate. */
    public var messagingTemplate: MessagingTemplate?
    /** Assets used in the response */
    public var assets: [AddressableEntityRef]?
    /** Footer template definition for responseType.Footer. */
    public var footer: FooterTemplate?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, version: Int?, libraries: [DomainEntityRef]?, texts: [ResponseText]?, createdBy: User?, dateCreated: Date?, interactionType: InteractionType?, substitutions: [ResponseSubstitution]?, substitutionsSchema: JsonSchemaDocument?, responseType: ResponseType?, messagingTemplate: MessagingTemplate?, assets: [AddressableEntityRef]?, footer: FooterTemplate?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.version = version
        self.libraries = libraries
        self.texts = texts
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.interactionType = interactionType
        self.substitutions = substitutions
        self.substitutionsSchema = substitutionsSchema
        self.responseType = responseType
        self.messagingTemplate = messagingTemplate
        self.assets = assets
        self.footer = footer
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case version
        case libraries
        case texts
        case createdBy
        case dateCreated
        case interactionType
        case substitutions
        case substitutionsSchema
        case responseType
        case messagingTemplate
        case assets
        case footer
        case selfUri
    }


}




public class MoveAgentResponse: Codable {



    public enum Result: String, Codable { 
        case alreadyMoved = "AlreadyMoved"
        case destinationBusinessUnitAgentLimitExceeded = "DestinationBusinessUnitAgentLimitExceeded"
        case destinationManagementUnitAgentLimitExceeded = "DestinationManagementUnitAgentLimitExceeded"
        case destinationManagementUnitDoesNotExist = "DestinationManagementUnitDoesNotExist"
        case moveSuccessful = "MoveSuccessful"
        case movingToDifferentManagementUnit = "MovingToDifferentManagementUnit"
        case nothingToDo = "NothingToDo"
        case sourceManagementUnitNotAuthorized = "SourceManagementUnitNotAuthorized"
    }

    /** The user associated with the move */
    public var user: UserReference?
    /** The result of the move */
    public var result: Result?

    public init(user: UserReference?, result: Result?) {
        self.user = user
        self.result = result
    }


}




public class MoveAgentsResponse: Codable {







    /** The user that made the request */
    public var requestingUser: UserReference?
    /** The management unit specified on the request */
    public var destinationManagementUnit: ManagementUnitReference?
    /** The list containing the agent and result of the move operation */
    public var results: [MoveAgentResponse]?

    public init(requestingUser: UserReference?, destinationManagementUnit: ManagementUnitReference?, results: [MoveAgentResponse]?) {
        self.requestingUser = requestingUser
        self.destinationManagementUnit = destinationManagementUnit
        self.results = results
    }


}




public class MoveManagementUnitRequest: Codable {



    /** The ID of the business unit to which to move the management unit */
    public var businessUnitId: String?

    public init(businessUnitId: String?) {
        self.businessUnitId = businessUnitId
    }


}




public class NamedEntityTypeBinding: Codable {





    /** The named entity type of the binding. It can be a built-in one such as builtin:number or a custom entity type such as BeverageType. */
    public var entityType: String?
    /** The name that this named entity type is bound to. */
    public var entityName: String?

    public init(entityType: String?, entityName: String?) {
        self.entityType = entityType
        self.entityName = entityName
    }


}




public class NamedEntityTypeItem: Codable {







    /** A value for an named entity type definition. */
    public var value: String?
    /** Synonyms for the given named entity value. */
    public var synonyms: [String]?
    /** Additional Language Synonyms for the given named entity value. */
    public var additionalLanguages: [String:AdditionalLanguagesSynonyms]?

    public init(value: String?, synonyms: [String]?, additionalLanguages: [String:AdditionalLanguagesSynonyms]?) {
        self.value = value
        self.synonyms = synonyms
        self.additionalLanguages = additionalLanguages
    }


}




public class NluInfo: Codable {











    public var domain: AddressableEntityRef?
    public var version: NluDomainVersion?
    public var intents: [Intent]?
    public var engineVersion: String?
    public var nluData: NluDomainVersion?

    public init(domain: AddressableEntityRef?, version: NluDomainVersion?, intents: [Intent]?, engineVersion: String?, nluData: NluDomainVersion?) {
        self.domain = domain
        self.version = version
        self.intents = intents
        self.engineVersion = engineVersion
        self.nluData = nluData
    }


}




public class NluQualityReportSummary: Codable {



    /** The list of metrics in the summary */
    public var metrics: [NluQualityReportSummaryMetric]?

    public init(metrics: [NluQualityReportSummaryMetric]?) {
        self.metrics = metrics
    }


}



/** Model for a Nuance bot credentials */

public class NuanceBotCredentials: Codable {









    /** The application ID */
    public var appId: String?
    /** The credentials client ID */
    public var clientId: String?
    /** The credentials client secret */
    public var clientSecret: String?
    /** True if the credentials secret is set (but not returned due to security reasons) */
    public var clientSecretProvided: Bool?

    public init(appId: String?, clientId: String?, clientSecret: String?, clientSecretProvided: Bool?) {
        self.appId = appId
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.clientSecretProvided = clientSecretProvided
    }


}



/** Model for a Nuance channel */

public class NuanceChannel: Codable {









    /** The channel ID */
    public var _id: String?
    /** The channel name */
    public var name: String?
    /** Supported Channel Modes */
    public var modes: [String]?
    /** The Channel Color */
    public var color: String?

    public init(_id: String?, name: String?, modes: [String]?, color: String?) {
        self._id = _id
        self.name = name
        self.modes = modes
        self.color = color
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case modes
        case color
    }


}




public class OAuthAuthorization: Codable {



















    public enum State: String, Codable { 
        case unauthorized = "Unauthorized"
        case requested = "Requested"
        case authorized = "Authorized"
        case revoked = "Revoked"
    }



    public var client: OAuthClient?
    public var scope: [String]?
    public var roles: [String]?
    public var resourceOwner: DomainEntityRef?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    public var createdBy: DomainEntityRef?
    public var modifiedBy: DomainEntityRef?
    public var pending: Bool?
    public var state: State?
    /** The URI for this object */
    public var selfUri: String?

    public init(client: OAuthClient?, scope: [String]?, roles: [String]?, resourceOwner: DomainEntityRef?, dateCreated: Date?, dateModified: Date?, createdBy: DomainEntityRef?, modifiedBy: DomainEntityRef?, pending: Bool?, state: State?, selfUri: String?) {
        self.client = client
        self.scope = scope
        self.roles = roles
        self.resourceOwner = resourceOwner
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.pending = pending
        self.state = state
        self.selfUri = selfUri
    }


}




public class OAuthAuthorizationListing: Codable {







    public var total: Int64?
    public var entities: [OAuthAuthorization]?
    public var selfUri: String?

    public init(total: Int64?, entities: [OAuthAuthorization]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class OAuthLastTokenIssued: Codable {



    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateIssued: Date?

    public init(dateIssued: Date?) {
        self.dateIssued = dateIssued
    }


}




public class ObservationMetricData: Codable {











    public var metric: String?
    public var qualifier: String?
    public var stats: StatisticalSummary?
    /** Flag for a truncated list of observations. If truncated, the first half of the list of observations will contain the oldest observations and the second half the newest observations. */
    public var truncated: Bool?
    /** List of observations sorted by timestamp in ascending order. This list may be truncated. */
    public var observations: [ObservationValue]?

    public init(metric: String?, qualifier: String?, stats: StatisticalSummary?, truncated: Bool?, observations: [ObservationValue]?) {
        self.metric = metric
        self.qualifier = qualifier
        self.stats = stats
        self.truncated = truncated
        self.observations = observations
    }


}




public class Okta: Codable {























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var disabled: Bool?
    public var issuerURI: String?
    public var ssoTargetURI: String?
    public var sloURI: String?
    public var sloBinding: String?
    public var relyingPartyIdentifier: String?
    public var certificate: String?
    public var certificates: [String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, disabled: Bool?, issuerURI: String?, ssoTargetURI: String?, sloURI: String?, sloBinding: String?, relyingPartyIdentifier: String?, certificate: String?, certificates: [String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.disabled = disabled
        self.issuerURI = issuerURI
        self.ssoTargetURI = ssoTargetURI
        self.sloURI = sloURI
        self.sloBinding = sloBinding
        self.relyingPartyIdentifier = relyingPartyIdentifier
        self.certificate = certificate
        self.certificates = certificates
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case disabled
        case issuerURI
        case ssoTargetURI
        case sloURI
        case sloBinding
        case relyingPartyIdentifier
        case certificate
        case certificates
        case selfUri
    }


}



/** Open Channel-specific information that describes the message and the message channel/provider. */

public class OpenInboundMessagingChannel: Codable {





    /** Information about the recipient the message is received from. */
    public var from: OpenMessagingFromRecipient?
    /** Original time of the event. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var time: Date?

    public init(from: OpenMessagingFromRecipient?, time: Date?) {
        self.from = from
        self.time = time
    }


}




public class OpenIntegrationUpdateRequest: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the Open messaging integration. */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    /** Defines the message settings to be applied for this integration */
    public var messagingSetting: MessagingSettingRequestReference?
    /** The outbound notification webhook URL for the Open messaging integration. */
    public var outboundNotificationWebhookUrl: String?
    /** The outbound notification webhook signature secret token. */
    public var outboundNotificationWebhookSignatureSecretToken: String?
    /** The user specified headers for the Open messaging integration. */
    public var webhookHeaders: [String:String]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingRequestReference?, outboundNotificationWebhookUrl: String?, outboundNotificationWebhookSignatureSecretToken: String?, webhookHeaders: [String:String]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.outboundNotificationWebhookUrl = outboundNotificationWebhookUrl
        self.outboundNotificationWebhookSignatureSecretToken = outboundNotificationWebhookSignatureSecretToken
        self.webhookHeaders = webhookHeaders
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case outboundNotificationWebhookUrl
        case outboundNotificationWebhookSignatureSecretToken
        case webhookHeaders
        case selfUri
    }


}



/** Information about the recipient the message is sent to. */

public class OpenMessagingToRecipient: Codable {





    public enum IdType: String, Codable { 
        case email = "Email"
        case phone = "Phone"
        case opaque = "Opaque"
    }









    /** Nickname or display name of the recipient. */
    public var nickname: String?
    /** The recipient ID specific to the provider. */
    public var _id: String?
    /** The recipient ID type. This is used to indicate the format used for the ID. */
    public var idType: IdType?
    /** First name of the recipient. */
    public var firstName: String?
    /** Last name of the recipient. */
    public var lastName: String?
    /** URL of an image that represents the recipient. */
    public var image: String?
    /** E-mail address of the recipient. */
    public var email: String?

    public init(nickname: String?, _id: String?, idType: IdType?, firstName: String?, lastName: String?, image: String?, email: String?) {
        self.nickname = nickname
        self._id = _id
        self.idType = idType
        self.firstName = firstName
        self.lastName = lastName
        self.image = image
        self.email = email
    }

    public enum CodingKeys: String, CodingKey { 
        case nickname
        case _id = "id"
        case idType
        case firstName
        case lastName
        case image
        case email
    }


}




public class OperationalEventNotificationTopicOperationalEventNotification: Codable {























    public var eventEntity: OperationalEventNotificationTopicEventEntity?
    public var entityId: String?
    public var entityName: String?
    public var previousValue: String?
    public var currentValue: String?
    public var errorCode: String?
    public var version: String?
    public var parentEntity: String?
    public var entityType: String?
    public var conversationId: String?
    public var timestamp: Int?

    public init(eventEntity: OperationalEventNotificationTopicEventEntity?, entityId: String?, entityName: String?, previousValue: String?, currentValue: String?, errorCode: String?, version: String?, parentEntity: String?, entityType: String?, conversationId: String?, timestamp: Int?) {
        self.eventEntity = eventEntity
        self.entityId = entityId
        self.entityName = entityName
        self.previousValue = previousValue
        self.currentValue = currentValue
        self.errorCode = errorCode
        self.version = version
        self.parentEntity = parentEntity
        self.entityType = entityType
        self.conversationId = conversationId
        self.timestamp = timestamp
    }


}




public class OptInSettings: Codable {





    /** List of keywords for compliance */
    public var keyword: [String]?
    /** The response configuration for the keywords */
    public var response: ComplianceResponse?

    public init(keyword: [String]?, response: ComplianceResponse?) {
        self.keyword = keyword
        self.response = response
    }


}




public class OrgOAuthClient: Codable {













    public enum AuthorizedGrantType: String, Codable { 
        case code = "CODE"
        case token = "TOKEN"
        case saml2Bearer = "SAML2-BEARER"
        case password = "PASSWORD"
        case clientCredentials = "CLIENT-CREDENTIALS"
    }





    public enum State: String, Codable { 
        case active = "active"
        case disabled = "disabled"
        case inactive = "inactive"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the OAuth client. */
    public var name: String?
    /** Date this client was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date this client was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** User that created this client */
    public var createdBy: DomainEntityRef?
    /** User that last modified this client */
    public var modifiedBy: DomainEntityRef?
    /** The OAuth Grant/Client type supported by this client. Code Authorization Grant/Client type - Preferred client type where the Client ID and Secret are required to create tokens. Used where the secret can be secured. PKCE-Enabled Code Authorization grant type - Code grant type which requires PKCE challenge and verifier to create tokens. Used in public clients for increased security. Implicit grant type - Client ID only is required to create tokens. Used in browser and mobile apps where the secret can not be secured. SAML2-Bearer extension grant type - SAML2 assertion provider for user authentication at the token endpoint. Client Credential grant type - Used to created access tokens that are tied only to the client.  */
    public var authorizedGrantType: AuthorizedGrantType?
    /** The scope requested by this client. Scopes only apply to clients not using the client_credential grant */
    public var scope: [String]?
    /** Set of roles and their corresponding divisions associated with this client. Roles and divisions only apply to clients using the client_credential grant */
    public var roleDivisions: [RoleDivision]?
    /** The state of the OAuth client. Active: The OAuth client can be used to create access tokens. This is the default state. Disabled: Access tokens created by the client are invalid and new ones cannot be created. Inactive: Access tokens cannot be created with this OAuth client and it will be deleted. */
    public var state: State?
    /** The time at which this client will be deleted. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateToDelete: Date?
    /** The  oauth client's organization. */
    public var organization: NamedEntity?

    public init(_id: String?, name: String?, dateCreated: Date?, dateModified: Date?, createdBy: DomainEntityRef?, modifiedBy: DomainEntityRef?, authorizedGrantType: AuthorizedGrantType?, scope: [String]?, roleDivisions: [RoleDivision]?, state: State?, dateToDelete: Date?, organization: NamedEntity?) {
        self._id = _id
        self.name = name
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.authorizedGrantType = authorizedGrantType
        self.scope = scope
        self.roleDivisions = roleDivisions
        self.state = state
        self.dateToDelete = dateToDelete
        self.organization = organization
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case dateCreated
        case dateModified
        case createdBy
        case modifiedBy
        case authorizedGrantType
        case scope
        case roleDivisions
        case state
        case dateToDelete
        case organization
    }


}




public class Organization: Codable {

















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }







    public enum ProductPlatform: String, Codable { 
        case genesysCloud = "GenesysCloud"
        case pureCloud = "PureCloud"
        case pureEngage = "PureEngage"
        case pureEngageCloud = "PureEngageCloud"
        case pureConnect = "PureConnect"
        case pureConnectCloud = "PureConnectCloud"
        case unknown = "Unknown"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The default language for this organization. Example: 'en' */
    public var defaultLanguage: String?
    /** The default country code for this organization. Example: 'US' */
    public var defaultCountryCode: String?
    /** The short name for the organization. This field is globally unique and cannot be changed. */
    public var thirdPartyOrgName: String?
    public var thirdPartyURI: String?
    public var domain: String?
    /** The current version of the organization. */
    public var version: Int?
    /** The current state. Examples are active, inactive, deleted. */
    public var state: State?
    public var defaultSiteId: String?
    /** Email address where support tickets are sent to. */
    public var supportURI: String?
    public var voicemailEnabled: Bool?
    /** Organizations Originating Platform. */
    public var productPlatform: ProductPlatform?
    /** The URI for this object */
    public var selfUri: String?
    /** The state of features available for the organization. */
    public var features: [String:Bool]?

    public init(_id: String?, name: String?, defaultLanguage: String?, defaultCountryCode: String?, thirdPartyOrgName: String?, thirdPartyURI: String?, domain: String?, version: Int?, state: State?, defaultSiteId: String?, supportURI: String?, voicemailEnabled: Bool?, productPlatform: ProductPlatform?, selfUri: String?, features: [String:Bool]?) {
        self._id = _id
        self.name = name
        self.defaultLanguage = defaultLanguage
        self.defaultCountryCode = defaultCountryCode
        self.thirdPartyOrgName = thirdPartyOrgName
        self.thirdPartyURI = thirdPartyURI
        self.domain = domain
        self.version = version
        self.state = state
        self.defaultSiteId = defaultSiteId
        self.supportURI = supportURI
        self.voicemailEnabled = voicemailEnabled
        self.productPlatform = productPlatform
        self.selfUri = selfUri
        self.features = features
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case defaultLanguage
        case defaultCountryCode
        case thirdPartyOrgName
        case thirdPartyURI
        case domain
        case version
        case state
        case defaultSiteId
        case supportURI
        case voicemailEnabled
        case productPlatform
        case selfUri
        case features
    }


}




public class OtherProfileAssignment: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The current performance profile that this user belongs to */
    public var currentProfile: DomainEntityRef?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, currentProfile: DomainEntityRef?, selfUri: String?) {
        self._id = _id
        self.currentProfile = currentProfile
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case currentProfile
        case selfUri
    }


}




public class OutboundDetailEventTopicOutboundInitEvent: Codable {









    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
    }



    public enum Direction: String, Codable { 
        case unknown = "UNKNOWN"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }











    public enum MessageType: String, Codable { 
        case unknown = "UNKNOWN"
        case sms = "SMS"
        case twitter = "TWITTER"
        case facebook = "FACEBOOK"
        case line = "LINE"
        case whatsapp = "WHATSAPP"
        case webmessaging = "WEBMESSAGING"
        case _open = "OPEN"
        case instagram = "INSTAGRAM"
    }













    public var eventTime: Int?
    public var conversationId: String?
    public var participantId: String?
    public var sessionId: String?
    public var mediaType: MediaType?
    public var provider: String?
    public var direction: Direction?
    public var ani: String?
    public var dnis: String?
    public var addressTo: String?
    public var addressFrom: String?
    public var subject: String?
    public var messageType: MessageType?
    public var outboundCampaignId: String?
    public var divisionId: String?
    public var outboundContactListId: String?
    public var outboundContactId: String?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?

    public init(eventTime: Int?, conversationId: String?, participantId: String?, sessionId: String?, mediaType: MediaType?, provider: String?, direction: Direction?, ani: String?, dnis: String?, addressTo: String?, addressFrom: String?, subject: String?, messageType: MessageType?, outboundCampaignId: String?, divisionId: String?, outboundContactListId: String?, outboundContactId: String?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.sessionId = sessionId
        self.mediaType = mediaType
        self.provider = provider
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.addressTo = addressTo
        self.addressFrom = addressFrom
        self.subject = subject
        self.messageType = messageType
        self.outboundCampaignId = outboundCampaignId
        self.divisionId = divisionId
        self.outboundContactListId = outboundContactListId
        self.outboundContactId = outboundContactId
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
    }


}




public class OutboundMessagingCampaignPostContactEmailEventTopicOutboundMessagingCampaignPostContactEmailEvent: Codable {





    public enum OutboundCampaignType: String, Codable { 
        case unknown = "UNKNOWN"
        case email = "EMAIL"
        case sms = "SMS"
    }



    public enum WrapupCode: String, Codable { 
        case unknown = "UNKNOWN"
        case outboundMessageSent = "OUTBOUND_MESSAGE_SENT"
        case outboundMessageFailed = "OUTBOUND_MESSAGE_FAILED"
        case outboundMessageThrottled = "OUTBOUND_MESSAGE_THROTTLED"
    }













    public var eventTime: Date?
    public var conversationId: String?
    public var outboundCampaignType: OutboundCampaignType?
    public var emailAttributes: OutboundMessagingCampaignPostContactEmailEventTopicEmailAttributes?
    public var wrapupCode: WrapupCode?
    public var outboundCampaignId: String?
    public var divisionId: String?
    public var contentTemplateId: String?
    public var outboundContactListId: String?
    public var outboundContactId: String?
    public var isCampaignAlwaysRunning: Bool?

    public init(eventTime: Date?, conversationId: String?, outboundCampaignType: OutboundCampaignType?, emailAttributes: OutboundMessagingCampaignPostContactEmailEventTopicEmailAttributes?, wrapupCode: WrapupCode?, outboundCampaignId: String?, divisionId: String?, contentTemplateId: String?, outboundContactListId: String?, outboundContactId: String?, isCampaignAlwaysRunning: Bool?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.outboundCampaignType = outboundCampaignType
        self.emailAttributes = emailAttributes
        self.wrapupCode = wrapupCode
        self.outboundCampaignId = outboundCampaignId
        self.divisionId = divisionId
        self.contentTemplateId = contentTemplateId
        self.outboundContactListId = outboundContactListId
        self.outboundContactId = outboundContactId
        self.isCampaignAlwaysRunning = isCampaignAlwaysRunning
    }


}




public class OutboundMessagingCampaignPreContactEmailEventTopicEmailAttributes: Codable {











    public var emailSubject: String?
    public var configuredEmailAddress: String?
    public var contactEmailAddress: String?
    public var replyToAddress: String?
    public var contactEmailColumnName: String?

    public init(emailSubject: String?, configuredEmailAddress: String?, contactEmailAddress: String?, replyToAddress: String?, contactEmailColumnName: String?) {
        self.emailSubject = emailSubject
        self.configuredEmailAddress = configuredEmailAddress
        self.contactEmailAddress = contactEmailAddress
        self.replyToAddress = replyToAddress
        self.contactEmailColumnName = contactEmailColumnName
    }


}




public class OutboundMessagingCampaignPreContactSmsEventTopicOutboundMessagingCampaignPreContactSMSEvent: Codable {



    public enum OutboundCampaignType: String, Codable { 
        case unknown = "UNKNOWN"
        case email = "EMAIL"
        case sms = "SMS"
    }



    public enum WrapupCode: String, Codable { 
        case unknown = "UNKNOWN"
        case ininOutboundNumbersInvalid = "ININ_OUTBOUND_NUMBERS_INVALID"
        case ininOutboundContactAttemptLimitSkipped = "ININ_OUTBOUND_CONTACT_ATTEMPT_LIMIT_SKIPPED"
        case ininOutboundInternalErrorSkipped = "ININ_OUTBOUND_INTERNAL_ERROR_SKIPPED"
        case ininOutboundDncSkipped = "ININ_OUTBOUND_DNC_SKIPPED"
        case ininOutboundZoneBlockedSkipped = "ININ_OUTBOUND_ZONE_BLOCKED_SKIPPED"
        case outboundMessageBlank = "OUTBOUND_MESSAGE_BLANK"
        case outboundRuleErrorSkipped = "OUTBOUND_RULE_ERROR_SKIPPED"
        case outboundRuleSkipped = "OUTBOUND_RULE_SKIPPED"
        case outboundContactUncontactableSkipped = "OUTBOUND_CONTACT_UNCONTACTABLE_SKIPPED"
        case outboundNumberUncontactableSkipped = "OUTBOUND_NUMBER_UNCONTACTABLE_SKIPPED"
        case outboundContactAddressUncontactableSkipped = "OUTBOUND_CONTACT_ADDRESS_UNCONTACTABLE_SKIPPED"
        case outboundInvalidPhoneNumber = "OUTBOUND_INVALID_PHONE_NUMBER"
        case ininOutboundDncAuthenticationFailed = "ININ_OUTBOUND_DNC_AUTHENTICATION_FAILED"
        case ininOutboundDncInvalidPhoneNumber = "ININ_OUTBOUND_DNC_INVALID_PHONE_NUMBER"
        case ininOutboundAutomaticTimezoneBlocked = "ININ_OUTBOUND_AUTOMATIC_TIMEZONE_BLOCKED"
        case ininOutboundNumberAttemptLimitSkipped = "ININ_OUTBOUND_NUMBER_ATTEMPT_LIMIT_SKIPPED"
        case ininOutboundOnDoNotCallList = "ININ_OUTBOUND_ON_DO_NOT_CALL_LIST"
        case ininOutboundNotCallableTime = "ININ_OUTBOUND_NOT_CALLABLE_TIME"
    }













    public var eventTime: Date?
    public var outboundCampaignType: OutboundCampaignType?
    public var smsAttributes: OutboundMessagingCampaignPreContactSmsEventTopicSMSAttributes?
    public var wrapupCode: WrapupCode?
    public var outboundCampaignId: String?
    public var divisionId: String?
    public var contentTemplateId: String?
    public var outboundContactListId: String?
    public var outboundContactId: String?
    public var isCampaignAlwaysRunning: Bool?

    public init(eventTime: Date?, outboundCampaignType: OutboundCampaignType?, smsAttributes: OutboundMessagingCampaignPreContactSmsEventTopicSMSAttributes?, wrapupCode: WrapupCode?, outboundCampaignId: String?, divisionId: String?, contentTemplateId: String?, outboundContactListId: String?, outboundContactId: String?, isCampaignAlwaysRunning: Bool?) {
        self.eventTime = eventTime
        self.outboundCampaignType = outboundCampaignType
        self.smsAttributes = smsAttributes
        self.wrapupCode = wrapupCode
        self.outboundCampaignId = outboundCampaignId
        self.divisionId = divisionId
        self.contentTemplateId = contentTemplateId
        self.outboundContactListId = outboundContactListId
        self.outboundContactId = outboundContactId
        self.isCampaignAlwaysRunning = isCampaignAlwaysRunning
    }


}




public class OutboundRouteBase: Codable {



















    public enum State: String, Codable { 
        case active = "active"
        case inactive = "inactive"
        case deleted = "deleted"
    }









    public enum Distribution: String, Codable { 
        case sequential = "SEQUENTIAL"
        case random = "RANDOM"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the entity. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** The resource's description. */
    public var _description: String?
    /** The current version of the resource. */
    public var version: Int?
    /** The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The ID of the user that last modified the resource. */
    public var modifiedBy: String?
    /** The ID of the user that created the resource. */
    public var createdBy: String?
    /** Indicates if the resource is active, inactive, or deleted. */
    public var state: State?
    /** The application that last modified the resource. */
    public var modifiedByApp: String?
    /** The application that created the resource. */
    public var createdByApp: String?
    /** The site associated to the outbound route. */
    public var classificationTypes: [String]?
    public var enabled: Bool?
    public var distribution: Distribution?
    /** Trunk base settings of trunkType \"EXTERNAL\".  This base must also be set on an edge logical interface for correct routing. */
    public var externalTrunkBases: [DomainEntityRef]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, version: Int?, dateCreated: Date?, dateModified: Date?, modifiedBy: String?, createdBy: String?, state: State?, modifiedByApp: String?, createdByApp: String?, classificationTypes: [String]?, enabled: Bool?, distribution: Distribution?, externalTrunkBases: [DomainEntityRef]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.version = version
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.createdBy = createdBy
        self.state = state
        self.modifiedByApp = modifiedByApp
        self.createdByApp = createdByApp
        self.classificationTypes = classificationTypes
        self.enabled = enabled
        self.distribution = distribution
        self.externalTrunkBases = externalTrunkBases
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case version
        case dateCreated
        case dateModified
        case modifiedBy
        case createdBy
        case state
        case modifiedByApp
        case createdByApp
        case classificationTypes
        case enabled
        case distribution
        case externalTrunkBases
        case selfUri
    }


}




public class OutcomeScoresResult: Codable {





    /** List of scored outcomes in the session. */
    public var outcomeScores: [OutcomeScore]?
    /** Timestamp indicating the last time that the event was scored. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?

    public init(outcomeScores: [OutcomeScore]?, modifiedDate: Date?) {
        self.outcomeScores = outcomeScores
        self.modifiedDate = modifiedDate
    }


}




public class OverallBestPointsItem: Codable {

    public enum GranularityType: String, Codable { 
        case daily = "Daily"
        case weekly = "Weekly"
        case monthly = "Monthly"
    }











    /** Best points aggregation interval granularity */
    public var granularityType: GranularityType?
    /** List of associated users with the equal points. */
    public var users: [UserReference]?
    /** The count of the user IDs in the list */
    public var count: Int?
    /** Gamification points */
    public var points: Int?
    /** Start workday of the best points aggregation interval. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStartWorkday: Date?
    /** End workday of the best points aggregation interval. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEndWorkday: Date?

    public init(granularityType: GranularityType?, users: [UserReference]?, count: Int?, points: Int?, dateStartWorkday: Date?, dateEndWorkday: Date?) {
        self.granularityType = granularityType
        self.users = users
        self.count = count
        self.points = points
        self.dateStartWorkday = dateStartWorkday
        self.dateEndWorkday = dateEndWorkday
    }


}




public class PINConfiguration: Codable {





    public var minimumLength: Int?
    public var maximumLength: Int?

    public init(minimumLength: Int?, maximumLength: Int?) {
        self.minimumLength = minimumLength
        self.maximumLength = maximumLength
    }


}




public class Parameter: Codable {



    public enum ParameterType: String, Codable { 
        case uuid = "UUID"
        case string = "STRING"
        case uuidlist = "UUIDLIST"
        case stringlist = "STRINGLIST"
    }

    public enum Domain: String, Codable { 
        case userid = "USERID"
        case queueid = "QUEUEID"
        case mediatype = "MEDIATYPE"
        case dialercampaignid = "DIALERCAMPAIGNID"
        case qmevalformid = "QMEVALFORMID"
        case unknown = "UNKNOWN"
    }



    public var name: String?
    public var parameterType: ParameterType?
    public var domain: Domain?
    public var _required: Bool?

    public init(name: String?, parameterType: ParameterType?, domain: Domain?, _required: Bool?) {
        self.name = name
        self.parameterType = parameterType
        self.domain = domain
        self._required = _required
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case parameterType
        case domain
        case _required = "required"
    }


}




public class ParticipantAttributes: Codable {



    /** The map of attribute keys to values. */
    public var attributes: [String:String]?

    public init(attributes: [String:String]?) {
        self.attributes = attributes
    }


}




public class PatchBuReschedulingOptionsManagementUnitRequest: Codable {





    /** The management unit portion of the rescheduling run to update */
    public var managementUnitId: String?
    /** Whether to mark the run as applied.  Only applies to reschedule runs.  Once applied, a run cannot be un-marked as applied */
    public var applied: Bool?

    public init(managementUnitId: String?, applied: Bool?) {
        self.managementUnitId = managementUnitId
        self.applied = applied
    }


}




public class PatchCallbackResponse: Codable {





    /** The conversation associated with the callback */
    public var conversation: DomainEntityRef?
    /** The list of communication identifiers for the callback participants */
    public var callbackIdentifiers: [CallbackIdentifier]?

    public init(conversation: DomainEntityRef?, callbackIdentifiers: [CallbackIdentifier]?) {
        self.conversation = conversation
        self.callbackIdentifiers = callbackIdentifiers
    }


}




public class PatchContentOfferStylingConfiguration: Codable {















    /** Properties for customizing the positioning of the content offer. */
    public var position: PatchContentPositionProperties?
    /** Properties for customizing the appearance of the content offer. */
    public var offer: PatchContentOfferStyleProperties?
    /** Properties for customizing the appearance of the close button. */
    public var closeButton: PatchCloseButtonStyleProperties?
    /** Properties for customizing the appearance of the CTA button. */
    public var ctaButton: PatchCtaButtonStyleProperties?
    /** Properties for customizing the appearance of the title text. */
    public var title: PatchTextStyleProperties?
    /** Properties for customizing the appearance of the headline text. */
    public var headline: PatchTextStyleProperties?
    /** Properties for customizing the appearance of the body text. */
    public var body: PatchTextStyleProperties?

    public init(position: PatchContentPositionProperties?, offer: PatchContentOfferStyleProperties?, closeButton: PatchCloseButtonStyleProperties?, ctaButton: PatchCtaButtonStyleProperties?, title: PatchTextStyleProperties?, headline: PatchTextStyleProperties?, body: PatchTextStyleProperties?) {
        self.position = position
        self.offer = offer
        self.closeButton = closeButton
        self.ctaButton = ctaButton
        self.title = title
        self.headline = headline
        self.body = body
    }


}




public class PatchContentPositionProperties: Codable {









    /** Top positioning offset. */
    public var top: String?
    /** Bottom positioning offset. */
    public var bottom: String?
    /** Left positioning offset. */
    public var _left: String?
    /** Right positioning offset. */
    public var _right: String?

    public init(top: String?, bottom: String?, _left: String?, _right: String?) {
        self.top = top
        self.bottom = bottom
        self._left = _left
        self._right = _right
    }

    public enum CodingKeys: String, CodingKey { 
        case top
        case bottom
        case _left = "left"
        case _right = "right"
    }


}




public class PatchExternalSegment: Codable {



    /** Name for the external segment in the system where it originates from. */
    public var name: String?

    public init(name: String?) {
        self.name = name
    }


}




public class PatchJourney: Codable {



    /** A list of zero or more patterns to match. */
    public var patterns: [PatchJourneyPattern]?

    public init(patterns: [PatchJourneyPattern]?) {
        self.patterns = patterns
    }


}




public class PatchSegment: Codable {





















    /** Whether or not the segment is active. */
    public var isActive: Bool?
    /** The display name of the segment. */
    public var displayName: String?
    /** The version of the segment. */
    public var version: Int?
    /** A description of the segment. */
    public var _description: String?
    /** The hexadecimal color value of the segment. */
    public var color: String?
    /** Whether or not the segment should be displayed to agent/supervisor users. */
    public var shouldDisplayToAgent: Bool?
    /** The context of the segment. */
    public var context: PatchContext?
    /** The pattern of rules defining the segment. */
    public var journey: PatchJourney?
    /** Details of an entity corresponding to this segment in an external system. */
    public var externalSegment: PatchExternalSegment?
    /** Time, in days, from when the segment is assigned until it is automatically unassigned. */
    public var assignmentExpirationDays: Int?

    public init(isActive: Bool?, displayName: String?, version: Int?, _description: String?, color: String?, shouldDisplayToAgent: Bool?, context: PatchContext?, journey: PatchJourney?, externalSegment: PatchExternalSegment?, assignmentExpirationDays: Int?) {
        self.isActive = isActive
        self.displayName = displayName
        self.version = version
        self._description = _description
        self.color = color
        self.shouldDisplayToAgent = shouldDisplayToAgent
        self.context = context
        self.journey = journey
        self.externalSegment = externalSegment
        self.assignmentExpirationDays = assignmentExpirationDays
    }

    public enum CodingKeys: String, CodingKey { 
        case isActive
        case displayName
        case version
        case _description = "description"
        case color
        case shouldDisplayToAgent
        case context
        case journey
        case externalSegment
        case assignmentExpirationDays
    }


}




public class PerformancePredictionCompleteEventTopicErrorBody: Codable {









    public var status: Int?
    public var code: String?
    public var message: String?
    public var messageParams: [String:String]?

    public init(status: Int?, code: String?, message: String?, messageParams: [String:String]?) {
        self.status = status
        self.code = code
        self.message = message
        self.messageParams = messageParams
    }


}




public class PerformancePredictionRecalculationCompleteEventTopicErrorBody: Codable {









    public var status: Int?
    public var code: String?
    public var message: String?
    public var messageParams: [String:String]?

    public init(status: Int?, code: String?, message: String?, messageParams: [String:String]?) {
        self.status = status
        self.code = code
        self.message = message
        self.messageParams = messageParams
    }


}




public class PerformancePredictionRecalculationUploadResponse: Codable {









    /** The key to pass to the secondary request to start processing of the upload */
    public var uploadKey: String?
    /** The url to which to PUT the upload body */
    public var url: String?
    /** Required headers for the PUT request to the url */
    public var headers: [String:String]?
    /** Always null. Defines the schema of the json body to be PUT to the url. The json body should be gzip encoded before uploading */
    public var uploadBodySchema: PerformancePredictionUploadSchema?

    public init(uploadKey: String?, url: String?, headers: [String:String]?, uploadBodySchema: PerformancePredictionUploadSchema?) {
        self.uploadKey = uploadKey
        self.url = url
        self.headers = headers
        self.uploadBodySchema = uploadBodySchema
    }


}




public class PerformanceProfile: Codable {























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** A name for this performance profile */
    public var name: String?
    /** The division for this performance profile associate to */
    public var division: Division?
    /** A description about this performance profile */
    public var _description: String?
    /** Order of the associated metrics. The list should contain valid ids for metrics */
    public var metricOrders: [String]?
    /** Creation date for this performance profile. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The reporting interval periods for this performance profile */
    public var reportingIntervals: [ReportingInterval]?
    /** The flag for active profiles */
    public var active: Bool?
    /** The number of members in this performance profile */
    public var memberCount: Int?
    /** The maximum rank size for the leaderboard. This counts the number of ranks can be retrieved in a leaderboard queries */
    public var maxLeaderboardRankSize: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, _description: String?, metricOrders: [String]?, dateCreated: Date?, reportingIntervals: [ReportingInterval]?, active: Bool?, memberCount: Int?, maxLeaderboardRankSize: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.metricOrders = metricOrders
        self.dateCreated = dateCreated
        self.reportingIntervals = reportingIntervals
        self.active = active
        self.memberCount = memberCount
        self.maxLeaderboardRankSize = maxLeaderboardRankSize
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case metricOrders
        case dateCreated
        case reportingIntervals
        case active
        case memberCount
        case maxLeaderboardRankSize
        case selfUri
    }


}




public class PhoneBaseSettings: Codable {







    /** The globally unique identifier for this phone base settings */
    public var _id: String?
    public var name: String?
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}




public class PhoneChangeTopicPhoneStatus: Codable {



    public enum OperationalStatus: String, Codable { 
        case operational = "OPERATIONAL"
        case degraded = "DEGRADED"
        case offline = "OFFLINE"
    }









    public var _id: String?
    public var operationalStatus: OperationalStatus?
    public var edge: PhoneChangeTopicEdgeReference?
    public var provision: PhoneChangeTopicProvisionInfo?
    public var lineStatuses: [PhoneChangeTopicLineStatus]?
    public var eventCreationTime: Date?

    public init(_id: String?, operationalStatus: OperationalStatus?, edge: PhoneChangeTopicEdgeReference?, provision: PhoneChangeTopicProvisionInfo?, lineStatuses: [PhoneChangeTopicLineStatus]?, eventCreationTime: Date?) {
        self._id = _id
        self.operationalStatus = operationalStatus
        self.edge = edge
        self.provision = provision
        self.lineStatuses = lineStatuses
        self.eventCreationTime = eventCreationTime
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case operationalStatus
        case edge
        case provision
        case lineStatuses
        case eventCreationTime
    }


}




public class PhoneChangeTopicProvisionInfo: Codable {







    public var time: Date?
    public var source: String?
    public var errorInfo: String?

    public init(time: Date?, source: String?, errorInfo: String?) {
        self.time = time
        self.source = source
        self.errorInfo = errorInfo
    }


}




public class PhysicalInterfaceEntityListing: Codable {





















    public var entities: [DomainPhysicalInterface]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [DomainPhysicalInterface]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class PlanningGroupReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class Policy: Codable {

























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    public var order: Int?
    public var _description: String?
    public var enabled: Bool?
    /** Conditions and actions per media type */
    public var mediaPolicies: MediaPolicies?
    /** Conditions */
    public var conditions: PolicyConditions?
    /** Actions */
    public var actions: PolicyActions?
    public var policyErrors: PolicyErrors?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, modifiedDate: Date?, createdDate: Date?, order: Int?, _description: String?, enabled: Bool?, mediaPolicies: MediaPolicies?, conditions: PolicyConditions?, actions: PolicyActions?, policyErrors: PolicyErrors?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.modifiedDate = modifiedDate
        self.createdDate = createdDate
        self.order = order
        self._description = _description
        self.enabled = enabled
        self.mediaPolicies = mediaPolicies
        self.conditions = conditions
        self.actions = actions
        self.policyErrors = policyErrors
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case modifiedDate
        case createdDate
        case order
        case _description = "description"
        case enabled
        case mediaPolicies
        case conditions
        case actions
        case policyErrors
        case selfUri
    }


}




public class PolicyConditions: Codable {



    public enum Directions: String, Codable { 
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }



    public enum MediaTypes: String, Codable { 
        case call = "CALL"
        case chat = "CHAT"
    }











    public enum CustomerParticipation: String, Codable { 
        case yes = "YES"
        case no = "NO"
    }

    public var forUsers: [User]?
    public var directions: [Directions]?
    public var dateRanges: [String]?
    public var mediaTypes: [MediaTypes]?
    public var forQueues: [Queue]?
    public var duration: DurationCondition?
    public var wrapupCodes: [WrapupCode]?
    public var timeAllowed: TimeAllowed?
    /** Teams to match conversations against */
    public var teams: [Team]?
    /** This condition is to filter out conversation with and without customer participation. */
    public var customerParticipation: CustomerParticipation?

    public init(forUsers: [User]?, directions: [Directions]?, dateRanges: [String]?, mediaTypes: [MediaTypes]?, forQueues: [Queue]?, duration: DurationCondition?, wrapupCodes: [WrapupCode]?, timeAllowed: TimeAllowed?, teams: [Team]?, customerParticipation: CustomerParticipation?) {
        self.forUsers = forUsers
        self.directions = directions
        self.dateRanges = dateRanges
        self.mediaTypes = mediaTypes
        self.forQueues = forQueues
        self.duration = duration
        self.wrapupCodes = wrapupCodes
        self.timeAllowed = timeAllowed
        self.teams = teams
        self.customerParticipation = customerParticipation
    }


}



/** The schemas defining all of the expected responses/outputs. */

public class PostOutputContract: Codable {



    /** JSON schema that defines the transformed, successful result that will be sent back to the caller. */
    public var successSchema: JsonSchemaDocument?

    public init(successSchema: JsonSchemaDocument?) {
        self.successSchema = successSchema
    }


}




public class PresenceDefinition: Codable {







    /** description */
    public var _id: String?
    public var systemPresence: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, systemPresence: String?, selfUri: String?) {
        self._id = _id
        self.systemPresence = systemPresence
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case systemPresence
        case selfUri
    }


}




public class PresenceDetailQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [PresenceDetailQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [PresenceDetailQueryPredicate]?

    public init(type: ModelType?, clauses: [PresenceDetailQueryClause]?, predicates: [PresenceDetailQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class ProgramMappings: Codable {











    public var program: BaseProgramEntity?
    public var queues: [AddressableEntityRef]?
    public var flows: [AddressableEntityRef]?
    public var modifiedBy: AddressableEntityRef?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?

    public init(program: BaseProgramEntity?, queues: [AddressableEntityRef]?, flows: [AddressableEntityRef]?, modifiedBy: AddressableEntityRef?, dateModified: Date?) {
        self.program = program
        self.queues = queues
        self.flows = flows
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
    }


}




public class ProgramMappingsRequest: Codable {





    /** The program queues */
    public var queueIds: [String]?
    /** The program flows */
    public var flowIds: [String]?

    public init(queueIds: [String]?, flowIds: [String]?) {
        self.queueIds = queueIds
        self.flowIds = flowIds
    }


}




public class ProgressTransferEvent: Codable {













    /** A unique (V4 UUID) eventId for this event */
    public var eventId: String?
    /** A Date Time representing the time this event occurred. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventDateTime: Date?
    /** A unique Id (V4 UUID) identifying this conversation */
    public var conversationId: String?
    /** The id (V4 UUID) used to identify the transfer already started by the external platform. */
    public var commandId: String?
    /** The id (V4 UUID) of the communication that is being transferred. */
    public var objectCommunicationId: String?
    /** The id (V4 UUID) of the communication that is being transferred to. */
    public var destinationCommunicationId: String?

    public init(eventId: String?, eventDateTime: Date?, conversationId: String?, commandId: String?, objectCommunicationId: String?, destinationCommunicationId: String?) {
        self.eventId = eventId
        self.eventDateTime = eventDateTime
        self.conversationId = conversationId
        self.commandId = commandId
        self.objectCommunicationId = objectCommunicationId
        self.destinationCommunicationId = destinationCommunicationId
    }


}




public class PromptAsset: Codable {















    public enum UploadStatus: String, Codable { 
        case created = "created"
        case uploaded = "uploaded"
        case transcoded = "transcoded"
        case transcodefailed = "transcodeFailed"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Associated prompt ID */
    public var promptId: String?
    /** Prompt resource language */
    public var language: String?
    /** URI of the resource audio */
    public var mediaUri: String?
    /** Text to speech of the resource */
    public var ttsString: String?
    /** Text of the resource */
    public var text: String?
    /** Audio upload status */
    public var uploadStatus: UploadStatus?
    /** Upload URI for the resource audio */
    public var uploadUri: String?
    /** Whether or not this resource locale is the default for the language */
    public var languageDefault: Bool?
    public var tags: [String:[String]]?
    public var durationSeconds: Double?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, promptId: String?, language: String?, mediaUri: String?, ttsString: String?, text: String?, uploadStatus: UploadStatus?, uploadUri: String?, languageDefault: Bool?, tags: [String:[String]]?, durationSeconds: Double?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.promptId = promptId
        self.language = language
        self.mediaUri = mediaUri
        self.ttsString = ttsString
        self.text = text
        self.uploadStatus = uploadStatus
        self.uploadUri = uploadUri
        self.languageDefault = languageDefault
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case promptId
        case language
        case mediaUri
        case ttsString
        case text
        case uploadStatus
        case uploadUri
        case languageDefault
        case tags
        case durationSeconds
        case selfUri
    }


}




public class PromptEntityListing: Codable {





















    public var entities: [Prompt]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Prompt]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class PublishScriptRequestData: Codable {





    /** The id of the script to publish */
    public var scriptId: String?
    public var versionId: String?

    public init(scriptId: String?, versionId: String?) {
        self.scriptId = scriptId
        self.versionId = versionId
    }


}




public class QueryRequest: Codable {

















    public var queryPhrase: String?
    public var pageNumber: Int?
    public var pageSize: Int?
    public var facetNameRequests: [String]?
    public var sort: [SortItem]?
    public var filters: [ContentFilterItem]?
    public var attributeFilters: [AttributeFilterItem]?
    public var includeShares: Bool?

    public init(queryPhrase: String?, pageNumber: Int?, pageSize: Int?, facetNameRequests: [String]?, sort: [SortItem]?, filters: [ContentFilterItem]?, attributeFilters: [AttributeFilterItem]?, includeShares: Bool?) {
        self.queryPhrase = queryPhrase
        self.pageNumber = pageNumber
        self.pageSize = pageSize
        self.facetNameRequests = facetNameRequests
        self.sort = sort
        self.filters = filters
        self.attributeFilters = attributeFilters
        self.includeShares = includeShares
    }


}




public class QueryRequestClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "And"
        case or = "Or"
    }



    /** The logic used to combine the predicates */
    public var type: ModelType?
    /** The list of predicates used to filter the data */
    public var predicates: [QueryRequestPredicate]?

    public init(type: ModelType?, predicates: [QueryRequestPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class QueryResponseData: Codable {





    /** Interval with start and end represented as ISO-8601 string. i.e: yyyy-MM-dd'T'HH:mm:ss.SSS'Z'/yyyy-MM-dd'T'HH:mm:ss.SSS'Z' */
    public var interval: String?
    /** A list of aggregated metrics */
    public var metrics: [QueryResponseMetric]?

    public init(interval: String?, metrics: [QueryResponseMetric]?) {
        self.interval = interval
        self.metrics = metrics
    }


}




public class QueueConversationCallEventTopicConversationRoutingData: Codable {











    /** A UriReference for a resource */
    public var queue: QueueConversationCallEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: QueueConversationCallEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int?
    /** The skills to use for routing decisions */
    public var skills: [QueueConversationCallEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [QueueConversationCallEventTopicScoredAgent]?

    public init(queue: QueueConversationCallEventTopicUriReference?, language: QueueConversationCallEventTopicUriReference?, priority: Int?, skills: [QueueConversationCallEventTopicUriReference]?, scoredAgents: [QueueConversationCallEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}




public class QueueConversationCallbackEventTopicCallbackConversation: Codable {









    public var _id: String?
    public var name: String?
    public var participants: [QueueConversationCallbackEventTopicCallbackMediaParticipant]?
    public var otherMediaUris: [String]?

    public init(_id: String?, name: String?, participants: [QueueConversationCallbackEventTopicCallbackMediaParticipant]?, otherMediaUris: [String]?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
    }


}




public class QueueConversationCallbackEventTopicDialerPreview: Codable {











    public var _id: String?
    /** The contact associated with this preview data pop */
    public var contactId: String?
    /** The contactList associated with this preview data pop. */
    public var contactListId: String?
    /** The campaignId associated with this preview data pop. */
    public var campaignId: String?
    /** The phone number columns associated with this campaign */
    public var phoneNumberColumns: [QueueConversationCallbackEventTopicPhoneNumberColumn]?

    public init(_id: String?, contactId: String?, contactListId: String?, campaignId: String?, phoneNumberColumns: [QueueConversationCallbackEventTopicPhoneNumberColumn]?) {
        self._id = _id
        self.contactId = contactId
        self.contactListId = contactListId
        self.campaignId = campaignId
        self.phoneNumberColumns = phoneNumberColumns
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case contactId
        case contactListId
        case campaignId
        case phoneNumberColumns
    }


}




public class QueueConversationCallbackEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}




public class QueueConversationCallbackEventTopicVoicemail: Codable {



    public enum UploadStatus: String, Codable { 
        case pending = "pending"
        case complete = "complete"
        case failed = "failed"
        case timeout = "timeout"
        case _none = "none"
    }

    /** The voicemail id */
    public var _id: String?
    /** current state of the voicemail upload */
    public var uploadStatus: UploadStatus?

    public init(_id: String?, uploadStatus: UploadStatus?) {
        self._id = _id
        self.uploadStatus = uploadStatus
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case uploadStatus
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationChatEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationChatEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}




public class QueueConversationChatEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: QueueConversationChatEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int?

    public init(agent: QueueConversationChatEventTopicUriReference?, score: Int?) {
        self.agent = agent
        self.score = score
    }


}




public class QueueConversationCobrowseEventTopicCobrowseConversation: Codable {









    public var _id: String?
    public var name: String?
    public var participants: [QueueConversationCobrowseEventTopicCobrowseMediaParticipant]?
    public var otherMediaUris: [String]?

    public init(_id: String?, name: String?, participants: [QueueConversationCobrowseEventTopicCobrowseMediaParticipant]?, otherMediaUris: [String]?) {
        self._id = _id
        self.name = name
        self.participants = participants
        self.otherMediaUris = otherMediaUris
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case participants
        case otherMediaUris
    }


}




public class QueueConversationCobrowseEventTopicQueueMediaSettings: Codable {









    /** Specifies how long the agent has to answer an interaction before being marked as not responding. */
    public var alertingTimeoutSeconds: Int?
    /** Specifies the duration of the alerting sound to be played for auto answered interactions. */
    public var autoAnswerAlertToneSeconds: Double?
    /** Specifies the duration of the alerting sound to be played for manually answered interactions */
    public var manualAnswerAlertToneSeconds: Double?
    /** Flag to indicate if auto answer is enabled for the given media type or media subtype. */
    public var enableAutoAnswer: Bool?

    public init(alertingTimeoutSeconds: Int?, autoAnswerAlertToneSeconds: Double?, manualAnswerAlertToneSeconds: Double?, enableAutoAnswer: Bool?) {
        self.alertingTimeoutSeconds = alertingTimeoutSeconds
        self.autoAnswerAlertToneSeconds = autoAnswerAlertToneSeconds
        self.manualAnswerAlertToneSeconds = manualAnswerAlertToneSeconds
        self.enableAutoAnswer = enableAutoAnswer
    }


}




public class QueueConversationEmailEventTopicEmailMediaParticipant: Codable {

















    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case converting = "converting"
        case uploading = "uploading"
        case transmitting = "transmitting"
        case scheduled = "scheduled"
        case _none = "none"
    }

    public enum Direction: String, Codable { 
        case inbound = "inbound"
        case outbound = "outbound"
    }

    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case transfer = "transfer"
        case timeout = "timeout"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }







































    public enum FlaggedReason: String, Codable { 
        case general = "general"
    }























    public var _id: String?
    public var name: String?
    public var address: String?
    public var startTime: Date?
    public var connectedTime: Date?
    public var endTime: Date?
    public var startHoldTime: Date?
    public var purpose: String?
    public var state: State?
    public var initialState: InitialState?
    public var direction: Direction?
    public var disconnectType: DisconnectType?
    public var held: Bool?
    public var wrapupRequired: Bool?
    public var wrapupPrompt: String?
    public var user: QueueConversationEmailEventTopicUriReference?
    public var queue: QueueConversationEmailEventTopicUriReference?
    public var team: QueueConversationEmailEventTopicUriReference?
    public var attributes: [String:String]?
    public var errorInfo: QueueConversationEmailEventTopicErrorBody?
    public var script: QueueConversationEmailEventTopicUriReference?
    public var wrapupTimeoutMs: Int?
    public var wrapupSkipped: Bool?
    public var alertingTimeoutMs: Int?
    public var provider: String?
    public var externalContact: QueueConversationEmailEventTopicUriReference?
    public var externalOrganization: QueueConversationEmailEventTopicUriReference?
    public var wrapup: QueueConversationEmailEventTopicWrapup?
    public var conversationRoutingData: QueueConversationEmailEventTopicConversationRoutingData?
    public var peer: String?
    public var screenRecordingState: String?
    public var flaggedReason: FlaggedReason?
    public var journeyContext: QueueConversationEmailEventTopicJourneyContext?
    public var startAcwTime: Date?
    public var endAcwTime: Date?
    public var mediaRoles: [String]?
    public var queueMediaSettings: QueueConversationEmailEventTopicQueueMediaSettings?
    public var subject: String?
    public var messagesSent: Int?
    public var autoGenerated: Bool?
    public var messageId: String?
    public var draftAttachments: [QueueConversationEmailEventTopicAttachment]?
    public var spam: Bool?

    public init(_id: String?, name: String?, address: String?, startTime: Date?, connectedTime: Date?, endTime: Date?, startHoldTime: Date?, purpose: String?, state: State?, initialState: InitialState?, direction: Direction?, disconnectType: DisconnectType?, held: Bool?, wrapupRequired: Bool?, wrapupPrompt: String?, user: QueueConversationEmailEventTopicUriReference?, queue: QueueConversationEmailEventTopicUriReference?, team: QueueConversationEmailEventTopicUriReference?, attributes: [String:String]?, errorInfo: QueueConversationEmailEventTopicErrorBody?, script: QueueConversationEmailEventTopicUriReference?, wrapupTimeoutMs: Int?, wrapupSkipped: Bool?, alertingTimeoutMs: Int?, provider: String?, externalContact: QueueConversationEmailEventTopicUriReference?, externalOrganization: QueueConversationEmailEventTopicUriReference?, wrapup: QueueConversationEmailEventTopicWrapup?, conversationRoutingData: QueueConversationEmailEventTopicConversationRoutingData?, peer: String?, screenRecordingState: String?, flaggedReason: FlaggedReason?, journeyContext: QueueConversationEmailEventTopicJourneyContext?, startAcwTime: Date?, endAcwTime: Date?, mediaRoles: [String]?, queueMediaSettings: QueueConversationEmailEventTopicQueueMediaSettings?, subject: String?, messagesSent: Int?, autoGenerated: Bool?, messageId: String?, draftAttachments: [QueueConversationEmailEventTopicAttachment]?, spam: Bool?) {
        self._id = _id
        self.name = name
        self.address = address
        self.startTime = startTime
        self.connectedTime = connectedTime
        self.endTime = endTime
        self.startHoldTime = startHoldTime
        self.purpose = purpose
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.disconnectType = disconnectType
        self.held = held
        self.wrapupRequired = wrapupRequired
        self.wrapupPrompt = wrapupPrompt
        self.user = user
        self.queue = queue
        self.team = team
        self.attributes = attributes
        self.errorInfo = errorInfo
        self.script = script
        self.wrapupTimeoutMs = wrapupTimeoutMs
        self.wrapupSkipped = wrapupSkipped
        self.alertingTimeoutMs = alertingTimeoutMs
        self.provider = provider
        self.externalContact = externalContact
        self.externalOrganization = externalOrganization
        self.wrapup = wrapup
        self.conversationRoutingData = conversationRoutingData
        self.peer = peer
        self.screenRecordingState = screenRecordingState
        self.flaggedReason = flaggedReason
        self.journeyContext = journeyContext
        self.startAcwTime = startAcwTime
        self.endAcwTime = endAcwTime
        self.mediaRoles = mediaRoles
        self.queueMediaSettings = queueMediaSettings
        self.subject = subject
        self.messagesSent = messagesSent
        self.autoGenerated = autoGenerated
        self.messageId = messageId
        self.draftAttachments = draftAttachments
        self.spam = spam
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case address
        case startTime
        case connectedTime
        case endTime
        case startHoldTime
        case purpose
        case state
        case initialState
        case direction
        case disconnectType
        case held
        case wrapupRequired
        case wrapupPrompt
        case user
        case queue
        case team
        case attributes
        case errorInfo
        case script
        case wrapupTimeoutMs
        case wrapupSkipped
        case alertingTimeoutMs
        case provider
        case externalContact
        case externalOrganization
        case wrapup
        case conversationRoutingData
        case peer
        case screenRecordingState
        case flaggedReason
        case journeyContext
        case startAcwTime
        case endAcwTime
        case mediaRoles
        case queueMediaSettings
        case subject
        case messagesSent
        case autoGenerated
        case messageId
        case draftAttachments
        case spam
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class QueueConversationEmailEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: QueueConversationEmailEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: QueueConversationEmailEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}




public class QueueConversationEmailEventTopicJourneyContext: Codable {







    public var customer: QueueConversationEmailEventTopicJourneyCustomer?
    public var customerSession: QueueConversationEmailEventTopicJourneyCustomerSession?
    public var triggeringAction: QueueConversationEmailEventTopicJourneyAction?

    public init(customer: QueueConversationEmailEventTopicJourneyCustomer?, customerSession: QueueConversationEmailEventTopicJourneyCustomerSession?, triggeringAction: QueueConversationEmailEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class QueueConversationEmailEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}



/** A communication's after-call work data. */

public class QueueConversationEventTopicAfterCallWork: Codable {

    public enum State: String, Codable { 
        case unknown = "unknown"
        case skipped = "skipped"
        case pending = "pending"
        case complete = "complete"
        case notapplicable = "notApplicable"
    }





    /** The communication's after-call work state. */
    public var state: State?
    /** The timestamp when this communication started after-call work in the cloud clock. */
    public var startTime: Date?
    /** The timestamp when this communication ended after-call work in the cloud clock. */
    public var endTime: Date?

    public init(state: State?, startTime: Date?, endTime: Date?) {
        self.state = state
        self.startTime = startTime
        self.endTime = endTime
    }


}



/** Information on how a communication should be routed to an agent. */

public class QueueConversationEventTopicConversationRoutingData: Codable {











    public var queue: QueueConversationEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: QueueConversationEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int?
    /** The skills to use for routing decisions */
    public var skills: [QueueConversationEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [QueueConversationEventTopicScoredAgent]?

    public init(queue: QueueConversationEventTopicUriReference?, language: QueueConversationEventTopicUriReference?, priority: Int?, skills: [QueueConversationEventTopicUriReference]?, scoredAgents: [QueueConversationEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}



/** Detailed information about an error response. */

public class QueueConversationEventTopicErrorDetails: Codable {















    /** The HTTP status code for this message (400, 401, 403, 404, 500, etc. */
    public var status: Int?
    /** A code unique to this error. */
    public var code: String?
    /** Friendly description of this error. */
    public var message: String?
    /** This is the same as message except it uses template fields for variable replacement. For instance: 'User {username} was not found' */
    public var messageWithParams: String?
    /** Used in conjunction with messageWithParams. These are the template parameters. For instance: UserParam.key = 'username', UserParam.value = 'john.doe' */
    public var messageParams: [String:String]?
    /** The correlation Id or context Id for this message. If left blank the Public API will look at the HTTP response header 'ININ-Correlation-Id' instead. */
    public var contextId: String?
    public var uri: String?

    public init(status: Int?, code: String?, message: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, uri: String?) {
        self.status = status
        self.code = code
        self.message = message
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.uri = uri
    }


}



/** Fields identifying the initiator of a given conversation command. */

public class QueueConversationEventTopicInitiator: Codable {



    /** The id of the user who initiated the command if it was initiated by a user. */
    public var userId: String?

    public init(userId: String?) {
        self.userId = userId
    }


}



/** A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationMessageEventTopicJourneyCustomer: Codable {





    /** An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable. */
    public var _id: String?
    /** The type of the customerId within the Journey System (e.g. cookie). */
    public var idType: String?

    public init(_id: String?, idType: String?) {
        self._id = _id
        self.idType = idType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case idType
    }


}



/** A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context) */

public class QueueConversationMessageEventTopicJourneyCustomerSession: Codable {





    /** An ID of a Customer/User's session within the Journey System at a point-in-time */
    public var _id: String?
    /** The type of the Customer/User's session within the Journey System (e.g. web, app) */
    public var type: String?

    public init(_id: String?, type: String?) {
        self._id = _id
        self.type = type
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case type
    }


}




public class QueueConversationMessageEventTopicScoredAgent: Codable {





    /** A UriReference for a resource */
    public var agent: QueueConversationMessageEventTopicUriReference?
    /** Agent's score for the current conversation, from 0 - 100, higher being better */
    public var score: Int?

    public init(agent: QueueConversationMessageEventTopicUriReference?, score: Int?) {
        self.agent = agent
        self.score = score
    }


}




public class QueueConversationScreenShareEventTopicDetail: Codable {









    public var errorCode: String?
    public var fieldName: String?
    public var entityId: String?
    public var entityName: String?

    public init(errorCode: String?, fieldName: String?, entityId: String?, entityName: String?) {
        self.errorCode = errorCode
        self.fieldName = fieldName
        self.entityId = entityId
        self.entityName = entityName
    }


}




public class QueueConversationScreenShareEventTopicErrorBody: Codable {





















    public var message: String?
    public var code: String?
    public var status: Int?
    public var entityId: String?
    public var entityName: String?
    public var messageWithParams: String?
    public var messageParams: [String:String]?
    public var contextId: String?
    public var details: [QueueConversationScreenShareEventTopicDetail]?
    public var errors: [QueueConversationScreenShareEventTopicErrorBody]?

    public init(message: String?, code: String?, status: Int?, entityId: String?, entityName: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, details: [QueueConversationScreenShareEventTopicDetail]?, errors: [QueueConversationScreenShareEventTopicErrorBody]?) {
        self.message = message
        self.code = code
        self.status = status
        self.entityId = entityId
        self.entityName = entityName
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.details = details
        self.errors = errors
    }


}



/** Details about the action map from the Journey System which triggered this action */

public class QueueConversationScreenShareEventTopicJourneyActionMap: Codable {





    /** The ID of the actionMap in the Journey System which triggered this action */
    public var _id: String?
    /** The version number of the actionMap in the Journey System at the time this action was triggered */
    public var version: Int?

    public init(_id: String?, version: Int?) {
        self._id = _id
        self.version = version
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case version
    }


}




public class QueueConversationScreenShareEventTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}



/** A communication's after-call work data. */

public class QueueConversationSocialExpressionEventTopicAfterCallWork: Codable {

    public enum State: String, Codable { 
        case unknown = "unknown"
        case skipped = "skipped"
        case pending = "pending"
        case complete = "complete"
        case notapplicable = "notApplicable"
    }





    /** The communication's after-call work state. */
    public var state: State?
    /** The timestamp when this communication started after-call work in the cloud clock. */
    public var startTime: Date?
    /** The timestamp when this communication ended after-call work in the cloud clock. */
    public var endTime: Date?

    public init(state: State?, startTime: Date?, endTime: Date?) {
        self.state = state
        self.startTime = startTime
        self.endTime = endTime
    }


}



/** Information on how a communication should be routed to an agent. */

public class QueueConversationSocialExpressionEventTopicConversationRoutingData: Codable {











    public var queue: QueueConversationSocialExpressionEventTopicUriReference?
    /** A UriReference for a resource */
    public var language: QueueConversationSocialExpressionEventTopicUriReference?
    /** The priority of the conversation to use for routing decisions */
    public var priority: Int?
    /** The skills to use for routing decisions */
    public var skills: [QueueConversationSocialExpressionEventTopicUriReference]?
    /** A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents */
    public var scoredAgents: [QueueConversationSocialExpressionEventTopicScoredAgent]?

    public init(queue: QueueConversationSocialExpressionEventTopicUriReference?, language: QueueConversationSocialExpressionEventTopicUriReference?, priority: Int?, skills: [QueueConversationSocialExpressionEventTopicUriReference]?, scoredAgents: [QueueConversationSocialExpressionEventTopicScoredAgent]?) {
        self.queue = queue
        self.language = language
        self.priority = priority
        self.skills = skills
        self.scoredAgents = scoredAgents
    }


}



/** Detailed information about an error response. */

public class QueueConversationSocialExpressionEventTopicErrorDetails: Codable {















    /** The HTTP status code for this message (400, 401, 403, 404, 500, etc. */
    public var status: Int?
    /** A code unique to this error. */
    public var code: String?
    /** Friendly description of this error. */
    public var message: String?
    /** This is the same as message except it uses template fields for variable replacement. For instance: 'User {username} was not found' */
    public var messageWithParams: String?
    /** Used in conjunction with messageWithParams. These are the template parameters. For instance: UserParam.key = 'username', UserParam.value = 'john.doe' */
    public var messageParams: [String:String]?
    /** The correlation Id or context Id for this message. If left blank the Public API will look at the HTTP response header 'ININ-Correlation-Id' instead. */
    public var contextId: String?
    public var uri: String?

    public init(status: Int?, code: String?, message: String?, messageWithParams: String?, messageParams: [String:String]?, contextId: String?, uri: String?) {
        self.status = status
        self.code = code
        self.message = message
        self.messageWithParams = messageWithParams
        self.messageParams = messageParams
        self.contextId = contextId
        self.uri = uri
    }


}



/** Fields identifying the initiator of a given conversation command. */

public class QueueConversationSocialExpressionEventTopicInitiator: Codable {



    /** The id of the user who initiated the command if it was initiated by a user. */
    public var userId: String?

    public init(userId: String?) {
        self.userId = userId
    }


}




public class QueueConversationVideoEventTopicChat: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transferForward = "transfer.forward"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }

















    public var state: State?
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The source provider of the chat. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The room id for the chat. */
    public var roomId: String?
    /** The avatar for the chat (if available). */
    public var avatarImageUrl: String?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the chat was placed on hold in the cloud clock if the chat is currently on hold. */
    public var startHoldTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    public var journeyContext: QueueConversationVideoEventTopicJourneyContext?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationVideoEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationVideoEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationVideoEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _id: String?, provider: String?, scriptId: String?, peerId: String?, roomId: String?, avatarImageUrl: String?, held: Bool?, disconnectType: DisconnectType?, startHoldTime: Date?, connectedTime: Date?, disconnectedTime: Date?, journeyContext: QueueConversationVideoEventTopicJourneyContext?, wrapup: QueueConversationVideoEventTopicWrapup?, afterCallWork: QueueConversationVideoEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: QueueConversationVideoEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.roomId = roomId
        self.avatarImageUrl = avatarImageUrl
        self.held = held
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.journeyContext = journeyContext
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case provider
        case scriptId
        case peerId
        case roomId
        case avatarImageUrl
        case held
        case disconnectType
        case startHoldTime
        case connectedTime
        case disconnectedTime
        case journeyContext
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}



/** Fields identifying the destination of a given conversation command. */

public class QueueConversationVideoEventTopicDestination: Codable {





    /** The id of the user if the command destination is a user. */
    public var userId: String?
    /** The destination address if the command destination is an endpoint. */
    public var address: String?

    public init(userId: String?, address: String?) {
        self.userId = userId
        self.address = address
    }


}



/** A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context) */

public class QueueConversationVideoEventTopicJourneyAction: Codable {





    /** The ID of an action from the Journey System (an action is spawned from an actionMap) */
    public var _id: String?
    public var actionMap: QueueConversationVideoEventTopicJourneyActionMap?

    public init(_id: String?, actionMap: QueueConversationVideoEventTopicJourneyActionMap?) {
        self._id = _id
        self.actionMap = actionMap
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case actionMap
    }


}



/** A subset of the Journey System's data relevant to a part of a conversation (for external linkage and internal usage/context). */

public class QueueConversationVideoEventTopicJourneyContext: Codable {







    public var customer: QueueConversationVideoEventTopicJourneyCustomer?
    public var customerSession: QueueConversationVideoEventTopicJourneyCustomerSession?
    public var triggeringAction: QueueConversationVideoEventTopicJourneyAction?

    public init(customer: QueueConversationVideoEventTopicJourneyCustomer?, customerSession: QueueConversationVideoEventTopicJourneyCustomerSession?, triggeringAction: QueueConversationVideoEventTopicJourneyAction?) {
        self.customer = customer
        self.customerSession = customerSession
        self.triggeringAction = triggeringAction
    }


}




public class QueueConversationVideoEventTopicMessage: Codable {



    public enum State: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case disconnected = "disconnected"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case connected = "connected"
        case disconnected = "disconnected"
    }

    public enum Direction: String, Codable { 
        case outbound = "outbound"
        case inbound = "inbound"
    }











    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }















    public enum ModelType: String, Codable { 
        case unknown = "unknown"
        case sms = "sms"
        case twitter = "twitter"
        case facebook = "facebook"
        case line = "line"
        case viber = "viber"
        case wechat = "wechat"
        case whatsapp = "whatsapp"
        case telegram = "telegram"
        case kakao = "kakao"
        case webmessaging = "webmessaging"
        case _open = "open"
        case instagram = "instagram"
    }



















    /** A globally unique identifier for this communication. */
    public var _id: String?
    public var state: State?
    public var initialState: InitialState?
    /** Whether a message is inbound or outbound. */
    public var direction: Direction?
    /** True if this call is held and the person on this side hears silence. */
    public var held: Bool?
    /** Detailed information about an error response. */
    public var errorInfo: QueueConversationVideoEventTopicErrorDetails?
    /** The source provider of the email. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the email was placed on hold in the cloud clock if the email is currently on hold. */
    public var startHoldTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** Address and name data for a call endpoint. */
    public var toAddress: QueueConversationVideoEventTopicAddress?
    /** Address and name data for a call endpoint. */
    public var fromAddress: QueueConversationVideoEventTopicAddress?
    /** The messages sent on this communication channel. */
    public var messages: [QueueConversationVideoEventTopicMessageDetails]?
    /** the messages transcript file uri. */
    public var messagesTranscriptUri: String?
    /** Indicates the type of message platform from which the message originated. */
    public var type: ModelType?
    /** Indicates the country where the recipient is associated in ISO 3166-1 alpha-2 format. */
    public var recipientCountry: String?
    /** The type of the recipient. Eg: Provisioned phoneNumber is the recipient for sms message type. */
    public var recipientType: String?
    /** A subset of the Journey System's data relevant to a part of a conversation (for external linkage and internal usage/context). */
    public var journeyContext: QueueConversationVideoEventTopicJourneyContext?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationVideoEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationVideoEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** UUID of virtual agent assistant that provide suggestions to the agent participant during the conversation. */
    public var agentAssistantId: String?
    public var byoSmsIntegrationId: String?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationVideoEventTopicQueueMediaSettings?

    public init(_id: String?, state: State?, initialState: InitialState?, direction: Direction?, held: Bool?, errorInfo: QueueConversationVideoEventTopicErrorDetails?, provider: String?, scriptId: String?, peerId: String?, disconnectType: DisconnectType?, startHoldTime: Date?, connectedTime: Date?, disconnectedTime: Date?, toAddress: QueueConversationVideoEventTopicAddress?, fromAddress: QueueConversationVideoEventTopicAddress?, messages: [QueueConversationVideoEventTopicMessageDetails]?, messagesTranscriptUri: String?, type: ModelType?, recipientCountry: String?, recipientType: String?, journeyContext: QueueConversationVideoEventTopicJourneyContext?, wrapup: QueueConversationVideoEventTopicWrapup?, afterCallWork: QueueConversationVideoEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, agentAssistantId: String?, byoSmsIntegrationId: String?, queueMediaSettings: QueueConversationVideoEventTopicQueueMediaSettings?) {
        self._id = _id
        self.state = state
        self.initialState = initialState
        self.direction = direction
        self.held = held
        self.errorInfo = errorInfo
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.disconnectType = disconnectType
        self.startHoldTime = startHoldTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.toAddress = toAddress
        self.fromAddress = fromAddress
        self.messages = messages
        self.messagesTranscriptUri = messagesTranscriptUri
        self.type = type
        self.recipientCountry = recipientCountry
        self.recipientType = recipientType
        self.journeyContext = journeyContext
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.agentAssistantId = agentAssistantId
        self.byoSmsIntegrationId = byoSmsIntegrationId
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case initialState
        case direction
        case held
        case errorInfo
        case provider
        case scriptId
        case peerId
        case disconnectType
        case startHoldTime
        case connectedTime
        case disconnectedTime
        case toAddress
        case fromAddress
        case messages
        case messagesTranscriptUri
        case type
        case recipientCountry
        case recipientType
        case journeyContext
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case agentAssistantId
        case byoSmsIntegrationId
        case queueMediaSettings
    }


}




public class QueueConversationVideoEventTopicMessageDetails: Codable {





    public enum MessageStatus: String, Codable { 
        case queued = "queued"
        case sent = "sent"
        case failed = "failed"
        case received = "received"
        case deliverySuccess = "delivery-success"
        case deliveryFailed = "delivery-failed"
        case read = "read"
        case removed = "removed"
    }











    /** UUID identifying the message media. */
    public var messageId: String?
    /** The time when the message was sent or received. */
    public var messageTime: Date?
    /** Indicates the delivery status of the message. */
    public var messageStatus: MessageStatus?
    /** The message segment count, greater than 1 if the message content was split into multiple parts for this message type, e.g. SMS character limits. */
    public var messageSegmentCount: Int?
    /** The media (images, files, etc) associated with this message, if any */
    public var media: [QueueConversationVideoEventTopicMessageMedia]?
    /** Detailed information about an error response. */
    public var errorInfo: QueueConversationVideoEventTopicErrorDetails?
    /** A list of stickers included in the message */
    public var stickers: [QueueConversationVideoEventTopicMessageSticker]?
    public var messageMetadata: QueueConversationVideoEventTopicMessageMetadata?

    public init(messageId: String?, messageTime: Date?, messageStatus: MessageStatus?, messageSegmentCount: Int?, media: [QueueConversationVideoEventTopicMessageMedia]?, errorInfo: QueueConversationVideoEventTopicErrorDetails?, stickers: [QueueConversationVideoEventTopicMessageSticker]?, messageMetadata: QueueConversationVideoEventTopicMessageMetadata?) {
        self.messageId = messageId
        self.messageTime = messageTime
        self.messageStatus = messageStatus
        self.messageSegmentCount = messageSegmentCount
        self.media = media
        self.errorInfo = errorInfo
        self.stickers = stickers
        self.messageMetadata = messageMetadata
    }


}




public class QueueConversationVideoEventTopicMessageMedia: Codable {











    /** The location of the media, useful for retrieving it */
    public var url: String?
    /** The optional internet media type of the the media object.  If null then the media type should be dictated by the url */
    public var mediaType: String?
    /** The optional content length of the the media object, in bytes. */
    public var contentLengthBytes: Int?
    /** The optional name of the the media object. */
    public var name: String?
    /** The optional id of the the media object. */
    public var _id: String?

    public init(url: String?, mediaType: String?, contentLengthBytes: Int?, name: String?, _id: String?) {
        self.url = url
        self.mediaType = mediaType
        self.contentLengthBytes = contentLengthBytes
        self.name = name
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case url
        case mediaType
        case contentLengthBytes
        case name
        case _id = "id"
    }


}




public class QueueConversationVideoEventTopicMessageMetadataEvent: Codable {





    /** Type of this event element. */
    public var eventType: String?
    /** Event subtype, if any */
    public var subType: String?

    public init(eventType: String?, subType: String?) {
        self.eventType = eventType
        self.subType = subType
    }


}




public class QueueConversationVideoEventTopicMessageSticker: Codable {





    /** The location of the sticker, useful for retrieving it */
    public var url: String?
    /** The unique id of the the sticker object. */
    public var _id: String?

    public init(url: String?, _id: String?) {
        self.url = url
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case url
        case _id = "id"
    }


}




public class QueueConversationVideoEventTopicScreenshare: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

















    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }













    public var state: State?
    public var initialState: InitialState?
    /** Address and name data for a call endpoint. */
    public var _self: QueueConversationVideoEventTopicAddress?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The room id context (xmpp jid) for the conference session. */
    public var context: String?
    /** Indicates whether this participant is sharing their screen to the session. */
    public var sharing: Bool?
    /** The source provider of the screen share. */
    public var provider: String?
    /** The UUID of the script to use. */
    public var scriptId: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The number of peer participants from the perspective of the participant in the conference. */
    public var peerCount: JSON?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp when this communication was connected in the cloud clock. */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. */
    public var disconnectedTime: Date?
    /** Call wrap up or disposition data. */
    public var wrapup: QueueConversationVideoEventTopicWrapup?
    /** A communication's after-call work data. */
    public var afterCallWork: QueueConversationVideoEventTopicAfterCallWork?
    /** Indicates if after-call is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?
    /** Represents the queue setting for this media. */
    public var queueMediaSettings: QueueConversationVideoEventTopicQueueMediaSettings?

    public init(state: State?, initialState: InitialState?, _self: QueueConversationVideoEventTopicAddress?, _id: String?, context: String?, sharing: Bool?, provider: String?, scriptId: String?, peerId: String?, peerCount: JSON?, disconnectType: DisconnectType?, connectedTime: Date?, disconnectedTime: Date?, wrapup: QueueConversationVideoEventTopicWrapup?, afterCallWork: QueueConversationVideoEventTopicAfterCallWork?, afterCallWorkRequired: Bool?, queueMediaSettings: QueueConversationVideoEventTopicQueueMediaSettings?) {
        self.state = state
        self.initialState = initialState
        self._self = _self
        self._id = _id
        self.context = context
        self.sharing = sharing
        self.provider = provider
        self.scriptId = scriptId
        self.peerId = peerId
        self.peerCount = peerCount
        self.disconnectType = disconnectType
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
        self.queueMediaSettings = queueMediaSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _self = "self"
        case _id = "id"
        case context
        case sharing
        case provider
        case scriptId
        case peerId
        case peerCount
        case disconnectType
        case connectedTime
        case disconnectedTime
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
        case queueMediaSettings
    }


}



/** Information about the workflow. */

public class QueueConversationVideoEventTopicWorkflow: Codable {



    /** The id of the workflow */
    public var workflowId: String?

    public init(workflowId: String?) {
        self.workflowId = workflowId
    }


}



/** Call wrap up or disposition data. */

public class QueueConversationVideoEventTopicWrapup: Codable {











    /** The user configured wrap up code name. */
    public var code: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work., Note, the format of utc-millisec should be ignored, our code generator needs it to generate a Long for us internally */
    public var durationSeconds: Int?
    /** The timestamp when the wrapup was finished. */
    public var endTime: Date?

    public init(code: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?) {
        self.code = code
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
    }


}




public class QueueEntityListing: Codable {





















    public var entities: [Queue]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Queue]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class QueueMemberEntityListing: Codable {















    public var entities: [QueueMember]?
    public var pageNumber: Int?
    public var pageSize: Int?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var selfUri: String?

    public init(entities: [QueueMember]?, pageNumber: Int?, pageSize: Int?, firstUri: String?, nextUri: String?, previousUri: String?, selfUri: String?) {
        self.entities = entities
        self.pageNumber = pageNumber
        self.pageSize = pageSize
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.selfUri = selfUri
    }


}




public class QueueMemberEntityListingV1: Codable {





















    public var entities: [QueueMember]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [QueueMember]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class QueueMessagingAddresses: Codable {







    public var smsAddress: DomainEntityRef?
    public var openMessagingRecipient: DomainEntityRef?
    public var whatsAppRecipient: DomainEntityRef?

    public init(smsAddress: DomainEntityRef?, openMessagingRecipient: DomainEntityRef?, whatsAppRecipient: DomainEntityRef?) {
        self.smsAddress = smsAddress
        self.openMessagingRecipient = openMessagingRecipient
        self.whatsAppRecipient = whatsAppRecipient
    }


}




public class QueueObservationQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [QueueObservationQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [QueueObservationQueryPredicate]?

    public init(type: ModelType?, clauses: [QueueObservationQueryClause]?, predicates: [QueueObservationQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class QueueUserEventTopicQueueMember: Codable {











    public var _id: String?
    public var user: QueueUserEventTopicUserReference?
    public var queueId: String?
    public var joined: Bool?
    public var additionalProperties: [String:JSON]?

    public init(_id: String?, user: QueueUserEventTopicUserReference?, queueId: String?, joined: Bool?, additionalProperties: [String:JSON]?) {
        self._id = _id
        self.user = user
        self.queueId = queueId
        self.joined = joined
        self.additionalProperties = additionalProperties
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case user
        case queueId
        case joined
        case additionalProperties
    }


}




public class RateLimitAggregateDataContainer: Codable {





    /** A mapping from dimension to value */
    public var group: [String:String]?
    public var data: [StatisticalResponse]?

    public init(group: [String:String]?, data: [StatisticalResponse]?) {
        self.group = group
        self.data = data
    }


}




public class RateLimitAggregateQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [RateLimitAggregateQueryPredicate]?

    public init(type: ModelType?, predicates: [RateLimitAggregateQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class RateLimitAggregationQuery: Codable {







    public enum GroupBy: String, Codable { 
        case correlationid = "correlationId"
        case entityid = "entityId"
        case limitname = "limitName"
        case max = "max"
        case namespace = "namespace"
        case timeunit = "timeUnit"
        case userid = "userId"
    }



    public enum Metrics: String, Codable { 
        case oratelimitrecorded = "oRateLimitRecorded"
    }





    public enum AlternateTimeDimension: String, Codable { 
        case eventtime = "eventTime"
    }

    /** Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H */
    public var granularity: String?
    /** Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var timeZone: String?
    /** Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group. */
    public var groupBy: [GroupBy]?
    /** Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters */
    public var filter: RateLimitAggregateQueryFilter?
    /** Behaves like a SQL SELECT clause. Only named metrics will be retrieved. */
    public var metrics: [Metrics]?
    /** Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c') */
    public var flattenMultivaluedDimensions: Bool?
    /** Custom derived metric views */
    public var views: [RateLimitAggregationView]?
    /** Dimension to use as the alternative timestamp for data in the aggregate.  Choosing \"eventTime\" uses the actual time of the data event. */
    public var alternateTimeDimension: AlternateTimeDimension?

    public init(interval: String?, granularity: String?, timeZone: String?, groupBy: [GroupBy]?, filter: RateLimitAggregateQueryFilter?, metrics: [Metrics]?, flattenMultivaluedDimensions: Bool?, views: [RateLimitAggregationView]?, alternateTimeDimension: AlternateTimeDimension?) {
        self.interval = interval
        self.granularity = granularity
        self.timeZone = timeZone
        self.groupBy = groupBy
        self.filter = filter
        self.metrics = metrics
        self.flattenMultivaluedDimensions = flattenMultivaluedDimensions
        self.views = views
        self.alternateTimeDimension = alternateTimeDimension
    }


}




public class RecipientFlow: Codable {



    /** The flow identifier */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class RecordingAnnotationFlow: Codable {





    /** The flow name */
    public var name: String?
    /** The flow Id */
    public var _id: String?

    public init(name: String?, _id: String?) {
        self.name = name
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _id = "id"
    }


}




public class RecordingEventRecording: Codable {













    public var _id: String?
    public var conversationId: String?
    public var fileState: String?
    public var mediaUris: [RecordingEventMediaResult]?
    public var estimatedTranscodeTimeMs: Int?
    public var actualTranscodeTimeMs: Int?

    public init(_id: String?, conversationId: String?, fileState: String?, mediaUris: [RecordingEventMediaResult]?, estimatedTranscodeTimeMs: Int?, actualTranscodeTimeMs: Int?) {
        self._id = _id
        self.conversationId = conversationId
        self.fileState = fileState
        self.mediaUris = mediaUris
        self.estimatedTranscodeTimeMs = estimatedTranscodeTimeMs
        self.actualTranscodeTimeMs = actualTranscodeTimeMs
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case conversationId
        case fileState
        case mediaUris
        case estimatedTranscodeTimeMs
        case actualTranscodeTimeMs
    }


}




public class RecordingJobFailedRecording: Codable {





    /** Conversation */
    public var conversation: AddressableEntityRef?
    /** Recording */
    public var recording: AddressableEntityRef?

    public init(conversation: AddressableEntityRef?, recording: AddressableEntityRef?) {
        self.conversation = conversation
        self.recording = recording
    }


}




public class RecordingSettings: Codable {







    /** Maximum number of simultaneous screen recording streams */
    public var maxSimultaneousStreams: Int?
    /** Upper limit that maxSimultaneousStreams can be configured */
    public var maxConfigurableScreenRecordingStreams: Int?
    /** Store call recordings in the region where they are intended to be recorded, otherwise in the organization's home region */
    public var regionalRecordingStorageEnabled: Bool?

    public init(maxSimultaneousStreams: Int?, maxConfigurableScreenRecordingStreams: Int?, regionalRecordingStorageEnabled: Bool?) {
        self.maxSimultaneousStreams = maxSimultaneousStreams
        self.maxConfigurableScreenRecordingStreams = maxConfigurableScreenRecordingStreams
        self.regionalRecordingStorageEnabled = regionalRecordingStorageEnabled
    }


}




public class RecordingUploadReport: Codable {





    public enum State: String, Codable { 
        case inProgress = "InProgress"
        case completed = "Completed"
        case failed = "Failed"
    }





    /** The report id. */
    public var _id: String?
    public var name: String?
    /** The current status of the upload report. */
    public var state: State?
    /** For COMPLETED tasks, the signed url to download the report. */
    public var signedUrl: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, state: State?, signedUrl: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.state = state
        self.signedUrl = signedUrl
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case state
        case signedUrl
        case selfUri
    }


}




public class RecordingUploadReportRequest: Codable {



    public enum UploadStatus: String, Codable { 
        case pending = "Pending"
        case success = "Success"
        case failure = "Failure"
        case waitForConversation = "WaitForConversation"
    }

    /** Report will include uploads since this date. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateSince: Date?
    /** Report will include uploads with this status */
    public var uploadStatus: UploadStatus?

    public init(dateSince: Date?, uploadStatus: UploadStatus?) {
        self.dateSince = dateSince
        self.uploadStatus = uploadStatus
    }


}




public class Referrer: Codable {

















    public enum Medium: String, Codable { 
        case _internal = "internal"
        case search = "search"
        case social = "social"
        case email = "email"
        case unknown = "unknown"
        case paid = "paid"
    }

    /** Referrer URL. */
    public var url: String?
    /** Referrer URL domain. */
    public var domain: String?
    /** Referrer URL hostname. */
    public var hostname: String?
    /** Referrer keywords. */
    public var keywords: String?
    /** Referrer URL pathname. */
    public var pathname: String?
    /** Referrer URL querystring. */
    public var queryString: String?
    /** Referrer URL fragment. */
    public var fragment: String?
    /** Name of referrer (e.g. Yahoo!, Google, InfoSpace). */
    public var name: String?
    /** Type of referrer (e.g. search, social). */
    public var medium: Medium?

    public init(url: String?, domain: String?, hostname: String?, keywords: String?, pathname: String?, queryString: String?, fragment: String?, name: String?, medium: Medium?) {
        self.url = url
        self.domain = domain
        self.hostname = hostname
        self.keywords = keywords
        self.pathname = pathname
        self.queryString = queryString
        self.fragment = fragment
        self.name = name
        self.medium = medium
    }


}




public class ReplacementTerm: Codable {

    public enum ModelType: String, Codable { 
        case name = "NAME"
        case address = "ADDRESS"
        case phone = "PHONE"
        case email = "EMAIL"
        case twitter = "TWITTER"
    }





    public var type: ModelType?
    public var existingValue: String?
    public var updatedValue: String?

    public init(type: ModelType?, existingValue: String?, updatedValue: String?) {
        self.type = type
        self.existingValue = existingValue
        self.updatedValue = updatedValue
    }


}




public class ReportSchedule: Codable {



































    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Quartz Cron Expression */
    public var quartzCronExpression: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var nextFireTime: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    public var _description: String?
    public var timeZone: String?
    public var timePeriod: String?
    /** Interval. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    public var reportFormat: String?
    public var locale: String?
    public var enabled: Bool?
    /** Report ID */
    public var reportId: String?
    public var parameters: [String:JSON]?
    public var lastRun: ReportRunEntry?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, quartzCronExpression: String?, nextFireTime: Date?, dateCreated: Date?, dateModified: Date?, _description: String?, timeZone: String?, timePeriod: String?, interval: String?, reportFormat: String?, locale: String?, enabled: Bool?, reportId: String?, parameters: [String:JSON]?, lastRun: ReportRunEntry?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.quartzCronExpression = quartzCronExpression
        self.nextFireTime = nextFireTime
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self._description = _description
        self.timeZone = timeZone
        self.timePeriod = timePeriod
        self.interval = interval
        self.reportFormat = reportFormat
        self.locale = locale
        self.enabled = enabled
        self.reportId = reportId
        self.parameters = parameters
        self.lastRun = lastRun
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case quartzCronExpression
        case nextFireTime
        case dateCreated
        case dateModified
        case _description = "description"
        case timeZone
        case timePeriod
        case interval
        case reportFormat
        case locale
        case enabled
        case reportId
        case parameters
        case lastRun
        case selfUri
    }


}




public class ReportingExportJobListing: Codable {





















    public var entities: [ReportingExportJobResponse]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ReportingExportJobResponse]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ReportingExportJobRequest: Codable {





    public enum ExportFormat: String, Codable { 
        case csv = "CSV"
        case pdf = "PDF"
    }





    public enum ViewType: String, Codable { 
        case queuePerformanceSummaryView = "QUEUE_PERFORMANCE_SUMMARY_VIEW"
        case queuePerformanceDetailView = "QUEUE_PERFORMANCE_DETAIL_VIEW"
        case interactionSearchView = "INTERACTION_SEARCH_VIEW"
        case agentPerformanceSummaryView = "AGENT_PERFORMANCE_SUMMARY_VIEW"
        case agentPerformanceDetailView = "AGENT_PERFORMANCE_DETAIL_VIEW"
        case agentStatusSummaryView = "AGENT_STATUS_SUMMARY_VIEW"
        case agentStatusDetailView = "AGENT_STATUS_DETAIL_VIEW"
        case agentEvaluationSummaryView = "AGENT_EVALUATION_SUMMARY_VIEW"
        case agentEvaluationDetailView = "AGENT_EVALUATION_DETAIL_VIEW"
        case agentQueueDetailView = "AGENT_QUEUE_DETAIL_VIEW"
        case agentInteractionDetailView = "AGENT_INTERACTION_DETAIL_VIEW"
        case abandonInsightsView = "ABANDON_INSIGHTS_VIEW"
        case skillsPerformanceView = "SKILLS_PERFORMANCE_VIEW"
        case surveyFormPerformanceSummaryView = "SURVEY_FORM_PERFORMANCE_SUMMARY_VIEW"
        case surveyFormPerformanceDetailView = "SURVEY_FORM_PERFORMANCE_DETAIL_VIEW"
        case dnisPerformanceSummaryView = "DNIS_PERFORMANCE_SUMMARY_VIEW"
        case dnisPerformanceDetailView = "DNIS_PERFORMANCE_DETAIL_VIEW"
        case wrapUpPerformanceSummaryView = "WRAP_UP_PERFORMANCE_SUMMARY_VIEW"
        case agentWrapUpPerformanceDetailView = "AGENT_WRAP_UP_PERFORMANCE_DETAIL_VIEW"
        case queueActivitySummaryView = "QUEUE_ACTIVITY_SUMMARY_VIEW"
        case queueActivityDetailView = "QUEUE_ACTIVITY_DETAIL_VIEW"
        case agentQueueActivitySummaryView = "AGENT_QUEUE_ACTIVITY_SUMMARY_VIEW"
        case queueAgentDetailView = "QUEUE_AGENT_DETAIL_VIEW"
        case queueInteractionDetailView = "QUEUE_INTERACTION_DETAIL_VIEW"
        case agentScheduleDetailView = "AGENT_SCHEDULE_DETAIL_VIEW"
        case ivrPerformanceSummaryView = "IVR_PERFORMANCE_SUMMARY_VIEW"
        case ivrPerformanceDetailView = "IVR_PERFORMANCE_DETAIL_VIEW"
        case answerInsightsView = "ANSWER_INSIGHTS_VIEW"
        case handleInsightsView = "HANDLE_INSIGHTS_VIEW"
        case talkInsightsView = "TALK_INSIGHTS_VIEW"
        case holdInsightsView = "HOLD_INSIGHTS_VIEW"
        case acwInsightsView = "ACW_INSIGHTS_VIEW"
        case waitInsightsView = "WAIT_INSIGHTS_VIEW"
        case agentWrapUpPerformanceIntervalDetailView = "AGENT_WRAP_UP_PERFORMANCE_INTERVAL_DETAIL_VIEW"
        case flowOutcomeSummaryView = "FLOW_OUTCOME_SUMMARY_VIEW"
        case flowOutcomePerformanceDetailView = "FLOW_OUTCOME_PERFORMANCE_DETAIL_VIEW"
        case flowOutcomePerformanceIntervalDetailView = "FLOW_OUTCOME_PERFORMANCE_INTERVAL_DETAIL_VIEW"
        case flowDestinationSummaryView = "FLOW_DESTINATION_SUMMARY_VIEW"
        case flowDestinationDetailView = "FLOW_DESTINATION_DETAIL_VIEW"
        case apiUsageView = "API_USAGE_VIEW"
        case scheduledCallbacksView = "SCHEDULED_CALLBACKS_VIEW"
        case contentSearchView = "CONTENT_SEARCH_VIEW"
        case landingPage = "LANDING_PAGE"
        case dashboardSummary = "DASHBOARD_SUMMARY"
        case dashboardDetail = "DASHBOARD_DETAIL"
        case dashboardUsers = "DASHBOARD_USERS"
        case dashboardUsersDetail = "DASHBOARD_USERS_DETAIL"
        case journeyActionMapSummaryView = "JOURNEY_ACTION_MAP_SUMMARY_VIEW"
        case journeyOutcomeSummaryView = "JOURNEY_OUTCOME_SUMMARY_VIEW"
        case journeySegmentSummaryView = "JOURNEY_SEGMENT_SUMMARY_VIEW"
        case agentDevelopmentDetailView = "AGENT_DEVELOPMENT_DETAIL_VIEW"
        case agentDevelopmentDetailMeView = "AGENT_DEVELOPMENT_DETAIL_ME_VIEW"
        case agentDevelopmentSummaryView = "AGENT_DEVELOPMENT_SUMMARY_VIEW"
        case agentPerformanceMeView = "AGENT_PERFORMANCE_ME_VIEW"
        case agentStatusMeView = "AGENT_STATUS_ME_VIEW"
        case agentEvaluationMeView = "AGENT_EVALUATION_ME_VIEW"
        case agentScorecardView = "AGENT_SCORECARD_VIEW"
        case agentScorecardMeView = "AGENT_SCORECARD_ME_VIEW"
        case agentGamificationLeadershipView = "AGENT_GAMIFICATION_LEADERSHIP_VIEW"
        case agentScheduleMeView = "AGENT_SCHEDULE_ME_VIEW"
        case botPerformanceSummaryView = "BOT_PERFORMANCE_SUMMARY_VIEW"
        case botPerformanceDetailView = "BOT_PERFORMANCE_DETAIL_VIEW"
        case scheduledExportsView = "SCHEDULED_EXPORTS_VIEW"
        case topicTrendSummaryView = "TOPIC_TREND_SUMMARY_VIEW"
        case topicTrendDetailView = "TOPIC_TREND_DETAIL_VIEW"
        case actionMapBlockedConstraintsDetailView = "ACTION_MAP_BLOCKED_CONSTRAINTS_DETAIL_VIEW"
        case actionMapBlockedConstraintsIntervalDetailView = "ACTION_MAP_BLOCKED_CONSTRAINTS_INTERVAL_DETAIL_VIEW"
        case flowMilestonePerformanceDetailView = "FLOW_MILESTONE_PERFORMANCE_DETAIL_VIEW"
        case flowMilestonePerformanceIntervalDetailView = "FLOW_MILESTONE_PERFORMANCE_INTERVAL_DETAIL_VIEW"
        case agentTopicSummaryView = "AGENT_TOPIC_SUMMARY_VIEW"
        case agentTopicDetailView = "AGENT_TOPIC_DETAIL_VIEW"
        case queueTopicSummaryView = "QUEUE_TOPIC_SUMMARY_VIEW"
        case queueTopicDetailView = "QUEUE_TOPIC_DETAIL_VIEW"
        case flowTopicSummaryView = "FLOW_TOPIC_SUMMARY_VIEW"
        case flowTopicDetailView = "FLOW_TOPIC_DETAIL_VIEW"
        case agentInteractionsMeView = "AGENT_INTERACTIONS_ME_VIEW"
        case alertRulesView = "ALERT_RULES_VIEW"
        case configureAlertRuleView = "CONFIGURE_ALERT_RULE_VIEW"
        case predictiveRoutingView = "PREDICTIVE_ROUTING_VIEW"
        case predictiveRoutingQueueOverview = "PREDICTIVE_ROUTING_QUEUE_OVERVIEW"
        case predictiveRoutingModelView = "PREDICTIVE_ROUTING_MODEL_VIEW"
        case predictiveRoutingImpactView = "PREDICTIVE_ROUTING_IMPACT_VIEW"
        case dataActionsPerformanceSummaryView = "DATA_ACTIONS_PERFORMANCE_SUMMARY_VIEW"
        case dataActionsPerformanceDetailView = "DATA_ACTIONS_PERFORMANCE_DETAIL_VIEW"
        case agentTimelineSummaryView = "AGENT_TIMELINE_SUMMARY_VIEW"
        case agentTimelineDetailView = "AGENT_TIMELINE_DETAIL_VIEW"
        case agentLoginLogoutSummaryView = "AGENT_LOGIN_LOGOUT_SUMMARY_VIEW"
        case agentLoginLogoutDetailView = "AGENT_LOGIN_LOGOUT_DETAIL_VIEW"
        case campaignPerformanceSummaryView = "CAMPAIGN_PERFORMANCE_SUMMARY_VIEW"
        case campaignPerformanceDetailView = "CAMPAIGN_PERFORMANCE_DETAIL_VIEW"
        case knowledgePerformanceView = "KNOWLEDGE_PERFORMANCE_VIEW"
        case agentScorecardInsightsSummaryView = "AGENT_SCORECARD_INSIGHTS_SUMMARY_VIEW"
        case agentScorecardInsightsDetailView = "AGENT_SCORECARD_INSIGHTS_DETAIL_VIEW"
        case queueWrapupDetailView = "QUEUE_WRAPUP_DETAIL_VIEW"
        case interactionDetailView = "INTERACTION_DETAIL_VIEW"
        case campaignInteractionDetailView = "CAMPAIGN_INTERACTION_DETAIL_VIEW"
        case campaignAttemptDetailView = "CAMPAIGN_ATTEMPT_DETAIL_VIEW"
        case workitemPerformanceSummaryView = "WORKITEM_PERFORMANCE_SUMMARY_VIEW"
        case agentAssistPerformanceView = "AGENT_ASSIST_PERFORMANCE_VIEW"
        case contactCenterPerformanceView = "CONTACT_CENTER_PERFORMANCE_VIEW"
        case queueRoutingPerformanceView = "QUEUE_ROUTING_PERFORMANCE_VIEW"
        case agentWorkitemPerformanceSummaryView = "AGENT_WORKITEM_PERFORMANCE_SUMMARY_VIEW"
        case agentWorkitemPerformanceDetailView = "AGENT_WORKITEM_PERFORMANCE_DETAIL_VIEW"
        case queueWorkitemPerformanceSummaryView = "QUEUE_WORKITEM_PERFORMANCE_SUMMARY_VIEW"
        case queueWorkitemPerformanceDetailView = "QUEUE_WORKITEM_PERFORMANCE_DETAIL_VIEW"
    }

















    public enum CsvDelimiter: String, Codable { 
        case semicolon = "SEMICOLON"
        case comma = "COMMA"
    }









    public enum DurationFormat: String, Codable { 
        case seconds = "Seconds"
        case milliseconds = "Milliseconds"
        case hhmmss = "Hhmmss"
        case hms = "Hms"
    }

    /** The user supplied name of the export request */
    public var name: String?
    /** The requested timezone of the exported data. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London */
    public var timeZone: String?
    /** The requested format of the exported data */
    public var exportFormat: ExportFormat?
    /** The time period used to limit the the exported data. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** The Period of the request in which to break down the intervals. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H */
    public var period: String?
    /** The type of view export job to be created */
    public var viewType: ViewType?
    /** Filters to apply to create the view */
    public var filter: ViewFilter?
    /** Indicates if the request has been marked as read */
    public var read: Bool?
    /** The locale used for localization of the exported data, i.e. en-US, es */
    public var locale: String?
    /** Indicates if durations are formatted in hh:mm:ss format instead of ms */
    public var hasFormatDurations: Bool?
    /** Indicates if filters will be split in aggregate detail exports */
    public var hasSplitFilters: Bool?
    /** Excludes empty rows from the exports */
    public var excludeEmptyRows: Bool?
    /** Indicates if media type will be split in aggregate detail exports */
    public var hasSplitByMedia: Bool?
    /** Indicates if summary row needs to be present in exports */
    public var hasSummaryRow: Bool?
    /** The user supplied csv delimiter string value either of type 'comma' or 'semicolon' permitted for the export request */
    public var csvDelimiter: CsvDelimiter?
    /** The list of ordered selected columns from the export view by the user */
    public var selectedColumns: [SelectedColumns]?
    /** Indicates if custom participant attributes will be exported */
    public var hasCustomParticipantAttributes: Bool?
    /** The list of email recipients for the exports */
    public var recipientEmails: [String]?
    /** Indicates whether to include selected duration format to the column headers */
    public var includeDurationFormatInHeader: Bool?
    /** Indicates the duration format for the exports */
    public var durationFormat: DurationFormat?

    public init(name: String?, timeZone: String?, exportFormat: ExportFormat?, interval: String?, period: String?, viewType: ViewType?, filter: ViewFilter?, read: Bool?, locale: String?, hasFormatDurations: Bool?, hasSplitFilters: Bool?, excludeEmptyRows: Bool?, hasSplitByMedia: Bool?, hasSummaryRow: Bool?, csvDelimiter: CsvDelimiter?, selectedColumns: [SelectedColumns]?, hasCustomParticipantAttributes: Bool?, recipientEmails: [String]?, includeDurationFormatInHeader: Bool?, durationFormat: DurationFormat?) {
        self.name = name
        self.timeZone = timeZone
        self.exportFormat = exportFormat
        self.interval = interval
        self.period = period
        self.viewType = viewType
        self.filter = filter
        self.read = read
        self.locale = locale
        self.hasFormatDurations = hasFormatDurations
        self.hasSplitFilters = hasSplitFilters
        self.excludeEmptyRows = excludeEmptyRows
        self.hasSplitByMedia = hasSplitByMedia
        self.hasSummaryRow = hasSummaryRow
        self.csvDelimiter = csvDelimiter
        self.selectedColumns = selectedColumns
        self.hasCustomParticipantAttributes = hasCustomParticipantAttributes
        self.recipientEmails = recipientEmails
        self.includeDurationFormatInHeader = includeDurationFormatInHeader
        self.durationFormat = durationFormat
    }


}




public class ReportingTurn: Codable {















    public enum AskActionResult: String, Codable { 
        case successCollection = "SuccessCollection"
        case successConfirmationYes = "SuccessConfirmationYes"
        case successConfirmationNo = "SuccessConfirmationNo"
        case noMatchCollection = "NoMatchCollection"
        case noMatchConfirmation = "NoMatchConfirmation"
        case agentRequestedByUser = "AgentRequestedByUser"
        case confirmationRequired = "ConfirmationRequired"
        case error = "Error"
        case expressionError = "ExpressionError"
        case noInputCollection = "NoInputCollection"
        case noInputConfirmation = "NoInputConfirmation"
        case disambiguationRequired = "DisambiguationRequired"
        case successDisambiguation = "SuccessDisambiguation"
        case successDisambiguationNone = "SuccessDisambiguationNone"
        case noMatchDisambiguation = "NoMatchDisambiguation"
        case noInputDisambiguation = "NoInputDisambiguation"
    }





    /** The chosen user input associated with this reporting turn. */
    public var userInput: String?
    /** The bot prompts associated with this reporting turn. */
    public var botPrompts: [String]?
    /** The bot session ID that this reporting turn is grouped under. */
    public var sessionId: String?
    /** The bot flow 'ask' action associated with this reporting turn (e.g. AskForIntent). */
    public var askAction: ReportingTurnAction?
    /** The intent and associated slots detected during this reporting turn. */
    public var intent: ReportingTurnIntent?
    /** The knowledge data captured during this reporting turn. */
    public var knowledge: ReportingTurnKnowledge?
    /** Timestamp indicating when the original turn was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Result of the bot flow 'ask' action. */
    public var askActionResult: AskActionResult?
    /** The details related to end of bot flow session. */
    public var sessionEndDetails: SessionEndDetails?
    /** The conversation details, across potentially multiple Bot Flow sessions. */
    public var conversation: AddressableEntityRef?

    public init(userInput: String?, botPrompts: [String]?, sessionId: String?, askAction: ReportingTurnAction?, intent: ReportingTurnIntent?, knowledge: ReportingTurnKnowledge?, dateCreated: Date?, askActionResult: AskActionResult?, sessionEndDetails: SessionEndDetails?, conversation: AddressableEntityRef?) {
        self.userInput = userInput
        self.botPrompts = botPrompts
        self.sessionId = sessionId
        self.askAction = askAction
        self.intent = intent
        self.knowledge = knowledge
        self.dateCreated = dateCreated
        self.askActionResult = askActionResult
        self.sessionEndDetails = sessionEndDetails
        self.conversation = conversation
    }


}




public class RequestCriteria: Codable {







    public enum Operator: String, Codable { 
        case containsall = "containsAll"
        case containsany = "containsAny"
        case notcontainsall = "notContainsAll"
        case notcontainsany = "notContainsAny"
        case equal = "equal"
        case notequal = "notEqual"
        case greaterthan = "greaterThan"
        case greaterthanorequal = "greaterThanOrEqual"
        case lessthan = "lessThan"
        case lessthanorequal = "lessThanOrEqual"
        case startswith = "startsWith"
        case endswith = "endsWith"
    }

    /** The criteria key. */
    public var key: String?
    /** The criteria values. */
    public var values: [String]?
    /** Should criteria be case insensitive. */
    public var shouldIgnoreCase: Bool?
    /** The comparison operator. */
    public var _operator: Operator?

    public init(key: String?, values: [String]?, shouldIgnoreCase: Bool?, _operator: Operator?) {
        self.key = key
        self.values = values
        self.shouldIgnoreCase = shouldIgnoreCase
        self._operator = _operator
    }

    public enum CodingKeys: String, CodingKey { 
        case key
        case values
        case shouldIgnoreCase
        case _operator = "operator"
    }


}




public class RequestEntityTypeCriteria: Codable {







    public enum Operator: String, Codable { 
        case containsall = "containsAll"
        case containsany = "containsAny"
        case notcontainsall = "notContainsAll"
        case notcontainsany = "notContainsAny"
        case equal = "equal"
        case notequal = "notEqual"
        case greaterthan = "greaterThan"
        case greaterthanorequal = "greaterThanOrEqual"
        case lessthan = "lessThan"
        case lessthanorequal = "lessThanOrEqual"
        case startswith = "startsWith"
        case endswith = "endsWith"
    }

    public enum EntityType: String, Codable { 
        case visit = "visit"
    }

    /** The criteria key. */
    public var key: String?
    /** The criteria values. */
    public var values: [String]?
    /** Should criteria be case insensitive. */
    public var shouldIgnoreCase: Bool?
    /** The comparison operator. */
    public var _operator: Operator?
    /** The entity to match the pattern against. */
    public var entityType: EntityType?

    public init(key: String?, values: [String]?, shouldIgnoreCase: Bool?, _operator: Operator?, entityType: EntityType?) {
        self.key = key
        self.values = values
        self.shouldIgnoreCase = shouldIgnoreCase
        self._operator = _operator
        self.entityType = entityType
    }

    public enum CodingKeys: String, CodingKey { 
        case key
        case values
        case shouldIgnoreCase
        case _operator = "operator"
        case entityType
    }


}




public class ReschedulingManagementUnitResponse: Codable {





    /** The management unit */
    public var managementUnit: ManagementUnitReference?
    /** Whether the rescheduling run is applied for the given management unit */
    public var applied: Bool?

    public init(managementUnit: ManagementUnitReference?, applied: Bool?) {
        self.managementUnit = managementUnit
        self.applied = applied
    }


}




public class ReschedulingOptionsRunResponse: Codable {





















    /** The existing schedule to which this reschedule run applies */
    public var existingSchedule: BuScheduleReference?
    /** The start date of the period to reschedule. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startDate: Date?
    /** The end date of the period to reschedule. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endDate: Date?
    /** Per-management unit rescheduling options */
    public var managementUnits: [ReschedulingManagementUnitResponse]?
    /** The number of agents to be considered in the reschedule */
    public var agentCount: Int?
    /** The IDs of the activity codes being considered for reschedule */
    public var activityCodeIds: [String]?
    /** Whether weekly paid time is allowed to be changed */
    public var doNotChangeWeeklyPaidTime: Bool?
    /** Whether daily paid time is allowed to be changed */
    public var doNotChangeDailyPaidTime: Bool?
    /** Whether shift start times are allowed to be changed */
    public var doNotChangeShiftStartTimes: Bool?
    /** Whether manually edited shifts are allowed to be changed */
    public var doNotChangeManuallyEditedShifts: Bool?

    public init(existingSchedule: BuScheduleReference?, startDate: Date?, endDate: Date?, managementUnits: [ReschedulingManagementUnitResponse]?, agentCount: Int?, activityCodeIds: [String]?, doNotChangeWeeklyPaidTime: Bool?, doNotChangeDailyPaidTime: Bool?, doNotChangeShiftStartTimes: Bool?, doNotChangeManuallyEditedShifts: Bool?) {
        self.existingSchedule = existingSchedule
        self.startDate = startDate
        self.endDate = endDate
        self.managementUnits = managementUnits
        self.agentCount = agentCount
        self.activityCodeIds = activityCodeIds
        self.doNotChangeWeeklyPaidTime = doNotChangeWeeklyPaidTime
        self.doNotChangeDailyPaidTime = doNotChangeDailyPaidTime
        self.doNotChangeShiftStartTimes = doNotChangeShiftStartTimes
        self.doNotChangeManuallyEditedShifts = doNotChangeManuallyEditedShifts
    }


}




public class ResolutionDetailQueryFilter: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }





    /** Boolean operation to apply to the provided predicates and clauses */
    public var type: ModelType?
    /** Boolean 'and/or' logic with up to two-levels of nesting */
    public var clauses: [ResolutionDetailQueryClause]?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [ResolutionDetailQueryPredicate]?

    public init(type: ModelType?, clauses: [ResolutionDetailQueryClause]?, predicates: [ResolutionDetailQueryPredicate]?) {
        self.type = type
        self.clauses = clauses
        self.predicates = predicates
    }


}




public class ResourceConditionValue: Codable {

    public enum ModelType: String, Codable { 
        case scalar = "SCALAR"
        case variable = "VARIABLE"
        case user = "USER"
        case queue = "QUEUE"
    }



    public var type: ModelType?
    public var value: String?

    public init(type: ModelType?, value: String?) {
        self.type = type
        self.value = value
    }


}




public class ResourcePermissionPolicy: Codable {























    public var _id: String?
    public var domain: String?
    public var entityName: String?
    public var policyName: String?
    public var policyDescription: String?
    public var actionSetKey: String?
    public var allowConditions: Bool?
    public var resourceConditionNode: ResourceConditionNode?
    public var namedResources: [String]?
    public var resourceCondition: String?
    public var actionSet: [String]?

    public init(_id: String?, domain: String?, entityName: String?, policyName: String?, policyDescription: String?, actionSetKey: String?, allowConditions: Bool?, resourceConditionNode: ResourceConditionNode?, namedResources: [String]?, resourceCondition: String?, actionSet: [String]?) {
        self._id = _id
        self.domain = domain
        self.entityName = entityName
        self.policyName = policyName
        self.policyDescription = policyDescription
        self.actionSetKey = actionSetKey
        self.allowConditions = allowConditions
        self.resourceConditionNode = resourceConditionNode
        self.namedResources = namedResources
        self.resourceCondition = resourceCondition
        self.actionSet = actionSet
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case domain
        case entityName
        case policyName
        case policyDescription
        case actionSetKey
        case allowConditions
        case resourceConditionNode
        case namedResources
        case resourceCondition
        case actionSet
    }


}




public class ResponseAsset: Codable {

























    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    /** response asset size in bytes */
    public var contentLength: Int64?
    /** response asset location. */
    public var contentLocation: String?
    /** MIME type of response asset */
    public var contentType: String?
    /** Created date of the response asset. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** User who created the response asset */
    public var createdBy: DomainEntityRef?
    /** Last modified date of the response asset. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** User who last modified the response asset */
    public var modifiedBy: DomainEntityRef?
    /** Canned responses actively using this asset */
    public var responses: [DomainEntityRef]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, contentLength: Int64?, contentLocation: String?, contentType: String?, dateCreated: Date?, createdBy: DomainEntityRef?, dateModified: Date?, modifiedBy: DomainEntityRef?, responses: [DomainEntityRef]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.contentLength = contentLength
        self.contentLocation = contentLocation
        self.contentType = contentType
        self.dateCreated = dateCreated
        self.createdBy = createdBy
        self.dateModified = dateModified
        self.modifiedBy = modifiedBy
        self.responses = responses
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case contentLength
        case contentLocation
        case contentType
        case dateCreated
        case createdBy
        case dateModified
        case modifiedBy
        case responses
        case selfUri
    }


}




public class ResponseAssetRequest: Codable {





    /** Name of the file to upload. It must not start with a dot and not end with a forward slash. Whitespace and the following characters are not allowed: \\{^}%`]\">[~<#| */
    public var name: String?
    /** Division to associate to this asset. Can only be used with this division. */
    public var divisionId: String?

    public init(name: String?, divisionId: String?) {
        self.name = name
        self.divisionId = divisionId
    }


}




public class ResponseEntityListing: Codable {





















    public var entities: [ModelResponse]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ModelResponse]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class ResponseSetEntityListing: Codable {





















    public var entities: [ResponseSet]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [ResponseSet]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class RoleDivision: Codable {





    /** Role to be associated with the given division which forms a grant */
    public var roleId: String?
    /** Division associated with the given role which forms a grant */
    public var divisionId: String?

    public init(roleId: String?, divisionId: String?) {
        self.roleId = roleId
        self.divisionId = divisionId
    }


}




public class RoutePathRequest: Codable {



    public enum MediaType: String, Codable { 
        case voice = "Voice"
        case chat = "Chat"
        case email = "Email"
        case callback = "Callback"
        case message = "Message"
    }







    /** The ID of the queue to associate with the route path */
    public var queueId: String?
    /** The media type of the given queue to associate with the route path */
    public var mediaType: MediaType?
    /** The ID of the language to associate with the route path */
    public var languageId: String?
    /** The set of skill IDs to associate with the route path */
    public var skillIds: [String]?
    /** The planning group from which to take route paths. This property is only needed if a route path already exists in another planning group.Note that taking a route path from another planning group will modify the other planning group */
    public var sourcePlanningGroup: SourcePlanningGroupRequest?

    public init(queueId: String?, mediaType: MediaType?, languageId: String?, skillIds: [String]?, sourcePlanningGroup: SourcePlanningGroupRequest?) {
        self.queueId = queueId
        self.mediaType = mediaType
        self.languageId = languageId
        self.skillIds = skillIds
        self.sourcePlanningGroup = sourcePlanningGroup
    }


}




public class RoutingConversationAttributesResponse: Codable {









    /** Current priority value on in-queue conversation. Range:[-25000000, 25000000] */
    public var priority: Int?
    /** Current routing skills on in-queue conversation */
    public var skills: [RoutingSkill]?
    /** Current language on in-queue conversation */
    public var language: Language?
    /** Current scored agents on in-queue conversation */
    public var scoredAgents: [ScoredAgent]?

    public init(priority: Int?, skills: [RoutingSkill]?, language: Language?, scoredAgents: [ScoredAgent]?) {
        self.priority = priority
        self.skills = skills
        self.language = language
        self.scoredAgents = scoredAgents
    }


}




public class RunNowResponse: Codable {







    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case selfUri
    }


}




public class SchedulingSettingsRequest: Codable {









    public enum StartDayOfWeekend: String, Codable { 
        case sunday = "Sunday"
        case monday = "Monday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
        case thursday = "Thursday"
        case friday = "Friday"
        case saturday = "Saturday"
    }

    /** Max occupancy percent for deferred work */
    public var maxOccupancyPercentForDeferredWork: Int?
    /** Default shrinkage percent for scheduling */
    public var defaultShrinkagePercent: Double?
    /** Shrinkage overrides for scheduling */
    public var shrinkageOverrides: ShrinkageOverrides?
    /** Planning period settings for scheduling */
    public var planningPeriod: ValueWrapperPlanningPeriodSettings?
    /** Start day of weekend for scheduling */
    public var startDayOfWeekend: StartDayOfWeekend?

    public init(maxOccupancyPercentForDeferredWork: Int?, defaultShrinkagePercent: Double?, shrinkageOverrides: ShrinkageOverrides?, planningPeriod: ValueWrapperPlanningPeriodSettings?, startDayOfWeekend: StartDayOfWeekend?) {
        self.maxOccupancyPercentForDeferredWork = maxOccupancyPercentForDeferredWork
        self.defaultShrinkagePercent = defaultShrinkagePercent
        self.shrinkageOverrides = shrinkageOverrides
        self.planningPeriod = planningPeriod
        self.startDayOfWeekend = startDayOfWeekend
    }


}



/** Defines a SCIM email address. */

public class ScimEmail: Codable {



    public enum ModelType: String, Codable { 
        case work = "work"
        case other = "other"
    }



    /** The email address. Is immutable if \"type\" is set to \"other\". */
    public var value: String?
    /** The type of email address. \"value\" is immutable if \"type\" is set to \"other\". */
    public var type: ModelType?
    /** Indicates whether the email address is the primary email address. */
    public var primary: Bool?

    public init(value: String?, type: ModelType?, primary: Bool?) {
        self.value = value
        self.type = type
        self.primary = primary
    }


}



/** Defines a SCIM phone number. */

public class ScimPhoneNumber: Codable {



    public enum ModelType: String, Codable { 
        case work = "work"
        case work2 = "work2"
        case work3 = "work3"
        case work4 = "work4"
        case home = "home"
        case mobile = "mobile"
        case other = "other"
        case microsoftteams = "microsoftteams"
        case zoomphone = "zoomphone"
        case eightbyeight = "eightbyeight"
    }



    /** The phone number in E.164 or tel URI format, for example, tel:+nnnnnnnn; ext=xxxxx. */
    public var value: String?
    /** The type of phone number. */
    public var type: ModelType?
    /** Indicates whether the phone number is the primary phone number. */
    public var primary: Bool?

    public init(value: String?, type: ModelType?, primary: Bool?) {
        self.value = value
        self.type = type
        self.primary = primary
    }


}




public class Script: Codable {































    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: Division?
    public var versionId: String?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var createdDate: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var publishedDate: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var versionDate: Date?
    public var startPageId: String?
    public var startPageName: String?
    public var features: JSON?
    public var variables: JSON?
    public var customActions: JSON?
    public var pages: [Page]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: Division?, versionId: String?, createdDate: Date?, modifiedDate: Date?, publishedDate: Date?, versionDate: Date?, startPageId: String?, startPageName: String?, features: JSON?, variables: JSON?, customActions: JSON?, pages: [Page]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self.versionId = versionId
        self.createdDate = createdDate
        self.modifiedDate = modifiedDate
        self.publishedDate = publishedDate
        self.versionDate = versionDate
        self.startPageId = startPageId
        self.startPageName = startPageName
        self.features = features
        self.variables = variables
        self.customActions = customActions
        self.pages = pages
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case versionId
        case createdDate
        case modifiedDate
        case publishedDate
        case versionDate
        case startPageId
        case startPageName
        case features
        case variables
        case customActions
        case pages
        case selfUri
    }


}



/** The routing language assigned to a user. */

public class ScimUserRoutingLanguage: Codable {





    /** The case-sensitive name of a routing language configured in Genesys Cloud. */
    public var name: String?
    /** A rating from 0.0 to 5.0 that indicates how fluent an agent is in a particular language. ACD interactions are routed to agents with higher proficiency ratings. */
    public var proficiency: Double?

    public init(name: String?, proficiency: Double?) {
        self.name = name
        self.proficiency = proficiency
    }


}



/** Defines a SCIM enterprise user. */

public class ScimV2EnterpriseUser: Codable {









    /** The division that the user belongs to. */
    public var division: String?
    /** The department that the user belongs to. */
    public var department: String?
    /** The user's manager. */
    public var manager: Manager?
    /** The user's employee number. */
    public var employeeNumber: String?

    public init(division: String?, department: String?, manager: Manager?, employeeNumber: String?) {
        self.division = division
        self.department = department
        self.manager = manager
        self.employeeNumber = employeeNumber
    }


}



/** Defines the list response for SCIM resource types. */

public class ScimV2SchemaListResponse: Codable {











    /** The list of supported schemas. */
    public var schemas: [String]?
    /** The total number of results. */
    public var totalResults: Int64?
    /** The 1-based index of the first result returned by this request. Add this to \"itemsPerPage\" when requesting the next page of results. */
    public var startIndex: Int64?
    /** The number of resources returned per page. */
    public var itemsPerPage: Int64?
    /** The list of requested resources. */
    public var resources: [ScimV2SchemaDefinition]?

    public init(schemas: [String]?, totalResults: Int64?, startIndex: Int64?, itemsPerPage: Int64?, resources: [ScimV2SchemaDefinition]?) {
        self.schemas = schemas
        self.totalResults = totalResults
        self.startIndex = startIndex
        self.itemsPerPage = itemsPerPage
        self.resources = resources
    }

    public enum CodingKeys: String, CodingKey { 
        case schemas
        case totalResults
        case startIndex
        case itemsPerPage
        case resources = "Resources"
    }


}




public class Screenshare: Codable {

    public enum State: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }

    public enum InitialState: String, Codable { 
        case alerting = "alerting"
        case dialing = "dialing"
        case contacting = "contacting"
        case offering = "offering"
        case connected = "connected"
        case disconnected = "disconnected"
        case terminated = "terminated"
        case _none = "none"
    }









    public enum DisconnectType: String, Codable { 
        case endpoint = "endpoint"
        case client = "client"
        case system = "system"
        case timeout = "timeout"
        case transfer = "transfer"
        case transferConference = "transfer.conference"
        case transferConsult = "transfer.consult"
        case transferForward = "transfer.forward"
        case transferNoanswer = "transfer.noanswer"
        case transferNotavailable = "transfer.notavailable"
        case transportFailure = "transport.failure"
        case error = "error"
        case peer = "peer"
        case other = "other"
        case spam = "spam"
        case uncallable = "uncallable"
    }



















    /** The connection state of this communication. */
    public var state: State?
    /** The initial connection state of this communication. */
    public var initialState: InitialState?
    /** A globally unique identifier for this communication. */
    public var _id: String?
    /** The room id context (xmpp jid) for the conference session. */
    public var context: String?
    /** Indicates whether this participant is sharing their screen. */
    public var sharing: Bool?
    /** The number of peer participants from the perspective of the participant in the conference. */
    public var peerCount: Int?
    /** System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects. */
    public var disconnectType: DisconnectType?
    /** The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var startAlertingTime: Date?
    /** The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var connectedTime: Date?
    /** The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var disconnectedTime: Date?
    /** The source provider for the screen share. */
    public var provider: String?
    /** The id of the peer communication corresponding to a matching leg for this communication. */
    public var peerId: String?
    /** The time line of the participant's call, divided into activity segments. */
    public var segments: [Segment]?
    /** Call wrap up or disposition data. */
    public var wrapup: Wrapup?
    /** After-call work for the communication. */
    public var afterCallWork: AfterCallWork?
    /** Indicates if after-call work is required for a communication. Only used when the ACW Setting is Agent Requested. */
    public var afterCallWorkRequired: Bool?

    public init(state: State?, initialState: InitialState?, _id: String?, context: String?, sharing: Bool?, peerCount: Int?, disconnectType: DisconnectType?, startAlertingTime: Date?, connectedTime: Date?, disconnectedTime: Date?, provider: String?, peerId: String?, segments: [Segment]?, wrapup: Wrapup?, afterCallWork: AfterCallWork?, afterCallWorkRequired: Bool?) {
        self.state = state
        self.initialState = initialState
        self._id = _id
        self.context = context
        self.sharing = sharing
        self.peerCount = peerCount
        self.disconnectType = disconnectType
        self.startAlertingTime = startAlertingTime
        self.connectedTime = connectedTime
        self.disconnectedTime = disconnectedTime
        self.provider = provider
        self.peerId = peerId
        self.segments = segments
        self.wrapup = wrapup
        self.afterCallWork = afterCallWork
        self.afterCallWorkRequired = afterCallWorkRequired
    }

    public enum CodingKeys: String, CodingKey { 
        case state
        case initialState
        case _id = "id"
        case context
        case sharing
        case peerCount
        case disconnectType
        case startAlertingTime
        case connectedTime
        case disconnectedTime
        case provider
        case peerId
        case segments
        case wrapup
        case afterCallWork
        case afterCallWorkRequired
    }


}




public class SearchShiftTradesRequest: Codable {





    /** The ID of the schedule for which to search for available shift trades */
    public var receivingScheduleId: String?
    /** The IDs of shifts that the receiving user would potentially be willing to trade. If empty, only returns one sided trades (pick up a shift) */
    public var receivingShiftIds: [String]?

    public init(receivingScheduleId: String?, receivingShiftIds: [String]?) {
        self.receivingScheduleId = receivingScheduleId
        self.receivingShiftIds = receivingShiftIds
    }


}




public class SearchUpdateRequest: Codable {







    /** The unique identifier of this session */
    public var sessionId: String?
    /** Mark the search as answered/unanswered */
    public var answered: Bool?
    /** The selected search result chosen as the answer. */
    public var selectedAnswer: SelectedAnswer?

    public init(sessionId: String?, answered: Bool?, selectedAnswer: SelectedAnswer?) {
        self.sessionId = sessionId
        self.answered = answered
        self.selectedAnswer = selectedAnswer
    }


}




public class SecurityProfileEntityListing: Codable {





















    public var entities: [SecurityProfile]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [SecurityProfile]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class SentimentFeedback: Codable {







    public enum FeedbackValue: String, Codable { 
        case neutral = "Neutral"
        case positive = "Positive"
        case negative = "Negative"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The phrase for which sentiment feedback is provided */
    public var phrase: String?
    /** The dialect for the given phrase, dialect format is {language}-{country} where language follows ISO 639-1 standard and country follows ISO 3166-1 alpha 2 standard */
    public var dialect: String?
    /** The sentiment feedback value for the given phrase */
    public var feedbackValue: FeedbackValue?
    /** The Timestamp when sentiment feedback created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The Id of user who created the sentiment feedback */
    public var createdBy: AddressableEntityRef?

    public init(_id: String?, phrase: String?, dialect: String?, feedbackValue: FeedbackValue?, dateCreated: Date?, createdBy: AddressableEntityRef?) {
        self._id = _id
        self.phrase = phrase
        self.dialect = dialect
        self.feedbackValue = feedbackValue
        self.dateCreated = dateCreated
        self.createdBy = createdBy
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case phrase
        case dialect
        case feedbackValue
        case dateCreated
        case createdBy
    }


}




public class ServiceGoalTemplateImpactOverride: Codable {





    /** Whether service goal overrides are enabled for this service goal template */
    public var enabled: Bool?
    /** Settings controlling max percent increase and decrease of service goals for this service goal template */
    public var impact: WfmServiceGoalImpactSettings?

    public init(enabled: Bool?, impact: WfmServiceGoalImpactSettings?) {
        self.enabled = enabled
        self.impact = impact
    }


}




public class SessionEndDetails: Codable {

    public enum ModelType: String, Codable { 
        case disconnect = "Disconnect"
        case exit = "Exit"
    }



    /** The type of termination handling that resulted in the session end. It can be either Exit or Disconnect */
    public var type: ModelType?
    /** The reason for termination action. It can be due to an error or normal flow execution */
    public var reason: String?

    public init(type: ModelType?, reason: String?) {
        self.type = type
        self.reason = reason
    }


}




public class SetContentTemplateActionSettings: Codable {





    /** A string of sms contentTemplateId. */
    public var smsContentTemplateId: String?
    /** A string of email contentTemplateId. */
    public var emailContentTemplateId: String?

    public init(smsContentTemplateId: String?, emailContentTemplateId: String?) {
        self.smsContentTemplateId = smsContentTemplateId
        self.emailContentTemplateId = emailContentTemplateId
    }


}




public class Settings: Codable {











    /** Communication Based ACW */
    public var communicationBasedACW: Bool?
    /** Display communication summary */
    public var includeNonAgentConversationSummary: Bool?
    /** Allow Callback Queue Selection */
    public var allowCallbackQueueSelection: Bool?
    /** Complete ACW When Agent Transitions Offline */
    public var completeAcwWhenAgentTransitionsOffline: Bool?
    /** Exclude the 'interacting' duration from the handle calculations of callbacks */
    public var totalActiveCallback: Bool?

    public init(communicationBasedACW: Bool?, includeNonAgentConversationSummary: Bool?, allowCallbackQueueSelection: Bool?, completeAcwWhenAgentTransitionsOffline: Bool?, totalActiveCallback: Bool?) {
        self.communicationBasedACW = communicationBasedACW
        self.includeNonAgentConversationSummary = includeNonAgentConversationSummary
        self.allowCallbackQueueSelection = allowCallbackQueueSelection
        self.completeAcwWhenAgentTransitionsOffline = completeAcwWhenAgentTransitionsOffline
        self.totalActiveCallback = totalActiveCallback
    }


}




public class Share: Codable {





    public enum SharedEntityType: String, Codable { 
        case document = "DOCUMENT"
    }



    public enum MemberType: String, Codable { 
        case user = "USER"
        case group = "GROUP"
        case _public = "PUBLIC"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var sharedEntityType: SharedEntityType?
    public var sharedEntity: DomainEntityRef?
    public var memberType: MemberType?
    public var member: DomainEntityRef?
    public var sharedBy: DomainEntityRef?
    public var workspace: DomainEntityRef?
    public var user: User?
    public var group: Group?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, sharedEntityType: SharedEntityType?, sharedEntity: DomainEntityRef?, memberType: MemberType?, member: DomainEntityRef?, sharedBy: DomainEntityRef?, workspace: DomainEntityRef?, user: User?, group: Group?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.sharedEntityType = sharedEntityType
        self.sharedEntity = sharedEntity
        self.memberType = memberType
        self.member = member
        self.sharedBy = sharedBy
        self.workspace = workspace
        self.user = user
        self.group = group
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case sharedEntityType
        case sharedEntity
        case memberType
        case member
        case sharedBy
        case workspace
        case user
        case group
        case selfUri
    }


}




public class ShiftTradeActivityRule: Codable {

    public enum ActivityCategory: String, Codable { 
        case onQueueWork = "OnQueueWork"
        case _break = "Break"
        case meal = "Meal"
        case meeting = "Meeting"
        case offQueueWork = "OffQueueWork"
        case timeOff = "TimeOff"
        case training = "Training"
        case unavailable = "Unavailable"
        case unscheduled = "Unscheduled"
    }

    public enum Action: String, Codable { 
        case replace = "Replace"
        case doNotAllowTrade = "DoNotAllowTrade"
        case keepWithSchedule = "KeepWithSchedule"
    }



    /** The activity category to which to apply this rule */
    public var activityCategory: ActivityCategory?
    /** The action this rule invokes */
    public var action: Action?
    /** The activity code ID with which to replace activities belonging to the original category if applicable (required if action == Replace, must be a default activity code ID) */
    public var activityCodeIdReplacement: String?

    public init(activityCategory: ActivityCategory?, action: Action?, activityCodeIdReplacement: String?) {
        self.activityCategory = activityCategory
        self.action = action
        self.activityCodeIdReplacement = activityCodeIdReplacement
    }


}




public class SkillGroupDefinition: Codable {

















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The group name. */
    public var name: String?
    /** The division to which this entity belongs. */
    public var division: WritableDivision?
    /** Group description */
    public var _description: String?
    /** Estimated number of members in this group. It can take some time for the count to be updated after expressions are changed. */
    public var memberCount: Int64?
    /** Last modified date/time of the skill group. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** Created date/time of the skill group. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, division: WritableDivision?, _description: String?, memberCount: Int64?, dateModified: Date?, dateCreated: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.division = division
        self._description = _description
        self.memberCount = memberCount
        self.dateModified = dateModified
        self.dateCreated = dateCreated
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case division
        case _description = "description"
        case memberCount
        case dateModified
        case dateCreated
        case selfUri
    }


}




public class SmsAddressEntityListing: Codable {





















    public var entities: [SmsAddress]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [SmsAddress]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class SmsPhoneNumberProvision: Codable {





    public enum PhoneNumberType: String, Codable { 
        case local = "local"
        case mobile = "mobile"
        case tollfree = "tollfree"
        case shortcode = "shortcode"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** A phone number to be used for SMS communications. E.g. +13175555555 or +34234234234 */
    public var phoneNumber: String?
    /** Type of the phone number provisioned. */
    public var phoneNumberType: PhoneNumberType?
    /** The ISO 3166-1 alpha-2 country code of the country this phone number is associated with. */
    public var countryCode: String?
    public var name: String?
    /** The id of an address added on your account. Due to regulatory requirements in some countries, an address may be required when provisioning a sms number. In those cases you should provide the provisioned sms address id here */
    public var addressId: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, phoneNumber: String?, phoneNumberType: PhoneNumberType?, countryCode: String?, name: String?, addressId: String?, selfUri: String?) {
        self._id = _id
        self.phoneNumber = phoneNumber
        self.phoneNumberType = phoneNumberType
        self.countryCode = countryCode
        self.name = name
        self.addressId = addressId
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case phoneNumber
        case phoneNumberType
        case countryCode
        case name
        case addressId
        case selfUri
    }


}




public class StatEventCampaignTopicStatsNotification: Codable {





    public var group: [String:String]?
    public var data: [StatEventCampaignTopicIntervalMetrics]?

    public init(group: [String:String]?, data: [StatEventCampaignTopicIntervalMetrics]?) {
        self.group = group
        self.data = data
    }


}




public class StatEventFlowOutcomeTopicStatsNotification: Codable {





    public var group: [String:String]?
    public var data: [StatEventFlowOutcomeTopicIntervalMetrics]?

    public init(group: [String:String]?, data: [StatEventFlowOutcomeTopicIntervalMetrics]?) {
        self.group = group
        self.data = data
    }


}




public class StatEventFlowTopicIntervalMetrics: Codable {





    public var interval: String?
    public var metrics: [StatEventFlowTopicMetricStats]?

    public init(interval: String?, metrics: [StatEventFlowTopicMetricStats]?) {
        self.interval = interval
        self.metrics = metrics
    }


}




public class StatEventFlowTopicMetricStats: Codable {







    public var metric: String?
    public var qualifier: String?
    public var stats: [String:Double]?

    public init(metric: String?, qualifier: String?, stats: [String:Double]?) {
        self.metric = metric
        self.qualifier = qualifier
        self.stats = stats
    }


}




public class StatEventUserTopicStatsNotification: Codable {





    public var group: [String:String]?
    public var data: [StatEventUserTopicIntervalMetrics]?

    public init(group: [String:String]?, data: [StatEventUserTopicIntervalMetrics]?) {
        self.group = group
        self.data = data
    }


}




public class StatisticalResponse: Codable {







    public var interval: String?
    public var metrics: [AggregateMetricData]?
    public var views: [AggregateViewData]?

    public init(interval: String?, metrics: [AggregateMetricData]?, views: [AggregateViewData]?) {
        self.interval = interval
        self.metrics = metrics
        self.views = views
    }


}




public class StorySetting: Codable {





    /** Setting relating to Story Mentions */
    public var mention: InboundOnlySetting?
    /** Setting relating to Story Replies */
    public var reply: InboundOnlySetting?

    public init(mention: InboundOnlySetting?, reply: InboundOnlySetting?) {
        self.mention = mention
        self.reply = reply
    }


}




public class SupportCenterCategory: Codable {







    public var _id: String?
    public var selfUri: String?
    /** Image attributes for a featured category */
    public var image: SupportCenterImage?

    public init(_id: String?, selfUri: String?, image: SupportCenterImage?) {
        self._id = _id
        self.selfUri = selfUri
        self.image = image
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case image
    }


}




public class Survey: Codable {











    public enum Status: String, Codable { 
        case pending = "Pending"
        case sent = "Sent"
        case inProgress = "InProgress"
        case finished = "Finished"
        case optOut = "OptOut"
        case error = "Error"
        case expired = "Expired"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var conversation: ConversationReference?
    /** Survey form used for this survey. */
    public var surveyForm: SurveyForm?
    public var agent: DomainEntityRef?
    public var status: Status?
    public var queue: QueueReference?
    public var answers: SurveyScoringSet?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var completedDate: Date?
    /** Additional information about what happened when the survey is in Error status. */
    public var surveyErrorDetails: SurveyErrorDetails?
    /** The team that the agent belongs to */
    public var agentTeam: Team?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, conversation: ConversationReference?, surveyForm: SurveyForm?, agent: DomainEntityRef?, status: Status?, queue: QueueReference?, answers: SurveyScoringSet?, completedDate: Date?, surveyErrorDetails: SurveyErrorDetails?, agentTeam: Team?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.conversation = conversation
        self.surveyForm = surveyForm
        self.agent = agent
        self.status = status
        self.queue = queue
        self.answers = answers
        self.completedDate = completedDate
        self.surveyErrorDetails = surveyErrorDetails
        self.agentTeam = agentTeam
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case conversation
        case surveyForm
        case agent
        case status
        case queue
        case answers
        case completedDate
        case surveyErrorDetails
        case agentTeam
        case selfUri
    }


}




public class SurveyAggregateQueryPredicate: Codable {

    public enum ModelType: String, Codable { 
        case dimension = "dimension"
        case property = "property"
        case metric = "metric"
    }

    public enum Dimension: String, Codable { 
        case conversationid = "conversationId"
        case divisionid = "divisionId"
        case externalcontactid = "externalContactId"
        case mediatype = "mediaType"
        case queueid = "queueId"
        case requestedlanguageid = "requestedLanguageId"
        case requestedroutingskillid = "requestedRoutingSkillId"
        case surveyanswerid = "surveyAnswerId"
        case surveycreateddate = "surveyCreatedDate"
        case surveyerrorreason = "surveyErrorReason"
        case surveyformcontextid = "surveyFormContextId"
        case surveyformid = "surveyFormId"
        case surveyformname = "surveyFormName"
        case surveyid = "surveyId"
        case surveypreviousstatus = "surveyPreviousStatus"
        case surveypromoterscore = "surveyPromoterScore"
        case surveyquestiongroupid = "surveyQuestionGroupId"
        case surveyquestionid = "surveyQuestionId"
        case surveystatus = "surveyStatus"
        case teamid = "teamId"
        case userid = "userId"
        case wrapupcode = "wrapUpCode"
    }

    public enum Operator: String, Codable { 
        case matches = "matches"
        case exists = "exists"
        case notexists = "notExists"
    }





    /** Optional type, can usually be inferred */
    public var type: ModelType?
    /** Left hand side for dimension predicates */
    public var dimension: Dimension?
    /** Optional operator, default is matches */
    public var _operator: Operator?
    /** Right hand side for dimension predicates */
    public var value: String?
    /** Right hand side for dimension predicates */
    public var range: NumericRange?

    public init(type: ModelType?, dimension: Dimension?, _operator: Operator?, value: String?, range: NumericRange?) {
        self.type = type
        self.dimension = dimension
        self._operator = _operator
        self.value = value
        self.range = range
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case dimension
        case _operator = "operator"
        case value
        case range
    }


}




public class SurveyScoringSet: Codable {







    public var totalScore: Float?
    public var npsScore: Int?
    public var questionGroupScores: [SurveyQuestionGroupScore]?

    public init(totalScore: Float?, npsScore: Int?, questionGroupScores: [SurveyQuestionGroupScore]?) {
        self.totalScore = totalScore
        self.npsScore = npsScore
        self.questionGroupScores = questionGroupScores
    }


}




public class SystemPromptAsset: Codable {



















    public enum UploadStatus: String, Codable { 
        case created = "created"
        case uploaded = "uploaded"
        case transcoded = "transcoded"
        case transcodefailed = "transcodeFailed"
    }









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var promptId: String?
    /** The asset resource language */
    public var language: String?
    public var durationSeconds: Double?
    public var mediaUri: String?
    public var ttsString: String?
    public var text: String?
    public var uploadUri: String?
    public var uploadStatus: UploadStatus?
    public var hasDefault: Bool?
    public var languageDefault: Bool?
    public var tags: [String:[String]]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, promptId: String?, language: String?, durationSeconds: Double?, mediaUri: String?, ttsString: String?, text: String?, uploadUri: String?, uploadStatus: UploadStatus?, hasDefault: Bool?, languageDefault: Bool?, tags: [String:[String]]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.promptId = promptId
        self.language = language
        self.durationSeconds = durationSeconds
        self.mediaUri = mediaUri
        self.ttsString = ttsString
        self.text = text
        self.uploadUri = uploadUri
        self.uploadStatus = uploadStatus
        self.hasDefault = hasDefault
        self.languageDefault = languageDefault
        self.tags = tags
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case promptId
        case language
        case durationSeconds
        case mediaUri
        case ttsString
        case text
        case uploadUri
        case uploadStatus
        case hasDefault
        case languageDefault
        case tags
        case selfUri
    }


}




public class SystemPromptEntityListing: Codable {





















    public var entities: [SystemPrompt]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [SystemPrompt]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class TargetPerformanceProfile: Codable {



    /** The target destination performanceProfileId for the linked metric. */
    public var targetPerformanceProfileId: String?

    public init(targetPerformanceProfileId: String?) {
        self.targetPerformanceProfileId = targetPerformanceProfileId
    }


}




public class TeamSearchRequest: Codable {

    public enum SortOrder: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
        case score = "SCORE"
    }











    /** The sort order for results */
    public var sortOrder: SortOrder?
    /** The field in the resource that you want to sort the results by */
    public var sortBy: String?
    /** The number of results per page */
    public var pageSize: Int?
    /** The page of resources you want to retrieve */
    public var pageNumber: Int?
    /** Multi-value sort order, list of multiple sort values */
    public var sort: [SearchSort]?
    /** Team Search Criteria */
    public var query: [TeamSearchCriteria]?

    public init(sortOrder: SortOrder?, sortBy: String?, pageSize: Int?, pageNumber: Int?, sort: [SearchSort]?, query: [TeamSearchCriteria]?) {
        self.sortOrder = sortOrder
        self.sortBy = sortBy
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.sort = sort
        self.query = query
    }


}



/** Results from evaluating matching criteria against test input */

public class TestMatchesEventOperation: Codable {









    /** The name of the processing step */
    public var name: String?
    /** The number of the processing step */
    public var step: Int?
    /** Triggers that matched */
    public var matchedTriggers: [TestModeTrigger]?
    /** Triggers that did not match */
    public var unmatchedTriggers: [TestModeTrigger]?

    public init(name: String?, step: Int?, matchedTriggers: [TestModeTrigger]?, unmatchedTriggers: [TestModeTrigger]?) {
        self.name = name
        self.step = step
        self.matchedTriggers = matchedTriggers
        self.unmatchedTriggers = unmatchedTriggers
    }


}



/** Information about trigger test mode execution */

public class TestModeResults: Codable {









    /** Information about the validation of the schema of the event body passed in to test mode */
    public var schemaValidation: TestSchemaOperation?
    /** Information about the validation of the trigger target */
    public var targetValidation: TestTargetOperation?
    /** Information about the json path matching criteria */
    public var jsonPathValidation: TestMatchesOperation?
    /** Whether the trigger would have matched on the provided event body */
    public var triggerMatches: Bool?

    public init(schemaValidation: TestSchemaOperation?, targetValidation: TestTargetOperation?, jsonPathValidation: TestMatchesOperation?, triggerMatches: Bool?) {
        self.schemaValidation = schemaValidation
        self.targetValidation = targetValidation
        self.jsonPathValidation = jsonPathValidation
        self.triggerMatches = triggerMatches
    }


}



/** Basic identifying information about a trigger */

public class TestModeTrigger: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the trigger */
    public var name: String?
    /** Whether or not the trigger is enabled */
    public var enabled: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, enabled: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.enabled = enabled
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case enabled
        case selfUri
    }


}



/** Information about the Trigger test mode schema validation step */

public class TestSchemaOperation: Codable {









    /** The name of the processing step */
    public var name: String?
    /** The number of the processing step */
    public var step: Int?
    /** Whether or not the operation matches expectations */
    public var matches: Bool?
    /** Details about why the operation did or did not succeed */
    public var details: [String]?

    public init(name: String?, step: Int?, matches: Bool?, details: [String]?) {
        self.name = name
        self.step = step
        self.matches = matches
        self.details = details
    }


}



/** Settings for a next-action of disconnecting, including the reason code for the disconnect. */

public class TextBotDisconnectAction: Codable {

    public enum Reason: String, Codable { 
        case triggeredByUser = "TriggeredByUser"
        case triggeredByFlow = "TriggeredByFlow"
        case sessionExpired = "SessionExpired"
        case error = "Error"
        case recognitionFailure = "RecognitionFailure"
    }







    /** The reason for the disconnect. */
    public var reason: Reason?
    /** Extended information related to the reason, if available. */
    public var reasonExtendedInfo: String?
    /** Describes where in the Bot Flow the user was when the disconnect occurred. */
    public var flowLocation: TextBotFlowLocation?
    /** The list of Flow Outcomes for the bot flow and their details. */
    public var flowOutcomes: [TextBotFlowOutcome]?

    public init(reason: Reason?, reasonExtendedInfo: String?, flowLocation: TextBotFlowLocation?, flowOutcomes: [TextBotFlowOutcome]?) {
        self.reason = reason
        self.reasonExtendedInfo = reasonExtendedInfo
        self.flowLocation = flowLocation
        self.flowOutcomes = flowOutcomes
    }


}



/** Flow Outcome data related to a bot flow which is exiting gracefully. */

public class TextBotFlowOutcome: Codable {



    public enum OutcomeValue: String, Codable { 
        case success = "SUCCESS"
        case failure = "FAILURE"
    }







    /** The Flow Outcome ID. */
    public var outcomeId: String?
    /** The value of the FlowOutcome. */
    public var outcomeValue: OutcomeValue?
    /** The timestamp for when the Flow Outcome began. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?
    /** The timestamp for when the Flow Outcome finished. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateEnd: Date?
    /** The Flow Milestones for the Flow Outcome. */
    public var milestones: [TextBotFlowMilestone]?

    public init(outcomeId: String?, outcomeValue: OutcomeValue?, dateStart: Date?, dateEnd: Date?, milestones: [TextBotFlowMilestone]?) {
        self.outcomeId = outcomeId
        self.outcomeValue = outcomeValue
        self.dateStart = dateStart
        self.dateEnd = dateEnd
        self.milestones = milestones
    }


}



/** Information related to a success bot flow turn request. */

public class TextBotFlowTurnResponse: Codable {







    public enum NextActionType: String, Codable { 
        case noOp = "NoOp"
        case disconnect = "Disconnect"
        case waitForInput = "WaitForInput"
        case exit = "Exit"
    }







    /** The ID of the bot flow turn. If additional turns are needed, supply this ID as the previous turn in your next turn request. */
    public var _id: String?
    /** The reference to a previous turn, if applicable. */
    public var previousTurn: TextBotTurnReference?
    /** The output prompts for this turn. */
    public var prompts: TextBotOutputPrompts?
    /** Indicates the suggested next action. If appropriate, the matching output event object includes additional information. */
    public var nextActionType: NextActionType?
    /** The next action directive for this turn if it is a Disconnect type. */
    public var nextActionDisconnect: TextBotDisconnectAction?
    /** The next action directive for this turn if it is a WaitForInput type. */
    public var nextActionWaitForInput: TextBotWaitForInputAction?
    /** The next action directive for this turn if it is an Exit type. */
    public var nextActionExit: TextBotExitAction?

    public init(_id: String?, previousTurn: TextBotTurnReference?, prompts: TextBotOutputPrompts?, nextActionType: NextActionType?, nextActionDisconnect: TextBotDisconnectAction?, nextActionWaitForInput: TextBotWaitForInputAction?, nextActionExit: TextBotExitAction?) {
        self._id = _id
        self.previousTurn = previousTurn
        self.prompts = prompts
        self.nextActionType = nextActionType
        self.nextActionDisconnect = nextActionDisconnect
        self.nextActionWaitForInput = nextActionWaitForInput
        self.nextActionExit = nextActionExit
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case previousTurn
        case prompts
        case nextActionType
        case nextActionDisconnect
        case nextActionWaitForInput
        case nextActionExit
    }


}



/** Mode constraints to observe when operating on a bot flow. */

public class TextBotModeConstraints: Codable {



    /** Mode constraints that apply to text scenarios. */
    public var text: TextBotTextModeConstraints?

    public init(text: TextBotTextModeConstraints?) {
        self.text = text
    }


}



/** Data for a single bot flow prompt segment. */

public class TextBotPromptSegment: Codable {



    public enum ModelType: String, Codable { 
        case text = "Text"
        case richMedia = "RichMedia"
    }





    /** The text of this prompt segment. */
    public var text: String?
    /** The segment type which describes any semantics about the 'text' and also indicates which other field might include additional relevant info. */
    public var type: ModelType?
    /** Additional details describing the segments contents, which the client should honour where possible. */
    public var format: Format?
    /** Details to display Rich Media content. This is only populated when the segment 'type' is 'Rich Media'. */
    public var content: [MessageContent]?

    public init(text: String?, type: ModelType?, format: Format?, content: [MessageContent]?) {
        self.text = text
        self.type = type
        self.format = format
        self.content = content
    }


}



/** Information about the caller executing a bot flow. */

public class TextBotUserAgent: Codable {

    public enum Name: String, Codable { 
        case phone = "Phone"
        case sms = "SMS"
        case genesysWebWidget = "GenesysWebWidget"
        case facebookMessenger = "FacebookMessenger"
        case weChat = "WeChat"
        case whatsapp = "Whatsapp"
        case appleBusinessChat = "AppleBusinessChat"
        case telegram = "Telegram"
        case slack = "Slack"
        case signal = "Signal"
        case line = "Line"
        case discord = "Discord"
        case twitterDirectMessage = "TwitterDirectMessage"
        case other = "Other"
        case unknown = "Unknown"
    }

    /** The name of the user agent. */
    public var name: Name?

    public init(name: Name?) {
        self.name = name
    }


}




public class TextStyleProperties: Codable {







    public enum TextAlign: String, Codable { 
        case _left = "Left"
        case _right = "Right"
        case center = "Center"
    }

    /** Color of the text. (eg. #FFFFFF) */
    public var color: String?
    /** Font of the text. (eg. Helvetica) */
    public var font: String?
    /** Font size of the text. (eg. '12') */
    public var fontSize: String?
    /** Text alignment. */
    public var textAlign: TextAlign?

    public init(color: String?, font: String?, fontSize: String?, textAlign: TextAlign?) {
        self.color = color
        self.font = font
        self.fontSize = fontSize
        self.textAlign = textAlign
    }


}




public class TimeOffBalanceJobReference: Codable {



    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case error = "Error"
    }



    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The status of the job */
    public var status: Status?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, status: Status?, selfUri: String?) {
        self._id = _id
        self.status = status
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case status
        case selfUri
    }


}




public class TimeOffIntegrationStatusResponse: Codable {



    public enum IntegrationStatus: String, Codable { 
        case processing = "Processing"
        case error = "Error"
        case automaticallyComplete = "AutomaticallyComplete"
        case manuallyComplete = "ManuallyComplete"
    }

    /** The time off request associated with this integration status */
    public var timeOffRequest: TimeOffRequestReference?
    /** The value of integration status for the time off request */
    public var integrationStatus: IntegrationStatus?

    public init(timeOffRequest: TimeOffRequestReference?, integrationStatus: IntegrationStatus?) {
        self.timeOffRequest = timeOffRequest
        self.integrationStatus = integrationStatus
    }


}




public class TimeOffIntegrationStatusResponseListing: Codable {



    public var entities: [TimeOffIntegrationStatusResponse]?

    public init(entities: [TimeOffIntegrationStatusResponse]?) {
        self.entities = entities
    }


}




public class TimeOffLimitReference: Codable {





    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class TimeOffRequestList: Codable {









    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    public var timeOffRequests: [TimeOffRequestResponse]?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, timeOffRequests: [TimeOffRequestResponse]?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.timeOffRequests = timeOffRequests
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case timeOffRequests
        case selfUri
    }


}




public class TimeOffRequestQueryBody: Codable {






    public enum Statuses: String, Codable { 
        case pending = "PENDING"
    }

    public enum Substatuses: String, Codable { 
        case advanceTimeElapsed = "AdvanceTimeElapsed"
        case autoApproved = "AutoApproved"
        case insufficientBalance = "InsufficientBalance"
        case invalidDailyDuration = "InvalidDailyDuration"
        case outsideShift = "OutsideShift"
        case removedFromWaitlist = "RemovedFromWaitlist"
        case waitlisted = "Waitlisted"
    }


    /** The set of ids to filter time off requests */
    public var ids: [String]?
    /** The set of user ids to filter time off requests */
    public var userIds: [String]?
    /** The set of statuses to filter time off requests */
    public var statuses: [Statuses]?
    /** The set of substatuses to filter time off requests */
    public var substatuses: [Substatuses]?
    /** The inclusive range of dates to filter time off requests */
    public var dateRange: DateRange?

    public init(ids: [String]?, userIds: [String]?, statuses: [Statuses]?, substatuses: [Substatuses]?, dateRange: DateRange?) {
        self.ids = ids
        self.userIds = userIds
        self.statuses = statuses
        self.substatuses = substatuses
        self.dateRange = dateRange
    }


}




public class TimeOffRequestResponse: Codable {













    public enum Status: String, Codable { 
        case pending = "PENDING"
        case approved = "APPROVED"
        case denied = "DENIED"
        case canceled = "CANCELED"
    }

    public enum Substatus: String, Codable { 
        case advanceTimeElapsed = "AdvanceTimeElapsed"
        case autoApproved = "AutoApproved"
        case insufficientBalance = "InsufficientBalance"
        case invalidDailyDuration = "InvalidDailyDuration"
        case outsideShift = "OutsideShift"
        case removedFromWaitlist = "RemovedFromWaitlist"
        case waitlisted = "Waitlisted"
    }































    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The user associated with this time off request */
    public var user: UserReference?
    /** Whether this is a full day request (false means partial day) */
    public var isFullDayRequest: Bool?
    /** Whether this request has been marked as read by the agent */
    public var markedAsRead: Bool?
    /** The ID of the activity code associated with this time off request. Activity code must be of the TimeOff category */
    public var activityCodeId: String?
    /** Whether this is a paid time off request */
    public var paid: Bool?
    /** The status of this time off request */
    public var status: Status?
    /** The substatus of this time off request */
    public var substatus: Substatus?
    /** A set of start date-times in ISO-8601 format for partial day requests. Will be not empty if isFullDayRequest == false */
    public var partialDayStartDateTimes: [Date]?
    /** A set of dates in yyyy-MM-dd format.  Should be interpreted in the management unit's configured time zone. Will be not empty if isFullDayRequest == true */
    public var fullDayManagementUnitDates: [String]?
    /** The daily duration of this time off request in minutes */
    public var dailyDurationMinutes: Int?
    /** Daily durations for each day of this time off request in minutes */
    public var durationMinutes: [Int]?
    /** Payable minutes for each day of this time off request */
    public var payableMinutes: [Int]?
    /** Notes about the time off request */
    public var notes: String?
    /** The user who submitted this time off request */
    public var submittedBy: UserReference?
    /** The timestamp when this request was submitted. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var submittedDate: Date?
    /** The user who reviewed this time off request */
    public var reviewedBy: UserReference?
    /** The timestamp when this request was reviewed. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var reviewedDate: Date?
    /** The user who last modified this TimeOffRequestResponse */
    public var modifiedBy: UserReference?
    /** The timestamp when this request was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?
    /** The sync version of this time off request for which the scheduled activity is associated */
    public var syncVersion: Int?
    /** The version metadata of the time off request */
    public var metadata: WfmVersionedEntityMetadata?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, user: UserReference?, isFullDayRequest: Bool?, markedAsRead: Bool?, activityCodeId: String?, paid: Bool?, status: Status?, substatus: Substatus?, partialDayStartDateTimes: [Date]?, fullDayManagementUnitDates: [String]?, dailyDurationMinutes: Int?, durationMinutes: [Int]?, payableMinutes: [Int]?, notes: String?, submittedBy: UserReference?, submittedDate: Date?, reviewedBy: UserReference?, reviewedDate: Date?, modifiedBy: UserReference?, modifiedDate: Date?, syncVersion: Int?, metadata: WfmVersionedEntityMetadata?, selfUri: String?) {
        self._id = _id
        self.user = user
        self.isFullDayRequest = isFullDayRequest
        self.markedAsRead = markedAsRead
        self.activityCodeId = activityCodeId
        self.paid = paid
        self.status = status
        self.substatus = substatus
        self.partialDayStartDateTimes = partialDayStartDateTimes
        self.fullDayManagementUnitDates = fullDayManagementUnitDates
        self.dailyDurationMinutes = dailyDurationMinutes
        self.durationMinutes = durationMinutes
        self.payableMinutes = payableMinutes
        self.notes = notes
        self.submittedBy = submittedBy
        self.submittedDate = submittedDate
        self.reviewedBy = reviewedBy
        self.reviewedDate = reviewedDate
        self.modifiedBy = modifiedBy
        self.modifiedDate = modifiedDate
        self.syncVersion = syncVersion
        self.metadata = metadata
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case user
        case isFullDayRequest
        case markedAsRead
        case activityCodeId
        case paid
        case status
        case substatus
        case partialDayStartDateTimes
        case fullDayManagementUnitDates
        case dailyDurationMinutes
        case durationMinutes
        case payableMinutes
        case notes
        case submittedBy
        case submittedDate
        case reviewedBy
        case reviewedDate
        case modifiedBy
        case modifiedDate
        case syncVersion
        case metadata
        case selfUri
    }


}




public class TokenInfo: Codable {











    /** The current organization */
    public var organization: NamedEntity?
    /** The token's home organization */
    public var homeOrganization: NamedEntity?
    /** The list of scopes authorized for the OAuth client */
    public var authorizedScope: [String]?
    /** Only present when a user is a clone of trustee user in the trustor org. */
    public var clonedUser: TokenInfoClonedUser?
    public var oAuthClient: OrgOAuthClient?

    public init(organization: NamedEntity?, homeOrganization: NamedEntity?, authorizedScope: [String]?, clonedUser: TokenInfoClonedUser?, oAuthClient: OrgOAuthClient?) {
        self.organization = organization
        self.homeOrganization = homeOrganization
        self.authorizedScope = authorizedScope
        self.clonedUser = clonedUser
        self.oAuthClient = oAuthClient
    }

    public enum CodingKeys: String, CodingKey { 
        case organization
        case homeOrganization
        case authorizedScope
        case clonedUser
        case oAuthClient = "OAuthClient"
    }


}




public class TopicDuration: Codable {



    /** The total duration of the topic phrase within the conversation */
    public var totalMilliseconds: Int64?

    public init(totalMilliseconds: Int64?) {
        self.totalMilliseconds = totalMilliseconds
    }


}




public class TopicJob: Codable {



    public enum State: String, Codable { 
        case running = "Running"
        case completed = "Completed"
        case failed = "Failed"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var state: State?
    public var topics: [BaseTopicEntitiy]?
    public var createdBy: AddressableEntityRef?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, state: State?, topics: [BaseTopicEntitiy]?, createdBy: AddressableEntityRef?, dateCreated: Date?, dateModified: Date?, selfUri: String?) {
        self._id = _id
        self.state = state
        self.topics = topics
        self.createdBy = createdBy
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case topics
        case createdBy
        case dateCreated
        case dateModified
        case selfUri
    }


}




public class TopicJobRequest: Codable {



    /** The ids of the topics used for this job */
    public var topicIds: [String]?

    public init(topicIds: [String]?) {
        self.topicIds = topicIds
    }


}




public class TranscriptConversationDetailSearchRequest: Codable {

    public enum SortOrder: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
        case score = "SCORE"
    }













    /** The sort order for results */
    public var sortOrder: SortOrder?
    /** The field in the resource that you want to sort the results by */
    public var sortBy: String?
    /** The number of results per page */
    public var pageSize: Int?
    /** The page of resources you want to retrieve */
    public var pageNumber: Int?
    /** Multi-value sort order, list of multiple sort values */
    public var sort: [SearchSort]?
    /** Resource domain type to search */
    public var types: [String]?
    /** The search criteria */
    public var query: [TranscriptConversationDetailSearchCriteria]?

    public init(sortOrder: SortOrder?, sortBy: String?, pageSize: Int?, pageNumber: Int?, sort: [SearchSort]?, types: [String]?, query: [TranscriptConversationDetailSearchCriteria]?) {
        self.sortOrder = sortOrder
        self.sortBy = sortBy
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.sort = sort
        self.types = types
        self.query = query
    }


}




public class TranscriptSearchRequest: Codable {

    public enum SortOrder: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
        case score = "SCORE"
    }















    /** The sort order for results */
    public var sortOrder: SortOrder?
    /** The field in the resource that you want to sort the results by */
    public var sortBy: String?
    /** The number of results per page */
    public var pageSize: Int?
    /** The page of resources you want to retrieve */
    public var pageNumber: Int?
    /** Multi-value sort order, list of multiple sort values */
    public var sort: [SearchSort]?
    public var returnFields: [String]?
    /** Resource domain type to search */
    public var types: [String]?
    /** The search criteria */
    public var query: [TranscriptSearchCriteria]?

    public init(sortOrder: SortOrder?, sortBy: String?, pageSize: Int?, pageNumber: Int?, sort: [SearchSort]?, returnFields: [String]?, types: [String]?, query: [TranscriptSearchCriteria]?) {
        self.sortOrder = sortOrder
        self.sortBy = sortBy
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.sort = sort
        self.returnFields = returnFields
        self.types = types
        self.query = query
    }


}




public class TranscriptionTopicTranscriptionMessage: Codable {

















    public var eventTime: Date?
    public var organizationId: String?
    public var conversationId: String?
    public var communicationId: String?
    public var sessionStartTimeMs: Int?
    public var transcriptionStartTimeMs: Int?
    public var transcripts: [TranscriptionTopicTranscriptResult]?
    public var status: TranscriptionTopicTranscriptionRequestStatus?

    public init(eventTime: Date?, organizationId: String?, conversationId: String?, communicationId: String?, sessionStartTimeMs: Int?, transcriptionStartTimeMs: Int?, transcripts: [TranscriptionTopicTranscriptResult]?, status: TranscriptionTopicTranscriptionRequestStatus?) {
        self.eventTime = eventTime
        self.organizationId = organizationId
        self.conversationId = conversationId
        self.communicationId = communicationId
        self.sessionStartTimeMs = sessionStartTimeMs
        self.transcriptionStartTimeMs = transcriptionStartTimeMs
        self.transcripts = transcripts
        self.status = status
    }


}




public class TranscriptionTopicTranscriptionRequestStatus: Codable {



    public enum Status: String, Codable { 
        case unknown = "UNKNOWN"
        case sessionOngoing = "SESSION_ONGOING"
        case sessionEnded = "SESSION_ENDED"
    }

    public var offsetMs: Int?
    public var status: Status?

    public init(offsetMs: Int?, status: Status?) {
        self.offsetMs = offsetMs
        self.status = status
    }


}




public class TransferInitiator: Codable {



    /** The id of the user who initiated the command if it was initiated by a user. */
    public var userId: String?

    public init(userId: String?) {
        self.userId = userId
    }


}




public class TransferResponse: Codable {



    public enum State: String, Codable { 
        case pending = "Pending"
        case active = "Active"
        case complete = "Complete"
        case canceled = "Canceled"
        case failed = "Failed"
        case timeout = "Timeout"
        case unknown = "Unknown"
    }









    public enum TransferType: String, Codable { 
        case attended = "Attended"
        case unattended = "Unattended"
    }

    /** The id of the command. */
    public var _id: String?
    /** The state of the command. */
    public var state: State?
    /** The date/time that this command was issued. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateIssued: Date?
    /** The initiator of the command. */
    public var initiator: TransferInitiator?
    /** The user or entity that modified the command. */
    public var modifiedBy: TransferResponseModifiedBy?
    /** The destination of the command. */
    public var destination: TransferDestination?
    /** The type of transfer to perform. */
    public var transferType: TransferType?

    public init(_id: String?, state: State?, dateIssued: Date?, initiator: TransferInitiator?, modifiedBy: TransferResponseModifiedBy?, destination: TransferDestination?, transferType: TransferType?) {
        self._id = _id
        self.state = state
        self.dateIssued = dateIssued
        self.initiator = initiator
        self.modifiedBy = modifiedBy
        self.destination = destination
        self.transferType = transferType
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case dateIssued
        case initiator
        case modifiedBy
        case destination
        case transferType
    }


}




public class TransferToQueueRequest: Codable {

    public enum TransferType: String, Codable { 
        case attended = "Attended"
        case unattended = "Unattended"
    }





    public var transferType: TransferType?
    /** The id of the queue. */
    public var queueId: String?
    /** The name of the queue. */
    public var queueName: String?

    public init(transferType: TransferType?, queueId: String?, queueName: String?) {
        self.transferType = transferType
        self.queueId = queueId
        self.queueName = queueName
    }


}



/** Defines a process automation trigger. */

public class Trigger: Codable {























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the trigger */
    public var name: String?
    /** The topic that will cause the trigger to be invoked */
    public var topicName: String?
    /** The target to invoke when a matching event is received */
    public var target: TriggerTarget?
    /** Version of this trigger */
    public var version: Int64?
    /** Whether or not the trigger is enabled */
    public var enabled: Bool?
    /** The configuration for when a trigger is considered to be a match for an event */
    public var matchCriteria: [MatchCriteria]?
    /** Optional length of time that events are meaningful after origination. Events older than this threshold may be dropped if the platform is delayed in processing events. Unset means events are valid indefinitely, otherwise must be set to at least 10 seconds. Only one of eventTTLSeconds or delayBySeconds can be set. */
    public var eventTTLSeconds: Int?
    /** Optional delay invoking target after trigger fires. Must be in the range of 60 to 900 seconds. Only one of eventTTLSeconds or delayBySeconds can be set. */
    public var delayBySeconds: Int?
    /** Description of the trigger. Can be up to 512 characters in length. */
    public var _description: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, topicName: String?, target: TriggerTarget?, version: Int64?, enabled: Bool?, matchCriteria: [MatchCriteria]?, eventTTLSeconds: Int?, delayBySeconds: Int?, _description: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.topicName = topicName
        self.target = target
        self.version = version
        self.enabled = enabled
        self.matchCriteria = matchCriteria
        self.eventTTLSeconds = eventTTLSeconds
        self.delayBySeconds = delayBySeconds
        self._description = _description
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case topicName
        case target
        case version
        case enabled
        case matchCriteria
        case eventTTLSeconds
        case delayBySeconds
        case _description = "description"
        case selfUri
    }


}



/** The target of a trigger invocation */

public class TriggerTarget: Codable {

    public enum ModelType: String, Codable { 
        case workflow = "Workflow"
    }





    /** The entity type to target */
    public var type: ModelType?
    /** The ID of the entity to target */
    public var _id: String?
    /** Optional config for the target. */
    public var workflowTargetSettings: WorkflowTargetSettings?

    public init(type: ModelType?, _id: String?, workflowTargetSettings: WorkflowTargetSettings?) {
        self.type = type
        self._id = _id
        self.workflowTargetSettings = workflowTargetSettings
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case _id = "id"
        case workflowTargetSettings
    }


}




public class TrunkEntityListing: Codable {





















    public var entities: [Trunk]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [Trunk]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class TrunkInstanceTopicTrunkErrorInfo: Codable {







    public var text: String?
    public var code: String?
    public var details: TrunkInstanceTopicTrunkErrorInfoDetails?

    public init(text: String?, code: String?, details: TrunkInstanceTopicTrunkErrorInfoDetails?) {
        self.text = text
        self.code = code
        self.details = details
    }


}




public class TrunkInstanceTopicTrunkErrorInfoDetails: Codable {







    public var code: String?
    public var message: String?
    public var hostname: String?

    public init(code: String?, message: String?, hostname: String?) {
        self.code = code
        self.message = message
        self.hostname = hostname
    }


}




public class TrunkMetrics: Codable {











    /** Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var eventTime: Date?
    public var logicalInterface: DomainEntityRef?
    public var trunk: DomainEntityRef?
    public var calls: TrunkMetricsCalls?
    public var qos: TrunkMetricsQoS?

    public init(eventTime: Date?, logicalInterface: DomainEntityRef?, trunk: DomainEntityRef?, calls: TrunkMetricsCalls?, qos: TrunkMetricsQoS?) {
        self.eventTime = eventTime
        self.logicalInterface = logicalInterface
        self.trunk = trunk
        self.calls = calls
        self.qos = qos
    }


}




public class TrunkMetricsCalls: Codable {





    public var inboundCallCount: Int?
    public var outboundCallCount: Int?

    public init(inboundCallCount: Int?, outboundCallCount: Int?) {
        self.inboundCallCount = inboundCallCount
        self.outboundCallCount = outboundCallCount
    }


}




public class TrunkMetricsQoS: Codable {



    /** Total number of QoS mismatches over the course of the last 24-hour period (sliding window). */
    public var mismatchCount: Int?

    public init(mismatchCount: Int?) {
        self.mismatchCount = mismatchCount
    }


}




public class TrunkMetricsTopicTrunkMetrics: Codable {









    public var calls: TrunkMetricsTopicTrunkMetricsCalls?
    public var eventTime: Date?
    public var qos: TrunkMetricsTopicTrunkMetricsQoS?
    public var trunk: TrunkMetricsTopicUriReference?

    public init(calls: TrunkMetricsTopicTrunkMetricsCalls?, eventTime: Date?, qos: TrunkMetricsTopicTrunkMetricsQoS?, trunk: TrunkMetricsTopicUriReference?) {
        self.calls = calls
        self.eventTime = eventTime
        self.qos = qos
        self.trunk = trunk
    }


}




public class TrunkMetricsTopicTrunkMetricsCalls: Codable {





    public var inboundCallCount: Int?
    public var outboundCallCount: Int?

    public init(inboundCallCount: Int?, outboundCallCount: Int?) {
        self.inboundCallCount = inboundCallCount
        self.outboundCallCount = outboundCallCount
    }


}




public class TrunkMetricsTopicTrunkMetricsQoS: Codable {



    public var mismatchCount: Int?

    public init(mismatchCount: Int?) {
        self.mismatchCount = mismatchCount
    }


}




public class TtsSettings: Codable {





    /** ID of the global default TTS engine */
    public var defaultEngine: String?
    /** The list of default overrides for specific languages */
    public var languageOverrides: [LanguageOverride]?

    public init(defaultEngine: String?, languageOverrides: [LanguageOverride]?) {
        self.defaultEngine = defaultEngine
        self.languageOverrides = languageOverrides
    }


}




public class TtsVoiceEntity: Codable {















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The gender of the TTS voice */
    public var gender: String?
    /** The language supported by the TTS voice */
    public var language: String?
    /** Ths TTS engine this voice belongs to */
    public var engine: TtsEngineEntity?
    /** The voice is the default voice for its language */
    public var isDefault: Bool?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, gender: String?, language: String?, engine: TtsEngineEntity?, isDefault: Bool?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.gender = gender
        self.language = language
        self.engine = engine
        self.isDefault = isDefault
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case gender
        case language
        case engine
        case isDefault
        case selfUri
    }


}




public class TtsVoiceEntityListing: Codable {





















    public var entities: [TtsVoiceEntity]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [TtsVoiceEntity]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class TypingSetting: Codable {



    /** Should typing indication Events be sent */
    public var on: SettingDirection?

    public init(on: SettingDirection?) {
        self.on = on
    }


}




public class UnreadMetric: Codable {



    /** The count of unread alerts for a specific rule type. */
    public var count: Int?

    public init(count: Int?) {
        self.count = count
    }


}



/** Update coaching appointment request */

public class UpdateCoachingAppointmentRequest: Codable {













    public enum Status: String, Codable { 
        case scheduled = "Scheduled"
        case inProgress = "InProgress"
        case completed = "Completed"
    }





    /** The name of coaching appointment. */
    public var name: String?
    /** The description of coaching appointment. */
    public var _description: String?
    /** The date/time the coaching appointment starts. Times will be rounded down to the minute. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateStart: Date?
    /** The duration of coaching appointment in minutes. */
    public var lengthInMinutes: Int?
    /** IDs of conversations associated with this coaching appointment. */
    public var conversationIds: [String]?
    /** IDs of documents associated with this coaching appointment. */
    public var documentIds: [String]?
    /** The status of the coaching appointment. */
    public var status: Status?
    /** The Workforce Management schedule the appointment is associated with. */
    public var wfmSchedule: WfmScheduleReference?
    /** The list of external links related to the appointment */
    public var externalLinks: [String]?

    public init(name: String?, _description: String?, dateStart: Date?, lengthInMinutes: Int?, conversationIds: [String]?, documentIds: [String]?, status: Status?, wfmSchedule: WfmScheduleReference?, externalLinks: [String]?) {
        self.name = name
        self._description = _description
        self.dateStart = dateStart
        self.lengthInMinutes = lengthInMinutes
        self.conversationIds = conversationIds
        self.documentIds = documentIds
        self.status = status
        self.wfmSchedule = wfmSchedule
        self.externalLinks = externalLinks
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case _description = "description"
        case dateStart
        case lengthInMinutes
        case conversationIds
        case documentIds
        case status
        case wfmSchedule
        case externalLinks
    }


}




public class UpdateContactColumnActionSettings: Codable {



    public enum UpdateOption: String, Codable { 
        case _set = "Set"
        case increment = "Increment"
        case decrement = "Decrement"
        case currentTime = "CurrentTime"
    }

    /** A mapping of contact columns to their new values. */
    public var properties: [String:String]?
    /** The type of update to make to the specified contact column(s). */
    public var updateOption: UpdateOption?

    public init(properties: [String:String]?, updateOption: UpdateOption?) {
        self.properties = properties
        self.updateOption = updateOption
    }


}




public class UpdatePlanningGroupRequest: Codable {









    /** The name of the planning group */
    public var name: String?
    /** Set of route paths to associate with the planning group */
    public var routePaths: SetWrapperRoutePathRequest?
    /** The ID of the service goal template to associate with this planning group */
    public var serviceGoalTemplateId: String?
    /** Version metadata for the planning group */
    public var metadata: WfmVersionedEntityMetadata?

    public init(name: String?, routePaths: SetWrapperRoutePathRequest?, serviceGoalTemplateId: String?, metadata: WfmVersionedEntityMetadata?) {
        self.name = name
        self.routePaths = routePaths
        self.serviceGoalTemplateId = serviceGoalTemplateId
        self.metadata = metadata
    }


}




public class UpdateScheduleUploadResponse: Codable {









    /** The key to pass to the secondary request to start processing of the upload */
    public var uploadKey: String?
    /** The url to which to PUT the upload body */
    public var url: String?
    /** Required headers for the PUT request to the url */
    public var headers: [String:String]?
    /** Always null. Defines the schema of the json body to be PUT to the url. The json body should be gzip encoded before uploading */
    public var uploadBodySchema: UpdateScheduleUploadSchema?

    public init(uploadKey: String?, url: String?, headers: [String:String]?, uploadBodySchema: UpdateScheduleUploadSchema?) {
        self.uploadKey = uploadKey
        self.url = url
        self.headers = headers
        self.uploadBodySchema = uploadBodySchema
    }


}




public class UpdateTimeOffLimitRequest: Codable {





    /** The default time off limit value in minutes per granularity */
    public var defaultLimitMinutes: Int?
    /** Version metadata for the time off limit */
    public var metadata: WfmVersionedEntityMetadata?

    public init(defaultLimitMinutes: Int?, metadata: WfmVersionedEntityMetadata?) {
        self.defaultLimitMinutes = defaultLimitMinutes
        self.metadata = metadata
    }


}




public class UpdateVerifierRequest: Codable {







    /** The name of the verifier. */
    public var name: String?
    /** Indicates whether this verifier will be enabled. */
    public var enabled: Bool?
    /** Indicates whether this will be the default verifier. */
    public var _default: Bool?

    public init(name: String?, enabled: Bool?, _default: Bool?) {
        self.name = name
        self.enabled = enabled
        self._default = _default
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case enabled
        case _default = "default"
    }


}




public class UrlResponse: Codable {



    public var url: String?

    public init(url: String?) {
        self.url = url
    }


}




public class UserAggregateQueryResponse: Codable {





    /** A mapping from system presence to a list of organization presence ids */
    public var systemToOrganizationMappings: [String:[String]]?
    public var results: [UserAggregateDataContainer]?

    public init(systemToOrganizationMappings: [String:[String]]?, results: [UserAggregateDataContainer]?) {
        self.systemToOrganizationMappings = systemToOrganizationMappings
        self.results = results
    }


}




public class UserAggregationView: Codable {

    public enum Target: String, Codable { 
        case tagentroutingstatus = "tAgentRoutingStatus"
        case torganizationpresence = "tOrganizationPresence"
        case tsystempresence = "tSystemPresence"
    }



    public enum Function: String, Codable { 
        case rangebound = "rangeBound"
    }



    /** Target metric name */
    public var target: Target?
    /** A unique name for this view. Must be distinct from other views and built-in metric names. */
    public var name: String?
    /** Type of view you wish to create */
    public var function: Function?
    /** Range of numbers for slicing up data */
    public var range: AggregationRange?

    public init(target: Target?, name: String?, function: Function?, range: AggregationRange?) {
        self.target = target
        self.name = name
        self.function = function
        self.range = range
    }


}



/** Details for a UserApp */

public class UserApp: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the userApp, used to distinguish this userApp from others of the same type. */
    public var name: String?
    /** Integration Type for the userApp */
    public var integrationType: IntegrationType?
    public var config: UserAppConfigurationInfo?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, integrationType: IntegrationType?, config: UserAppConfigurationInfo?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.integrationType = integrationType
        self.config = config
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case integrationType
        case config
        case selfUri
    }


}




public class UserBestPointsItem: Codable {

    public enum GranularityType: String, Codable { 
        case daily = "Daily"
        case weekly = "Weekly"
        case monthly = "Monthly"
    }









    /** Best points aggregation interval granularity */
    public var granularityType: GranularityType?
    /** Gamification points */
    public var points: Int?
    /** Start workday of the best points aggregation interval. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStartWorkday: Date?
    /** End workday of the best points aggregation interval. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEndWorkday: Date?
    /** The rank of this user */
    public var rank: Int?

    public init(granularityType: GranularityType?, points: Int?, dateStartWorkday: Date?, dateEndWorkday: Date?, rank: Int?) {
        self.granularityType = granularityType
        self.points = points
        self.dateStartWorkday = dateStartWorkday
        self.dateEndWorkday = dateEndWorkday
        self.rank = rank
    }


}




public class UserConversationsEventMediaSummary: Codable {





    public var contactCenter: UserConversationsEventMediaSummaryDetail?
    public var enterprise: UserConversationsEventMediaSummaryDetail?

    public init(contactCenter: UserConversationsEventMediaSummaryDetail?, enterprise: UserConversationsEventMediaSummaryDetail?) {
        self.contactCenter = contactCenter
        self.enterprise = enterprise
    }


}




public class UserConversationsEventMediaSummaryDetail: Codable {





    public var active: Int?
    public var acw: Int?

    public init(active: Int?, acw: Int?) {
        self.active = active
        self.acw = acw
    }


}




public class UserConversationsEventUserConversationSummary: Codable {

















    public var userId: String?
    public var call: UserConversationsEventMediaSummary?
    public var callback: UserConversationsEventMediaSummary?
    public var email: UserConversationsEventMediaSummary?
    public var message: UserConversationsEventMediaSummary?
    public var chat: UserConversationsEventMediaSummary?
    public var socialExpression: UserConversationsEventMediaSummary?
    public var video: UserConversationsEventMediaSummary?

    public init(userId: String?, call: UserConversationsEventMediaSummary?, callback: UserConversationsEventMediaSummary?, email: UserConversationsEventMediaSummary?, message: UserConversationsEventMediaSummary?, chat: UserConversationsEventMediaSummary?, socialExpression: UserConversationsEventMediaSummary?, video: UserConversationsEventMediaSummary?) {
        self.userId = userId
        self.call = call
        self.callback = callback
        self.email = email
        self.message = message
        self.chat = chat
        self.socialExpression = socialExpression
        self.video = video
    }


}




public class UserDetailQueryClause: Codable {

    public enum ModelType: String, Codable { 
        case and = "and"
        case or = "or"
    }



    /** Boolean operation to apply to the provided predicates */
    public var type: ModelType?
    /** Like a three-word sentence: (attribute-name) (operator) (target-value). */
    public var predicates: [UserDetailQueryPredicate]?

    public init(type: ModelType?, predicates: [UserDetailQueryPredicate]?) {
        self.type = type
        self.predicates = predicates
    }


}




public class UserDetailsQuery: Codable {









    public enum Order: String, Codable { 
        case asc = "asc"
        case desc = "desc"
        case unordered = "unordered"
    }







    /** Specifies the date and time range of data being queried. Conversations MUST have started within this time range to potentially be included within the result set. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss */
    public var interval: String?
    /** Filters that target the users to retrieve data for */
    public var userFilters: [UserDetailQueryFilter]?
    /** Filters that target system and organization presence-level data */
    public var presenceFilters: [PresenceDetailQueryFilter]?
    /** Filters that target agent routing status-level data */
    public var routingStatusFilters: [RoutingStatusDetailQueryFilter]?
    /** Sort the result set in ascending/descending order. Default is ascending */
    public var order: Order?
    /** Include faceted search and aggregate roll-ups of presence data in your search results. This does not function as a filter, but rather, summary data about the presence results matching your filters */
    public var presenceAggregations: [AnalyticsQueryAggregation]?
    /** Include faceted search and aggregate roll-ups of agent routing status data in your search results. This does not function as a filter, but rather, summary data about the agent routing status results matching your filters */
    public var routingStatusAggregations: [AnalyticsQueryAggregation]?
    /** Page size and number to control iterating through large result sets. Default page size is 25 */
    public var paging: PagingSpec?

    public init(interval: String?, userFilters: [UserDetailQueryFilter]?, presenceFilters: [PresenceDetailQueryFilter]?, routingStatusFilters: [RoutingStatusDetailQueryFilter]?, order: Order?, presenceAggregations: [AnalyticsQueryAggregation]?, routingStatusAggregations: [AnalyticsQueryAggregation]?, paging: PagingSpec?) {
        self.interval = interval
        self.userFilters = userFilters
        self.presenceFilters = presenceFilters
        self.routingStatusFilters = routingStatusFilters
        self.order = order
        self.presenceAggregations = presenceAggregations
        self.routingStatusAggregations = routingStatusAggregations
        self.paging = paging
    }


}




public class UserGreetingEventGreetingOwner: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class UserLicensesEntityListing: Codable {











    public var entities: [UserLicenses]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var pageCount: Int?

    public init(entities: [UserLicenses]?, pageSize: Int?, pageNumber: Int?, total: Int64?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.pageCount = pageCount
    }


}




public class UserProfilesInDateRange: Codable {









    /** The query agent */
    public var user: UserReference?
    /** Start workday used as the date range. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateStartWorkday: Date?
    /** End workday used as the date range. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateEndWorkday: Date?
    /** The list of profiles of the agent */
    public var profiles: [ProfileWithDateRange]?

    public init(user: UserReference?, dateStartWorkday: Date?, dateEndWorkday: Date?, profiles: [ProfileWithDateRange]?) {
        self.user = user
        self.dateStartWorkday = dateStartWorkday
        self.dateEndWorkday = dateEndWorkday
        self.profiles = profiles
    }


}




public class UserProfilesInDateRangeRequest: Codable {





    /** Start work day in ISO-8601 format used in the date range. */
    public var startWorkday: String?
    /** End work day in ISO-8601 format used in the date range. */
    public var endWorkday: String?

    public init(startWorkday: String?, endWorkday: String?) {
        self.startWorkday = startWorkday
        self.endWorkday = endWorkday
    }


}




public class UserQueueEntityListing: Codable {





















    public var entities: [UserQueue]?
    public var pageSize: Int?
    public var pageNumber: Int?
    public var total: Int64?
    public var firstUri: String?
    public var nextUri: String?
    public var previousUri: String?
    public var lastUri: String?
    public var selfUri: String?
    public var pageCount: Int?

    public init(entities: [UserQueue]?, pageSize: Int?, pageNumber: Int?, total: Int64?, firstUri: String?, nextUri: String?, previousUri: String?, lastUri: String?, selfUri: String?, pageCount: Int?) {
        self.entities = entities
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.total = total
        self.firstUri = firstUri
        self.nextUri = nextUri
        self.previousUri = previousUri
        self.lastUri = lastUri
        self.selfUri = selfUri
        self.pageCount = pageCount
    }


}




public class UserScheduleContainer: Codable {







    /** The reference time zone used for the management unit */
    public var managementUnitTimeZone: String?
    /** References to all published week schedules overlapping the start/end date query parameters */
    public var publishedSchedules: [WeekScheduleReference]?
    /** Map of user id to user schedule */
    public var userSchedules: [String:UserSchedule]?

    public init(managementUnitTimeZone: String?, publishedSchedules: [WeekScheduleReference]?, userSchedules: [String:UserSchedule]?) {
        self.managementUnitTimeZone = managementUnitTimeZone
        self.publishedSchedules = publishedSchedules
        self.userSchedules = userSchedules
    }


}




public class UserScheduleFullDayTimeOffMarker: Codable {













    /** The date associated with the time off request that this marker corresponds to.  Date only, in ISO-8601 format. */
    public var managementUnitDate: String?
    /** The id for the activity code.  Look up a map of activity codes with the activities route */
    public var activityCodeId: String?
    /** Whether this is paid time off */
    public var isPaid: Bool?
    /** The length in minutes of this time off marker */
    public var lengthInMinutes: Int?
    /** The description associated with the time off request that this marker corresponds to */
    public var _description: String?
    /** If marked true for updating an existing full day time off marker, it will be deleted */
    public var delete: Bool?

    public init(managementUnitDate: String?, activityCodeId: String?, isPaid: Bool?, lengthInMinutes: Int?, _description: String?, delete: Bool?) {
        self.managementUnitDate = managementUnitDate
        self.activityCodeId = activityCodeId
        self.isPaid = isPaid
        self.lengthInMinutes = lengthInMinutes
        self._description = _description
        self.delete = delete
    }

    public enum CodingKeys: String, CodingKey { 
        case managementUnitDate
        case activityCodeId
        case isPaid
        case lengthInMinutes
        case _description = "description"
        case delete
    }


}




public class UserStationChangeTopicUserStation: Codable {







    public var _id: String?
    public var name: String?
    public var associatedUser: UserStationChangeTopicUser?

    public init(_id: String?, name: String?, associatedUser: UserStationChangeTopicUser?) {
        self._id = _id
        self.name = name
        self.associatedUser = associatedUser
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case associatedUser
    }


}




public class UserStationChangeTopicUserStations: Codable {



    public var associatedStation: UserStationChangeTopicUserStation?

    public init(associatedStation: UserStationChangeTopicUserStation?) {
        self.associatedStation = associatedStation
    }


}




public class UserTimeOffIntegrationStatusResponse: Codable {



    public enum IntegrationStatus: String, Codable { 
        case processing = "Processing"
        case error = "Error"
        case automaticallyComplete = "AutomaticallyComplete"
        case manuallyComplete = "ManuallyComplete"
    }



    /** The time off request associated with this integration status */
    public var timeOffRequest: TimeOffRequestReference?
    /** The value of integration status for the time off request */
    public var integrationStatus: IntegrationStatus?
    /** The user to whom the time off request belongs */
    public var user: UserReference?

    public init(timeOffRequest: TimeOffRequestReference?, integrationStatus: IntegrationStatus?, user: UserReference?) {
        self.timeOffRequest = timeOffRequest
        self.integrationStatus = integrationStatus
        self.user = user
    }


}




public class UserTimeOffIntegrationStatusResponseListing: Codable {



    public var entities: [UserTimeOffIntegrationStatusResponse]?

    public init(entities: [UserTimeOffIntegrationStatusResponse]?) {
        self.entities = entities
    }


}




public class UserTokensTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class Utterance: Codable {



    /** Utterance text */
    public var utteranceText: String?

    public init(utteranceText: String?) {
        self.utteranceText = utteranceText
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationContentAttachment: Codable {



    public enum MediaType: String, Codable { 
        case image = "Image"
        case video = "Video"
        case audio = "Audio"
        case file = "File"
        case link = "Link"
    }











    public var _id: String?
    public var mediaType: MediaType?
    public var url: String?
    public var mime: String?
    public var text: String?
    public var sha256: String?
    public var filename: String?

    public init(_id: String?, mediaType: MediaType?, url: String?, mime: String?, text: String?, sha256: String?, filename: String?) {
        self._id = _id
        self.mediaType = mediaType
        self.url = url
        self.mime = mime
        self.text = text
        self.sha256 = sha256
        self.filename = filename
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case mediaType
        case url
        case mime
        case text
        case sha256
        case filename
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationContentButtonResponse: Codable {

    public enum ModelType: String, Codable { 
        case button = "Button"
        case quickReply = "QuickReply"
    }





    public var type: ModelType?
    public var text: String?
    public var payload: String?

    public init(type: ModelType?, text: String?, payload: String?) {
        self.type = type
        self.text = text
        self.payload = payload
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationContentNotificationTemplate: Codable {











    public var _id: String?
    public var language: String?
    public var header: V2ConversationMessageTypingEventForUserTopicConversationNotificationTemplateHeader?
    public var body: V2ConversationMessageTypingEventForUserTopicConversationNotificationTemplateBody?
    public var footer: V2ConversationMessageTypingEventForUserTopicConversationNotificationTemplateFooter?

    public init(_id: String?, language: String?, header: V2ConversationMessageTypingEventForUserTopicConversationNotificationTemplateHeader?, body: V2ConversationMessageTypingEventForUserTopicConversationNotificationTemplateBody?, footer: V2ConversationMessageTypingEventForUserTopicConversationNotificationTemplateFooter?) {
        self._id = _id
        self.language = language
        self.header = header
        self.body = body
        self.footer = footer
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case language
        case header
        case body
        case footer
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationContentQuickReply: Codable {







    public enum Action: String, Codable { 
        case message = "Message"
    }

    public var text: String?
    public var payload: String?
    public var image: String?
    public var action: Action?

    public init(text: String?, payload: String?, image: String?, action: Action?) {
        self.text = text
        self.payload = payload
        self.image = image
        self.action = action
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationEventTyping: Codable {

    public enum ModelType: String, Codable { 
        case on = "On"
    }



    public var type: ModelType?
    public var duration: Int?

    public init(type: ModelType?, duration: Int?) {
        self.type = type
        self.duration = duration
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationMessagingChannelMetadata: Codable {



    public var customAttributes: [String:String]?

    public init(customAttributes: [String:String]?) {
        self.customAttributes = customAttributes
    }


}




public class V2ConversationMessageTypingEventForUserTopicConversationNormalizedMessage: Codable {





    public enum ModelType: String, Codable { 
        case text = "Text"
        case structured = "Structured"
        case receipt = "Receipt"
        case event = "Event"
    }







    public enum Status: String, Codable { 
        case sent = "Sent"
        case delivered = "Delivered"
        case read = "Read"
        case failed = "Failed"
        case published = "Published"
        case removed = "Removed"
    }



    public enum OriginatingEntity: String, Codable { 
        case human = "Human"
        case bot = "Bot"
    }



    public enum Direction: String, Codable { 
        case inbound = "Inbound"
        case outbound = "Outbound"
    }



    public var _id: String?
    public var channel: V2ConversationMessageTypingEventForUserTopicConversationMessagingChannel?
    public var type: ModelType?
    public var text: String?
    public var content: [V2ConversationMessageTypingEventForUserTopicConversationMessageContent]?
    public var events: [V2ConversationMessageTypingEventForUserTopicConversationMessageEvent]?
    public var status: Status?
    public var reasons: [V2ConversationMessageTypingEventForUserTopicConversationReason]?
    public var originatingEntity: OriginatingEntity?
    public var isFinalReceipt: Bool?
    public var direction: Direction?
    public var metadata: [String:String]?

    public init(_id: String?, channel: V2ConversationMessageTypingEventForUserTopicConversationMessagingChannel?, type: ModelType?, text: String?, content: [V2ConversationMessageTypingEventForUserTopicConversationMessageContent]?, events: [V2ConversationMessageTypingEventForUserTopicConversationMessageEvent]?, status: Status?, reasons: [V2ConversationMessageTypingEventForUserTopicConversationReason]?, originatingEntity: OriginatingEntity?, isFinalReceipt: Bool?, direction: Direction?, metadata: [String:String]?) {
        self._id = _id
        self.channel = channel
        self.type = type
        self.text = text
        self.content = content
        self.events = events
        self.status = status
        self.reasons = reasons
        self.originatingEntity = originatingEntity
        self.isFinalReceipt = isFinalReceipt
        self.direction = direction
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case channel
        case type
        case text
        case content
        case events
        case status
        case reasons
        case originatingEntity
        case isFinalReceipt
        case direction
        case metadata
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationMessageContent: Codable {

    public enum ContentType: String, Codable { 
        case attachment = "Attachment"
        case location = "Location"
        case story = "Story"
        case quickReply = "QuickReply"
        case notification = "Notification"
        case buttonResponse = "ButtonResponse"
        case genericTemplate = "GenericTemplate"
    }















    public var contentType: ContentType?
    public var location: V2ConversationMessageTypingEventForWorkflowTopicConversationContentLocation?
    public var story: V2ConversationMessageTypingEventForWorkflowTopicConversationContentStory?
    public var attachment: V2ConversationMessageTypingEventForWorkflowTopicConversationContentAttachment?
    public var quickReply: V2ConversationMessageTypingEventForWorkflowTopicConversationContentQuickReply?
    public var template: V2ConversationMessageTypingEventForWorkflowTopicConversationContentNotificationTemplate?
    public var buttonResponse: V2ConversationMessageTypingEventForWorkflowTopicConversationContentButtonResponse?
    public var generic: V2ConversationMessageTypingEventForWorkflowTopicConversationContentGeneric?

    public init(contentType: ContentType?, location: V2ConversationMessageTypingEventForWorkflowTopicConversationContentLocation?, story: V2ConversationMessageTypingEventForWorkflowTopicConversationContentStory?, attachment: V2ConversationMessageTypingEventForWorkflowTopicConversationContentAttachment?, quickReply: V2ConversationMessageTypingEventForWorkflowTopicConversationContentQuickReply?, template: V2ConversationMessageTypingEventForWorkflowTopicConversationContentNotificationTemplate?, buttonResponse: V2ConversationMessageTypingEventForWorkflowTopicConversationContentButtonResponse?, generic: V2ConversationMessageTypingEventForWorkflowTopicConversationContentGeneric?) {
        self.contentType = contentType
        self.location = location
        self.story = story
        self.attachment = attachment
        self.quickReply = quickReply
        self.template = template
        self.buttonResponse = buttonResponse
        self.generic = generic
    }


}




public class V2ConversationMessageTypingEventForWorkflowTopicConversationRecipientAdditionalIdentifier: Codable {

    public enum ModelType: String, Codable { 
        case deployment = "Deployment"
        case subject = "Subject"
        case unknown = "Unknown"
    }



    public var type: ModelType?
    public var value: String?

    public init(type: ModelType?, value: String?) {
        self.type = type
        self.value = value
    }


}




public class V2FlowExecutionDataFlowidTopicFlowExecutionHistory: Codable {



























    public enum MessageType: String, Codable { 
        case unknown = "unknown"
        case sms = "sms"
        case twitter = "twitter"
        case facebook = "facebook"
        case instagram = "instagram"
        case line = "line"
        case whatsapp = "whatsapp"
        case webmessaging = "webmessaging"
        case _open = "open"
    }







    /** The execution identifier which represents this unique instance of the flow that ran. */
    public var executionId: String?
    /** The Genesys Cloud conversation identifier associated with this flow instance execution data. */
    public var conversationId: String?
    /** The division identifier for the division associated with the flow for this flow instance. */
    public var divisionId: String?
    /** The end date time for this flow instance execution data. */
    public var endDateTime: Date?
    /** The public endpoint a user can use to retrieve the full historical log from the service. */
    public var endpoint: String?
    /** If the flow invoked error handling, an array of errors. */
    public var errors: [V2FlowExecutionDataFlowidTopicFlowErrorWarningInfo]?
    /** An array of execution items that describe what happened when an Architect flow action container ran such as a flow, task, state or bot. */
    public var execution: [V2FlowExecutionDataFlowidTopicExecution]?
    /** Provides information about why a flow ended. */
    public var flowExitReason: String?
    /** The flow identifier for this flow instance execution data.  This is the identifier of the flow configuration that users load up in Architect. */
    public var flowId: String?
    /** Whether the flow that ran for this flow instance execution data was in debug mode. */
    public var flowIsDebug: Bool?
    /** If true, the execution items in this event have been truncated to be deliverable. */
    public var executionItemsTruncated: Bool?
    /** The flow type of the Architect flow that was run. */
    public var flowType: String?
    /** The version of the flow for this flow instance execution data. Typically this is a numeric value like 1.0 represented as a string but can also be 'debug' */
    public var flowVersion: String?
    /** If applicable, the type of message platform from which the message originated. */
    public var messageType: MessageType?
    public var invokingContext: V2FlowExecutionDataFlowidTopicInvokingContext?
    /** The start date time for this flow instance execution data. */
    public var startDateTime: Date?
    /** If the flow encountered a warning during execution, this is an array of the warnings. */
    public var warnings: [V2FlowExecutionDataFlowidTopicFlowErrorWarningInfo]?

    public init(executionId: String?, conversationId: String?, divisionId: String?, endDateTime: Date?, endpoint: String?, errors: [V2FlowExecutionDataFlowidTopicFlowErrorWarningInfo]?, execution: [V2FlowExecutionDataFlowidTopicExecution]?, flowExitReason: String?, flowId: String?, flowIsDebug: Bool?, executionItemsTruncated: Bool?, flowType: String?, flowVersion: String?, messageType: MessageType?, invokingContext: V2FlowExecutionDataFlowidTopicInvokingContext?, startDateTime: Date?, warnings: [V2FlowExecutionDataFlowidTopicFlowErrorWarningInfo]?) {
        self.executionId = executionId
        self.conversationId = conversationId
        self.divisionId = divisionId
        self.endDateTime = endDateTime
        self.endpoint = endpoint
        self.errors = errors
        self.execution = execution
        self.flowExitReason = flowExitReason
        self.flowId = flowId
        self.flowIsDebug = flowIsDebug
        self.executionItemsTruncated = executionItemsTruncated
        self.flowType = flowType
        self.flowVersion = flowVersion
        self.messageType = messageType
        self.invokingContext = invokingContext
        self.startDateTime = startDateTime
        self.warnings = warnings
    }


}



/** This contains contextual information about an invoking entity. */

public class V2FlowExecutionDataFlowidTopicJourneyActionMap: Codable {





    /** The identifier of the journey action map that invoked this flow. */
    public var actionMapId: String?
    /** The identifier of the specific action map instance that invoked this flow. */
    public var actionId: String?

    public init(actionMapId: String?, actionId: String?) {
        self.actionMapId = actionMapId
        self.actionId = actionId
    }


}



/** The quality context that invoked this. */

public class V2FlowExecutionDataFlowidTopicQuality: Codable {





    /** The identifier of the quality policy that invoked this flow. */
    public var policyId: String?
    /** The name of the quality policy that invoked this flow. */
    public var policyName: String?

    public init(policyId: String?, policyName: String?) {
        self.policyId = policyId
        self.policyName = policyName
    }


}




public class V2MobiusAlertsTopicCondition: Codable {





    public enum ModelType: String, Codable { 
        case and = "And"
        case or = "Or"
        case not = "Not"
        case unknown = "Unknown"
    }

    public var conditions: [V2MobiusAlertsTopicCondition]?
    public var predicates: [V2MobiusAlertsTopicConditionRulePredicate]?
    public var type: ModelType?

    public init(conditions: [V2MobiusAlertsTopicCondition]?, predicates: [V2MobiusAlertsTopicConditionRulePredicate]?, type: ModelType?) {
        self.conditions = conditions
        self.predicates = predicates
        self.type = type
    }


}




public class V2MobiusRulesTopicAddressableEntityRef: Codable {



    /** The ID of the resource */
    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class V2MobiusRulesTopicConditionRulePredicate: Codable {





    public enum MetricType: String, Codable { 
        case interval = "Interval"
        case instance = "Instance"
        case unknown = "Unknown"
    }

    public enum MetricValueType: String, Codable { 
        case count = "Count"
        case percentage = "Percentage"
        case average = "Average"
        case timer = "Timer"
        case observation = "Observation"
        case min = "Min"
        case max = "Max"
        case unknown = "Unknown"
    }



    public enum ComparisonOperator: String, Codable { 
        case gt = "Gt"
        case gte = "Gte"
        case lt = "Lt"
        case lte = "Lte"
        case eq = "Eq"
        case ne = "Ne"
        case unknown = "Unknown"
    }

    public var entity: V2MobiusRulesTopicEntityProperties?
    public var metric: String?
    public var metricType: MetricType?
    public var metricValueType: MetricValueType?
    public var value: Double?
    public var comparisonOperator: ComparisonOperator?

    public init(entity: V2MobiusRulesTopicEntityProperties?, metric: String?, metricType: MetricType?, metricValueType: MetricValueType?, value: Double?, comparisonOperator: ComparisonOperator?) {
        self.entity = entity
        self.metric = metric
        self.metricType = metricType
        self.metricValueType = metricValueType
        self.value = value
        self.comparisonOperator = comparisonOperator
    }


}




public class V2MobiusRulesTopicEntityProperties: Codable {

    public enum EntityType: String, Codable { 
        case organization = "Organization"
        case user = "User"
        case queue = "Queue"
        case group = "Group"
        case edge = "Edge"
        case team = "Team"
        case teamMembers = "TeamMembers"
    }









    public var entityType: EntityType?
    public var user: V2MobiusRulesTopicAddressableEntityRef?
    public var group: V2MobiusRulesTopicAddressableEntityRef?
    public var queue: V2MobiusRulesTopicAddressableEntityRef?
    public var team: V2MobiusRulesTopicAddressableEntityRef?

    public init(entityType: EntityType?, user: V2MobiusRulesTopicAddressableEntityRef?, group: V2MobiusRulesTopicAddressableEntityRef?, queue: V2MobiusRulesTopicAddressableEntityRef?, team: V2MobiusRulesTopicAddressableEntityRef?) {
        self.entityType = entityType
        self.user = user
        self.group = group
        self.queue = queue
        self.team = team
    }


}




public class ValueWrapperPlanningPeriodSettings: Codable {



    /** The value for the associated field */
    public var value: PlanningPeriodSettings?

    public init(value: PlanningPeriodSettings?) {
        self.value = value
    }


}




public class VisibilityCondition: Codable {

    public enum CombiningOperation: String, Codable { 
        case and = "AND"
        case or = "OR"
    }



    public var combiningOperation: CombiningOperation?
    /** A list of strings, each representing the location in the form of the Answer Option to depend on. In the format of \"/form/questionGroup/{questionGroupIndex}/question/{questionIndex}/answer/{answerIndex}\" or, to assume the current question group, \"../question/{questionIndex}/answer/{answerIndex}\". Note: Indexes are zero-based */
    public var predicates: [JSON]?

    public init(combiningOperation: CombiningOperation?, predicates: [JSON]?) {
        self.combiningOperation = combiningOperation
        self.predicates = predicates
    }


}




public class VoicemailCopyRecord: Codable {







    /** The user that the voicemail message was copied to/from */
    public var user: User?
    /** The group that the voicemail message was copied to/from */
    public var group: Group?
    /** The date when the voicemail was copied. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var date: Date?

    public init(user: User?, group: Group?, date: Date?) {
        self.user = user
        self.group = group
        self.date = date
    }


}




public class VoicemailEndDetailEventTopicVoicemailEndEvent: Codable {









    public enum DisconnectType: String, Codable { 
        case unknown = "UNKNOWN"
        case endpoint = "ENDPOINT"
        case client = "CLIENT"
        case system = "SYSTEM"
        case transfer = "TRANSFER"
        case error = "ERROR"
        case peer = "PEER"
        case other = "OTHER"
        case spam = "SPAM"
        case timeout = "TIMEOUT"
        case transportFailure = "TRANSPORT_FAILURE"
        case conferenceTransfer = "CONFERENCE_TRANSFER"
        case consultTransfer = "CONSULT_TRANSFER"
        case forwardTransfer = "FORWARD_TRANSFER"
        case noAnswerTransfer = "NO_ANSWER_TRANSFER"
        case notAvailableTransfer = "NOT_AVAILABLE_TRANSFER"
        case uncallable = "UNCALLABLE"
        case dndEndpoint = "DND_ENDPOINT"
        case dndTransfer = "DND_TRANSFER"
    }

    public enum MediaType: String, Codable { 
        case unknown = "UNKNOWN"
        case voice = "VOICE"
        case chat = "CHAT"
        case email = "EMAIL"
        case callback = "CALLBACK"
        case cobrowse = "COBROWSE"
        case video = "VIDEO"
        case screenshare = "SCREENSHARE"
        case message = "MESSAGE"
    }



    public enum Direction: String, Codable { 
        case unknown = "UNKNOWN"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
    }

















    public var eventTime: Int?
    public var conversationId: String?
    public var participantId: String?
    public var sessionId: String?
    public var disconnectType: DisconnectType?
    public var mediaType: MediaType?
    public var provider: String?
    public var direction: Direction?
    public var ani: String?
    public var dnis: String?
    public var userId: String?
    public var queueId: String?
    public var divisionId: String?
    public var voicemailDurationMs: Int?
    public var conversationExternalContactIds: [String]?
    public var conversationExternalOrganizationIds: [String]?

    public init(eventTime: Int?, conversationId: String?, participantId: String?, sessionId: String?, disconnectType: DisconnectType?, mediaType: MediaType?, provider: String?, direction: Direction?, ani: String?, dnis: String?, userId: String?, queueId: String?, divisionId: String?, voicemailDurationMs: Int?, conversationExternalContactIds: [String]?, conversationExternalOrganizationIds: [String]?) {
        self.eventTime = eventTime
        self.conversationId = conversationId
        self.participantId = participantId
        self.sessionId = sessionId
        self.disconnectType = disconnectType
        self.mediaType = mediaType
        self.provider = provider
        self.direction = direction
        self.ani = ani
        self.dnis = dnis
        self.userId = userId
        self.queueId = queueId
        self.divisionId = divisionId
        self.voicemailDurationMs = voicemailDurationMs
        self.conversationExternalContactIds = conversationExternalContactIds
        self.conversationExternalOrganizationIds = conversationExternalOrganizationIds
    }


}




public class VoicemailMessagesTopicOwner: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class VoicemailOrganizationPolicy: Codable {























    /** Whether voicemail is enabled for this organization */
    public var enabled: Bool?
    /** The organization's default number of seconds to ring a user's phone before a call is transferred to voicemail */
    public var alertTimeoutSeconds: Int?
    /** The configuration for user PINs to access their voicemail from a phone */
    public var pinConfiguration: PINConfiguration?
    /** The extension for voicemail retrieval.  The default value is *86. */
    public var voicemailExtension: String?
    /** If this is true, a PIN is required when accessing a user's voicemail from a phone. */
    public var pinRequired: Bool?
    /** Whether user should be prompted with a confirmation prompt when connecting to a Group Ring call */
    public var interactiveResponseRequired: Bool?
    /** Whether email notifications are sent for new voicemails in the organization. If false, new voicemail email notifications are not be sent for the organization overriding any user or group setting. */
    public var sendEmailNotifications: Bool?
    /** Whether to include the voicemail transcription in the notification email */
    public var includeEmailTranscriptions: Bool?
    /** Removes any PII from emails. This overrides any analogous group configuration value. This is always true if HIPAA is enabled or unknown for an organization. */
    public var disableEmailPii: Bool?
    /** Default value for the maximum length of time in seconds of a recorded voicemail */
    public var maximumRecordingTimeSeconds: Int?
    /** The date the policy was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var modifiedDate: Date?

    public init(enabled: Bool?, alertTimeoutSeconds: Int?, pinConfiguration: PINConfiguration?, voicemailExtension: String?, pinRequired: Bool?, interactiveResponseRequired: Bool?, sendEmailNotifications: Bool?, includeEmailTranscriptions: Bool?, disableEmailPii: Bool?, maximumRecordingTimeSeconds: Int?, modifiedDate: Date?) {
        self.enabled = enabled
        self.alertTimeoutSeconds = alertTimeoutSeconds
        self.pinConfiguration = pinConfiguration
        self.voicemailExtension = voicemailExtension
        self.pinRequired = pinRequired
        self.interactiveResponseRequired = interactiveResponseRequired
        self.sendEmailNotifications = sendEmailNotifications
        self.includeEmailTranscriptions = includeEmailTranscriptions
        self.disableEmailPii = disableEmailPii
        self.maximumRecordingTimeSeconds = maximumRecordingTimeSeconds
        self.modifiedDate = modifiedDate
    }


}




public class VoicemailSearchRequest: Codable {

    public enum SortOrder: String, Codable { 
        case asc = "ASC"
        case desc = "DESC"
        case score = "SCORE"
    }













    /** The sort order for results */
    public var sortOrder: SortOrder?
    /** The field in the resource that you want to sort the results by */
    public var sortBy: String?
    /** The number of results per page */
    public var pageSize: Int?
    /** The page of resources you want to retrieve */
    public var pageNumber: Int?
    /** Multi-value sort order, list of multiple sort values */
    public var sort: [SearchSort]?
    /** Provides more details about a specified resource */
    public var expand: [String]?
    public var query: [VoicemailSearchCriteria]?

    public init(sortOrder: SortOrder?, sortBy: String?, pageSize: Int?, pageNumber: Int?, sort: [SearchSort]?, expand: [String]?, query: [VoicemailSearchCriteria]?) {
        self.sortOrder = sortOrder
        self.sortBy = sortBy
        self.pageSize = pageSize
        self.pageNumber = pageNumber
        self.sort = sort
        self.expand = expand
        self.query = query
    }


}




public class WebChatDeploymentEntityListing: Codable {







    public var total: Int64?
    public var entities: [WebChatDeployment]?
    public var selfUri: String?

    public init(total: Int64?, entities: [WebChatDeployment]?, selfUri: String?) {
        self.total = total
        self.entities = entities
        self.selfUri = selfUri
    }


}




public class WebChatGuestMediaRequestEntityList: Codable {



    public var entities: [WebChatGuestMediaRequest]?

    public init(entities: [WebChatGuestMediaRequest]?) {
        self.entities = entities
    }


}




public class WebChatMessage: Codable {











    public enum BodyType: String, Codable { 
        case standard = "standard"
        case notice = "notice"
        case memberJoin = "member-join"
        case memberLeave = "member-leave"
        case mediaRequest = "media-request"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** The identifier of the conversation */
    public var conversation: WebChatConversation?
    /** The member who sent the message */
    public var sender: WebChatMemberInfo?
    /** The message body. */
    public var body: String?
    /** The purpose of the message within the conversation, such as a standard text entry versus a greeting. */
    public var bodyType: BodyType?
    /** The timestamp of the message, in ISO-8601 format */
    public var timestamp: Date?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, conversation: WebChatConversation?, sender: WebChatMemberInfo?, body: String?, bodyType: BodyType?, timestamp: Date?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.conversation = conversation
        self.sender = sender
        self.body = body
        self.bodyType = bodyType
        self.timestamp = timestamp
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case conversation
        case sender
        case body
        case bodyType
        case timestamp
        case selfUri
    }


}




public class WebChatRoutingTarget: Codable {

    public enum TargetType: String, Codable { 
        case queue = "QUEUE"
    }









    /** The target type of the routing target, such as 'QUEUE'. */
    public var targetType: TargetType?
    /** The target of the route, in the format appropriate given the 'targetType'. */
    public var targetAddress: String?
    /** The list of skill names to use for routing. */
    public var skills: [String]?
    /** The language name to use for routing. */
    public var language: String?
    /** The priority to assign to the conversation for routing. */
    public var priority: Int64?

    public init(targetType: TargetType?, targetAddress: String?, skills: [String]?, language: String?, priority: Int64?) {
        self.targetType = targetType
        self.targetAddress = targetAddress
        self.skills = skills
        self.language = language
        self.priority = priority
    }


}




public class WebChatSettings: Codable {



    public var requireDeployment: Bool?

    public init(requireDeployment: Bool?) {
        self.requireDeployment = requireDeployment
    }


}




public class WebDeploymentsDeploymentTopicWebMessagingDeploymentChangeEventBody: Codable {





    public enum Status: String, Codable { 
        case pending = "Pending"
        case active = "Active"
        case inactive = "Inactive"
        case error = "Error"
        case deleting = "Deleting"
    }

    public var _id: String?
    public var configuration: WebDeploymentsDeploymentTopicWebMessagingConfigChangeEventBody?
    public var status: Status?

    public init(_id: String?, configuration: WebDeploymentsDeploymentTopicWebMessagingConfigChangeEventBody?, status: Status?) {
        self._id = _id
        self.configuration = configuration
        self.status = status
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case configuration
        case status
    }


}



/** Channel-specific information that describes the message and the message channel/provider. */

public class WebMessagingChannel: Codable {









    /** Information about the recipient the message is received from. */
    public var from: WebMessagingRecipient?
    /** Information about the recipient the message is sent to. */
    public var to: WebMessagingRecipient?
    /** When the message was processed by Genesys Cloud. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var time: Date?
    /** Unique provider ID of the message. */
    public var messageId: String?

    public init(from: WebMessagingRecipient?, to: WebMessagingRecipient?, time: Date?, messageId: String?) {
        self.from = from
        self.to = to
        self.time = time
        self.messageId = messageId
    }


}




public class WebMessagingOfferFields: Codable {





    /** Text value to be used when inviting a visitor to engage with a web messaging offer. */
    public var offerText: String?
    /** Flow to be invoked, overrides default flow when specified. */
    public var architectFlow: AddressableEntityRef?

    public init(offerText: String?, architectFlow: AddressableEntityRef?) {
        self.offerText = offerText
        self.architectFlow = architectFlow
    }


}




public class WebMessagingOfferProperties: Codable {



    /** Text value to be used when inviting a visitor to engage with a web messaging offer. */
    public var offerText: String?

    public init(offerText: String?) {
        self.offerText = offerText
    }


}




public class WeekSchedule: Codable {























    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?
    /** First day of this week schedule in yyyy-MM-dd format */
    public var weekDate: String?
    /** Description of the week schedule */
    public var _description: String?
    /** Whether the week schedule is published */
    public var published: Bool?
    /** Summary of the results from the schedule run */
    public var generationResults: WeekScheduleGenerationResult?
    /** Short term forecast associated with this schedule */
    public var shortTermForecast: ShortTermForecastReference?
    /** Version metadata for this work plan */
    public var metadata: WfmVersionedEntityMetadata?
    /** User schedules in the week */
    public var userSchedules: [String:UserSchedule]?
    /** Headcount information for the week schedule */
    public var headcountForecast: HeadcountForecast?
    /** Version of agent schedules in the week schedule */
    public var agentSchedulesVersion: Int?

    public init(_id: String?, selfUri: String?, weekDate: String?, _description: String?, published: Bool?, generationResults: WeekScheduleGenerationResult?, shortTermForecast: ShortTermForecastReference?, metadata: WfmVersionedEntityMetadata?, userSchedules: [String:UserSchedule]?, headcountForecast: HeadcountForecast?, agentSchedulesVersion: Int?) {
        self._id = _id
        self.selfUri = selfUri
        self.weekDate = weekDate
        self._description = _description
        self.published = published
        self.generationResults = generationResults
        self.shortTermForecast = shortTermForecast
        self.metadata = metadata
        self.userSchedules = userSchedules
        self.headcountForecast = headcountForecast
        self.agentSchedulesVersion = agentSchedulesVersion
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
        case weekDate
        case _description = "description"
        case published
        case generationResults
        case shortTermForecast
        case metadata
        case userSchedules
        case headcountForecast
        case agentSchedulesVersion
    }


}




public class WeekScheduleGenerationResult: Codable {









    /** Whether the schedule generation failed */
    public var failed: Bool?
    /** ID of the schedule run */
    public var runId: String?
    /** Warning messages from the schedule run. This will be available only when requesting information for a single week schedule */
    public var agentWarnings: [ScheduleGenerationWarning]?
    /** Count of warning messages from the schedule run. This will be available only when requesting multiple week schedules */
    public var agentWarningCount: Int?

    public init(failed: Bool?, runId: String?, agentWarnings: [ScheduleGenerationWarning]?, agentWarningCount: Int?) {
        self.failed = failed
        self.runId = runId
        self.agentWarnings = agentWarnings
        self.agentWarningCount = agentWarningCount
    }


}




public class WeekShiftTradeResponse: Codable {





    /** The shift trade details */
    public var trade: ShiftTradeResponse?
    /** A preview of what the schedule would look like if the shift trade is approved plus any violations */
    public var matchReview: ShiftTradeMatchReviewResponse?

    public init(trade: ShiftTradeResponse?, matchReview: ShiftTradeMatchReviewResponse?) {
        self.trade = trade
        self.matchReview = matchReview
    }


}




public class WfmAdherenceExplanationJobCompleteTopicAdherenceExplanationChangedNotification: Codable {









    public enum ModelType: String, Codable { 
        case late = "Late"
    }

    public enum Status: String, Codable { 
        case pending = "Pending"
        case approved = "Approved"
        case denied = "Denied"
    }











    public var _id: String?
    public var agent: WfmAdherenceExplanationJobCompleteTopicUserReference?
    public var managementUnit: WfmAdherenceExplanationJobCompleteTopicManagementUnit?
    public var businessUnit: WfmAdherenceExplanationJobCompleteTopicBusinessUnit?
    public var type: ModelType?
    public var status: Status?
    public var startDate: Date?
    public var lengthMinutes: Int?
    public var notes: String?
    public var reviewedBy: WfmAdherenceExplanationJobCompleteTopicUserReference?
    public var reviewedDate: Date?

    public init(_id: String?, agent: WfmAdherenceExplanationJobCompleteTopicUserReference?, managementUnit: WfmAdherenceExplanationJobCompleteTopicManagementUnit?, businessUnit: WfmAdherenceExplanationJobCompleteTopicBusinessUnit?, type: ModelType?, status: Status?, startDate: Date?, lengthMinutes: Int?, notes: String?, reviewedBy: WfmAdherenceExplanationJobCompleteTopicUserReference?, reviewedDate: Date?) {
        self._id = _id
        self.agent = agent
        self.managementUnit = managementUnit
        self.businessUnit = businessUnit
        self.type = type
        self.status = status
        self.startDate = startDate
        self.lengthMinutes = lengthMinutes
        self.notes = notes
        self.reviewedBy = reviewedBy
        self.reviewedDate = reviewedDate
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case agent
        case managementUnit
        case businessUnit
        case type
        case status
        case startDate
        case lengthMinutes
        case notes
        case reviewedBy
        case reviewedDate
    }


}




public class WfmAdherenceExplanationJobCompleteTopicManagementUnit: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmBuScheduleRunTopicBuScheduleRun: Codable {







    public enum State: String, Codable { 
        case _none = "None"
        case queued = "Queued"
        case scheduling = "Scheduling"
        case canceled = "Canceled"
        case failed = "Failed"
        case complete = "Complete"
    }













    public var _id: String?
    public var percentComplete: Double?
    public var intradayRescheduling: Bool?
    public var state: State?
    public var weekCount: Int?
    public var schedule: WfmBuScheduleRunTopicBuScheduleReference?
    public var schedulingCanceledBy: WfmBuScheduleRunTopicUserReference?
    public var schedulingCompletedTime: String?
    public var messageCount: Int?
    public var messageSeverityCounts: [WfmBuScheduleRunTopicSchedulerMessageSeverityCount]?

    public init(_id: String?, percentComplete: Double?, intradayRescheduling: Bool?, state: State?, weekCount: Int?, schedule: WfmBuScheduleRunTopicBuScheduleReference?, schedulingCanceledBy: WfmBuScheduleRunTopicUserReference?, schedulingCompletedTime: String?, messageCount: Int?, messageSeverityCounts: [WfmBuScheduleRunTopicSchedulerMessageSeverityCount]?) {
        self._id = _id
        self.percentComplete = percentComplete
        self.intradayRescheduling = intradayRescheduling
        self.state = state
        self.weekCount = weekCount
        self.schedule = schedule
        self.schedulingCanceledBy = schedulingCanceledBy
        self.schedulingCompletedTime = schedulingCompletedTime
        self.messageCount = messageCount
        self.messageSeverityCounts = messageSeverityCounts
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case percentComplete
        case intradayRescheduling
        case state
        case weekCount
        case schedule
        case schedulingCanceledBy
        case schedulingCompletedTime
        case messageCount
        case messageSeverityCounts
    }


}




public class WfmAgentScheduleUpdateTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmBuIntradayDataUpdateTopicBuIntradayResult: Codable {









    public enum Categories: String, Codable { 
        case forecastData = "ForecastData"
        case scheduleData = "ScheduleData"
        case performancePredictionData = "PerformancePredictionData"
    }







    public var startDate: Date?
    public var endDate: Date?
    public var intervalLengthMinutes: Int?
    public var intradayDataGroupings: [WfmBuIntradayDataUpdateTopicBuIntradayDataGroup]?
    public var categories: [Categories]?
    public var noDataReason: String?
    public var schedule: WfmBuIntradayDataUpdateTopicBuScheduleReference?
    public var shortTermForecast: WfmBuIntradayDataUpdateTopicBuShortTermForecastReference?

    public init(startDate: Date?, endDate: Date?, intervalLengthMinutes: Int?, intradayDataGroupings: [WfmBuIntradayDataUpdateTopicBuIntradayDataGroup]?, categories: [Categories]?, noDataReason: String?, schedule: WfmBuIntradayDataUpdateTopicBuScheduleReference?, shortTermForecast: WfmBuIntradayDataUpdateTopicBuShortTermForecastReference?) {
        self.startDate = startDate
        self.endDate = endDate
        self.intervalLengthMinutes = intervalLengthMinutes
        self.intradayDataGroupings = intradayDataGroupings
        self.categories = categories
        self.noDataReason = noDataReason
        self.schedule = schedule
        self.shortTermForecast = shortTermForecast
    }


}




public class WfmBuIntradayDataUpdateTopicIntradayPerformancePredictionData: Codable {







    public var serviceLevelPercent: Double?
    public var averageSpeedOfAnswerSeconds: Double?
    public var occupancyPercent: Double?

    public init(serviceLevelPercent: Double?, averageSpeedOfAnswerSeconds: Double?, occupancyPercent: Double?) {
        self.serviceLevelPercent = serviceLevelPercent
        self.averageSpeedOfAnswerSeconds = averageSpeedOfAnswerSeconds
        self.occupancyPercent = occupancyPercent
    }


}




public class WfmBuScheduleRunTopicBuSchedulingRunProgressNotification: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }





    public var status: Status?
    public var operationId: String?
    public var result: WfmBuScheduleRunTopicBuScheduleRun?

    public init(status: Status?, operationId: String?, result: WfmBuScheduleRunTopicBuScheduleRun?) {
        self.status = status
        self.operationId = operationId
        self.result = result
    }


}




public class WfmBuScheduleTopicWfmVersionedEntityMetadata: Codable {







    public var version: Int?
    public var modifiedBy: WfmBuScheduleTopicUserReference?
    public var dateModified: Date?

    public init(version: Int?, modifiedBy: WfmBuScheduleTopicUserReference?, dateModified: Date?) {
        self.version = version
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
    }


}




public class WfmBuShortTermForecastCopyCompleteTopicBuShortTermForecast: Codable {





    public enum CreationMethod: String, Codable { 
        case _import = "Import"
        case importedHistoricalWeightedAverage = "ImportedHistoricalWeightedAverage"
        case historicalWeightedAverage = "HistoricalWeightedAverage"
        case advanced = "Advanced"
    }





















    public var _id: String?
    public var weekDate: String?
    public var creationMethod: CreationMethod?
    public var _description: String?
    public var legacy: Bool?
    public var referenceStartDate: Date?
    public var sourceDays: [WfmBuShortTermForecastCopyCompleteTopicForecastSourceDayPointer]?
    public var modifications: [WfmBuShortTermForecastCopyCompleteTopicBuForecastModification]?
    public var timeZone: String?
    public var planningGroupsVersion: Int?
    public var weekCount: Int?
    public var metadata: WfmBuShortTermForecastCopyCompleteTopicWfmVersionedEntityMetadata?
    public var canUseForScheduling: Bool?

    public init(_id: String?, weekDate: String?, creationMethod: CreationMethod?, _description: String?, legacy: Bool?, referenceStartDate: Date?, sourceDays: [WfmBuShortTermForecastCopyCompleteTopicForecastSourceDayPointer]?, modifications: [WfmBuShortTermForecastCopyCompleteTopicBuForecastModification]?, timeZone: String?, planningGroupsVersion: Int?, weekCount: Int?, metadata: WfmBuShortTermForecastCopyCompleteTopicWfmVersionedEntityMetadata?, canUseForScheduling: Bool?) {
        self._id = _id
        self.weekDate = weekDate
        self.creationMethod = creationMethod
        self._description = _description
        self.legacy = legacy
        self.referenceStartDate = referenceStartDate
        self.sourceDays = sourceDays
        self.modifications = modifications
        self.timeZone = timeZone
        self.planningGroupsVersion = planningGroupsVersion
        self.weekCount = weekCount
        self.metadata = metadata
        self.canUseForScheduling = canUseForScheduling
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case creationMethod
        case _description = "description"
        case legacy
        case referenceStartDate
        case sourceDays
        case modifications
        case timeZone
        case planningGroupsVersion
        case weekCount
        case metadata
        case canUseForScheduling
    }


}




public class WfmBuShortTermForecastCopyCompleteTopicBuShortTermForecastNotification: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }





    public var status: Status?
    public var result: WfmBuShortTermForecastCopyCompleteTopicBuShortTermForecast?
    public var operationId: String?

    public init(status: Status?, result: WfmBuShortTermForecastCopyCompleteTopicBuShortTermForecast?, operationId: String?) {
        self.status = status
        self.result = result
        self.operationId = operationId
    }


}




public class WfmBuShortTermForecastGenerateProgressTopicBuForecastModification: Codable {

    public enum ModelType: String, Codable { 
        case minimumPerInterval = "MinimumPerInterval"
        case maximumPerInterval = "MaximumPerInterval"
        case setValuePerInterval = "SetValuePerInterval"
        case changeValuePerInterval = "ChangeValuePerInterval"
        case changePercentPerInterval = "ChangePercentPerInterval"
        case setValueOverRange = "SetValueOverRange"
        case changeValueOverRange = "ChangeValueOverRange"
        case setValuesForIntervalSet = "SetValuesForIntervalSet"
        case setMultiGranularityValuesForIntervalSet = "SetMultiGranularityValuesForIntervalSet"
    }





    public enum Metric: String, Codable { 
        case offered = "Offered"
        case averageHandleTimeSeconds = "AverageHandleTimeSeconds"
    }

    public enum LegacyMetric: String, Codable { 
        case averageAfterCallWorkTimeSeconds = "AverageAfterCallWorkTimeSeconds"
        case averageHandleTimeSeconds = "AverageHandleTimeSeconds"
        case averageTalkTimeSeconds = "AverageTalkTimeSeconds"
        case offered = "Offered"
    }

















    public var type: ModelType?
    public var startIntervalIndex: Int?
    public var endIntervalIndex: Int?
    public var metric: Metric?
    public var legacyMetric: LegacyMetric?
    public var value: Double?
    public var values: [WfmBuShortTermForecastGenerateProgressTopicModificationIntervalOffsetValue]?
    public var secondaryValues: [WfmBuShortTermForecastGenerateProgressTopicModificationIntervalOffsetValue]?
    public var enabled: Bool?
    public var granularity: String?
    public var secondaryGranularity: String?
    public var displayGranularity: String?
    public var planningGroupIds: [String]?

    public init(type: ModelType?, startIntervalIndex: Int?, endIntervalIndex: Int?, metric: Metric?, legacyMetric: LegacyMetric?, value: Double?, values: [WfmBuShortTermForecastGenerateProgressTopicModificationIntervalOffsetValue]?, secondaryValues: [WfmBuShortTermForecastGenerateProgressTopicModificationIntervalOffsetValue]?, enabled: Bool?, granularity: String?, secondaryGranularity: String?, displayGranularity: String?, planningGroupIds: [String]?) {
        self.type = type
        self.startIntervalIndex = startIntervalIndex
        self.endIntervalIndex = endIntervalIndex
        self.metric = metric
        self.legacyMetric = legacyMetric
        self.value = value
        self.values = values
        self.secondaryValues = secondaryValues
        self.enabled = enabled
        self.granularity = granularity
        self.secondaryGranularity = secondaryGranularity
        self.displayGranularity = displayGranularity
        self.planningGroupIds = planningGroupIds
    }


}




public class WfmBuShortTermForecastGenerateProgressTopicModificationIntervalOffsetValue: Codable {





    public var intervalIndex: Int?
    public var value: Double?

    public init(intervalIndex: Int?, value: Double?) {
        self.intervalIndex = intervalIndex
        self.value = value
    }


}




public class WfmBuShortTermForecastGenerateProgressTopicWfmVersionedEntityMetadata: Codable {







    public var version: Int?
    public var modifiedBy: WfmBuShortTermForecastGenerateProgressTopicUserReference?
    public var dateModified: Date?

    public init(version: Int?, modifiedBy: WfmBuShortTermForecastGenerateProgressTopicUserReference?, dateModified: Date?) {
        self.version = version
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
    }


}




public class WfmBuShortTermForecastUpdateCompleteTopicBuShortTermForecast: Codable {





    public enum CreationMethod: String, Codable { 
        case _import = "Import"
        case importedHistoricalWeightedAverage = "ImportedHistoricalWeightedAverage"
        case historicalWeightedAverage = "HistoricalWeightedAverage"
        case advanced = "Advanced"
    }





















    public var _id: String?
    public var weekDate: String?
    public var creationMethod: CreationMethod?
    public var _description: String?
    public var legacy: Bool?
    public var referenceStartDate: Date?
    public var sourceDays: [WfmBuShortTermForecastUpdateCompleteTopicForecastSourceDayPointer]?
    public var modifications: [WfmBuShortTermForecastUpdateCompleteTopicBuForecastModification]?
    public var timeZone: String?
    public var planningGroupsVersion: Int?
    public var weekCount: Int?
    public var metadata: WfmBuShortTermForecastUpdateCompleteTopicWfmVersionedEntityMetadata?
    public var canUseForScheduling: Bool?

    public init(_id: String?, weekDate: String?, creationMethod: CreationMethod?, _description: String?, legacy: Bool?, referenceStartDate: Date?, sourceDays: [WfmBuShortTermForecastUpdateCompleteTopicForecastSourceDayPointer]?, modifications: [WfmBuShortTermForecastUpdateCompleteTopicBuForecastModification]?, timeZone: String?, planningGroupsVersion: Int?, weekCount: Int?, metadata: WfmBuShortTermForecastUpdateCompleteTopicWfmVersionedEntityMetadata?, canUseForScheduling: Bool?) {
        self._id = _id
        self.weekDate = weekDate
        self.creationMethod = creationMethod
        self._description = _description
        self.legacy = legacy
        self.referenceStartDate = referenceStartDate
        self.sourceDays = sourceDays
        self.modifications = modifications
        self.timeZone = timeZone
        self.planningGroupsVersion = planningGroupsVersion
        self.weekCount = weekCount
        self.metadata = metadata
        self.canUseForScheduling = canUseForScheduling
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case weekDate
        case creationMethod
        case _description = "description"
        case legacy
        case referenceStartDate
        case sourceDays
        case modifications
        case timeZone
        case planningGroupsVersion
        case weekCount
        case metadata
        case canUseForScheduling
    }


}




public class WfmBuShortTermForecastUpdateCompleteTopicBuShortTermForecastNotification: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }





    public var status: Status?
    public var result: WfmBuShortTermForecastUpdateCompleteTopicBuShortTermForecast?
    public var operationId: String?

    public init(status: Status?, result: WfmBuShortTermForecastUpdateCompleteTopicBuShortTermForecast?, operationId: String?) {
        self.status = status
        self.result = result
        self.operationId = operationId
    }


}




public class WfmBulkShiftTradeStateUpdateNotificationTopicBulkShiftTradeStateUpdateResult: Codable {



    public enum State: String, Codable { 
        case unmatched = "Unmatched"
        case matched = "Matched"
        case approved = "Approved"
        case denied = "Denied"
        case expired = "Expired"
        case canceled = "Canceled"
    }





    public enum FailureReason: String, Codable { 
        case initiatingAgentScheduleNotFound = "InitiatingAgentScheduleNotFound"
        case initiatingAgentShiftNotFound = "InitiatingAgentShiftNotFound"
        case receivingAgentNotFound = "ReceivingAgentNotFound"
        case receivingAgentScheduleNotFound = "ReceivingAgentScheduleNotFound"
        case receivingAgentShiftNotFound = "ReceivingAgentShiftNotFound"
        case scheduleNotPublished = "ScheduleNotPublished"
        case transitionNotAllowed = "TransitionNotAllowed"
    }



    public var _id: String?
    public var state: State?
    public var reviewedBy: WfmBulkShiftTradeStateUpdateNotificationTopicUserReference?
    public var reviewedDate: Date?
    public var failureReason: FailureReason?
    public var metadata: WfmBulkShiftTradeStateUpdateNotificationTopicWfmVersionedEntityMetadata?

    public init(_id: String?, state: State?, reviewedBy: WfmBulkShiftTradeStateUpdateNotificationTopicUserReference?, reviewedDate: Date?, failureReason: FailureReason?, metadata: WfmBulkShiftTradeStateUpdateNotificationTopicWfmVersionedEntityMetadata?) {
        self._id = _id
        self.state = state
        self.reviewedBy = reviewedBy
        self.reviewedDate = reviewedDate
        self.failureReason = failureReason
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case state
        case reviewedBy
        case reviewedDate
        case failureReason
        case metadata
    }


}




public class WfmBulkShiftTradeStateUpdateNotificationTopicBulkShiftTradeStateUpdateResultListing: Codable {



    public var entities: [WfmBulkShiftTradeStateUpdateNotificationTopicBulkShiftTradeStateUpdateResult]?

    public init(entities: [WfmBulkShiftTradeStateUpdateNotificationTopicBulkShiftTradeStateUpdateResult]?) {
        self.entities = entities
    }


}




public class WfmBusinessUnitReference: Codable {





    /** The ID of the business unit */
    public var _id: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, selfUri: String?) {
        self._id = _id
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case selfUri
    }


}




public class WfmHistoricalAdherenceQuery: Codable {













    /** Beginning of the date range to query in ISO-8601 format */
    public var startDate: Date?
    /** End of the date range to query in ISO-8601 format. If it is not set, end date will be set to current time */
    public var endDate: Date?
    /** The time zone, in olson format, to use in defining days when computing adherence. The results will be returned as UTC timestamps regardless of the time zone input. */
    public var timeZone: String?
    /** The userIds to report on. If null or not set, adherence will be computed for all the users in management unit or requested teamIds */
    public var userIds: [String]?
    /** Whether user exceptions should be returned as part of the results */
    public var includeExceptions: Bool?
    /** The teamIds to report on. If null or not set, adherence will be computed for requested users if applicable or otherwise all users in the management unit. Note: If teamIds is also specified, only adherence for users in the requested teams will be returned */
    public var teamIds: [String]?

    public init(startDate: Date?, endDate: Date?, timeZone: String?, userIds: [String]?, includeExceptions: Bool?, teamIds: [String]?) {
        self.startDate = startDate
        self.endDate = endDate
        self.timeZone = timeZone
        self.userIds = userIds
        self.includeExceptions = includeExceptions
        self.teamIds = teamIds
    }


}




public class WfmHistoricalAdherenceQueryForUsers: Codable {











    /** Beginning of the date range to query in ISO-8601 format */
    public var startDate: Date?
    /** End of the date range to query in ISO-8601 format. If it is not set, end date will be set to current time */
    public var endDate: Date?
    /** The time zone, in olson format, to use in defining days when computing adherence. The results will be returned as UTC timestamps regardless of the time zone input. */
    public var timeZone: String?
    /** The userIds to report on */
    public var userIds: [String]?
    /** Whether user exceptions should be returned as part of the results */
    public var includeExceptions: Bool?

    public init(startDate: Date?, endDate: Date?, timeZone: String?, userIds: [String]?, includeExceptions: Bool?) {
        self.startDate = startDate
        self.endDate = endDate
        self.timeZone = timeZone
        self.userIds = userIds
        self.includeExceptions = includeExceptions
    }


}




public class WfmHistoricalShrinkageRequest: Codable {







    public enum Granularity: String, Codable { 
        case daily = "Daily"
        case weekly = "Weekly"
    }

    /** Beginning of the date range to query in ISO-8601 format */
    public var startDate: Date?
    /** End of the date range to query in ISO-8601 format. If it is not set, end date will be set to current time */
    public var endDate: Date?
    /** The time zone, in olson format, to use in defining days when computing shrinkage for requested granularity. If it is not set, the business unit time zone will be used. The results will be returned as UTC timestamps regardless of the time zone input. */
    public var timeZone: String?
    /** Shrinkage aggregation interval granularity. */
    public var granularity: Granularity?

    public init(startDate: Date?, endDate: Date?, timeZone: String?, granularity: Granularity?) {
        self.startDate = startDate
        self.endDate = endDate
        self.timeZone = timeZone
        self.granularity = granularity
    }


}




public class WfmIntegrationListing: Codable {



    public var entities: [WfmIntegrationResponse]?

    public init(entities: [WfmIntegrationResponse]?) {
        self.entities = entities
    }


}




public class WfmIntegrationsHrisTimeOffTypesJobTopicErrorBody: Codable {









    public var status: Int?
    public var code: String?
    public var message: String?
    public var messageParams: [String:String]?

    public init(status: Int?, code: String?, message: String?, messageParams: [String:String]?) {
        self.status = status
        self.code = code
        self.message = message
        self.messageParams = messageParams
    }


}




public class WfmIntradayDataUpdateTopicIntradayHistoricalAgentData: Codable {





    public var onQueueTimeSeconds: Double?
    public var interactingTimeSeconds: Double?

    public init(onQueueTimeSeconds: Double?, interactingTimeSeconds: Double?) {
        self.onQueueTimeSeconds = onQueueTimeSeconds
        self.interactingTimeSeconds = interactingTimeSeconds
    }


}




public class WfmIntradayPlanningGroupListing: Codable {



    public enum NoDataReason: String, Codable { 
        case noPublishedSchedule = "NoPublishedSchedule"
        case noSourceForecast = "NoSourceForecast"
    }

    public var entities: [ForecastPlanningGroupResponse]?
    /** The reason there was no data for the request */
    public var noDataReason: NoDataReason?

    public init(entities: [ForecastPlanningGroupResponse]?, noDataReason: NoDataReason?) {
        self.entities = entities
        self.noDataReason = noDataReason
    }


}




public class WfmMoveAgentsCompleteTopicWfmMoveAgentData: Codable {



    public enum Result: String, Codable { 
        case alreadyMoved = "AlreadyMoved"
        case destinationBusinessUnitAgentLimitExceeded = "DestinationBusinessUnitAgentLimitExceeded"
        case destinationManagementUnitAgentLimitExceeded = "DestinationManagementUnitAgentLimitExceeded"
        case destinationManagementUnitDoesNotExist = "DestinationManagementUnitDoesNotExist"
        case moveSuccessful = "MoveSuccessful"
        case movingToDifferentManagementUnit = "MovingToDifferentManagementUnit"
        case nothingToDo = "NothingToDo"
        case sourceManagementUnitNotAuthorized = "SourceManagementUnitNotAuthorized"
    }

    public var user: WfmMoveAgentsCompleteTopicUserReference?
    public var result: Result?

    public init(user: WfmMoveAgentsCompleteTopicUserReference?, result: Result?) {
        self.user = user
        self.result = result
    }


}




public class Wrapup: Codable {















    /** The user configured wrap up code id. */
    public var code: String?
    /** The user configured wrap up code name. */
    public var name: String?
    /** Text entered by the agent to describe the call or disposition. */
    public var notes: String?
    /** List of tags selected by the agent to describe the call or disposition. */
    public var tags: [String]?
    /** The length of time in seconds that the agent spent doing after call work. */
    public var durationSeconds: Int?
    /** The timestamp when the wrapup was finished. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var endTime: Date?
    /** Indicates if this is a pending save and should not require a code to be specified.  This allows someone to save some temporary wrapup that will be used later. */
    public var provisional: Bool?

    public init(code: String?, name: String?, notes: String?, tags: [String]?, durationSeconds: Int?, endTime: Date?, provisional: Bool?) {
        self.code = code
        self.name = name
        self.notes = notes
        self.tags = tags
        self.durationSeconds = durationSeconds
        self.endTime = endTime
        self.provisional = provisional
    }


}




public class WfmUpdateAgentDetailsTopicWfmUpdateAgentDetailsComplete: Codable {

    public enum Status: String, Codable { 
        case processing = "Processing"
        case complete = "Complete"
        case canceled = "Canceled"
        case error = "Error"
    }

    public var status: Status?

    public init(status: Status?) {
        self.status = status
    }


}




public class WfmUserNotificationTopicAdherenceExplanationNotification: Codable {













    public enum Status: String, Codable { 
        case pending = "Pending"
        case approved = "Approved"
        case denied = "Denied"
    }

    public enum ModelType: String, Codable { 
        case late = "Late"
    }



    public var _id: String?
    public var agent: WfmUserNotificationTopicUserReference?
    public var managementUnit: WfmUserNotificationTopicManagementUnit?
    public var businessUnit: WfmUserNotificationTopicBusinessUnit?
    public var startDate: Date?
    public var lengthMinutes: Int?
    public var status: Status?
    public var type: ModelType?
    public var notes: String?

    public init(_id: String?, agent: WfmUserNotificationTopicUserReference?, managementUnit: WfmUserNotificationTopicManagementUnit?, businessUnit: WfmUserNotificationTopicBusinessUnit?, startDate: Date?, lengthMinutes: Int?, status: Status?, type: ModelType?, notes: String?) {
        self._id = _id
        self.agent = agent
        self.managementUnit = managementUnit
        self.businessUnit = businessUnit
        self.startDate = startDate
        self.lengthMinutes = lengthMinutes
        self.status = status
        self.type = type
        self.notes = notes
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case agent
        case managementUnit
        case businessUnit
        case startDate
        case lengthMinutes
        case status
        case type
        case notes
    }


}




public class WfmUserNotificationTopicBusinessUnit: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmUserScheduleAdherenceUpdatedMuTopicRealTimeAdherenceExplanation: Codable {







    public enum Status: String, Codable { 
        case pending = "Pending"
        case approved = "Approved"
        case denied = "Denied"
    }

    public var _id: String?
    public var startDate: Date?
    public var lengthMinutes: Int?
    public var status: Status?

    public init(_id: String?, startDate: Date?, lengthMinutes: Int?, status: Status?) {
        self._id = _id
        self.startDate = startDate
        self.lengthMinutes = lengthMinutes
        self.status = status
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case startDate
        case lengthMinutes
        case status
    }


}




public class WfmUserScheduleAdherenceUpdatedTeamTopicActivityCodeReference: Codable {





    public var _id: String?
    public var secondaryPresences: [WfmUserScheduleAdherenceUpdatedTeamTopicSecondaryPresenceReference]?

    public init(_id: String?, secondaryPresences: [WfmUserScheduleAdherenceUpdatedTeamTopicSecondaryPresenceReference]?) {
        self._id = _id
        self.secondaryPresences = secondaryPresences
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case secondaryPresences
    }


}




public class WfmUserScheduleAdherenceUpdatedTeamTopicUriReference: Codable {





    /** The ID of the resource */
    public var _id: String?
    /** The name of the resource */
    public var name: String?

    public init(_id: String?, name: String?) {
        self._id = _id
        self.name = name
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
    }


}




public class WfmUserScheduleAdherenceUpdatedTopicUserReference: Codable {



    public var _id: String?

    public init(_id: String?) {
        self._id = _id
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
    }


}




public class WfmVersionedEntityMetadata: Codable {











    /** The version of the associated entity.  Used to prevent conflicts on concurrent edits */
    public var version: Int?
    /** The user who last modified the associated entity */
    public var modifiedBy: UserReference?
    /** The date the associated entity was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** The user who created the associated entity, if available */
    public var createdBy: UserReference?
    /** The date the associated entity was created, if available. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?

    public init(version: Int?, modifiedBy: UserReference?, dateModified: Date?, createdBy: UserReference?, dateCreated: Date?) {
        self.version = version
        self.modifiedBy = modifiedBy
        self.dateModified = dateModified
        self.createdBy = createdBy
        self.dateCreated = dateCreated
    }


}




public class WhatsAppEmbeddedSignupIntegrationActivationRequest: Codable {











    /** The globally unique identifier for the object. */
    public var _id: String?
    /** WhatsApp Integration name */
    public var name: String?
    /** Phone number to associate with the WhatsApp integration */
    public var phoneNumber: String?
    /** Specify the two-step verification PIN for that phone number */
    public var pin: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, phoneNumber: String?, pin: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.phoneNumber = phoneNumber
        self.pin = pin
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case phoneNumber
        case pin
        case selfUri
    }


}




public class WhatsAppIntegration: Codable {













    public enum Status: String, Codable { 
        case active = "Active"
        case inactive = "Inactive"
        case error = "Error"
        case starting = "Starting"
        case incomplete = "Incomplete"
        case deleting = "Deleting"
        case deletionFailed = "DeletionFailed"
    }













    public enum ActivationStatusCode: String, Codable { 
        case codeSent = "CodeSent"
        case waitRequired = "WaitRequired"
        case activationFailed = "ActivationFailed"
        case codeConfirmed = "CodeConfirmed"
        case confirmationFailed = "ConfirmationFailed"
        case resendCode = "ResendCode"
    }



    public enum CreateStatus: String, Codable { 
        case initiated = "Initiated"
        case completed = "Completed"
        case error = "Error"
    }





    /** A unique Integration Id. */
    public var _id: String?
    /** The name of the WhatsApp integration. */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    public var messagingSetting: MessagingSettingReference?
    /** The phone number associated to the WhatsApp integration. */
    public var phoneNumber: String?
    /** The list of available WhatsApp phone numbers for this account. Please select one phone number from this list to use with the created integration. */
    public var availablePhoneNumbers: WhatsAppAvailablePhoneNumberDetailsListing?
    /** The status of the WhatsApp Integration */
    public var status: Status?
    /** The recipient associated to the WhatsApp Integration. This recipient is used to associate a flow to an integration */
    public var recipient: DomainEntityRef?
    /** Date this Integration was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateCreated: Date?
    /** Date this Integration was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z */
    public var dateModified: Date?
    /** User reference that created this Integration */
    public var createdBy: DomainEntityRef?
    /** User reference that last modified this Integration */
    public var modifiedBy: DomainEntityRef?
    /** Version number required for updates. */
    public var version: Int?
    /** The status code of WhatsApp Integration activation process */
    public var activationStatusCode: ActivationStatusCode?
    /** The error information of WhatsApp Integration activation process */
    public var activationErrorInfo: ErrorBody?
    /** Status of asynchronous create operation */
    public var createStatus: CreateStatus?
    /** Error information returned, if createStatus is set to Error */
    public var createError: ErrorBody?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingReference?, phoneNumber: String?, availablePhoneNumbers: WhatsAppAvailablePhoneNumberDetailsListing?, status: Status?, recipient: DomainEntityRef?, dateCreated: Date?, dateModified: Date?, createdBy: DomainEntityRef?, modifiedBy: DomainEntityRef?, version: Int?, activationStatusCode: ActivationStatusCode?, activationErrorInfo: ErrorBody?, createStatus: CreateStatus?, createError: ErrorBody?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.phoneNumber = phoneNumber
        self.availablePhoneNumbers = availablePhoneNumbers
        self.status = status
        self.recipient = recipient
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.createdBy = createdBy
        self.modifiedBy = modifiedBy
        self.version = version
        self.activationStatusCode = activationStatusCode
        self.activationErrorInfo = activationErrorInfo
        self.createStatus = createStatus
        self.createError = createError
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case phoneNumber
        case availablePhoneNumbers
        case status
        case recipient
        case dateCreated
        case dateModified
        case createdBy
        case modifiedBy
        case version
        case activationStatusCode
        case activationErrorInfo
        case createStatus
        case createError
        case selfUri
    }


}




public class WhatsAppIntegrationRequest: Codable {















    /** The globally unique identifier for the object. */
    public var _id: String?
    /** The name of the WhatsApp Integration */
    public var name: String?
    /** Defines the SupportedContent profile configured for an integration */
    public var supportedContent: SupportedContentReference?
    /** Defines the message settings to be applied for this integration */
    public var messagingSetting: MessagingSettingRequestReference?
    /** The phone number associated to the whatsApp integration */
    public var phoneNumber: String?
    /** The waba(WhatsApp Business Manager) certificate associated to the WhatsApp integration phone number */
    public var wabaCertificate: String?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, supportedContent: SupportedContentReference?, messagingSetting: MessagingSettingRequestReference?, phoneNumber: String?, wabaCertificate: String?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.supportedContent = supportedContent
        self.messagingSetting = messagingSetting
        self.phoneNumber = phoneNumber
        self.wabaCertificate = wabaCertificate
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case supportedContent
        case messagingSetting
        case phoneNumber
        case wabaCertificate
        case selfUri
    }


}




public class WidgetDeployment: Codable {















    public enum ClientType: String, Codable { 
        case v1 = "v1"
        case v2 = "v2"
        case v1Http = "v1-http"
        case thirdParty = "third-party"
    }





    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** A human-readable description of this Deployment. */
    public var _description: String?
    /** When true, the customer members starting a chat must be authenticated by supplying their JWT to the create operation. */
    public var authenticationRequired: Bool?
    /** When true, all create chat operations using this Deployment will be rejected. */
    public var disabled: Bool?
    /** The URI of the Inbound Chat Flow to run when new chats are initiated under this Deployment. */
    public var flow: DomainEntityRef?
    /** The list of domains that are approved to use this Deployment; the list will be added to CORS headers for ease of web use. */
    public var allowedDomains: [String]?
    /** The type of display widget for which this Deployment is configured, which controls the administrator settings shown. */
    public var clientType: ClientType?
    /** The client configuration options that should be made available to the clients of this Deployment. */
    public var clientConfig: WidgetClientConfig?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, _description: String?, authenticationRequired: Bool?, disabled: Bool?, flow: DomainEntityRef?, allowedDomains: [String]?, clientType: ClientType?, clientConfig: WidgetClientConfig?, selfUri: String?) {
        self._id = _id
        self.name = name
        self._description = _description
        self.authenticationRequired = authenticationRequired
        self.disabled = disabled
        self.flow = flow
        self.allowedDomains = allowedDomains
        self.clientType = clientType
        self.clientConfig = clientConfig
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case _description = "description"
        case authenticationRequired
        case disabled
        case flow
        case allowedDomains
        case clientType
        case clientConfig
        case selfUri
    }


}




public class WorkPlan: Codable {





















































    public enum ShiftStartVarianceType: String, Codable { 
        case shiftStart = "ShiftStart"
        case shiftStartAndPaidDuration = "ShiftStartAndPaidDuration"
    }













    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Whether the work plan is enabled for scheduling */
    public var enabled: Bool?
    /** Whether the work plan is valid or not */
    public var valid: Bool?
    /** Whether the weekly paid time constraint is enabled for this work plan */
    public var constrainWeeklyPaidTime: Bool?
    /** Whether the weekly paid time constraint is flexible for this work plan */
    public var flexibleWeeklyPaidTime: Bool?
    /** Exact weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == false */
    public var weeklyExactPaidMinutes: Int?
    /** Minimum weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == true */
    public var weeklyMinimumPaidMinutes: Int?
    /** Maximum weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == true */
    public var weeklyMaximumPaidMinutes: Int?
    /** Whether paid time granularity is constrained for this work plan */
    public var constrainPaidTimeGranularity: Bool?
    /** Granularity in minutes allowed for shift paid time in this work plan. Used if constrainPaidTimeGranularity == true */
    public var paidTimeGranularityMinutes: Int?
    /** Whether the minimum time between shifts constraint is enabled for this work plan */
    public var constrainMinimumTimeBetweenShifts: Bool?
    /** Minimum time between shifts in minutes defined in this work plan. Used if constrainMinimumTimeBetweenShifts == true */
    public var minimumTimeBetweenShiftsMinutes: Int?
    /** Maximum number days in a week allowed to be scheduled for this work plan */
    public var maximumDays: Int?
    /** Minimum amount of consecutive non working minutes per week that agents who are assigned this work plan are allowed to have off */
    public var minimumConsecutiveNonWorkingMinutesPerWeek: Int?
    /** Whether to constrain the maximum consecutive working weekends */
    public var constrainMaximumConsecutiveWorkingWeekends: Bool?
    /** The maximum number of consecutive weekends that agents who are assigned to this work plan are allowed to work */
    public var maximumConsecutiveWorkingWeekends: Int?
    /** The minimum number of days that agents assigned to a work plan must work per week */
    public var minimumWorkingDaysPerWeek: Int?
    /** Whether to constrain the maximum consecutive working days */
    public var constrainMaximumConsecutiveWorkingDays: Bool?
    /** The maximum number of consecutive days that agents assigned to this work plan are allowed to work. Used if constrainMaximumConsecutiveWorkingDays == true */
    public var maximumConsecutiveWorkingDays: Int?
    /** The time period in minutes for the duration between the start times of two consecutive working days */
    public var minimumShiftStartDistanceMinutes: Int?
    /** Minimum days off in the planning period */
    public var minimumDaysOffPerPlanningPeriod: Int?
    /** Maximum days off in the planning period */
    public var maximumDaysOffPerPlanningPeriod: Int?
    /** Minimum paid minutes in the planning period */
    public var minimumPaidMinutesPerPlanningPeriod: Int?
    /** Maximum paid minutes in the planning period */
    public var maximumPaidMinutesPerPlanningPeriod: Int?
    /** Optional days to schedule for this work plan */
    public var optionalDays: SetWrapperDayOfWeek?
    /** This constraint ensures that an agent starts each workday within a user-defined time threshold */
    public var shiftStartVarianceType: ShiftStartVarianceType?
    /** Variance in minutes among start times of shifts in this work plan */
    public var shiftStartVariances: ListWrapperShiftStartVariance?
    /** Shifts in this work plan */
    public var shifts: [WorkPlanShift]?
    /** Agents in this work plan */
    public var agents: [DeletableUserReference]?
    /** Number of agents in this work plan */
    public var agentCount: Int?
    /** Version metadata for this work plan */
    public var metadata: WfmVersionedEntityMetadata?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, enabled: Bool?, valid: Bool?, constrainWeeklyPaidTime: Bool?, flexibleWeeklyPaidTime: Bool?, weeklyExactPaidMinutes: Int?, weeklyMinimumPaidMinutes: Int?, weeklyMaximumPaidMinutes: Int?, constrainPaidTimeGranularity: Bool?, paidTimeGranularityMinutes: Int?, constrainMinimumTimeBetweenShifts: Bool?, minimumTimeBetweenShiftsMinutes: Int?, maximumDays: Int?, minimumConsecutiveNonWorkingMinutesPerWeek: Int?, constrainMaximumConsecutiveWorkingWeekends: Bool?, maximumConsecutiveWorkingWeekends: Int?, minimumWorkingDaysPerWeek: Int?, constrainMaximumConsecutiveWorkingDays: Bool?, maximumConsecutiveWorkingDays: Int?, minimumShiftStartDistanceMinutes: Int?, minimumDaysOffPerPlanningPeriod: Int?, maximumDaysOffPerPlanningPeriod: Int?, minimumPaidMinutesPerPlanningPeriod: Int?, maximumPaidMinutesPerPlanningPeriod: Int?, optionalDays: SetWrapperDayOfWeek?, shiftStartVarianceType: ShiftStartVarianceType?, shiftStartVariances: ListWrapperShiftStartVariance?, shifts: [WorkPlanShift]?, agents: [DeletableUserReference]?, agentCount: Int?, metadata: WfmVersionedEntityMetadata?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.enabled = enabled
        self.valid = valid
        self.constrainWeeklyPaidTime = constrainWeeklyPaidTime
        self.flexibleWeeklyPaidTime = flexibleWeeklyPaidTime
        self.weeklyExactPaidMinutes = weeklyExactPaidMinutes
        self.weeklyMinimumPaidMinutes = weeklyMinimumPaidMinutes
        self.weeklyMaximumPaidMinutes = weeklyMaximumPaidMinutes
        self.constrainPaidTimeGranularity = constrainPaidTimeGranularity
        self.paidTimeGranularityMinutes = paidTimeGranularityMinutes
        self.constrainMinimumTimeBetweenShifts = constrainMinimumTimeBetweenShifts
        self.minimumTimeBetweenShiftsMinutes = minimumTimeBetweenShiftsMinutes
        self.maximumDays = maximumDays
        self.minimumConsecutiveNonWorkingMinutesPerWeek = minimumConsecutiveNonWorkingMinutesPerWeek
        self.constrainMaximumConsecutiveWorkingWeekends = constrainMaximumConsecutiveWorkingWeekends
        self.maximumConsecutiveWorkingWeekends = maximumConsecutiveWorkingWeekends
        self.minimumWorkingDaysPerWeek = minimumWorkingDaysPerWeek
        self.constrainMaximumConsecutiveWorkingDays = constrainMaximumConsecutiveWorkingDays
        self.maximumConsecutiveWorkingDays = maximumConsecutiveWorkingDays
        self.minimumShiftStartDistanceMinutes = minimumShiftStartDistanceMinutes
        self.minimumDaysOffPerPlanningPeriod = minimumDaysOffPerPlanningPeriod
        self.maximumDaysOffPerPlanningPeriod = maximumDaysOffPerPlanningPeriod
        self.minimumPaidMinutesPerPlanningPeriod = minimumPaidMinutesPerPlanningPeriod
        self.maximumPaidMinutesPerPlanningPeriod = maximumPaidMinutesPerPlanningPeriod
        self.optionalDays = optionalDays
        self.shiftStartVarianceType = shiftStartVarianceType
        self.shiftStartVariances = shiftStartVariances
        self.shifts = shifts
        self.agents = agents
        self.agentCount = agentCount
        self.metadata = metadata
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case enabled
        case valid
        case constrainWeeklyPaidTime
        case flexibleWeeklyPaidTime
        case weeklyExactPaidMinutes
        case weeklyMinimumPaidMinutes
        case weeklyMaximumPaidMinutes
        case constrainPaidTimeGranularity
        case paidTimeGranularityMinutes
        case constrainMinimumTimeBetweenShifts
        case minimumTimeBetweenShiftsMinutes
        case maximumDays
        case minimumConsecutiveNonWorkingMinutesPerWeek
        case constrainMaximumConsecutiveWorkingWeekends
        case maximumConsecutiveWorkingWeekends
        case minimumWorkingDaysPerWeek
        case constrainMaximumConsecutiveWorkingDays
        case maximumConsecutiveWorkingDays
        case minimumShiftStartDistanceMinutes
        case minimumDaysOffPerPlanningPeriod
        case maximumDaysOffPerPlanningPeriod
        case minimumPaidMinutesPerPlanningPeriod
        case maximumPaidMinutesPerPlanningPeriod
        case optionalDays
        case shiftStartVarianceType
        case shiftStartVariances
        case shifts
        case agents
        case agentCount
        case metadata
        case selfUri
    }


}




public class WorkPlanActivity: Codable {

































    /** ID of the activity code associated with this activity */
    public var activityCodeId: String?
    /** Description of the activity */
    public var _description: String?
    /** Length of the activity in minutes */
    public var lengthMinutes: Int?
    /** Whether the start time of the activity is relative to the start time of the shift it belongs to */
    public var startTimeIsRelativeToShiftStart: Bool?
    /** Whether the start time of the activity is flexible */
    public var flexibleStartTime: Bool?
    /** Earliest activity start in offset minutes relative to shift start time if startTimeIsRelativeToShiftStart == true else its based on midnight. Used if flexibleStartTime == true */
    public var earliestStartTimeMinutes: Int?
    /** Latest activity start in offset minutes relative to shift start time if startTimeIsRelativeToShiftStart == true else its based on midnight. Used if flexibleStartTime == true */
    public var latestStartTimeMinutes: Int?
    /** Exact activity start in offset minutes relative to shift start time if startTimeIsRelativeToShiftStart == true else its based on midnight. Used if flexibleStartTime == false */
    public var exactStartTimeMinutes: Int?
    /** Increment in offset minutes that would contribute to different possible start times for the activity */
    public var startTimeIncrementMinutes: Int?
    /** Whether the activity is paid */
    public var countsAsPaidTime: Bool?
    /** Whether the activity duration is counted towards contiguous work time */
    public var countsAsContiguousWorkTime: Bool?
    /** The minimum duration between shift start and shift item (e.g., break or meal) start in minutes */
    public var minimumLengthFromShiftStartMinutes: Int?
    /** The minimum duration between shift item (e.g., break or meal) end and shift end in minutes */
    public var minimumLengthFromShiftEndMinutes: Int?
    /** ID of the activity. This is required only for the case of updating an existing activity */
    public var _id: String?
    /** If marked true for updating an existing activity, the activity will be permanently deleted */
    public var delete: Bool?
    /** ID of the activity in the context of work plan validation */
    public var validationId: String?

    public init(activityCodeId: String?, _description: String?, lengthMinutes: Int?, startTimeIsRelativeToShiftStart: Bool?, flexibleStartTime: Bool?, earliestStartTimeMinutes: Int?, latestStartTimeMinutes: Int?, exactStartTimeMinutes: Int?, startTimeIncrementMinutes: Int?, countsAsPaidTime: Bool?, countsAsContiguousWorkTime: Bool?, minimumLengthFromShiftStartMinutes: Int?, minimumLengthFromShiftEndMinutes: Int?, _id: String?, delete: Bool?, validationId: String?) {
        self.activityCodeId = activityCodeId
        self._description = _description
        self.lengthMinutes = lengthMinutes
        self.startTimeIsRelativeToShiftStart = startTimeIsRelativeToShiftStart
        self.flexibleStartTime = flexibleStartTime
        self.earliestStartTimeMinutes = earliestStartTimeMinutes
        self.latestStartTimeMinutes = latestStartTimeMinutes
        self.exactStartTimeMinutes = exactStartTimeMinutes
        self.startTimeIncrementMinutes = startTimeIncrementMinutes
        self.countsAsPaidTime = countsAsPaidTime
        self.countsAsContiguousWorkTime = countsAsContiguousWorkTime
        self.minimumLengthFromShiftStartMinutes = minimumLengthFromShiftStartMinutes
        self.minimumLengthFromShiftEndMinutes = minimumLengthFromShiftEndMinutes
        self._id = _id
        self.delete = delete
        self.validationId = validationId
    }

    public enum CodingKeys: String, CodingKey { 
        case activityCodeId
        case _description = "description"
        case lengthMinutes
        case startTimeIsRelativeToShiftStart
        case flexibleStartTime
        case earliestStartTimeMinutes
        case latestStartTimeMinutes
        case exactStartTimeMinutes
        case startTimeIncrementMinutes
        case countsAsPaidTime
        case countsAsContiguousWorkTime
        case minimumLengthFromShiftStartMinutes
        case minimumLengthFromShiftEndMinutes
        case _id = "id"
        case delete
        case validationId
    }


}




public class WorkPlanConstraintMessage: Codable {

    public enum ModelType: String, Codable { 
        case activityEarliestStartTimeMinutesFromMidnight = "ActivityEarliestStartTimeMinutesFromMidnight"
        case activityEarliestStartTimeMinutesFromShiftStart = "ActivityEarliestStartTimeMinutesFromShiftStart"
        case activityLatestStartTimeMinutesFromMidnight = "ActivityLatestStartTimeMinutesFromMidnight"
        case activityLatestStartTimeMinutesFromShiftStart = "ActivityLatestStartTimeMinutesFromShiftStart"
        case activityMinimumLengthFromShiftEndMinutes = "ActivityMinimumLengthFromShiftEndMinutes"
        case activityMinimumLengthFromShiftStartMinutes = "ActivityMinimumLengthFromShiftStartMinutes"
        case activityStartTimeIncrementInMinutes = "ActivityStartTimeIncrementInMinutes"
        case planningPeriodMaximumDaysOff = "PlanningPeriodMaximumDaysOff"
        case planningPeriodMaximumPaidTimeMinutes = "PlanningPeriodMaximumPaidTimeMinutes"
        case planningPeriodMinimumDaysOff = "PlanningPeriodMinimumDaysOff"
        case planningPeriodMinimumPaidTimeMinutes = "PlanningPeriodMinimumPaidTimeMinutes"
        case shiftDayOffRule = "ShiftDayOffRule"
        case shiftEarliestStartTimeMinutesFromMidnight = "ShiftEarliestStartTimeMinutesFromMidnight"
        case shiftEarliestStopTimeMinutesFromMidnight = "ShiftEarliestStopTimeMinutesFromMidnight"
        case shiftLatestStartTimeMinutesFromMidnight = "ShiftLatestStartTimeMinutesFromMidnight"
        case shiftLatestStopTimeMinutesFromMidnight = "ShiftLatestStopTimeMinutesFromMidnight"
        case shiftMaximumContiguousTimeMinutes = "ShiftMaximumContiguousTimeMinutes"
        case shiftMaximumPaidTimeMinutes = "ShiftMaximumPaidTimeMinutes"
        case shiftMinimumContiguousTimeMinutes = "ShiftMinimumContiguousTimeMinutes"
        case shiftMinimumPaidTimeMinutes = "ShiftMinimumPaidTimeMinutes"
        case shiftStartTimeIncrementInMinutes = "ShiftStartTimeIncrementInMinutes"
        case shiftStartVarianceMaximumVarianceMinutes = "ShiftStartVarianceMaximumVarianceMinutes"
        case shiftStartVariancePaidDuration = "ShiftStartVariancePaidDuration"
        case workPlanMaximumConsecutiveWorkingDays = "WorkPlanMaximumConsecutiveWorkingDays"
        case workPlanMaximumConsecutiveWorkingWeekends = "WorkPlanMaximumConsecutiveWorkingWeekends"
        case workPlanMaximumWeeklyPaidTimeMinutes = "WorkPlanMaximumWeeklyPaidTimeMinutes"
        case workPlanMaximumWorkingDaysPerWeek = "WorkPlanMaximumWorkingDaysPerWeek"
        case workPlanMinimumConsecutiveNonWorkingTimePerWeekMinutes = "WorkPlanMinimumConsecutiveNonWorkingTimePerWeekMinutes"
        case workPlanMinimumInterShiftTimeMinutes = "WorkPlanMinimumInterShiftTimeMinutes"
        case workPlanMinimumShiftStartDistanceMinutes = "WorkPlanMinimumShiftStartDistanceMinutes"
        case workPlanMinimumWeeklyPaidTimeMinutes = "WorkPlanMinimumWeeklyPaidTimeMinutes"
        case workPlanMinimumWorkingDaysPerWeek = "WorkPlanMinimumWorkingDaysPerWeek"
        case workPlanOptionalDays = "WorkPlanOptionalDays"
        case workPlanPaidTimeGranularityMinutes = "WorkPlanPaidTimeGranularityMinutes"
    }



    /** Type of the work plan constraint in this message */
    public var type: ModelType?
    /** Arguments of the message that provide information about the constraint that is being conflicted with, such as the value of the constraint */
    public var arguments: [WorkPlanValidationMessageArgument]?

    public init(type: ModelType?, arguments: [WorkPlanValidationMessageArgument]?) {
        self.type = type
        self.arguments = arguments
    }


}




public class WorkPlanRotationAgentResponse: Codable {







    /** The user associated with this work plan rotation */
    public var user: UserReference?
    /** The date range to which this agent is effective in the work plan rotation */
    public var dateRange: DateRangeWithOptionalEnd?
    /** Start position of the work plan in the pattern for this agent in the work plan rotation. Position value starts from 0 */
    public var position: Int?

    public init(user: UserReference?, dateRange: DateRangeWithOptionalEnd?, position: Int?) {
        self.user = user
        self.dateRange = dateRange
        self.position = position
    }


}




public class WorkPlanRotationResponse: Codable {



















    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Whether the work plan rotation is enabled for scheduling */
    public var enabled: Bool?
    /** The date range to which this work plan rotation applies */
    public var dateRange: DateRangeWithOptionalEnd?
    /** Pattern with ordered list of work plans that rotate on a weekly basis */
    public var pattern: WorkPlanPatternResponse?
    /** Number of agents in this work plan rotation */
    public var agentCount: Int?
    /** Agents in this work plan rotation. Populate with expand=agents for GET WorkPlanRotationsList (defaults to empty list) */
    public var agents: [WorkPlanRotationAgentResponse]?
    /** Version metadata for this work plan rotation */
    public var metadata: WfmVersionedEntityMetadata?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, enabled: Bool?, dateRange: DateRangeWithOptionalEnd?, pattern: WorkPlanPatternResponse?, agentCount: Int?, agents: [WorkPlanRotationAgentResponse]?, metadata: WfmVersionedEntityMetadata?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.enabled = enabled
        self.dateRange = dateRange
        self.pattern = pattern
        self.agentCount = agentCount
        self.agents = agents
        self.metadata = metadata
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case enabled
        case dateRange
        case pattern
        case agentCount
        case agents
        case metadata
        case selfUri
    }


}




public class WorkPlanShift: Codable {









































    public enum DayOffRule: String, Codable { 
        case nextDayOff = "NextDayOff"
        case previousDayOff = "PreviousDayOff"
    }









    /** Name of the shift */
    public var name: String?
    /** Days of the week applicable for this shift */
    public var days: SetWrapperDayOfWeek?
    /** Whether the start time of the shift is flexible */
    public var flexibleStartTime: Bool?
    /** Exact start time of the shift defined as offset minutes from midnight. Used if flexibleStartTime == false */
    public var exactStartTimeMinutesFromMidnight: Int?
    /** Earliest start time of the shift defined as offset minutes from midnight. Used if flexibleStartTime == true */
    public var earliestStartTimeMinutesFromMidnight: Int?
    /** Latest start time of the shift defined as offset minutes from midnight. Used if flexibleStartTime == true */
    public var latestStartTimeMinutesFromMidnight: Int?
    /** Whether the latest stop time constraint for the shift is enabled.  Deprecated, use constrainLatestStopTime instead */
    public var constrainStopTime: Bool?
    /** Whether the latest stop time constraint for the shift is enabled */
    public var constrainLatestStopTime: Bool?
    /** Latest stop time of the shift defined as offset minutes from midnight. Used if constrainStopTime == true */
    public var latestStopTimeMinutesFromMidnight: Int?
    /** Whether the earliest stop time constraint for the shift is enabled */
    public var constrainEarliestStopTime: Bool?
    /** This is the earliest time a shift can end */
    public var earliestStopTimeMinutesFromMidnight: Int?
    /** Increment in offset minutes that would contribute to different possible start times for the shift. Used if flexibleStartTime == true */
    public var startIncrementMinutes: Int?
    /** Whether the paid time setting for the shift is flexible */
    public var flexiblePaidTime: Bool?
    /** Exact paid time in minutes configured for the shift. Used if flexiblePaidTime == false */
    public var exactPaidTimeMinutes: Int?
    /** Minimum paid time in minutes configured for the shift. Used if flexiblePaidTime == true */
    public var minimumPaidTimeMinutes: Int?
    /** Maximum paid time in minutes configured for the shift. Used if flexiblePaidTime == true */
    public var maximumPaidTimeMinutes: Int?
    /** Whether the contiguous time constraint for the shift is enabled */
    public var constrainContiguousWorkTime: Bool?
    /** Minimum contiguous time in minutes configured for the shift. Used if constrainContiguousWorkTime == true */
    public var minimumContiguousWorkTimeMinutes: Int?
    /** Maximum contiguous time in minutes configured for the shift. Used if constrainContiguousWorkTime == true */
    public var maximumContiguousWorkTimeMinutes: Int?
    /** Whether day off rule is enabled */
    public var constrainDayOff: Bool?
    /** The day off rule for agents to have next day off or previous day off. used if constrainDayOff = true */
    public var dayOffRule: DayOffRule?
    /** Activities configured for this shift */
    public var activities: [WorkPlanActivity]?
    /** ID of the shift. This is required only for the case of updating an existing shift */
    public var _id: String?
    /** If marked true for updating an existing shift, the shift will be permanently deleted */
    public var delete: Bool?
    /** ID of shift in the context of work plan validation */
    public var validationId: String?

    public init(name: String?, days: SetWrapperDayOfWeek?, flexibleStartTime: Bool?, exactStartTimeMinutesFromMidnight: Int?, earliestStartTimeMinutesFromMidnight: Int?, latestStartTimeMinutesFromMidnight: Int?, constrainStopTime: Bool?, constrainLatestStopTime: Bool?, latestStopTimeMinutesFromMidnight: Int?, constrainEarliestStopTime: Bool?, earliestStopTimeMinutesFromMidnight: Int?, startIncrementMinutes: Int?, flexiblePaidTime: Bool?, exactPaidTimeMinutes: Int?, minimumPaidTimeMinutes: Int?, maximumPaidTimeMinutes: Int?, constrainContiguousWorkTime: Bool?, minimumContiguousWorkTimeMinutes: Int?, maximumContiguousWorkTimeMinutes: Int?, constrainDayOff: Bool?, dayOffRule: DayOffRule?, activities: [WorkPlanActivity]?, _id: String?, delete: Bool?, validationId: String?) {
        self.name = name
        self.days = days
        self.flexibleStartTime = flexibleStartTime
        self.exactStartTimeMinutesFromMidnight = exactStartTimeMinutesFromMidnight
        self.earliestStartTimeMinutesFromMidnight = earliestStartTimeMinutesFromMidnight
        self.latestStartTimeMinutesFromMidnight = latestStartTimeMinutesFromMidnight
        self.constrainStopTime = constrainStopTime
        self.constrainLatestStopTime = constrainLatestStopTime
        self.latestStopTimeMinutesFromMidnight = latestStopTimeMinutesFromMidnight
        self.constrainEarliestStopTime = constrainEarliestStopTime
        self.earliestStopTimeMinutesFromMidnight = earliestStopTimeMinutesFromMidnight
        self.startIncrementMinutes = startIncrementMinutes
        self.flexiblePaidTime = flexiblePaidTime
        self.exactPaidTimeMinutes = exactPaidTimeMinutes
        self.minimumPaidTimeMinutes = minimumPaidTimeMinutes
        self.maximumPaidTimeMinutes = maximumPaidTimeMinutes
        self.constrainContiguousWorkTime = constrainContiguousWorkTime
        self.minimumContiguousWorkTimeMinutes = minimumContiguousWorkTimeMinutes
        self.maximumContiguousWorkTimeMinutes = maximumContiguousWorkTimeMinutes
        self.constrainDayOff = constrainDayOff
        self.dayOffRule = dayOffRule
        self.activities = activities
        self._id = _id
        self.delete = delete
        self.validationId = validationId
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case days
        case flexibleStartTime
        case exactStartTimeMinutesFromMidnight
        case earliestStartTimeMinutesFromMidnight
        case latestStartTimeMinutesFromMidnight
        case constrainStopTime
        case constrainLatestStopTime
        case latestStopTimeMinutesFromMidnight
        case constrainEarliestStopTime
        case earliestStopTimeMinutesFromMidnight
        case startIncrementMinutes
        case flexiblePaidTime
        case exactPaidTimeMinutes
        case minimumPaidTimeMinutes
        case maximumPaidTimeMinutes
        case constrainContiguousWorkTime
        case minimumContiguousWorkTimeMinutes
        case maximumContiguousWorkTimeMinutes
        case constrainDayOff
        case dayOffRule
        case activities
        case _id = "id"
        case delete
        case validationId
    }


}




public class WorkPlanValidationRequest: Codable {





















































    public enum ShiftStartVarianceType: String, Codable { 
        case shiftStart = "ShiftStart"
        case shiftStartAndPaidDuration = "ShiftStartAndPaidDuration"
    }











    /** The globally unique identifier for the object. */
    public var _id: String?
    public var name: String?
    /** Whether the work plan is enabled for scheduling */
    public var enabled: Bool?
    /** Whether the work plan is valid or not */
    public var valid: Bool?
    /** Whether the weekly paid time constraint is enabled for this work plan */
    public var constrainWeeklyPaidTime: Bool?
    /** Whether the weekly paid time constraint is flexible for this work plan */
    public var flexibleWeeklyPaidTime: Bool?
    /** Exact weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == false */
    public var weeklyExactPaidMinutes: Int?
    /** Minimum weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == true */
    public var weeklyMinimumPaidMinutes: Int?
    /** Maximum weekly paid time in minutes for this work plan. Used if flexibleWeeklyPaidTime == true */
    public var weeklyMaximumPaidMinutes: Int?
    /** Whether paid time granularity is constrained for this work plan */
    public var constrainPaidTimeGranularity: Bool?
    /** Granularity in minutes allowed for shift paid time in this work plan. Used if constrainPaidTimeGranularity == true */
    public var paidTimeGranularityMinutes: Int?
    /** Whether the minimum time between shifts constraint is enabled for this work plan */
    public var constrainMinimumTimeBetweenShifts: Bool?
    /** Minimum time between shifts in minutes defined in this work plan. Used if constrainMinimumTimeBetweenShifts == true */
    public var minimumTimeBetweenShiftsMinutes: Int?
    /** Maximum number days in a week allowed to be scheduled for this work plan */
    public var maximumDays: Int?
    /** Minimum amount of consecutive non working minutes per week that agents who are assigned this work plan are allowed to have off */
    public var minimumConsecutiveNonWorkingMinutesPerWeek: Int?
    /** Whether to constrain the maximum consecutive working weekends */
    public var constrainMaximumConsecutiveWorkingWeekends: Bool?
    /** The maximum number of consecutive weekends that agents who are assigned to this work plan are allowed to work */
    public var maximumConsecutiveWorkingWeekends: Int?
    /** The minimum number of days that agents assigned to a work plan must work per week */
    public var minimumWorkingDaysPerWeek: Int?
    /** Whether to constrain the maximum consecutive working days */
    public var constrainMaximumConsecutiveWorkingDays: Bool?
    /** The maximum number of consecutive days that agents assigned to this work plan are allowed to work. Used if constrainMaximumConsecutiveWorkingDays == true */
    public var maximumConsecutiveWorkingDays: Int?
    /** The time period in minutes for the duration between the start times of two consecutive working days */
    public var minimumShiftStartDistanceMinutes: Int?
    /** Minimum days off in the planning period */
    public var minimumDaysOffPerPlanningPeriod: Int?
    /** Maximum days off in the planning period */
    public var maximumDaysOffPerPlanningPeriod: Int?
    /** Minimum paid minutes in the planning period */
    public var minimumPaidMinutesPerPlanningPeriod: Int?
    /** Maximum paid minutes in the planning period */
    public var maximumPaidMinutesPerPlanningPeriod: Int?
    /** Optional days to schedule for this work plan */
    public var optionalDays: SetWrapperDayOfWeek?
    /** This constraint ensures that an agent starts each workday within a user-defined time threshold */
    public var shiftStartVarianceType: ShiftStartVarianceType?
    /** Variance in minutes among start times of shifts in this work plan */
    public var shiftStartVariances: ListWrapperShiftStartVariance?
    /** Shifts in this work plan */
    public var shifts: [WorkPlanShift]?
    /** Agents in this work plan */
    public var agents: [DeletableUserReference]?
    /** Number of agents in this work plan */
    public var agentCount: Int?
    /** The URI for this object */
    public var selfUri: String?

    public init(_id: String?, name: String?, enabled: Bool?, valid: Bool?, constrainWeeklyPaidTime: Bool?, flexibleWeeklyPaidTime: Bool?, weeklyExactPaidMinutes: Int?, weeklyMinimumPaidMinutes: Int?, weeklyMaximumPaidMinutes: Int?, constrainPaidTimeGranularity: Bool?, paidTimeGranularityMinutes: Int?, constrainMinimumTimeBetweenShifts: Bool?, minimumTimeBetweenShiftsMinutes: Int?, maximumDays: Int?, minimumConsecutiveNonWorkingMinutesPerWeek: Int?, constrainMaximumConsecutiveWorkingWeekends: Bool?, maximumConsecutiveWorkingWeekends: Int?, minimumWorkingDaysPerWeek: Int?, constrainMaximumConsecutiveWorkingDays: Bool?, maximumConsecutiveWorkingDays: Int?, minimumShiftStartDistanceMinutes: Int?, minimumDaysOffPerPlanningPeriod: Int?, maximumDaysOffPerPlanningPeriod: Int?, minimumPaidMinutesPerPlanningPeriod: Int?, maximumPaidMinutesPerPlanningPeriod: Int?, optionalDays: SetWrapperDayOfWeek?, shiftStartVarianceType: ShiftStartVarianceType?, shiftStartVariances: ListWrapperShiftStartVariance?, shifts: [WorkPlanShift]?, agents: [DeletableUserReference]?, agentCount: Int?, selfUri: String?) {
        self._id = _id
        self.name = name
        self.enabled = enabled
        self.valid = valid
        self.constrainWeeklyPaidTime = constrainWeeklyPaidTime
        self.flexibleWeeklyPaidTime = flexibleWeeklyPaidTime
        self.weeklyExactPaidMinutes = weeklyExactPaidMinutes
        self.weeklyMinimumPaidMinutes = weeklyMinimumPaidMinutes
        self.weeklyMaximumPaidMinutes = weeklyMaximumPaidMinutes
        self.constrainPaidTimeGranularity = constrainPaidTimeGranularity
        self.paidTimeGranularityMinutes = paidTimeGranularityMinutes
        self.constrainMinimumTimeBetweenShifts = constrainMinimumTimeBetweenShifts
        self.minimumTimeBetweenShiftsMinutes = minimumTimeBetweenShiftsMinutes
        self.maximumDays = maximumDays
        self.minimumConsecutiveNonWorkingMinutesPerWeek = minimumConsecutiveNonWorkingMinutesPerWeek
        self.constrainMaximumConsecutiveWorkingWeekends = constrainMaximumConsecutiveWorkingWeekends
        self.maximumConsecutiveWorkingWeekends = maximumConsecutiveWorkingWeekends
        self.minimumWorkingDaysPerWeek = minimumWorkingDaysPerWeek
        self.constrainMaximumConsecutiveWorkingDays = constrainMaximumConsecutiveWorkingDays
        self.maximumConsecutiveWorkingDays = maximumConsecutiveWorkingDays
        self.minimumShiftStartDistanceMinutes = minimumShiftStartDistanceMinutes
        self.minimumDaysOffPerPlanningPeriod = minimumDaysOffPerPlanningPeriod
        self.maximumDaysOffPerPlanningPeriod = maximumDaysOffPerPlanningPeriod
        self.minimumPaidMinutesPerPlanningPeriod = minimumPaidMinutesPerPlanningPeriod
        self.maximumPaidMinutesPerPlanningPeriod = maximumPaidMinutesPerPlanningPeriod
        self.optionalDays = optionalDays
        self.shiftStartVarianceType = shiftStartVarianceType
        self.shiftStartVariances = shiftStartVariances
        self.shifts = shifts
        self.agents = agents
        self.agentCount = agentCount
        self.selfUri = selfUri
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case enabled
        case valid
        case constrainWeeklyPaidTime
        case flexibleWeeklyPaidTime
        case weeklyExactPaidMinutes
        case weeklyMinimumPaidMinutes
        case weeklyMaximumPaidMinutes
        case constrainPaidTimeGranularity
        case paidTimeGranularityMinutes
        case constrainMinimumTimeBetweenShifts
        case minimumTimeBetweenShiftsMinutes
        case maximumDays
        case minimumConsecutiveNonWorkingMinutesPerWeek
        case constrainMaximumConsecutiveWorkingWeekends
        case maximumConsecutiveWorkingWeekends
        case minimumWorkingDaysPerWeek
        case constrainMaximumConsecutiveWorkingDays
        case maximumConsecutiveWorkingDays
        case minimumShiftStartDistanceMinutes
        case minimumDaysOffPerPlanningPeriod
        case maximumDaysOffPerPlanningPeriod
        case minimumPaidMinutesPerPlanningPeriod
        case maximumPaidMinutesPerPlanningPeriod
        case optionalDays
        case shiftStartVarianceType
        case shiftStartVariances
        case shifts
        case agents
        case agentCount
        case selfUri
    }


}




public class WorkdayMetric: Codable {















    /** Gamification metric */
    public var metric: Metric?
    /** Current objective for this metric */
    public var objective: Objective?
    /** Gamification points earned for this metric */
    public var points: Int?
    /** The maximum Gamification points a user may earn for this metric */
    public var maxPoints: Int?
    /** Value of this metric */
    public var value: Double?
    /** List of schedule activity events for punctuality metrics */
    public var punctualityEvents: [PunctualityEvent]?
    /** List of evaluations for quality evaluation score metrics */
    public var evaluationDetails: [QualityEvaluationScoreItem]?

    public init(metric: Metric?, objective: Objective?, points: Int?, maxPoints: Int?, value: Double?, punctualityEvents: [PunctualityEvent]?, evaluationDetails: [QualityEvaluationScoreItem]?) {
        self.metric = metric
        self.objective = objective
        self.points = points
        self.maxPoints = maxPoints
        self.value = value
        self.punctualityEvents = punctualityEvents
        self.evaluationDetails = evaluationDetails
    }


}




public class WorkdayMetricListing: Codable {



    public var entities: [WorkdayMetric]?

    public init(entities: [WorkdayMetric]?) {
        self.entities = entities
    }


}




public class WorkdayValuesTrendItem: Codable {





    /** The workday for the metric value. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd */
    public var dateWorkday: Date?
    /** The metric value */
    public var value: Double?

    public init(dateWorkday: Date?, value: Double?) {
        self.dateWorkday = dateWorkday
        self.value = value
    }


}




public class WorkitemsEventsNotificationDelta: Codable {

    public enum Op: String, Codable { 
        case add = "add"
        case remove = "remove"
        case replace = "replace"
        case unknown = "unknown"
    }







    public var op: Op?
    public var field: String?
    public var oldValue: String?
    public var newValue: String?

    public init(op: Op?, field: String?, oldValue: String?, newValue: String?) {
        self.op = op
        self.field = field
        self.oldValue = oldValue
        self.newValue = newValue
    }


}




public class WorkitemsEventsNotificationSession: Codable {

    public enum ModelType: String, Codable { 
        case unknown = "Unknown"
        case agent = "Agent"
        case queueAssignment = "QueueAssignment"
        case directAssignment = "DirectAssignment"
    }



    public enum Status: String, Codable { 
        case unknown = "Unknown"
        case active = "Active"
        case completed = "Completed"
    }







    public var type: ModelType?
    public var _id: String?
    public var status: Status?
    public var dateSessionStart: String?
    public var dateSessionEnd: String?
    public var assignmentSegments: [WorkitemsEventsNotificationAssignmentSegment]?

    public init(type: ModelType?, _id: String?, status: Status?, dateSessionStart: String?, dateSessionEnd: String?, assignmentSegments: [WorkitemsEventsNotificationAssignmentSegment]?) {
        self.type = type
        self._id = _id
        self.status = status
        self.dateSessionStart = dateSessionStart
        self.dateSessionEnd = dateSessionEnd
        self.assignmentSegments = assignmentSegments
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case _id = "id"
        case status
        case dateSessionStart
        case dateSessionEnd
        case assignmentSegments
    }


}




public class WorkitemsEventsNotificationWorkitem: Codable {





























    public enum StatusCategory: String, Codable { 
        case unknown = "Unknown"
        case _open = "Open"
        case inProgress = "InProgress"
        case waiting = "Waiting"
        case closed = "Closed"
    }

















    public enum Operation: String, Codable { 
        case unknown = "unknown"
        case add = "add"
        case edit = "edit"
        case delete = "delete"
        case view = "view"
        case upload = "upload"
        case download = "download"
        case activate = "activate"
        case deactivate = "deactivate"
        case purge = "purge"
        case processed = "processed"
        case published = "published"
        case assigned = "assigned"
        case unassigned = "unassigned"
        case reset = "reset"
        case reassigned = "reassigned"
        case reassign = "reassign"
        case archive = "archive"
        case unarchive = "unarchive"
        case reschedule = "reschedule"
    }



    public enum AssignmentState: String, Codable { 
        case unknown = "Unknown"
        case idle = "Idle"
        case acdStarted = "AcdStarted"
        case alerting = "Alerting"
        case alertTimeout = "AlertTimeout"
        case declined = "Declined"
        case connected = "Connected"
        case disconnected = "Disconnected"
        case parked = "Parked"
        case held = "Held"
        case acdCancelled = "AcdCancelled"
        case terminated = "Terminated"
        case acdExpired = "AcdExpired"
    }















    public var _id: String?
    public var name: String?
    public var typeId: String?
    public var _description: String?
    public var languageId: String?
    public var priority: Int?
    public var dateCreated: String?
    public var dateModified: String?
    public var dateDue: String?
    public var dateExpires: String?
    public var dateAssignmentStateChanged: String?
    public var durationSeconds: Int?
    public var ttl: Int?
    public var statusId: String?
    public var statusCategory: StatusCategory?
    public var dateClosed: String?
    public var workbinId: String?
    public var reporterId: String?
    public var assigneeId: String?
    public var externalContactId: String?
    public var externalTag: String?
    public var wrapupId: String?
    public var modifiedBy: String?
    public var operation: Operation?
    public var changes: [WorkitemsEventsNotificationDelta]?
    public var assignmentState: AssignmentState?
    public var assignmentId: String?
    public var alertTimeoutSeconds: Int?
    public var queueId: String?
    public var customFields: [String:WorkitemsEventsNotificationCustomAttribute]?
    public var wrapup: WorkitemsEventsNotificationWrapup?
    public var sessions: [WorkitemsEventsNotificationSession]?
    public var skillIds: [String]?

    public init(_id: String?, name: String?, typeId: String?, _description: String?, languageId: String?, priority: Int?, dateCreated: String?, dateModified: String?, dateDue: String?, dateExpires: String?, dateAssignmentStateChanged: String?, durationSeconds: Int?, ttl: Int?, statusId: String?, statusCategory: StatusCategory?, dateClosed: String?, workbinId: String?, reporterId: String?, assigneeId: String?, externalContactId: String?, externalTag: String?, wrapupId: String?, modifiedBy: String?, operation: Operation?, changes: [WorkitemsEventsNotificationDelta]?, assignmentState: AssignmentState?, assignmentId: String?, alertTimeoutSeconds: Int?, queueId: String?, customFields: [String:WorkitemsEventsNotificationCustomAttribute]?, wrapup: WorkitemsEventsNotificationWrapup?, sessions: [WorkitemsEventsNotificationSession]?, skillIds: [String]?) {
        self._id = _id
        self.name = name
        self.typeId = typeId
        self._description = _description
        self.languageId = languageId
        self.priority = priority
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.dateDue = dateDue
        self.dateExpires = dateExpires
        self.dateAssignmentStateChanged = dateAssignmentStateChanged
        self.durationSeconds = durationSeconds
        self.ttl = ttl
        self.statusId = statusId
        self.statusCategory = statusCategory
        self.dateClosed = dateClosed
        self.workbinId = workbinId
        self.reporterId = reporterId
        self.assigneeId = assigneeId
        self.externalContactId = externalContactId
        self.externalTag = externalTag
        self.wrapupId = wrapupId
        self.modifiedBy = modifiedBy
        self.operation = operation
        self.changes = changes
        self.assignmentState = assignmentState
        self.assignmentId = assignmentId
        self.alertTimeoutSeconds = alertTimeoutSeconds
        self.queueId = queueId
        self.customFields = customFields
        self.wrapup = wrapup
        self.sessions = sessions
        self.skillIds = skillIds
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case typeId
        case _description = "description"
        case languageId
        case priority
        case dateCreated
        case dateModified
        case dateDue
        case dateExpires
        case dateAssignmentStateChanged
        case durationSeconds
        case ttl
        case statusId
        case statusCategory
        case dateClosed
        case workbinId
        case reporterId
        case assigneeId
        case externalContactId
        case externalTag
        case wrapupId
        case modifiedBy
        case operation
        case changes
        case assignmentState
        case assignmentId
        case alertTimeoutSeconds
        case queueId
        case customFields
        case wrapup
        case sessions
        case skillIds
    }


}




public class WorkitemsQueueEventsNotificationCustomAttribute: Codable {

    public enum DataType: String, Codable { 
        case unknown = "unknown"
        case string = "string"
        case number = "number"
        case boolean_ = "boolean$"
        case integer = "integer"
    }



    public var dataType: DataType?
    public var value: String?

    public init(dataType: DataType?, value: String?) {
        self.dataType = dataType
        self.value = value
    }


}




public class WorkitemsUserEventsNotificationDelta: Codable {

    public enum Op: String, Codable { 
        case add = "add"
        case remove = "remove"
        case replace = "replace"
        case unknown = "unknown"
    }







    public var op: Op?
    public var field: String?
    public var oldValue: String?
    public var newValue: String?

    public init(op: Op?, field: String?, oldValue: String?, newValue: String?) {
        self.op = op
        self.field = field
        self.oldValue = oldValue
        self.newValue = newValue
    }


}




public class WorkitemsUserEventsNotificationSession: Codable {

    public enum ModelType: String, Codable { 
        case unknown = "Unknown"
        case agent = "Agent"
        case queueAssignment = "QueueAssignment"
        case directAssignment = "DirectAssignment"
    }



    public enum Status: String, Codable { 
        case unknown = "Unknown"
        case active = "Active"
        case completed = "Completed"
    }







    public var type: ModelType?
    public var _id: String?
    public var status: Status?
    public var dateSessionStart: String?
    public var dateSessionEnd: String?
    public var assignmentSegments: [WorkitemsUserEventsNotificationAssignmentSegment]?

    public init(type: ModelType?, _id: String?, status: Status?, dateSessionStart: String?, dateSessionEnd: String?, assignmentSegments: [WorkitemsUserEventsNotificationAssignmentSegment]?) {
        self.type = type
        self._id = _id
        self.status = status
        self.dateSessionStart = dateSessionStart
        self.dateSessionEnd = dateSessionEnd
        self.assignmentSegments = assignmentSegments
    }

    public enum CodingKeys: String, CodingKey { 
        case type
        case _id = "id"
        case status
        case dateSessionStart
        case dateSessionEnd
        case assignmentSegments
    }


}




public class WorkitemsUserEventsNotificationWorkitem: Codable {





























    public enum StatusCategory: String, Codable { 
        case unknown = "Unknown"
        case _open = "Open"
        case inProgress = "InProgress"
        case waiting = "Waiting"
        case closed = "Closed"
    }

















    public enum Operation: String, Codable { 
        case unknown = "unknown"
        case add = "add"
        case edit = "edit"
        case delete = "delete"
        case view = "view"
        case upload = "upload"
        case download = "download"
        case activate = "activate"
        case deactivate = "deactivate"
        case purge = "purge"
        case processed = "processed"
        case published = "published"
        case assigned = "assigned"
        case unassigned = "unassigned"
        case reset = "reset"
        case reassigned = "reassigned"
        case reassign = "reassign"
        case archive = "archive"
        case unarchive = "unarchive"
        case reschedule = "reschedule"
    }



    public enum AssignmentState: String, Codable { 
        case unknown = "Unknown"
        case idle = "Idle"
        case acdStarted = "AcdStarted"
        case alerting = "Alerting"
        case alertTimeout = "AlertTimeout"
        case declined = "Declined"
        case connected = "Connected"
        case disconnected = "Disconnected"
        case parked = "Parked"
        case held = "Held"
        case acdCancelled = "AcdCancelled"
        case terminated = "Terminated"
        case acdExpired = "AcdExpired"
    }















    public var _id: String?
    public var name: String?
    public var typeId: String?
    public var _description: String?
    public var languageId: String?
    public var priority: Int?
    public var dateCreated: String?
    public var dateModified: String?
    public var dateDue: String?
    public var dateExpires: String?
    public var dateAssignmentStateChanged: String?
    public var durationSeconds: Int?
    public var ttl: Int?
    public var statusId: String?
    public var statusCategory: StatusCategory?
    public var dateClosed: String?
    public var workbinId: String?
    public var reporterId: String?
    public var assigneeId: String?
    public var externalContactId: String?
    public var externalTag: String?
    public var wrapupId: String?
    public var modifiedBy: String?
    public var operation: Operation?
    public var changes: [WorkitemsUserEventsNotificationDelta]?
    public var assignmentState: AssignmentState?
    public var assignmentId: String?
    public var alertTimeoutSeconds: Int?
    public var queueId: String?
    public var customFields: [String:WorkitemsUserEventsNotificationCustomAttribute]?
    public var wrapup: WorkitemsUserEventsNotificationWrapup?
    public var sessions: [WorkitemsUserEventsNotificationSession]?
    public var skillIds: [String]?

    public init(_id: String?, name: String?, typeId: String?, _description: String?, languageId: String?, priority: Int?, dateCreated: String?, dateModified: String?, dateDue: String?, dateExpires: String?, dateAssignmentStateChanged: String?, durationSeconds: Int?, ttl: Int?, statusId: String?, statusCategory: StatusCategory?, dateClosed: String?, workbinId: String?, reporterId: String?, assigneeId: String?, externalContactId: String?, externalTag: String?, wrapupId: String?, modifiedBy: String?, operation: Operation?, changes: [WorkitemsUserEventsNotificationDelta]?, assignmentState: AssignmentState?, assignmentId: String?, alertTimeoutSeconds: Int?, queueId: String?, customFields: [String:WorkitemsUserEventsNotificationCustomAttribute]?, wrapup: WorkitemsUserEventsNotificationWrapup?, sessions: [WorkitemsUserEventsNotificationSession]?, skillIds: [String]?) {
        self._id = _id
        self.name = name
        self.typeId = typeId
        self._description = _description
        self.languageId = languageId
        self.priority = priority
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.dateDue = dateDue
        self.dateExpires = dateExpires
        self.dateAssignmentStateChanged = dateAssignmentStateChanged
        self.durationSeconds = durationSeconds
        self.ttl = ttl
        self.statusId = statusId
        self.statusCategory = statusCategory
        self.dateClosed = dateClosed
        self.workbinId = workbinId
        self.reporterId = reporterId
        self.assigneeId = assigneeId
        self.externalContactId = externalContactId
        self.externalTag = externalTag
        self.wrapupId = wrapupId
        self.modifiedBy = modifiedBy
        self.operation = operation
        self.changes = changes
        self.assignmentState = assignmentState
        self.assignmentId = assignmentId
        self.alertTimeoutSeconds = alertTimeoutSeconds
        self.queueId = queueId
        self.customFields = customFields
        self.wrapup = wrapup
        self.sessions = sessions
        self.skillIds = skillIds
    }

    public enum CodingKeys: String, CodingKey { 
        case _id = "id"
        case name
        case typeId
        case _description = "description"
        case languageId
        case priority
        case dateCreated
        case dateModified
        case dateDue
        case dateExpires
        case dateAssignmentStateChanged
        case durationSeconds
        case ttl
        case statusId
        case statusCategory
        case dateClosed
        case workbinId
        case reporterId
        case assigneeId
        case externalContactId
        case externalTag
        case wrapupId
        case modifiedBy
        case operation
        case changes
        case assignmentState
        case assignmentId
        case alertTimeoutSeconds
        case queueId
        case customFields
        case wrapup
        case sessions
        case skillIds
    }


}




public class WorkspaceCreate: Codable {







    /** The workspace name */
    public var name: String?
    public var bucket: String?
    public var _description: String?

    public init(name: String?, bucket: String?, _description: String?) {
        self.name = name
        self.bucket = bucket
        self._description = _description
    }

    public enum CodingKeys: String, CodingKey { 
        case name
        case bucket
        case _description = "description"
    }


}




public class WrapUpCodeConfig: Codable {



    /** A set of valid Wrap Up Code UUIDs used to optimize a KPI. */
    public var values: [String]?

    public init(values: [String]?) {
        self.values = values
    }


}

